
blackmagic:     file format elf32-littlearm


Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 40 00 20 61 c2 00 08 5d c2 00 08 5b c2 00 08     .@. a...]...[...
	...
 800002c:	5d c2 00 08 00 00 00 00 00 00 00 00 5d c2 00 08     ]...........]...
 800003c:	ff b4 00 08 5b c2 00 08 5b c2 00 08 5b c2 00 08     ....[...[...[...
 800004c:	5b c2 00 08 5b c2 00 08 5b c2 00 08 5b c2 00 08     [...[...[...[...
 800005c:	5b c2 00 08 5b c2 00 08 5b c2 00 08 5b c2 00 08     [...[...[...[...
 800006c:	5b c2 00 08 5b c2 00 08 5b c2 00 08 5b c2 00 08     [...[...[...[...
 800007c:	5b c2 00 08 35 b4 00 08 5b c2 00 08 5b c2 00 08     [...5...[...[...
 800008c:	5b c2 00 08 5b c2 00 08 5b c2 00 08 5b c2 00 08     [...[...[...[...
 800009c:	5b c2 00 08 5b c2 00 08 5b c2 00 08 5b c2 00 08     [...[...[...[...
 80000ac:	5b c2 00 08 33 b4 00 08 5b c2 00 08 5b c2 00 08     [...3...[...[...
 80000bc:	99 b3 00 08                                         ....

080000c0 <adiv5_dp_read>:
		uint8_t fault;
	};
} ADIv5_DP_t;

static inline uint32_t adiv5_dp_read(ADIv5_DP_t *dp, uint16_t addr)
{
 80000c0:	b508      	push	{r3, lr}
	return dp->dp_read(dp, addr);
 80000c2:	6883      	ldr	r3, [r0, #8]
 80000c4:	4798      	blx	r3
}
 80000c6:	bd08      	pop	{r3, pc}

080000c8 <adiv5_dp_low_access>:
	return dp->error(dp);
}

static inline uint32_t adiv5_dp_low_access(struct ADIv5_DP_s *dp, uint8_t RnW,
                                           uint16_t addr, uint32_t value)
{
 80000c8:	b510      	push	{r4, lr}
	return dp->low_access(dp, RnW, addr, value);
 80000ca:	6904      	ldr	r4, [r0, #16]
 80000cc:	47a0      	blx	r4
}
 80000ce:	bd10      	pop	{r4, pc}

080000d0 <extract>:
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, addr);
}

/* Extract read data from data lane based on align and src address */
static void * extract(void *dest, uint32_t src, uint32_t val, enum align align)
{
 80000d0:	b510      	push	{r4, lr}
	switch (align) {
 80000d2:	2b01      	cmp	r3, #1
 80000d4:	d00b      	beq.n	80000ee <extract+0x1e>
 80000d6:	2b00      	cmp	r3, #0
 80000d8:	d003      	beq.n	80000e2 <extract+0x12>
 80000da:	2b02      	cmp	r3, #2
 80000dc:	d10c      	bne.n	80000f8 <extract+0x28>
		break;
	case ALIGN_HALFWORD:
		*(uint16_t *)dest = (val >> ((src & 0x2) << 3) & 0xFFFF);
		break;
	case ALIGN_WORD:
		*(uint32_t *)dest = val;
 80000de:	6002      	str	r2, [r0, #0]
		break;
 80000e0:	e00a      	b.n	80000f8 <extract+0x28>
/* Extract read data from data lane based on align and src address */
static void * extract(void *dest, uint32_t src, uint32_t val, enum align align)
{
	switch (align) {
	case ALIGN_BYTE:
		*(uint8_t *)dest = (val >> ((src & 0x3) << 3) & 0xFF);
 80000e2:	2403      	movs	r4, #3
 80000e4:	4021      	ands	r1, r4
 80000e6:	40a1      	lsls	r1, r4
 80000e8:	40ca      	lsrs	r2, r1
 80000ea:	7002      	strb	r2, [r0, #0]
		break;
 80000ec:	e004      	b.n	80000f8 <extract+0x28>
	case ALIGN_HALFWORD:
		*(uint16_t *)dest = (val >> ((src & 0x2) << 3) & 0xFFFF);
 80000ee:	2402      	movs	r4, #2
 80000f0:	4021      	ands	r1, r4
 80000f2:	00c9      	lsls	r1, r1, #3
 80000f4:	40ca      	lsrs	r2, r1
 80000f6:	8002      	strh	r2, [r0, #0]
		break;
	case ALIGN_WORD:
		*(uint32_t *)dest = val;
		break;
	}
	return (uint8_t *)dest + (1 << align);
 80000f8:	2201      	movs	r2, #1
 80000fa:	409a      	lsls	r2, r3
 80000fc:	1880      	adds	r0, r0, r2
}
 80000fe:	bd10      	pop	{r4, pc}

08000100 <adiv5_dp_ref>:

extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);

void adiv5_dp_ref(ADIv5_DP_t *dp)
{
	dp->refcnt++;
 8000100:	6803      	ldr	r3, [r0, #0]
 8000102:	3301      	adds	r3, #1
 8000104:	6003      	str	r3, [r0, #0]
}
 8000106:	4770      	bx	lr

08000108 <adiv5_ap_ref>:

void adiv5_ap_ref(ADIv5_AP_t *ap)
{
	ap->refcnt++;
 8000108:	6803      	ldr	r3, [r0, #0]
 800010a:	3301      	adds	r3, #1
 800010c:	6003      	str	r3, [r0, #0]
}
 800010e:	4770      	bx	lr

08000110 <adiv5_dp_unref>:

void adiv5_dp_unref(ADIv5_DP_t *dp)
{
 8000110:	b508      	push	{r3, lr}
	if (--(dp->refcnt) == 0)
 8000112:	6803      	ldr	r3, [r0, #0]
 8000114:	3b01      	subs	r3, #1
 8000116:	2b00      	cmp	r3, #0
 8000118:	d001      	beq.n	800011e <adiv5_dp_unref+0xe>
 800011a:	6003      	str	r3, [r0, #0]
 800011c:	e001      	b.n	8000122 <adiv5_dp_unref+0x12>
		free(dp);
 800011e:	f00c fbc1 	bl	800c8a4 <free>
}
 8000122:	bd08      	pop	{r3, pc}

08000124 <adiv5_ap_unref>:

void adiv5_ap_unref(ADIv5_AP_t *ap)
{
	if (--(ap->refcnt) == 0) {
 8000124:	6803      	ldr	r3, [r0, #0]
	if (--(dp->refcnt) == 0)
		free(dp);
}

void adiv5_ap_unref(ADIv5_AP_t *ap)
{
 8000126:	b510      	push	{r4, lr}
	if (--(ap->refcnt) == 0) {
 8000128:	3b01      	subs	r3, #1
 800012a:	6003      	str	r3, [r0, #0]
 800012c:	2b00      	cmp	r3, #0
 800012e:	d106      	bne.n	800013e <adiv5_ap_unref+0x1a>
 8000130:	1c04      	adds	r4, r0, #0
		adiv5_dp_unref(ap->dp);
 8000132:	6840      	ldr	r0, [r0, #4]
 8000134:	f7ff ffec 	bl	8000110 <adiv5_dp_unref>
		free(ap);
 8000138:	1c20      	adds	r0, r4, #0
 800013a:	f00c fbb3 	bl	800c8a4 <free>
	}
}
 800013e:	bd10      	pop	{r4, pc}

08000140 <adiv5_dp_write>:

void adiv5_dp_write(ADIv5_DP_t *dp, uint16_t addr, uint32_t value)
{
 8000140:	b538      	push	{r3, r4, r5, lr}
 8000142:	1c0d      	adds	r5, r1, #0
 8000144:	1c13      	adds	r3, r2, #0
	dp->low_access(dp, ADIV5_LOW_WRITE, addr, value);
 8000146:	6904      	ldr	r4, [r0, #16]
 8000148:	1c2a      	adds	r2, r5, #0
 800014a:	2100      	movs	r1, #0
 800014c:	47a0      	blx	r4
}
 800014e:	bd38      	pop	{r3, r4, r5, pc}

08000150 <adiv5_ap_write>:
		}
	}
}

void adiv5_ap_write(ADIv5_AP_t *ap, uint16_t addr, uint32_t value)
{
 8000150:	b570      	push	{r4, r5, r6, lr}
 8000152:	1c16      	adds	r6, r2, #0
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
 8000154:	22f0      	movs	r2, #240	; 0xf0
		}
	}
}

void adiv5_ap_write(ADIv5_AP_t *ap, uint16_t addr, uint32_t value)
{
 8000156:	1c0d      	adds	r5, r1, #0
 8000158:	1c04      	adds	r4, r0, #0
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
 800015a:	7a03      	ldrb	r3, [r0, #8]
	}
}

void adiv5_ap_write(ADIv5_AP_t *ap, uint16_t addr, uint32_t value)
{
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
 800015c:	400a      	ands	r2, r1
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
 800015e:	061b      	lsls	r3, r3, #24
	}
}

void adiv5_ap_write(ADIv5_AP_t *ap, uint16_t addr, uint32_t value)
{
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
 8000160:	431a      	orrs	r2, r3
 8000162:	6840      	ldr	r0, [r0, #4]
 8000164:	2108      	movs	r1, #8
 8000166:	f7ff ffeb 	bl	8000140 <adiv5_dp_write>
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
	adiv5_dp_write(ap->dp, addr, value);
 800016a:	1c29      	adds	r1, r5, #0
 800016c:	1c32      	adds	r2, r6, #0
 800016e:	6860      	ldr	r0, [r4, #4]
 8000170:	f7ff ffe6 	bl	8000140 <adiv5_dp_write>
}
 8000174:	bd70      	pop	{r4, r5, r6, pc}

08000176 <ap_mem_access_setup>:
#define ALIGNOF(x) (((x) & 3) == 0 ? ALIGN_WORD : \
                    (((x) & 1) == 0 ? ALIGN_HALFWORD : ALIGN_BYTE))

/* Program the CSW and TAR for sequencial access at a given width */
static void ap_mem_access_setup(ADIv5_AP_t *ap, uint32_t addr, enum align align)
{
 8000176:	b538      	push	{r3, r4, r5, lr}
 8000178:	1c04      	adds	r4, r0, #0
 800017a:	1c0d      	adds	r5, r1, #0
	uint32_t csw = ap->csw | ADIV5_AP_CSW_ADDRINC_SINGLE;
 800017c:	6983      	ldr	r3, [r0, #24]

	switch (align) {
 800017e:	2a01      	cmp	r2, #1
 8000180:	d003      	beq.n	800018a <ap_mem_access_setup+0x14>
 8000182:	2a02      	cmp	r2, #2
 8000184:	d003      	beq.n	800018e <ap_mem_access_setup+0x18>
                    (((x) & 1) == 0 ? ALIGN_HALFWORD : ALIGN_BYTE))

/* Program the CSW and TAR for sequencial access at a given width */
static void ap_mem_access_setup(ADIv5_AP_t *ap, uint32_t addr, enum align align)
{
	uint32_t csw = ap->csw | ADIV5_AP_CSW_ADDRINC_SINGLE;
 8000186:	2210      	movs	r2, #16
 8000188:	e002      	b.n	8000190 <ap_mem_access_setup+0x1a>
	switch (align) {
	case ALIGN_BYTE:
		csw |= ADIV5_AP_CSW_SIZE_BYTE;
		break;
	case ALIGN_HALFWORD:
		csw |= ADIV5_AP_CSW_SIZE_HALFWORD;
 800018a:	2211      	movs	r2, #17
 800018c:	e000      	b.n	8000190 <ap_mem_access_setup+0x1a>
		break;
	case ALIGN_WORD:
		csw |= ADIV5_AP_CSW_SIZE_WORD;
 800018e:	2212      	movs	r2, #18
		break;
	}
	adiv5_ap_write(ap, ADIV5_AP_CSW, csw);
 8000190:	2180      	movs	r1, #128	; 0x80
		break;
	case ALIGN_HALFWORD:
		csw |= ADIV5_AP_CSW_SIZE_HALFWORD;
		break;
	case ALIGN_WORD:
		csw |= ADIV5_AP_CSW_SIZE_WORD;
 8000192:	431a      	orrs	r2, r3
		break;
	}
	adiv5_ap_write(ap, ADIV5_AP_CSW, csw);
 8000194:	1c20      	adds	r0, r4, #0
 8000196:	0049      	lsls	r1, r1, #1
 8000198:	f7ff ffda 	bl	8000150 <adiv5_ap_write>
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, addr);
 800019c:	2282      	movs	r2, #130	; 0x82
 800019e:	1c2b      	adds	r3, r5, #0
 80001a0:	6860      	ldr	r0, [r4, #4]
 80001a2:	2100      	movs	r1, #0
 80001a4:	0052      	lsls	r2, r2, #1
 80001a6:	f7ff ff8f 	bl	80000c8 <adiv5_dp_low_access>
}
 80001aa:	bd38      	pop	{r3, r4, r5, pc}

080001ac <adiv5_mem_read>:
	return (uint8_t *)dest + (1 << align);
}

void
adiv5_mem_read(ADIv5_AP_t *ap, void *dest, uint32_t src, size_t len)
{
 80001ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001ae:	1c0f      	adds	r7, r1, #0
 80001b0:	2103      	movs	r1, #3
 80001b2:	1c15      	adds	r5, r2, #0
 80001b4:	b087      	sub	sp, #28
 80001b6:	1c04      	adds	r4, r0, #0
	uint32_t tmp;
	uint32_t osrc = src;
	enum align align = MIN(ALIGNOF(src), ALIGNOF(len));
 80001b8:	2202      	movs	r2, #2
 80001ba:	420b      	tst	r3, r1
 80001bc:	d001      	beq.n	80001c2 <adiv5_mem_read+0x16>
 80001be:	3a01      	subs	r2, #1
 80001c0:	439a      	bics	r2, r3
 80001c2:	2602      	movs	r6, #2
 80001c4:	420d      	tst	r5, r1
 80001c6:	d001      	beq.n	80001cc <adiv5_mem_read+0x20>
 80001c8:	3e01      	subs	r6, #1
 80001ca:	43ae      	bics	r6, r5

	if (len == 0)
 80001cc:	2b00      	cmp	r3, #0
 80001ce:	d100      	bne.n	80001d2 <adiv5_mem_read+0x26>
 80001d0:	e092      	b.n	80002f8 <adiv5_mem_read+0x14c>
void
adiv5_mem_read(ADIv5_AP_t *ap, void *dest, uint32_t src, size_t len)
{
	uint32_t tmp;
	uint32_t osrc = src;
	enum align align = MIN(ALIGNOF(src), ALIGNOF(len));
 80001d2:	4296      	cmp	r6, r2
 80001d4:	dd00      	ble.n	80001d8 <adiv5_mem_read+0x2c>
 80001d6:	1c16      	adds	r6, r2, #0
 80001d8:	b2f2      	uxtb	r2, r6
 80001da:	9202      	str	r2, [sp, #8]

	if (len == 0)
		return;

	if (align == ALIGN_WORD)
 80001dc:	2e02      	cmp	r6, #2
 80001de:	d13b      	bne.n	8000258 <adiv5_mem_read+0xac>
	{
		len >>= ALIGN_WORD;
 80001e0:	089b      	lsrs	r3, r3, #2
		ap_mem_access_setup(ap, src, ALIGN_WORD);
 80001e2:	1c32      	adds	r2, r6, #0
 80001e4:	1c20      	adds	r0, r4, #0
 80001e6:	1c29      	adds	r1, r5, #0
	if (len == 0)
		return;

	if (align == ALIGN_WORD)
	{
		len >>= ALIGN_WORD;
 80001e8:	9304      	str	r3, [sp, #16]
		ap_mem_access_setup(ap, src, ALIGN_WORD);
 80001ea:	f7ff ffc4 	bl	8000176 <ap_mem_access_setup>
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 80001ee:	2286      	movs	r2, #134	; 0x86
		while (--len) {
 80001f0:	1c2e      	adds	r6, r5, #0

	if (align == ALIGN_WORD)
	{
		len >>= ALIGN_WORD;
		ap_mem_access_setup(ap, src, ALIGN_WORD);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 80001f2:	2300      	movs	r3, #0
 80001f4:	6860      	ldr	r0, [r4, #4]
 80001f6:	2101      	movs	r1, #1
 80001f8:	0052      	lsls	r2, r2, #1
 80001fa:	f7ff ff65 	bl	80000c8 <adiv5_dp_low_access>
	if (len == 0)
		return;

	if (align == ALIGN_WORD)
	{
		len >>= ALIGN_WORD;
 80001fe:	9b04      	ldr	r3, [sp, #16]
		ap_mem_access_setup(ap, src, ALIGN_WORD);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
 8000200:	9503      	str	r5, [sp, #12]
	if (len == 0)
		return;

	if (align == ALIGN_WORD)
	{
		len >>= ALIGN_WORD;
 8000202:	9301      	str	r3, [sp, #4]
		ap_mem_access_setup(ap, src, ALIGN_WORD);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
 8000204:	9b01      	ldr	r3, [sp, #4]
 8000206:	3b01      	subs	r3, #1
 8000208:	9301      	str	r3, [sp, #4]
 800020a:	2b00      	cmp	r3, #0
 800020c:	d01d      	beq.n	800024a <adiv5_mem_read+0x9e>
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 800020e:	2286      	movs	r2, #134	; 0x86
 8000210:	2300      	movs	r3, #0
 8000212:	6860      	ldr	r0, [r4, #4]
 8000214:	2101      	movs	r1, #1
 8000216:	0052      	lsls	r2, r2, #1
 8000218:	f7ff ff56 	bl	80000c8 <adiv5_dp_low_access>
 800021c:	1b7b      	subs	r3, r7, r5
			* ((uint32_t *) dest) = tmp;
 800021e:	5198      	str	r0, [r3, r6]
			dest = dest + 4;

			src += 1 << ALIGN_WORD;
			/* Check for 10 bit address overflow */
			if ((src ^ osrc) & 0xfffffc00) {
 8000220:	9b03      	ldr	r3, [sp, #12]
		while (--len) {
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
			* ((uint32_t *) dest) = tmp;
			dest = dest + 4;

			src += 1 << ALIGN_WORD;
 8000222:	3604      	adds	r6, #4
			/* Check for 10 bit address overflow */
			if ((src ^ osrc) & 0xfffffc00) {
 8000224:	4073      	eors	r3, r6
 8000226:	0a9b      	lsrs	r3, r3, #10
 8000228:	d0ec      	beq.n	8000204 <adiv5_mem_read+0x58>
				osrc = src;
				adiv5_dp_low_access(ap->dp,
 800022a:	2282      	movs	r2, #130	; 0x82
 800022c:	2100      	movs	r1, #0
 800022e:	0052      	lsls	r2, r2, #1
 8000230:	1c33      	adds	r3, r6, #0
 8000232:	6860      	ldr	r0, [r4, #4]
 8000234:	f7ff ff48 	bl	80000c8 <adiv5_dp_low_access>
				                    ADIV5_LOW_WRITE, ADIV5_AP_TAR, src);
				adiv5_dp_low_access(ap->dp,
 8000238:	2286      	movs	r2, #134	; 0x86
 800023a:	6860      	ldr	r0, [r4, #4]
 800023c:	2101      	movs	r1, #1
 800023e:	0052      	lsls	r2, r2, #1
 8000240:	2300      	movs	r3, #0
 8000242:	f7ff ff41 	bl	80000c8 <adiv5_dp_low_access>
			dest = dest + 4;

			src += 1 << ALIGN_WORD;
			/* Check for 10 bit address overflow */
			if ((src ^ osrc) & 0xfffffc00) {
				osrc = src;
 8000246:	9603      	str	r6, [sp, #12]
 8000248:	e7dc      	b.n	8000204 <adiv5_mem_read+0x58>
 800024a:	4a2c      	ldr	r2, [pc, #176]	; (80002fc <adiv5_mem_read+0x150>)
 800024c:	9b04      	ldr	r3, [sp, #16]
 800024e:	4694      	mov	ip, r2
 8000250:	4463      	add	r3, ip
 8000252:	009e      	lsls	r6, r3, #2
 8000254:	19bf      	adds	r7, r7, r6
 8000256:	e042      	b.n	80002de <adiv5_mem_read+0x132>
			}
		}
	}
	else
	{
		len >>= align;
 8000258:	40f3      	lsrs	r3, r6
		ap_mem_access_setup(ap, src, align);
 800025a:	1c20      	adds	r0, r4, #0
 800025c:	1c29      	adds	r1, r5, #0
 800025e:	9a02      	ldr	r2, [sp, #8]
			}
		}
	}
	else
	{
		len >>= align;
 8000260:	9304      	str	r3, [sp, #16]
		ap_mem_access_setup(ap, src, align);
 8000262:	f7ff ff88 	bl	8000176 <ap_mem_access_setup>
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 8000266:	2286      	movs	r2, #134	; 0x86
 8000268:	2300      	movs	r3, #0
 800026a:	6860      	ldr	r0, [r4, #4]
 800026c:	2101      	movs	r1, #1
 800026e:	0052      	lsls	r2, r2, #1
 8000270:	f7ff ff2a 	bl	80000c8 <adiv5_dp_low_access>
		while (--len) {
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
			dest = extract(dest, src, tmp, align);

			src += (1 << align);
 8000274:	2301      	movs	r3, #1
 8000276:	40b3      	lsls	r3, r6
	else
	{
		len >>= align;
		ap_mem_access_setup(ap, src, align);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
 8000278:	1c2e      	adds	r6, r5, #0
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
			dest = extract(dest, src, tmp, align);

			src += (1 << align);
 800027a:	9305      	str	r3, [sp, #20]
			}
		}
	}
	else
	{
		len >>= align;
 800027c:	9b04      	ldr	r3, [sp, #16]
		ap_mem_access_setup(ap, src, align);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
 800027e:	9503      	str	r5, [sp, #12]
			}
		}
	}
	else
	{
		len >>= align;
 8000280:	9301      	str	r3, [sp, #4]
		ap_mem_access_setup(ap, src, align);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
 8000282:	9b01      	ldr	r3, [sp, #4]
 8000284:	3b01      	subs	r3, #1
 8000286:	9301      	str	r3, [sp, #4]
 8000288:	2b00      	cmp	r3, #0
 800028a:	d023      	beq.n	80002d4 <adiv5_mem_read+0x128>
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 800028c:	2286      	movs	r2, #134	; 0x86
 800028e:	2101      	movs	r1, #1
 8000290:	0052      	lsls	r2, r2, #1
 8000292:	2300      	movs	r3, #0
 8000294:	6860      	ldr	r0, [r4, #4]
 8000296:	f7ff ff17 	bl	80000c8 <adiv5_dp_low_access>
			dest = extract(dest, src, tmp, align);
 800029a:	1c31      	adds	r1, r6, #0
	{
		len >>= align;
		ap_mem_access_setup(ap, src, align);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 800029c:	1c02      	adds	r2, r0, #0
			dest = extract(dest, src, tmp, align);
 800029e:	9b02      	ldr	r3, [sp, #8]
 80002a0:	1c38      	adds	r0, r7, #0
 80002a2:	f7ff ff15 	bl	80000d0 <extract>

			src += (1 << align);
 80002a6:	9b05      	ldr	r3, [sp, #20]
		len >>= align;
		ap_mem_access_setup(ap, src, align);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
		while (--len) {
			tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
			dest = extract(dest, src, tmp, align);
 80002a8:	1c07      	adds	r7, r0, #0

			src += (1 << align);
 80002aa:	18f6      	adds	r6, r6, r3
			/* Check for 10 bit address overflow */
			if ((src ^ osrc) & 0xfffffc00) {
 80002ac:	9b03      	ldr	r3, [sp, #12]
 80002ae:	4073      	eors	r3, r6
 80002b0:	0a9b      	lsrs	r3, r3, #10
 80002b2:	d0e6      	beq.n	8000282 <adiv5_mem_read+0xd6>
				osrc = src;
				adiv5_dp_low_access(ap->dp,
 80002b4:	2282      	movs	r2, #130	; 0x82
 80002b6:	2100      	movs	r1, #0
 80002b8:	0052      	lsls	r2, r2, #1
 80002ba:	1c33      	adds	r3, r6, #0
 80002bc:	6860      	ldr	r0, [r4, #4]
 80002be:	f7ff ff03 	bl	80000c8 <adiv5_dp_low_access>
				                    ADIV5_LOW_WRITE, ADIV5_AP_TAR, src);
				adiv5_dp_low_access(ap->dp,
 80002c2:	2286      	movs	r2, #134	; 0x86
 80002c4:	6860      	ldr	r0, [r4, #4]
 80002c6:	2101      	movs	r1, #1
 80002c8:	0052      	lsls	r2, r2, #1
 80002ca:	2300      	movs	r3, #0
 80002cc:	f7ff fefc 	bl	80000c8 <adiv5_dp_low_access>
			dest = extract(dest, src, tmp, align);

			src += (1 << align);
			/* Check for 10 bit address overflow */
			if ((src ^ osrc) & 0xfffffc00) {
				osrc = src;
 80002d0:	9603      	str	r6, [sp, #12]
 80002d2:	e7d6      	b.n	8000282 <adiv5_mem_read+0xd6>
 80002d4:	9e04      	ldr	r6, [sp, #16]
 80002d6:	9b05      	ldr	r3, [sp, #20]
 80002d8:	3e01      	subs	r6, #1
 80002da:	4373      	muls	r3, r6
 80002dc:	1c1e      	adds	r6, r3, #0
				adiv5_dp_low_access(ap->dp,
				                    ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
			}
		}
	}
	tmp = adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_DP_RDBUFF, 0);
 80002de:	2101      	movs	r1, #1
 80002e0:	220c      	movs	r2, #12
 80002e2:	2300      	movs	r3, #0
 80002e4:	6860      	ldr	r0, [r4, #4]
 80002e6:	f7ff feef 	bl	80000c8 <adiv5_dp_low_access>
 80002ea:	1975      	adds	r5, r6, r5
 80002ec:	1c02      	adds	r2, r0, #0
	extract(dest, src, tmp, align);
 80002ee:	1c29      	adds	r1, r5, #0
 80002f0:	1c38      	adds	r0, r7, #0
 80002f2:	9b02      	ldr	r3, [sp, #8]
 80002f4:	f7ff feec 	bl	80000d0 <extract>
}
 80002f8:	b007      	add	sp, #28
 80002fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80002fc:	3fffffff 	.word	0x3fffffff

08000300 <adiv5_component_probe>:
	return ret;
}

static void adiv5_component_probe(ADIv5_AP_t *ap, uint32_t addr)
{
	addr &= ~3;
 8000300:	2303      	movs	r3, #3
 8000302:	4399      	bics	r1, r3
 8000304:	23fe      	movs	r3, #254	; 0xfe
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
	return ret;
}

static void adiv5_component_probe(ADIv5_AP_t *ap, uint32_t addr)
{
 8000306:	b5f0      	push	{r4, r5, r6, r7, lr}
	addr &= ~3;
 8000308:	1c0c      	adds	r4, r1, #0
	uint64_t pidr = 0;
 800030a:	2700      	movs	r7, #0
 800030c:	011b      	lsls	r3, r3, #4
 800030e:	18cd      	adds	r5, r1, r3
 8000310:	3310      	adds	r3, #16
 8000312:	18ce      	adds	r6, r1, r3
 8000314:	07cb      	lsls	r3, r1, #31
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
	return ret;
}

static void adiv5_component_probe(ADIv5_AP_t *ap, uint32_t addr)
{
 8000316:	b089      	sub	sp, #36	; 0x24
 8000318:	1a5b      	subs	r3, r3, r1
 800031a:	9002      	str	r0, [sp, #8]
 800031c:	9303      	str	r3, [sp, #12]
}

static uint32_t adiv5_mem_read32(ADIv5_AP_t *ap, uint32_t addr)
{
	uint32_t ret;
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
 800031e:	1c2a      	adds	r2, r5, #0
 8000320:	a907      	add	r1, sp, #28
 8000322:	2304      	movs	r3, #4
 8000324:	9802      	ldr	r0, [sp, #8]
 8000326:	f7ff ff41 	bl	80001ac <adiv5_mem_read>
	uint32_t cidr = 0;

	/* Assemble logical Product ID register value. */
	for (int i = 0; i < 4; i++) {
		uint32_t x = adiv5_mem_read32(ap, addr + PIDR0_OFFSET + 4*i);
		pidr |= (x & 0xff) << (i * 8);
 800032a:	9b07      	ldr	r3, [sp, #28]
 800032c:	4959      	ldr	r1, [pc, #356]	; (8000494 <adiv5_component_probe+0x194>)
 800032e:	b2da      	uxtb	r2, r3
 8000330:	9b03      	ldr	r3, [sp, #12]
 8000332:	185b      	adds	r3, r3, r1
 8000334:	195b      	adds	r3, r3, r5
 8000336:	005b      	lsls	r3, r3, #1
 8000338:	409a      	lsls	r2, r3
 800033a:	3504      	adds	r5, #4
 800033c:	4317      	orrs	r7, r2
	addr &= ~3;
	uint64_t pidr = 0;
	uint32_t cidr = 0;

	/* Assemble logical Product ID register value. */
	for (int i = 0; i < 4; i++) {
 800033e:	42b5      	cmp	r5, r6
 8000340:	d1ed      	bne.n	800031e <adiv5_component_probe+0x1e>
}

static uint32_t adiv5_mem_read32(ADIv5_AP_t *ap, uint32_t addr)
{
	uint32_t ret;
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
 8000342:	23fd      	movs	r3, #253	; 0xfd
 8000344:	011b      	lsls	r3, r3, #4
 8000346:	18e2      	adds	r2, r4, r3
 8000348:	9802      	ldr	r0, [sp, #8]
 800034a:	2304      	movs	r3, #4
 800034c:	a907      	add	r1, sp, #28
 800034e:	f7ff ff2d 	bl	80001ac <adiv5_mem_read>
	return ret;
 8000352:	9b07      	ldr	r3, [sp, #28]

static void adiv5_component_probe(ADIv5_AP_t *ap, uint32_t addr)
{
	addr &= ~3;
	uint64_t pidr = 0;
	uint32_t cidr = 0;
 8000354:	2500      	movs	r5, #0

static uint32_t adiv5_mem_read32(ADIv5_AP_t *ap, uint32_t addr)
{
	uint32_t ret;
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
	return ret;
 8000356:	9304      	str	r3, [sp, #16]
 8000358:	2380      	movs	r3, #128	; 0x80
 800035a:	015b      	lsls	r3, r3, #5
 800035c:	18e3      	adds	r3, r4, r3
 800035e:	9305      	str	r3, [sp, #20]
}

static uint32_t adiv5_mem_read32(ADIv5_AP_t *ap, uint32_t addr)
{
	uint32_t ret;
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
 8000360:	1c32      	adds	r2, r6, #0
 8000362:	9802      	ldr	r0, [sp, #8]
 8000364:	a907      	add	r1, sp, #28
 8000366:	2304      	movs	r3, #4
 8000368:	f7ff ff20 	bl	80001ac <adiv5_mem_read>
	}

	/* Assemble logical Component ID register value. */
	for (int i = 0; i < 4; i++) {
		uint32_t x = adiv5_mem_read32(ap, addr + CIDR0_OFFSET + 4*i);
		cidr |= ((uint64_t)(x & 0xff)) << (i * 8);
 800036c:	9b07      	ldr	r3, [sp, #28]
 800036e:	4a4a      	ldr	r2, [pc, #296]	; (8000498 <adiv5_component_probe+0x198>)
 8000370:	b2d8      	uxtb	r0, r3
 8000372:	9b03      	ldr	r3, [sp, #12]
 8000374:	2100      	movs	r1, #0
 8000376:	189a      	adds	r2, r3, r2
 8000378:	1992      	adds	r2, r2, r6
 800037a:	0052      	lsls	r2, r2, #1
 800037c:	f00e fc8a 	bl	800ec94 <__aeabi_llsl>
		uint32_t x = adiv5_mem_read32(ap, addr + PIDR4_OFFSET);
		pidr |= (uint64_t)x << 32;
	}

	/* Assemble logical Component ID register value. */
	for (int i = 0; i < 4; i++) {
 8000380:	9b05      	ldr	r3, [sp, #20]
 8000382:	3604      	adds	r6, #4
		uint32_t x = adiv5_mem_read32(ap, addr + CIDR0_OFFSET + 4*i);
		cidr |= ((uint64_t)(x & 0xff)) << (i * 8);
 8000384:	4305      	orrs	r5, r0
		uint32_t x = adiv5_mem_read32(ap, addr + PIDR4_OFFSET);
		pidr |= (uint64_t)x << 32;
	}

	/* Assemble logical Component ID register value. */
	for (int i = 0; i < 4; i++) {
 8000386:	429e      	cmp	r6, r3
 8000388:	d1ea      	bne.n	8000360 <adiv5_component_probe+0x60>
		uint32_t x = adiv5_mem_read32(ap, addr + CIDR0_OFFSET + 4*i);
		cidr |= ((uint64_t)(x & 0xff)) << (i * 8);
	}

	/* CIDR preamble sanity check */
	if ((cidr & ~CID_CLASS_MASK) != CID_PREAMBLE) {
 800038a:	4a44      	ldr	r2, [pc, #272]	; (800049c <adiv5_component_probe+0x19c>)
 800038c:	4b44      	ldr	r3, [pc, #272]	; (80004a0 <adiv5_component_probe+0x1a0>)
 800038e:	402a      	ands	r2, r5
 8000390:	429a      	cmp	r2, r3
 8000392:	d005      	beq.n	80003a0 <adiv5_component_probe+0xa0>
		DEBUG("0x%"PRIx32": 0x%"PRIx32" <- does not match preamble (0x%X)\n",
 8000394:	1c21      	adds	r1, r4, #0
 8000396:	1c2a      	adds	r2, r5, #0
 8000398:	4842      	ldr	r0, [pc, #264]	; (80004a4 <adiv5_component_probe+0x1a4>)
 800039a:	f00c fb5f 	bl	800ca5c <iprintf>
                      addr, cidr, CID_PREAMBLE);
		return;
 800039e:	e077      	b.n	8000490 <adiv5_component_probe+0x190>
	}

	/* Extract Component ID class nibble */
	uint32_t cid_class = (cidr & CID_CLASS_MASK) >> CID_CLASS_SHIFT;
 80003a0:	042d      	lsls	r5, r5, #16
 80003a2:	0f2e      	lsrs	r6, r5, #28

	if (cid_class == cidc_romtab) { /* ROM table, probe recursively */
 80003a4:	2e01      	cmp	r6, #1
 80003a6:	d118      	bne.n	80003da <adiv5_component_probe+0xda>
 80003a8:	2380      	movs	r3, #128	; 0x80
 80003aa:	1c25      	adds	r5, r4, #0
 80003ac:	00db      	lsls	r3, r3, #3
 80003ae:	18e6      	adds	r6, r4, r3
}

static uint32_t adiv5_mem_read32(ADIv5_AP_t *ap, uint32_t addr)
{
	uint32_t ret;
	adiv5_mem_read(ap, &ret, addr, sizeof(ret));
 80003b0:	a907      	add	r1, sp, #28
 80003b2:	9802      	ldr	r0, [sp, #8]
 80003b4:	1c2a      	adds	r2, r5, #0
 80003b6:	2304      	movs	r3, #4
 80003b8:	f7ff fef8 	bl	80001ac <adiv5_mem_read>
	return ret;
 80003bc:	9907      	ldr	r1, [sp, #28]
	uint32_t cid_class = (cidr & CID_CLASS_MASK) >> CID_CLASS_SHIFT;

	if (cid_class == cidc_romtab) { /* ROM table, probe recursively */
		for (int i = 0; i < 256; i++) {
			uint32_t entry = adiv5_mem_read32(ap, addr + i*4);
			if (entry == 0)
 80003be:	2900      	cmp	r1, #0
 80003c0:	d066      	beq.n	8000490 <adiv5_component_probe+0x190>
				break;

			if ((entry & 1) == 0)
 80003c2:	07cb      	lsls	r3, r1, #31
 80003c4:	d505      	bpl.n	80003d2 <adiv5_component_probe+0xd2>
				continue;

			adiv5_component_probe(ap, addr + (entry & ~0xfff));
 80003c6:	0b09      	lsrs	r1, r1, #12
 80003c8:	0309      	lsls	r1, r1, #12
 80003ca:	1861      	adds	r1, r4, r1
 80003cc:	9802      	ldr	r0, [sp, #8]
 80003ce:	f7ff ff97 	bl	8000300 <adiv5_component_probe>
 80003d2:	3504      	adds	r5, #4

	/* Extract Component ID class nibble */
	uint32_t cid_class = (cidr & CID_CLASS_MASK) >> CID_CLASS_SHIFT;

	if (cid_class == cidc_romtab) { /* ROM table, probe recursively */
		for (int i = 0; i < 256; i++) {
 80003d4:	42b5      	cmp	r5, r6
 80003d6:	d1eb      	bne.n	80003b0 <adiv5_component_probe+0xb0>
 80003d8:	e05a      	b.n	8000490 <adiv5_component_probe+0x190>
		}
	} else {
		/* Check if the component was designed by ARM, we currently do not support,
		 * any components by other designers.
		 */
		if ((pidr & ~(PIDR_REV_MASK | PIDR_PN_MASK)) != PIDR_ARM_BITS) {
 80003da:	23ff      	movs	r3, #255	; 0xff
 80003dc:	22bb      	movs	r2, #187	; 0xbb
 80003de:	031b      	lsls	r3, r3, #12
 80003e0:	403b      	ands	r3, r7
 80003e2:	0312      	lsls	r2, r2, #12
 80003e4:	4293      	cmp	r3, r2
 80003e6:	d102      	bne.n	80003ee <adiv5_component_probe+0xee>
 80003e8:	9b04      	ldr	r3, [sp, #16]
 80003ea:	2b04      	cmp	r3, #4
 80003ec:	d006      	beq.n	80003fc <adiv5_component_probe+0xfc>
			DEBUG("0x%"PRIx32": 0x%"PRIx64" <- does not match ARM JEP-106\n",
 80003ee:	1c21      	adds	r1, r4, #0
 80003f0:	1c3a      	adds	r2, r7, #0
 80003f2:	9b04      	ldr	r3, [sp, #16]
 80003f4:	482c      	ldr	r0, [pc, #176]	; (80004a8 <adiv5_component_probe+0x1a8>)
 80003f6:	f00c fb31 	bl	800ca5c <iprintf>
                              addr, pidr);
			return;
 80003fa:	e049      	b.n	8000490 <adiv5_component_probe+0x190>
		}

		/* Extract part number from the part id register. */
		uint16_t part_number = pidr & PIDR_PN_MASK;
 80003fc:	0539      	lsls	r1, r7, #20
 80003fe:	0d0b      	lsrs	r3, r1, #20
 8000400:	469c      	mov	ip, r3
		/* Find the part number in our part list and run the appropriate probe
		 * routine if applicable.
		 */
		int i;
		for (i = 0; pidr_pn_bits[i].arch != aa_end; i++) {
 8000402:	2200      	movs	r2, #0
 8000404:	230c      	movs	r3, #12
 8000406:	4353      	muls	r3, r2
 8000408:	4828      	ldr	r0, [pc, #160]	; (80004ac <adiv5_component_probe+0x1ac>)
 800040a:	18c5      	adds	r5, r0, r3
 800040c:	78a9      	ldrb	r1, [r5, #2]
 800040e:	9103      	str	r1, [sp, #12]
 8000410:	2903      	cmp	r1, #3
 8000412:	d032      	beq.n	800047a <adiv5_component_probe+0x17a>
			if (pidr_pn_bits[i].part_number == part_number) {
 8000414:	5a1b      	ldrh	r3, [r3, r0]
 8000416:	4563      	cmp	r3, ip
 8000418:	d119      	bne.n	800044e <adiv5_component_probe+0x14e>
				DEBUG("0x%"PRIx32": %s - %s %s\n", addr,
 800041a:	4f25      	ldr	r7, [pc, #148]	; (80004b0 <adiv5_component_probe+0x1b0>)
 800041c:	00b3      	lsls	r3, r6, #2
 800041e:	18fb      	adds	r3, r7, r3
 8000420:	691b      	ldr	r3, [r3, #16]
 8000422:	4824      	ldr	r0, [pc, #144]	; (80004b4 <adiv5_component_probe+0x1b4>)
 8000424:	9304      	str	r3, [sp, #16]
 8000426:	68ab      	ldr	r3, [r5, #8]
 8000428:	1c21      	adds	r1, r4, #0
 800042a:	9300      	str	r3, [sp, #0]
 800042c:	9a04      	ldr	r2, [sp, #16]
 800042e:	686b      	ldr	r3, [r5, #4]
 8000430:	f00c fb14 	bl	800ca5c <iprintf>
				      pidr_pn_bits[i].type,
				      pidr_pn_bits[i].full);
				/* Perform sanity check, if we know what to expect as component ID
				 * class.
				 */
				if ((pidr_pn_bits[i].cidc != cidc_unknown) &&
 8000434:	78eb      	ldrb	r3, [r5, #3]
 8000436:	2b10      	cmp	r3, #16
 8000438:	d00b      	beq.n	8000452 <adiv5_component_probe+0x152>
 800043a:	429e      	cmp	r6, r3
 800043c:	d009      	beq.n	8000452 <adiv5_component_probe+0x152>
				    (cid_class != pidr_pn_bits[i].cidc)) {
					DEBUG("WARNING: \"%s\" !match expected \"%s\"\n",
 800043e:	009b      	lsls	r3, r3, #2
 8000440:	18ff      	adds	r7, r7, r3
 8000442:	9904      	ldr	r1, [sp, #16]
 8000444:	693a      	ldr	r2, [r7, #16]
 8000446:	481c      	ldr	r0, [pc, #112]	; (80004b8 <adiv5_component_probe+0x1b8>)
 8000448:	f00c fb08 	bl	800ca5c <iprintf>
 800044c:	e001      	b.n	8000452 <adiv5_component_probe+0x152>
		uint16_t part_number = pidr & PIDR_PN_MASK;
		/* Find the part number in our part list and run the appropriate probe
		 * routine if applicable.
		 */
		int i;
		for (i = 0; pidr_pn_bits[i].arch != aa_end; i++) {
 800044e:	3201      	adds	r2, #1
 8000450:	e7d8      	b.n	8000404 <adiv5_component_probe+0x104>
				    (cid_class != pidr_pn_bits[i].cidc)) {
					DEBUG("WARNING: \"%s\" !match expected \"%s\"\n",
					      cidc_debug_strings[cid_class],
					      cidc_debug_strings[pidr_pn_bits[i].cidc]);
				}
				switch (pidr_pn_bits[i].arch) {
 8000452:	9b03      	ldr	r3, [sp, #12]
 8000454:	2b01      	cmp	r3, #1
 8000456:	d106      	bne.n	8000466 <adiv5_component_probe+0x166>
				case aa_cortexm:
					DEBUG("-> cortexm_probe\n");
 8000458:	4818      	ldr	r0, [pc, #96]	; (80004bc <adiv5_component_probe+0x1bc>)
 800045a:	f00c fb8f 	bl	800cb7c <puts>
					cortexm_probe(ap);
 800045e:	9802      	ldr	r0, [sp, #8]
 8000460:	f001 ff33 	bl	80022ca <cortexm_probe>
					break;
 8000464:	e014      	b.n	8000490 <adiv5_component_probe+0x190>
				    (cid_class != pidr_pn_bits[i].cidc)) {
					DEBUG("WARNING: \"%s\" !match expected \"%s\"\n",
					      cidc_debug_strings[cid_class],
					      cidc_debug_strings[pidr_pn_bits[i].cidc]);
				}
				switch (pidr_pn_bits[i].arch) {
 8000466:	2b02      	cmp	r3, #2
 8000468:	d112      	bne.n	8000490 <adiv5_component_probe+0x190>
				case aa_cortexm:
					DEBUG("-> cortexm_probe\n");
					cortexm_probe(ap);
					break;
				case aa_cortexa:
					DEBUG("-> cortexa_probe\n");
 800046a:	4815      	ldr	r0, [pc, #84]	; (80004c0 <adiv5_component_probe+0x1c0>)
 800046c:	f00c fb86 	bl	800cb7c <puts>
					cortexa_probe(ap, addr);
 8000470:	9802      	ldr	r0, [sp, #8]
 8000472:	1c21      	adds	r1, r4, #0
 8000474:	f001 f966 	bl	8001744 <cortexa_probe>
					break;
 8000478:	e00a      	b.n	8000490 <adiv5_component_probe+0x190>
				}
				break;
			}
		}
		if (pidr_pn_bits[i].arch == aa_end) {
			DEBUG("0x%"PRIx32": %s - Unknown (PIDR = 0x%"PRIx64")\n", addr,
 800047a:	4a0d      	ldr	r2, [pc, #52]	; (80004b0 <adiv5_component_probe+0x1b0>)
 800047c:	00b3      	lsls	r3, r6, #2
 800047e:	18d3      	adds	r3, r2, r3
 8000480:	9a04      	ldr	r2, [sp, #16]
 8000482:	9700      	str	r7, [sp, #0]
 8000484:	9201      	str	r2, [sp, #4]
 8000486:	480f      	ldr	r0, [pc, #60]	; (80004c4 <adiv5_component_probe+0x1c4>)
 8000488:	1c21      	adds	r1, r4, #0
 800048a:	691a      	ldr	r2, [r3, #16]
 800048c:	f00c fae6 	bl	800ca5c <iprintf>
			      cidc_debug_strings[cid_class], pidr);
		}
	}
}
 8000490:	b009      	add	sp, #36	; 0x24
 8000492:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000494:	7ffff020 	.word	0x7ffff020
 8000498:	7ffff010 	.word	0x7ffff010
 800049c:	ffff0fff 	.word	0xffff0fff
 80004a0:	b105000d 	.word	0xb105000d
 80004a4:	0800f3e4 	.word	0x0800f3e4
 80004a8:	0800f414 	.word	0x0800f414
 80004ac:	0800f190 	.word	0x0800f190
 80004b0:	0800f390 	.word	0x0800f390
 80004b4:	0800f441 	.word	0x0800f441
 80004b8:	0800f454 	.word	0x0800f454
 80004bc:	0800f478 	.word	0x0800f478
 80004c0:	0800f489 	.word	0x0800f489
 80004c4:	0800f49a 	.word	0x0800f49a

080004c8 <adiv5_mem_write>:

uint32_t max_write;

void
adiv5_mem_write(ADIv5_AP_t *ap, uint32_t dest, const void *src, size_t len)
{
 80004c8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004ca:	1c0e      	adds	r6, r1, #0
 80004cc:	2103      	movs	r1, #3
 80004ce:	b085      	sub	sp, #20
 80004d0:	9202      	str	r2, [sp, #8]
 80004d2:	1c07      	adds	r7, r0, #0
	uint32_t odest = dest;
	enum align align = MIN(ALIGNOF(dest), ALIGNOF(len));
 80004d4:	2202      	movs	r2, #2
 80004d6:	420b      	tst	r3, r1
 80004d8:	d001      	beq.n	80004de <adiv5_mem_write+0x16>
 80004da:	3a01      	subs	r2, #1
 80004dc:	439a      	bics	r2, r3
 80004de:	2402      	movs	r4, #2
 80004e0:	420e      	tst	r6, r1
 80004e2:	d001      	beq.n	80004e8 <adiv5_mem_write+0x20>
 80004e4:	3c01      	subs	r4, #1
 80004e6:	43b4      	bics	r4, r6
 80004e8:	4294      	cmp	r4, r2
 80004ea:	dd00      	ble.n	80004ee <adiv5_mem_write+0x26>
 80004ec:	1c14      	adds	r4, r2, #0
	if (len > max_write)
 80004ee:	4921      	ldr	r1, [pc, #132]	; (8000574 <adiv5_mem_write+0xac>)

void
adiv5_mem_write(ADIv5_AP_t *ap, uint32_t dest, const void *src, size_t len)
{
	uint32_t odest = dest;
	enum align align = MIN(ALIGNOF(dest), ALIGNOF(len));
 80004f0:	b2e2      	uxtb	r2, r4
	if (len > max_write)
 80004f2:	6808      	ldr	r0, [r1, #0]
 80004f4:	4283      	cmp	r3, r0
 80004f6:	d900      	bls.n	80004fa <adiv5_mem_write+0x32>
		max_write = len;
 80004f8:	600b      	str	r3, [r1, #0]
	                
	len >>= align;
 80004fa:	40e3      	lsrs	r3, r4
	ap_mem_access_setup(ap, dest, align);
 80004fc:	1c38      	adds	r0, r7, #0
 80004fe:	1c31      	adds	r1, r6, #0
	uint32_t odest = dest;
	enum align align = MIN(ALIGNOF(dest), ALIGNOF(len));
	if (len > max_write)
		max_write = len;
	                
	len >>= align;
 8000500:	1c1d      	adds	r5, r3, #0
	ap_mem_access_setup(ap, dest, align);
 8000502:	f7ff fe38 	bl	8000176 <ap_mem_access_setup>
			break;
		case ALIGN_WORD:
			tmp = *(uint32_t *)src;
			break;
		}
		src = (uint8_t *)src + (1 << align);
 8000506:	2301      	movs	r3, #1
 8000508:	40a3      	lsls	r3, r4
	if (len > max_write)
		max_write = len;
	                
	len >>= align;
	ap_mem_access_setup(ap, dest, align);
	while (len--) {
 800050a:	9500      	str	r5, [sp, #0]
 800050c:	1c35      	adds	r5, r6, #0
			break;
		case ALIGN_WORD:
			tmp = *(uint32_t *)src;
			break;
		}
		src = (uint8_t *)src + (1 << align);
 800050e:	9303      	str	r3, [sp, #12]
	if (len > max_write)
		max_write = len;
	                
	len >>= align;
	ap_mem_access_setup(ap, dest, align);
	while (len--) {
 8000510:	9601      	str	r6, [sp, #4]
 8000512:	9a02      	ldr	r2, [sp, #8]
 8000514:	1bab      	subs	r3, r5, r6
 8000516:	18d3      	adds	r3, r2, r3
 8000518:	9a00      	ldr	r2, [sp, #0]
 800051a:	2a00      	cmp	r2, #0
 800051c:	d028      	beq.n	8000570 <adiv5_mem_write+0xa8>
		uint32_t tmp = 0;
		/* Pack data into correct data lane */
		switch (align) {
 800051e:	2c01      	cmp	r4, #1
 8000520:	d006      	beq.n	8000530 <adiv5_mem_write+0x68>
 8000522:	2c02      	cmp	r4, #2
 8000524:	d00b      	beq.n	800053e <adiv5_mem_write+0x76>
 8000526:	9b02      	ldr	r3, [sp, #8]
 8000528:	1b9b      	subs	r3, r3, r6
		case ALIGN_BYTE:
			tmp = ((uint32_t)*(uint8_t *)src) << ((dest & 3) << 3);
 800052a:	5d5a      	ldrb	r2, [r3, r5]
 800052c:	2303      	movs	r3, #3
 800052e:	e001      	b.n	8000534 <adiv5_mem_write+0x6c>
			break;
		case ALIGN_HALFWORD:
			tmp = ((uint32_t)*(uint16_t *)src) << ((dest & 2) << 3);
 8000530:	881a      	ldrh	r2, [r3, #0]
 8000532:	2302      	movs	r3, #2
 8000534:	402b      	ands	r3, r5
 8000536:	00db      	lsls	r3, r3, #3
 8000538:	409a      	lsls	r2, r3
 800053a:	1c13      	adds	r3, r2, #0
			break;
 800053c:	e000      	b.n	8000540 <adiv5_mem_write+0x78>
		case ALIGN_WORD:
			tmp = *(uint32_t *)src;
 800053e:	681b      	ldr	r3, [r3, #0]
			break;
		}
		src = (uint8_t *)src + (1 << align);
		dest += (1 << align);
 8000540:	9a03      	ldr	r2, [sp, #12]
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, tmp);
 8000542:	6878      	ldr	r0, [r7, #4]
		case ALIGN_WORD:
			tmp = *(uint32_t *)src;
			break;
		}
		src = (uint8_t *)src + (1 << align);
		dest += (1 << align);
 8000544:	18ad      	adds	r5, r5, r2
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, tmp);
 8000546:	2286      	movs	r2, #134	; 0x86
 8000548:	2100      	movs	r1, #0
 800054a:	0052      	lsls	r2, r2, #1
 800054c:	f7ff fdbc 	bl	80000c8 <adiv5_dp_low_access>

		/* Check for 10 bit address overflow */
		if ((dest ^ odest) & 0xfffffc00) {
 8000550:	9b01      	ldr	r3, [sp, #4]
 8000552:	406b      	eors	r3, r5
 8000554:	0a9b      	lsrs	r3, r3, #10
 8000556:	d007      	beq.n	8000568 <adiv5_mem_write+0xa0>
			odest = dest;
			adiv5_dp_low_access(ap->dp,
 8000558:	2282      	movs	r2, #130	; 0x82
 800055a:	6878      	ldr	r0, [r7, #4]
 800055c:	2100      	movs	r1, #0
 800055e:	0052      	lsls	r2, r2, #1
 8000560:	1c2b      	adds	r3, r5, #0
 8000562:	f7ff fdb1 	bl	80000c8 <adiv5_dp_low_access>
		dest += (1 << align);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, tmp);

		/* Check for 10 bit address overflow */
		if ((dest ^ odest) & 0xfffffc00) {
			odest = dest;
 8000566:	9501      	str	r5, [sp, #4]
 8000568:	9b00      	ldr	r3, [sp, #0]
 800056a:	3b01      	subs	r3, #1
 800056c:	9300      	str	r3, [sp, #0]
 800056e:	e7d0      	b.n	8000512 <adiv5_mem_write+0x4a>
			adiv5_dp_low_access(ap->dp,
					ADIV5_LOW_WRITE, ADIV5_AP_TAR, dest);
		}
	}
}
 8000570:	b005      	add	sp, #20
 8000572:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000574:	20001d94 	.word	0x20001d94

08000578 <adiv5_ap_read>:
}

uint32_t adiv5_ap_read(ADIv5_AP_t *ap, uint16_t addr)
{
	uint32_t ret;
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
 8000578:	22f0      	movs	r2, #240	; 0xf0
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
	adiv5_dp_write(ap->dp, addr, value);
}

uint32_t adiv5_ap_read(ADIv5_AP_t *ap, uint16_t addr)
{
 800057a:	b538      	push	{r3, r4, r5, lr}
 800057c:	1c0d      	adds	r5, r1, #0
 800057e:	1c04      	adds	r4, r0, #0
	uint32_t ret;
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
 8000580:	7a03      	ldrb	r3, [r0, #8]
}

uint32_t adiv5_ap_read(ADIv5_AP_t *ap, uint16_t addr)
{
	uint32_t ret;
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
 8000582:	400a      	ands	r2, r1
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
 8000584:	061b      	lsls	r3, r3, #24
}

uint32_t adiv5_ap_read(ADIv5_AP_t *ap, uint16_t addr)
{
	uint32_t ret;
	adiv5_dp_write(ap->dp, ADIV5_DP_SELECT,
 8000586:	431a      	orrs	r2, r3
 8000588:	6840      	ldr	r0, [r0, #4]
 800058a:	2108      	movs	r1, #8
 800058c:	f7ff fdd8 	bl	8000140 <adiv5_dp_write>
			((uint32_t)ap->apsel << 24)|(addr & 0xF0));
	ret = adiv5_dp_read(ap->dp, addr);
 8000590:	1c29      	adds	r1, r5, #0
 8000592:	6860      	ldr	r0, [r4, #4]
 8000594:	f7ff fd94 	bl	80000c0 <adiv5_dp_read>
	return ret;
}
 8000598:	bd38      	pop	{r3, r4, r5, pc}

0800059a <adiv5_new_ap>:
		}
	}
}

ADIv5_AP_t *adiv5_new_ap(ADIv5_DP_t *dp, uint8_t apsel)
{
 800059a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800059c:	b08b      	sub	sp, #44	; 0x2c
	ADIv5_AP_t *ap, tmpap;

	/* Assume valid and try to read IDR */
	memset(&tmpap, 0, sizeof(tmpap));
 800059e:	ad03      	add	r5, sp, #12
		}
	}
}

ADIv5_AP_t *adiv5_new_ap(ADIv5_DP_t *dp, uint8_t apsel)
{
 80005a0:	1c06      	adds	r6, r0, #0
 80005a2:	1c0f      	adds	r7, r1, #0
	ADIv5_AP_t *ap, tmpap;

	/* Assume valid and try to read IDR */
	memset(&tmpap, 0, sizeof(tmpap));
 80005a4:	221c      	movs	r2, #28
 80005a6:	2100      	movs	r1, #0
 80005a8:	1c28      	adds	r0, r5, #0
 80005aa:	f00c f9a2 	bl	800c8f2 <memset>
	tmpap.dp = dp;
	tmpap.apsel = apsel;
	tmpap.idr = adiv5_ap_read(&tmpap, ADIV5_AP_IDR);
 80005ae:	21fe      	movs	r1, #254	; 0xfe
 80005b0:	1c28      	adds	r0, r5, #0
 80005b2:	0049      	lsls	r1, r1, #1
{
	ADIv5_AP_t *ap, tmpap;

	/* Assume valid and try to read IDR */
	memset(&tmpap, 0, sizeof(tmpap));
	tmpap.dp = dp;
 80005b4:	606e      	str	r6, [r5, #4]
	tmpap.apsel = apsel;
 80005b6:	722f      	strb	r7, [r5, #8]
	tmpap.idr = adiv5_ap_read(&tmpap, ADIV5_AP_IDR);
 80005b8:	f7ff ffde 	bl	8000578 <adiv5_ap_read>
 80005bc:	1e03      	subs	r3, r0, #0
 80005be:	60e8      	str	r0, [r5, #12]

	if(!tmpap.idr) /* IDR Invalid - Should we not continue here? */
 80005c0:	d046      	beq.n	8000650 <adiv5_new_ap+0xb6>
		return NULL;

	/* Check for ARM Mem-AP */
	uint16_t mfg = (tmpap.idr >> 17) & 0x3ff;
	uint8_t cls = (tmpap.idr >> 13) & 0xf;
 80005c2:	220f      	movs	r2, #15
 80005c4:	0b59      	lsrs	r1, r3, #13
 80005c6:	4011      	ands	r1, r2
	uint8_t type = tmpap.idr & 0xf;
	if (mfg != 0x23B) /* Ditch if not ARM */
 80005c8:	4a22      	ldr	r2, [pc, #136]	; (8000654 <adiv5_new_ap+0xba>)
	if(!tmpap.idr) /* IDR Invalid - Should we not continue here? */
		return NULL;

	/* Check for ARM Mem-AP */
	uint16_t mfg = (tmpap.idr >> 17) & 0x3ff;
	uint8_t cls = (tmpap.idr >> 13) & 0xf;
 80005ca:	1c0c      	adds	r4, r1, #0

	if(!tmpap.idr) /* IDR Invalid - Should we not continue here? */
		return NULL;

	/* Check for ARM Mem-AP */
	uint16_t mfg = (tmpap.idr >> 17) & 0x3ff;
 80005cc:	0159      	lsls	r1, r3, #5
	uint8_t cls = (tmpap.idr >> 13) & 0xf;
	uint8_t type = tmpap.idr & 0xf;
	if (mfg != 0x23B) /* Ditch if not ARM */
 80005ce:	0d89      	lsrs	r1, r1, #22
	tmpap.dp = dp;
	tmpap.apsel = apsel;
	tmpap.idr = adiv5_ap_read(&tmpap, ADIV5_AP_IDR);

	if(!tmpap.idr) /* IDR Invalid - Should we not continue here? */
		return NULL;
 80005d0:	2000      	movs	r0, #0

	/* Check for ARM Mem-AP */
	uint16_t mfg = (tmpap.idr >> 17) & 0x3ff;
	uint8_t cls = (tmpap.idr >> 13) & 0xf;
	uint8_t type = tmpap.idr & 0xf;
	if (mfg != 0x23B) /* Ditch if not ARM */
 80005d2:	4291      	cmp	r1, r2
 80005d4:	d13c      	bne.n	8000650 <adiv5_new_ap+0xb6>
		return NULL;
	if ((cls != 8) || (type == 0)) /* Ditch if not Mem-AP */
 80005d6:	2c08      	cmp	r4, #8
 80005d8:	d13a      	bne.n	8000650 <adiv5_new_ap+0xb6>
 80005da:	220f      	movs	r2, #15
 80005dc:	4013      	ands	r3, r2
	tmpap.dp = dp;
	tmpap.apsel = apsel;
	tmpap.idr = adiv5_ap_read(&tmpap, ADIV5_AP_IDR);

	if(!tmpap.idr) /* IDR Invalid - Should we not continue here? */
		return NULL;
 80005de:	1e18      	subs	r0, r3, #0
	uint16_t mfg = (tmpap.idr >> 17) & 0x3ff;
	uint8_t cls = (tmpap.idr >> 13) & 0xf;
	uint8_t type = tmpap.idr & 0xf;
	if (mfg != 0x23B) /* Ditch if not ARM */
		return NULL;
	if ((cls != 8) || (type == 0)) /* Ditch if not Mem-AP */
 80005e0:	d036      	beq.n	8000650 <adiv5_new_ap+0xb6>
		return NULL;

	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
 80005e2:	201c      	movs	r0, #28
 80005e4:	f00c f954 	bl	800c890 <malloc>
	memcpy(ap, &tmpap, sizeof(*ap));
 80005e8:	1c03      	adds	r3, r0, #0
		return NULL;
	if ((cls != 8) || (type == 0)) /* Ditch if not Mem-AP */
		return NULL;

	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
 80005ea:	1c04      	adds	r4, r0, #0
	memcpy(ap, &tmpap, sizeof(*ap));
 80005ec:	cd07      	ldmia	r5!, {r0, r1, r2}
 80005ee:	c307      	stmia	r3!, {r0, r1, r2}
 80005f0:	cd07      	ldmia	r5!, {r0, r1, r2}
 80005f2:	c307      	stmia	r3!, {r0, r1, r2}
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
 80005f4:	21fa      	movs	r1, #250	; 0xfa
	if ((cls != 8) || (type == 0)) /* Ditch if not Mem-AP */
		return NULL;

	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
	memcpy(ap, &tmpap, sizeof(*ap));
 80005f6:	682a      	ldr	r2, [r5, #0]
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
 80005f8:	0049      	lsls	r1, r1, #1
	if ((cls != 8) || (type == 0)) /* Ditch if not Mem-AP */
		return NULL;

	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
	memcpy(ap, &tmpap, sizeof(*ap));
 80005fa:	601a      	str	r2, [r3, #0]

extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);

void adiv5_dp_ref(ADIv5_DP_t *dp)
{
	dp->refcnt++;
 80005fc:	6833      	ldr	r3, [r6, #0]
	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
	memcpy(ap, &tmpap, sizeof(*ap));
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
 80005fe:	1c20      	adds	r0, r4, #0

extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);

void adiv5_dp_ref(ADIv5_DP_t *dp)
{
	dp->refcnt++;
 8000600:	3301      	adds	r3, #1
 8000602:	6033      	str	r3, [r6, #0]
	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
	memcpy(ap, &tmpap, sizeof(*ap));
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
 8000604:	f7ff ffb8 	bl	8000578 <adiv5_ap_read>
	ap->base = adiv5_ap_read(ap, ADIV5_AP_BASE);
 8000608:	21fc      	movs	r1, #252	; 0xfc
	/* It's valid to so create a heap copy */
	ap = malloc(sizeof(*ap));
	memcpy(ap, &tmpap, sizeof(*ap));
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
 800060a:	6120      	str	r0, [r4, #16]
	ap->base = adiv5_ap_read(ap, ADIV5_AP_BASE);
 800060c:	0049      	lsls	r1, r1, #1
 800060e:	1c20      	adds	r0, r4, #0
 8000610:	f7ff ffb2 	bl	8000578 <adiv5_ap_read>
	ap->csw = adiv5_ap_read(ap, ADIV5_AP_CSW) &
 8000614:	2180      	movs	r1, #128	; 0x80
	ap = malloc(sizeof(*ap));
	memcpy(ap, &tmpap, sizeof(*ap));
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
	ap->base = adiv5_ap_read(ap, ADIV5_AP_BASE);
 8000616:	6160      	str	r0, [r4, #20]
	ap->csw = adiv5_ap_read(ap, ADIV5_AP_CSW) &
 8000618:	0049      	lsls	r1, r1, #1
 800061a:	1c20      	adds	r0, r4, #0
 800061c:	f7ff ffac 	bl	8000578 <adiv5_ap_read>
 8000620:	2337      	movs	r3, #55	; 0x37
 8000622:	1c02      	adds	r2, r0, #0
		~(ADIV5_AP_CSW_SIZE_MASK | ADIV5_AP_CSW_ADDRINC_MASK);

	if (ap->csw & ADIV5_AP_CSW_TRINPROG) {
 8000624:	2580      	movs	r5, #128	; 0x80
	memcpy(ap, &tmpap, sizeof(*ap));
	adiv5_dp_ref(dp);

	ap->cfg = adiv5_ap_read(ap, ADIV5_AP_CFG);
	ap->base = adiv5_ap_read(ap, ADIV5_AP_BASE);
	ap->csw = adiv5_ap_read(ap, ADIV5_AP_CSW) &
 8000626:	439a      	bics	r2, r3
 8000628:	61a2      	str	r2, [r4, #24]
		~(ADIV5_AP_CSW_SIZE_MASK | ADIV5_AP_CSW_ADDRINC_MASK);

	if (ap->csw & ADIV5_AP_CSW_TRINPROG) {
 800062a:	4228      	tst	r0, r5
 800062c:	d005      	beq.n	800063a <adiv5_new_ap+0xa0>
		DEBUG("AP transaction in progress.  Target may not be usable.\n");
 800062e:	480a      	ldr	r0, [pc, #40]	; (8000658 <adiv5_new_ap+0xbe>)
 8000630:	f00c faa4 	bl	800cb7c <puts>
		ap->csw &= ~ADIV5_AP_CSW_TRINPROG;
 8000634:	69a3      	ldr	r3, [r4, #24]
 8000636:	43ab      	bics	r3, r5
 8000638:	61a3      	str	r3, [r4, #24]
	}

	DEBUG(" AP %3d: IDR=%08"PRIx32" CFG=%08"PRIx32" BASE=%08"PRIx32" CSW=%08"PRIx32"\n",
 800063a:	6963      	ldr	r3, [r4, #20]
 800063c:	4807      	ldr	r0, [pc, #28]	; (800065c <adiv5_new_ap+0xc2>)
 800063e:	9300      	str	r3, [sp, #0]
 8000640:	69a3      	ldr	r3, [r4, #24]
 8000642:	1c39      	adds	r1, r7, #0
 8000644:	9301      	str	r3, [sp, #4]
 8000646:	68e2      	ldr	r2, [r4, #12]
 8000648:	6923      	ldr	r3, [r4, #16]
 800064a:	f00c fa07 	bl	800ca5c <iprintf>
	      apsel, ap->idr, ap->cfg, ap->base, ap->csw);

	return ap;
 800064e:	1c20      	adds	r0, r4, #0
}
 8000650:	b00b      	add	sp, #44	; 0x2c
 8000652:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000654:	0000023b 	.word	0x0000023b
 8000658:	0800f4bf 	.word	0x0800f4bf
 800065c:	0800f4f6 	.word	0x0800f4f6

08000660 <adiv5_dp_init>:


void adiv5_dp_init(ADIv5_DP_t *dp)
{
	volatile uint32_t ctrlstat = 0;
 8000660:	2200      	movs	r2, #0
	return ap;
}


void adiv5_dp_init(ADIv5_DP_t *dp)
{
 8000662:	b530      	push	{r4, r5, lr}
 8000664:	b0a1      	sub	sp, #132	; 0x84
	volatile uint32_t ctrlstat = 0;
 8000666:	9204      	str	r2, [sp, #16]

	adiv5_dp_ref(dp);

	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000668:	9205      	str	r2, [sp, #20]
 800066a:	3202      	adds	r2, #2

extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);

void adiv5_dp_ref(ADIv5_DP_t *dp)
{
	dp->refcnt++;
 800066c:	6803      	ldr	r3, [r0, #0]
	volatile uint32_t ctrlstat = 0;

	adiv5_dp_ref(dp);

	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 800066e:	9207      	str	r2, [sp, #28]
 8000670:	4a2c      	ldr	r2, [pc, #176]	; (8000724 <adiv5_dp_init+0xc4>)

extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);

void adiv5_dp_ref(ADIv5_DP_t *dp)
{
	dp->refcnt++;
 8000672:	9302      	str	r3, [sp, #8]
	volatile uint32_t ctrlstat = 0;

	adiv5_dp_ref(dp);

	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000674:	6811      	ldr	r1, [r2, #0]

extern bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base);

void adiv5_dp_ref(ADIv5_DP_t *dp)
{
	dp->refcnt++;
 8000676:	3301      	adds	r3, #1
 8000678:	6003      	str	r3, [r0, #0]
	return ap;
}


void adiv5_dp_init(ADIv5_DP_t *dp)
{
 800067a:	9001      	str	r0, [sp, #4]
	volatile uint32_t ctrlstat = 0;

	adiv5_dp_ref(dp);

	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 800067c:	ab05      	add	r3, sp, #20
 800067e:	a808      	add	r0, sp, #32
 8000680:	911f      	str	r1, [sp, #124]	; 0x7c
 8000682:	6013      	str	r3, [r2, #0]
 8000684:	f00c fa96 	bl	800cbb4 <setjmp>
 8000688:	2800      	cmp	r0, #0
 800068a:	d011      	beq.n	80006b0 <adiv5_dp_init+0x50>
		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
	}
	if (e.type) {
 800068c:	9b05      	ldr	r3, [sp, #20]
 800068e:	2b00      	cmp	r3, #0
 8000690:	d01b      	beq.n	80006ca <adiv5_dp_init+0x6a>
		DEBUG("DP not responding!  Trying abort sequence...\n");
 8000692:	4825      	ldr	r0, [pc, #148]	; (8000728 <adiv5_dp_init+0xc8>)
 8000694:	f00c fa72 	bl	800cb7c <puts>

static inline void adiv5_dp_abort(struct ADIv5_DP_s *dp, uint32_t abort)
{
	return dp->abort(dp, abort);
 8000698:	9b01      	ldr	r3, [sp, #4]
 800069a:	9801      	ldr	r0, [sp, #4]
 800069c:	695b      	ldr	r3, [r3, #20]
 800069e:	2101      	movs	r1, #1
 80006a0:	9303      	str	r3, [sp, #12]
 80006a2:	4798      	blx	r3
		adiv5_dp_abort(dp, ADIV5_DP_ABORT_DAPABORT);
		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
 80006a4:	9801      	ldr	r0, [sp, #4]
 80006a6:	2104      	movs	r1, #4
 80006a8:	f7ff fd0a 	bl	80000c0 <adiv5_dp_read>
 80006ac:	9004      	str	r0, [sp, #16]
 80006ae:	e00c      	b.n	80006ca <adiv5_dp_init+0x6a>
	volatile uint32_t ctrlstat = 0;

	adiv5_dp_ref(dp);

	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 80006b0:	4d1c      	ldr	r5, [pc, #112]	; (8000724 <adiv5_dp_init+0xc4>)
 80006b2:	ab05      	add	r3, sp, #20
 80006b4:	682c      	ldr	r4, [r5, #0]
 80006b6:	429c      	cmp	r4, r3
 80006b8:	d1e8      	bne.n	800068c <adiv5_dp_init+0x2c>
		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
 80006ba:	9801      	ldr	r0, [sp, #4]
 80006bc:	2104      	movs	r1, #4
 80006be:	f7ff fcff 	bl	80000c0 <adiv5_dp_read>
 80006c2:	9004      	str	r0, [sp, #16]
	volatile uint32_t ctrlstat = 0;

	adiv5_dp_ref(dp);

	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 80006c4:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80006c6:	602b      	str	r3, [r5, #0]
 80006c8:	e7f2      	b.n	80006b0 <adiv5_dp_init+0x50>
		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
	}

	/* Write request for system and debug power up */
	adiv5_dp_write(dp, ADIV5_DP_CTRLSTAT,
			ctrlstat |= ADIV5_DP_CTRLSTAT_CSYSPWRUPREQ |
 80006ca:	22a0      	movs	r2, #160	; 0xa0
 80006cc:	9b04      	ldr	r3, [sp, #16]
 80006ce:	05d2      	lsls	r2, r2, #23
 80006d0:	431a      	orrs	r2, r3
		adiv5_dp_abort(dp, ADIV5_DP_ABORT_DAPABORT);
		ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT);
	}

	/* Write request for system and debug power up */
	adiv5_dp_write(dp, ADIV5_DP_CTRLSTAT,
 80006d2:	9801      	ldr	r0, [sp, #4]
 80006d4:	2104      	movs	r1, #4
 80006d6:	9204      	str	r2, [sp, #16]
 80006d8:	f7ff fd32 	bl	8000140 <adiv5_dp_write>
			ctrlstat |= ADIV5_DP_CTRLSTAT_CSYSPWRUPREQ |
				ADIV5_DP_CTRLSTAT_CDBGPWRUPREQ);
	/* Wait for acknowledge */
	while(((ctrlstat = adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT)) &
 80006dc:	9801      	ldr	r0, [sp, #4]
 80006de:	2104      	movs	r1, #4
 80006e0:	f7ff fcee 	bl	80000c0 <adiv5_dp_read>
 80006e4:	23a0      	movs	r3, #160	; 0xa0
 80006e6:	061b      	lsls	r3, r3, #24
 80006e8:	9004      	str	r0, [sp, #16]
 80006ea:	4018      	ands	r0, r3
 80006ec:	4298      	cmp	r0, r3
 80006ee:	d1f5      	bne.n	80006dc <adiv5_dp_init+0x7c>
 80006f0:	2400      	movs	r4, #0
				ADIV5_DP_CTRLSTAT_CDBGRSTACK);
	}

	/* Probe for APs on this DP */
	for(int i = 0; i < 256; i++) {
		ADIv5_AP_t *ap = adiv5_new_ap(dp, i);
 80006f2:	b2e1      	uxtb	r1, r4
 80006f4:	9801      	ldr	r0, [sp, #4]
 80006f6:	f7ff ff50 	bl	800059a <adiv5_new_ap>
		if (ap == NULL)
 80006fa:	2800      	cmp	r0, #0
 80006fc:	d109      	bne.n	8000712 <adiv5_dp_init+0xb2>
		while(adiv5_dp_read(dp, ADIV5_DP_CTRLSTAT) &
				ADIV5_DP_CTRLSTAT_CDBGRSTACK);
	}

	/* Probe for APs on this DP */
	for(int i = 0; i < 256; i++) {
 80006fe:	2380      	movs	r3, #128	; 0x80
 8000700:	3401      	adds	r4, #1
 8000702:	005b      	lsls	r3, r3, #1
 8000704:	429c      	cmp	r4, r3
 8000706:	d1f4      	bne.n	80006f2 <adiv5_dp_init+0x92>
		 */

		/* The rest sould only be added after checking ROM table */
		adiv5_component_probe(ap, ap->base);
	}
	adiv5_dp_unref(dp);
 8000708:	9801      	ldr	r0, [sp, #4]
 800070a:	f7ff fd01 	bl	8000110 <adiv5_dp_unref>
}
 800070e:	b021      	add	sp, #132	; 0x84
 8000710:	bd30      	pop	{r4, r5, pc}
	for(int i = 0; i < 256; i++) {
		ADIv5_AP_t *ap = adiv5_new_ap(dp, i);
		if (ap == NULL)
			continue;

		if (ap->base == 0xffffffff) {
 8000712:	6941      	ldr	r1, [r0, #20]
 8000714:	1c4b      	adds	r3, r1, #1
 8000716:	d102      	bne.n	800071e <adiv5_dp_init+0xbe>
			/* No debug entries... useless AP */
			adiv5_ap_unref(ap);
 8000718:	f7ff fd04 	bl	8000124 <adiv5_ap_unref>
 800071c:	e7ef      	b.n	80006fe <adiv5_dp_init+0x9e>
		/* Should probe further here to make sure it's a valid target.
		 * AP should be unref'd if not valid.
		 */

		/* The rest sould only be added after checking ROM table */
		adiv5_component_probe(ap, ap->base);
 800071e:	f7ff fdef 	bl	8000300 <adiv5_component_probe>
 8000722:	e7ec      	b.n	80006fe <adiv5_dp_init+0x9e>
 8000724:	20001dc4 	.word	0x20001dc4
 8000728:	0800f529 	.word	0x0800f529

0800072c <adiv5_jtagdp_abort>:

	return (uint32_t)(response >> 3);
}

static void adiv5_jtagdp_abort(ADIv5_DP_t *dp, uint32_t abort)
{
 800072c:	b513      	push	{r0, r1, r4, lr}
 800072e:	1c04      	adds	r4, r0, #0
	uint64_t request = (uint64_t)abort << 3;
 8000730:	0f4b      	lsrs	r3, r1, #29
 8000732:	00c9      	lsls	r1, r1, #3
 8000734:	9100      	str	r1, [sp, #0]
	jtag_dev_write_ir(dp->dev, IR_ABORT);
 8000736:	6980      	ldr	r0, [r0, #24]
 8000738:	2108      	movs	r1, #8
	return (uint32_t)(response >> 3);
}

static void adiv5_jtagdp_abort(ADIv5_DP_t *dp, uint32_t abort)
{
	uint64_t request = (uint64_t)abort << 3;
 800073a:	9301      	str	r3, [sp, #4]
	jtag_dev_write_ir(dp->dev, IR_ABORT);
 800073c:	f003 fb58 	bl	8003df0 <jtag_dev_write_ir>
	jtag_dev_shift_dr(dp->dev, NULL, (const uint8_t*)&request, 35);
 8000740:	69a0      	ldr	r0, [r4, #24]
 8000742:	2100      	movs	r1, #0
 8000744:	466a      	mov	r2, sp
 8000746:	2323      	movs	r3, #35	; 0x23
 8000748:	f003 fb8a 	bl	8003e60 <jtag_dev_shift_dr>
}
 800074c:	bd13      	pop	{r0, r1, r4, pc}

0800074e <adiv5_jtagdp_low_access>:
				ADIV5_DP_CTRLSTAT, 0xF0000032) & 0x32;
}

static uint32_t adiv5_jtagdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
					uint16_t addr, uint32_t value)
{
 800074e:	b530      	push	{r4, r5, lr}
 8000750:	1c04      	adds	r4, r0, #0
	addr &= 0xff;
	uint64_t request, response;
	uint8_t ack;
	platform_timeout timeout;

	request = ((uint64_t)value << 3) | ((addr >> 1) & 0x06) | (RnW?1:0);
 8000752:	1e48      	subs	r0, r1, #1
 8000754:	4181      	sbcs	r1, r0
 8000756:	2006      	movs	r0, #6
 8000758:	0f5d      	lsrs	r5, r3, #29
 800075a:	00db      	lsls	r3, r3, #3
 800075c:	4319      	orrs	r1, r3
 800075e:	0853      	lsrs	r3, r2, #1
 8000760:	4018      	ands	r0, r3
				ADIV5_DP_CTRLSTAT, 0xF0000032) & 0x32;
}

static uint32_t adiv5_jtagdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
					uint16_t addr, uint32_t value)
{
 8000762:	b087      	sub	sp, #28
	addr &= 0xff;
	uint64_t request, response;
	uint8_t ack;
	platform_timeout timeout;

	request = ((uint64_t)value << 3) | ((addr >> 1) & 0x06) | (RnW?1:0);
 8000764:	4301      	orrs	r1, r0
 8000766:	9102      	str	r1, [sp, #8]

	jtag_dev_write_ir(dp->dev, APnDP ? IR_APACC : IR_DPACC);
 8000768:	05d1      	lsls	r1, r2, #23
 800076a:	0fc9      	lsrs	r1, r1, #31
 800076c:	310a      	adds	r1, #10
 800076e:	69a0      	ldr	r0, [r4, #24]
	addr &= 0xff;
	uint64_t request, response;
	uint8_t ack;
	platform_timeout timeout;

	request = ((uint64_t)value << 3) | ((addr >> 1) & 0x06) | (RnW?1:0);
 8000770:	9503      	str	r5, [sp, #12]

	jtag_dev_write_ir(dp->dev, APnDP ? IR_APACC : IR_DPACC);
 8000772:	f003 fb3d 	bl	8003df0 <jtag_dev_write_ir>

	platform_timeout_set(&timeout, 2000);
 8000776:	21fa      	movs	r1, #250	; 0xfa
 8000778:	a801      	add	r0, sp, #4
 800077a:	00c9      	lsls	r1, r1, #3
 800077c:	f00a fe88 	bl	800b490 <platform_timeout_set>
	do {
		jtag_dev_shift_dr(dp->dev, (uint8_t*)&response, (uint8_t*)&request, 35);
		ack = response & 0x07;
 8000780:	2507      	movs	r5, #7

	jtag_dev_write_ir(dp->dev, APnDP ? IR_APACC : IR_DPACC);

	platform_timeout_set(&timeout, 2000);
	do {
		jtag_dev_shift_dr(dp->dev, (uint8_t*)&response, (uint8_t*)&request, 35);
 8000782:	69a0      	ldr	r0, [r4, #24]
 8000784:	2323      	movs	r3, #35	; 0x23
 8000786:	a904      	add	r1, sp, #16
 8000788:	aa02      	add	r2, sp, #8
 800078a:	f003 fb69 	bl	8003e60 <jtag_dev_shift_dr>
		ack = response & 0x07;
 800078e:	9b04      	ldr	r3, [sp, #16]
	} while(!platform_timeout_is_expired(&timeout) && (ack == JTAGDP_ACK_WAIT));
 8000790:	a801      	add	r0, sp, #4
	jtag_dev_write_ir(dp->dev, APnDP ? IR_APACC : IR_DPACC);

	platform_timeout_set(&timeout, 2000);
	do {
		jtag_dev_shift_dr(dp->dev, (uint8_t*)&response, (uint8_t*)&request, 35);
		ack = response & 0x07;
 8000792:	401d      	ands	r5, r3
	} while(!platform_timeout_is_expired(&timeout) && (ack == JTAGDP_ACK_WAIT));
 8000794:	f00a fe84 	bl	800b4a0 <platform_timeout_is_expired>
 8000798:	2800      	cmp	r0, #0
 800079a:	d102      	bne.n	80007a2 <adiv5_jtagdp_low_access+0x54>
 800079c:	2d01      	cmp	r5, #1
 800079e:	d0ef      	beq.n	8000780 <adiv5_jtagdp_low_access+0x32>
 80007a0:	e006      	b.n	80007b0 <adiv5_jtagdp_low_access+0x62>

	if (ack == JTAGDP_ACK_WAIT)
 80007a2:	2d01      	cmp	r5, #1
 80007a4:	d104      	bne.n	80007b0 <adiv5_jtagdp_low_access+0x62>
		raise_exception(EXCEPTION_TIMEOUT, "JTAG-DP ACK timeout");
 80007a6:	2002      	movs	r0, #2
 80007a8:	4908      	ldr	r1, [pc, #32]	; (80007cc <adiv5_jtagdp_low_access+0x7e>)
 80007aa:	f002 f895 	bl	80028d8 <raise_exception>
 80007ae:	e001      	b.n	80007b4 <adiv5_jtagdp_low_access+0x66>

	if((ack != JTAGDP_ACK_OK))
 80007b0:	2d02      	cmp	r5, #2
 80007b2:	d003      	beq.n	80007bc <adiv5_jtagdp_low_access+0x6e>
		raise_exception(EXCEPTION_ERROR, "JTAG-DP invalid ACK");
 80007b4:	2001      	movs	r0, #1
 80007b6:	4906      	ldr	r1, [pc, #24]	; (80007d0 <adiv5_jtagdp_low_access+0x82>)
 80007b8:	f002 f88e 	bl	80028d8 <raise_exception>

	return (uint32_t)(response >> 3);
 80007bc:	9b05      	ldr	r3, [sp, #20]
 80007be:	9a04      	ldr	r2, [sp, #16]
 80007c0:	075b      	lsls	r3, r3, #29
 80007c2:	08d0      	lsrs	r0, r2, #3
 80007c4:	4318      	orrs	r0, r3
}
 80007c6:	b007      	add	sp, #28
 80007c8:	bd30      	pop	{r4, r5, pc}
 80007ca:	46c0      	nop			; (mov r8, r8)
 80007cc:	0800fab9 	.word	0x0800fab9
 80007d0:	0800facd 	.word	0x0800facd

080007d4 <adiv5_jtagdp_error>:
	return adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ,
					ADIV5_DP_RDBUFF, 0);
}

static uint32_t adiv5_jtagdp_error(ADIv5_DP_t *dp)
{
 80007d4:	b510      	push	{r4, lr}
 80007d6:	1c04      	adds	r4, r0, #0
	adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ, ADIV5_DP_CTRLSTAT, 0);
 80007d8:	2101      	movs	r1, #1
 80007da:	2204      	movs	r2, #4
 80007dc:	2300      	movs	r3, #0
 80007de:	f7ff ffb6 	bl	800074e <adiv5_jtagdp_low_access>
	return adiv5_jtagdp_low_access(dp, ADIV5_LOW_WRITE,
 80007e2:	1c20      	adds	r0, r4, #0
 80007e4:	2100      	movs	r1, #0
 80007e6:	2204      	movs	r2, #4
 80007e8:	4b02      	ldr	r3, [pc, #8]	; (80007f4 <adiv5_jtagdp_error+0x20>)
 80007ea:	f7ff ffb0 	bl	800074e <adiv5_jtagdp_low_access>
 80007ee:	2332      	movs	r3, #50	; 0x32
 80007f0:	4018      	ands	r0, r3
				ADIV5_DP_CTRLSTAT, 0xF0000032) & 0x32;
}
 80007f2:	bd10      	pop	{r4, pc}
 80007f4:	f0000032 	.word	0xf0000032

080007f8 <adiv5_jtagdp_read>:

	adiv5_dp_init(dp);
}

static uint32_t adiv5_jtagdp_read(ADIv5_DP_t *dp, uint16_t addr)
{
 80007f8:	b510      	push	{r4, lr}
 80007fa:	1c04      	adds	r4, r0, #0
 80007fc:	1c0a      	adds	r2, r1, #0
	adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ, addr, 0);
 80007fe:	2300      	movs	r3, #0
 8000800:	2101      	movs	r1, #1
 8000802:	f7ff ffa4 	bl	800074e <adiv5_jtagdp_low_access>
	return adiv5_jtagdp_low_access(dp, ADIV5_LOW_READ,
 8000806:	1c20      	adds	r0, r4, #0
 8000808:	2101      	movs	r1, #1
 800080a:	220c      	movs	r2, #12
 800080c:	2300      	movs	r3, #0
 800080e:	f7ff ff9e 	bl	800074e <adiv5_jtagdp_low_access>
					ADIV5_DP_RDBUFF, 0);
}
 8000812:	bd10      	pop	{r4, pc}

08000814 <adiv5_jtag_dp_handler>:
					uint16_t addr, uint32_t value);

static void adiv5_jtagdp_abort(ADIv5_DP_t *dp, uint32_t abort);

void adiv5_jtag_dp_handler(jtag_dev_t *dev)
{
 8000814:	b510      	push	{r4, lr}
 8000816:	1c04      	adds	r4, r0, #0
	ADIv5_DP_t *dp = (void*)calloc(1, sizeof(*dp));
 8000818:	211c      	movs	r1, #28
 800081a:	2001      	movs	r0, #1
 800081c:	f00c f82c 	bl	800c878 <calloc>

	dp->dev = dev;
	dp->idcode = dev->idcode;
 8000820:	68a3      	ldr	r3, [r4, #8]

void adiv5_jtag_dp_handler(jtag_dev_t *dev)
{
	ADIv5_DP_t *dp = (void*)calloc(1, sizeof(*dp));

	dp->dev = dev;
 8000822:	6184      	str	r4, [r0, #24]
	dp->idcode = dev->idcode;
 8000824:	6043      	str	r3, [r0, #4]

	dp->dp_read = adiv5_jtagdp_read;
 8000826:	4b05      	ldr	r3, [pc, #20]	; (800083c <adiv5_jtag_dp_handler+0x28>)
 8000828:	6083      	str	r3, [r0, #8]
	dp->error = adiv5_jtagdp_error;
 800082a:	4b05      	ldr	r3, [pc, #20]	; (8000840 <adiv5_jtag_dp_handler+0x2c>)
 800082c:	60c3      	str	r3, [r0, #12]
	dp->low_access = adiv5_jtagdp_low_access;
 800082e:	4b05      	ldr	r3, [pc, #20]	; (8000844 <adiv5_jtag_dp_handler+0x30>)
 8000830:	6103      	str	r3, [r0, #16]
	dp->abort = adiv5_jtagdp_abort;
 8000832:	4b05      	ldr	r3, [pc, #20]	; (8000848 <adiv5_jtag_dp_handler+0x34>)
 8000834:	6143      	str	r3, [r0, #20]

	adiv5_dp_init(dp);
 8000836:	f7ff ff13 	bl	8000660 <adiv5_dp_init>
}
 800083a:	bd10      	pop	{r4, pc}
 800083c:	080007f9 	.word	0x080007f9
 8000840:	080007d5 	.word	0x080007d5
 8000844:	0800074f 	.word	0x0800074f
 8000848:	0800072d 	.word	0x0800072d

0800084c <adiv5_swdp_abort>:

	return response;
}

static void adiv5_swdp_abort(ADIv5_DP_t *dp, uint32_t abort)
{
 800084c:	b508      	push	{r3, lr}
 800084e:	1c0a      	adds	r2, r1, #0
	adiv5_dp_write(dp, ADIV5_DP_ABORT, abort);
 8000850:	2100      	movs	r1, #0
 8000852:	f7ff fc75 	bl	8000140 <adiv5_dp_write>
}
 8000856:	bd08      	pop	{r3, pc}

08000858 <adiv5_swdp_low_access>:
	return err;
}

static uint32_t adiv5_swdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
				      uint16_t addr, uint32_t value)
{
 8000858:	b5f0      	push	{r4, r5, r6, r7, lr}
 800085a:	1c04      	adds	r4, r0, #0
	bool APnDP = addr & ADIV5_APnDP;
	addr &= 0xff;
	uint8_t request = 0x81;
	uint32_t response = 0;
 800085c:	2000      	movs	r0, #0
	return err;
}

static uint32_t adiv5_swdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
				      uint16_t addr, uint32_t value)
{
 800085e:	b085      	sub	sp, #20
	bool APnDP = addr & ADIV5_APnDP;
	addr &= 0xff;
	uint8_t request = 0x81;
	uint32_t response = 0;
 8000860:	9002      	str	r0, [sp, #8]
	uint8_t ack;
	platform_timeout timeout;

	if(APnDP && dp->fault) return 0;
 8000862:	05d5      	lsls	r5, r2, #23
 8000864:	d504      	bpl.n	8000870 <adiv5_swdp_low_access+0x18>
 8000866:	7e25      	ldrb	r5, [r4, #24]
 8000868:	4285      	cmp	r5, r0
 800086a:	d14c      	bne.n	8000906 <adiv5_swdp_low_access+0xae>

	if(APnDP) request ^= 0x22;
 800086c:	25a3      	movs	r5, #163	; 0xa3
 800086e:	e000      	b.n	8000872 <adiv5_swdp_low_access+0x1a>
static uint32_t adiv5_swdp_low_access(ADIv5_DP_t *dp, uint8_t RnW,
				      uint16_t addr, uint32_t value)
{
	bool APnDP = addr & ADIV5_APnDP;
	addr &= 0xff;
	uint8_t request = 0x81;
 8000870:	2581      	movs	r5, #129	; 0x81
	platform_timeout timeout;

	if(APnDP && dp->fault) return 0;

	if(APnDP) request ^= 0x22;
	if(RnW)   request ^= 0x24;
 8000872:	2900      	cmp	r1, #0
 8000874:	d001      	beq.n	800087a <adiv5_swdp_low_access+0x22>
 8000876:	2024      	movs	r0, #36	; 0x24
 8000878:	4045      	eors	r5, r0

	addr &= 0xC;
 800087a:	200c      	movs	r0, #12
 800087c:	4002      	ands	r2, r0
	request |= (addr << 1) & 0x18;
 800087e:	0050      	lsls	r0, r2, #1
 8000880:	4305      	orrs	r5, r0
	if((addr == 4) || (addr == 8))
 8000882:	2004      	movs	r0, #4
 8000884:	3a04      	subs	r2, #4
 8000886:	4382      	bics	r2, r0
 8000888:	b292      	uxth	r2, r2
 800088a:	2a00      	cmp	r2, #0
 800088c:	d102      	bne.n	8000894 <adiv5_swdp_low_access+0x3c>
		request ^= 0x20;
 800088e:	3220      	adds	r2, #32
 8000890:	4055      	eors	r5, r2
 8000892:	b2ed      	uxtb	r5, r5
 8000894:	1c0e      	adds	r6, r1, #0

	platform_timeout_set(&timeout, 2000);
 8000896:	21fa      	movs	r1, #250	; 0xfa
 8000898:	a803      	add	r0, sp, #12
 800089a:	00c9      	lsls	r1, r1, #3
 800089c:	1c1f      	adds	r7, r3, #0
 800089e:	9401      	str	r4, [sp, #4]
 80008a0:	f00a fdf6 	bl	800b490 <platform_timeout_set>
	do {
		swdptap_seq_out(request, 8);
 80008a4:	1c28      	adds	r0, r5, #0
 80008a6:	2108      	movs	r1, #8
 80008a8:	f004 fff6 	bl	8005898 <swdptap_seq_out>
		ack = swdptap_seq_in(3);
 80008ac:	2003      	movs	r0, #3
 80008ae:	f004 ff10 	bl	80056d2 <swdptap_seq_in>
 80008b2:	b2c4      	uxtb	r4, r0
	} while (ack == SWDP_ACK_WAIT && !platform_timeout_is_expired(&timeout));
 80008b4:	2c02      	cmp	r4, #2
 80008b6:	d10e      	bne.n	80008d6 <adiv5_swdp_low_access+0x7e>
 80008b8:	a803      	add	r0, sp, #12
 80008ba:	f00a fdf1 	bl	800b4a0 <platform_timeout_is_expired>
 80008be:	2800      	cmp	r0, #0
 80008c0:	d0f0      	beq.n	80008a4 <adiv5_swdp_low_access+0x4c>
		}
	}
	else
	{
		if (ack == SWDP_ACK_WAIT)
			raise_exception(EXCEPTION_TIMEOUT, "SWDP ACK timeout");
 80008c2:	1c20      	adds	r0, r4, #0
 80008c4:	4911      	ldr	r1, [pc, #68]	; (800090c <adiv5_swdp_low_access+0xb4>)
 80008c6:	f002 f807 	bl	80028d8 <raise_exception>
			dp->fault = 1;
			return 0;
		}

		if(ack != SWDP_ACK_OK)
			raise_exception(EXCEPTION_ERROR, "SWDP invalid ACK");
 80008ca:	2001      	movs	r0, #1
 80008cc:	4910      	ldr	r1, [pc, #64]	; (8000910 <adiv5_swdp_low_access+0xb8>)
 80008ce:	f002 f803 	bl	80028d8 <raise_exception>
	}

	/* REMOVE THIS */
	//swdptap_seq_out(0, 8);

	return response;
 80008d2:	9802      	ldr	r0, [sp, #8]
 80008d4:	e017      	b.n	8000906 <adiv5_swdp_low_access+0xae>
	do {
		swdptap_seq_out(request, 8);
		ack = swdptap_seq_in(3);
	} while (ack == SWDP_ACK_WAIT && !platform_timeout_is_expired(&timeout));

	if(ack == SWDP_ACK_OK)
 80008d6:	2c01      	cmp	r4, #1
 80008d8:	d10f      	bne.n	80008fa <adiv5_swdp_low_access+0xa2>
	{
		if(RnW) {
 80008da:	2e00      	cmp	r6, #0
 80008dc:	d008      	beq.n	80008f0 <adiv5_swdp_low_access+0x98>
			if(swdptap_seq_in_parity(&response, 32))  /* Give up on parity error */
 80008de:	a802      	add	r0, sp, #8
 80008e0:	2120      	movs	r1, #32
 80008e2:	f004 ff6b 	bl	80057bc <swdptap_seq_in_parity>
 80008e6:	2800      	cmp	r0, #0
 80008e8:	d0f3      	beq.n	80008d2 <adiv5_swdp_low_access+0x7a>
				raise_exception(EXCEPTION_ERROR, "SWDP Parity error");
 80008ea:	1c20      	adds	r0, r4, #0
 80008ec:	4909      	ldr	r1, [pc, #36]	; (8000914 <adiv5_swdp_low_access+0xbc>)
 80008ee:	e7ee      	b.n	80008ce <adiv5_swdp_low_access+0x76>
		} else {
			swdptap_seq_out_parity(value, 32);
 80008f0:	1c38      	adds	r0, r7, #0
 80008f2:	2120      	movs	r1, #32
 80008f4:	f005 f804 	bl	8005900 <swdptap_seq_out_parity>
 80008f8:	e7eb      	b.n	80008d2 <adiv5_swdp_low_access+0x7a>
	else
	{
		if (ack == SWDP_ACK_WAIT)
			raise_exception(EXCEPTION_TIMEOUT, "SWDP ACK timeout");

		if(ack == SWDP_ACK_FAULT) {
 80008fa:	2c04      	cmp	r4, #4
 80008fc:	d1e5      	bne.n	80008ca <adiv5_swdp_low_access+0x72>
			dp->fault = 1;
 80008fe:	2301      	movs	r3, #1
			return 0;
 8000900:	2000      	movs	r0, #0
	{
		if (ack == SWDP_ACK_WAIT)
			raise_exception(EXCEPTION_TIMEOUT, "SWDP ACK timeout");

		if(ack == SWDP_ACK_FAULT) {
			dp->fault = 1;
 8000902:	9a01      	ldr	r2, [sp, #4]
 8000904:	7613      	strb	r3, [r2, #24]

	/* REMOVE THIS */
	//swdptap_seq_out(0, 8);

	return response;
}
 8000906:	b005      	add	sp, #20
 8000908:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800090a:	46c0      	nop			; (mov r8, r8)
 800090c:	0800fb04 	.word	0x0800fb04
 8000910:	0800faf3 	.word	0x0800faf3
 8000914:	0800fae1 	.word	0x0800fae1

08000918 <adiv5_swdp_read>:

	return target_list?1:0;
}

static uint32_t adiv5_swdp_read(ADIv5_DP_t *dp, uint16_t addr)
{
 8000918:	b538      	push	{r3, r4, r5, lr}
	if (addr & ADIV5_APnDP) {
 800091a:	2380      	movs	r3, #128	; 0x80
 800091c:	005b      	lsls	r3, r3, #1

	return target_list?1:0;
}

static uint32_t adiv5_swdp_read(ADIv5_DP_t *dp, uint16_t addr)
{
 800091e:	1c0a      	adds	r2, r1, #0
	if (addr & ADIV5_APnDP) {
 8000920:	400b      	ands	r3, r1

	return target_list?1:0;
}

static uint32_t adiv5_swdp_read(ADIv5_DP_t *dp, uint16_t addr)
{
 8000922:	1c04      	adds	r4, r0, #0
}

static inline uint32_t adiv5_dp_low_access(struct ADIv5_DP_s *dp, uint8_t RnW,
                                           uint16_t addr, uint32_t value)
{
	return dp->low_access(dp, RnW, addr, value);
 8000924:	2101      	movs	r1, #1
	if (addr & ADIV5_APnDP) {
 8000926:	2b00      	cmp	r3, #0
 8000928:	d009      	beq.n	800093e <adiv5_swdp_read+0x26>
 800092a:	6925      	ldr	r5, [r4, #16]
 800092c:	2300      	movs	r3, #0
 800092e:	47a8      	blx	r5
 8000930:	6925      	ldr	r5, [r4, #16]
 8000932:	1c20      	adds	r0, r4, #0
 8000934:	2101      	movs	r1, #1
 8000936:	220c      	movs	r2, #12
 8000938:	2300      	movs	r3, #0
 800093a:	47a8      	blx	r5
 800093c:	e001      	b.n	8000942 <adiv5_swdp_read+0x2a>
		adiv5_dp_low_access(dp, ADIV5_LOW_READ, addr, 0);
		return adiv5_dp_low_access(dp, ADIV5_LOW_READ,
		                           ADIV5_DP_RDBUFF, 0);
	} else {
		return adiv5_swdp_low_access(dp, ADIV5_LOW_READ, addr, 0);
 800093e:	f7ff ff8b 	bl	8000858 <adiv5_swdp_low_access>
	}
}
 8000942:	bd38      	pop	{r3, r4, r5, pc}

08000944 <adiv5_swdp_error>:

static uint32_t adiv5_swdp_error(ADIv5_DP_t *dp)
{
 8000944:	b538      	push	{r3, r4, r5, lr}
	uint32_t err, clr = 0;

	err = adiv5_swdp_read(dp, ADIV5_DP_CTRLSTAT) &
 8000946:	2104      	movs	r1, #4
		return adiv5_swdp_low_access(dp, ADIV5_LOW_READ, addr, 0);
	}
}

static uint32_t adiv5_swdp_error(ADIv5_DP_t *dp)
{
 8000948:	1c05      	adds	r5, r0, #0
	uint32_t err, clr = 0;

	err = adiv5_swdp_read(dp, ADIV5_DP_CTRLSTAT) &
 800094a:	f7ff ffe5 	bl	8000918 <adiv5_swdp_read>
		(ADIV5_DP_CTRLSTAT_STICKYORUN | ADIV5_DP_CTRLSTAT_STICKYCMP |
		ADIV5_DP_CTRLSTAT_STICKYERR | ADIV5_DP_CTRLSTAT_WDATAERR);

	if(err & ADIV5_DP_CTRLSTAT_STICKYORUN)
 800094e:	2302      	movs	r3, #2
 8000950:	1c02      	adds	r2, r0, #0
 8000952:	401a      	ands	r2, r3

static uint32_t adiv5_swdp_error(ADIv5_DP_t *dp)
{
	uint32_t err, clr = 0;

	err = adiv5_swdp_read(dp, ADIV5_DP_CTRLSTAT) &
 8000954:	24b2      	movs	r4, #178	; 0xb2
		(ADIV5_DP_CTRLSTAT_STICKYORUN | ADIV5_DP_CTRLSTAT_STICKYCMP |
		ADIV5_DP_CTRLSTAT_STICKYERR | ADIV5_DP_CTRLSTAT_WDATAERR);

	if(err & ADIV5_DP_CTRLSTAT_STICKYORUN)
		clr |= ADIV5_DP_ABORT_ORUNERRCLR;
 8000956:	1e51      	subs	r1, r2, #1
 8000958:	418a      	sbcs	r2, r1

static uint32_t adiv5_swdp_error(ADIv5_DP_t *dp)
{
	uint32_t err, clr = 0;

	err = adiv5_swdp_read(dp, ADIV5_DP_CTRLSTAT) &
 800095a:	4004      	ands	r4, r0
		(ADIV5_DP_CTRLSTAT_STICKYORUN | ADIV5_DP_CTRLSTAT_STICKYCMP |
		ADIV5_DP_CTRLSTAT_STICKYERR | ADIV5_DP_CTRLSTAT_WDATAERR);

	if(err & ADIV5_DP_CTRLSTAT_STICKYORUN)
		clr |= ADIV5_DP_ABORT_ORUNERRCLR;
 800095c:	0112      	lsls	r2, r2, #4
	if(err & ADIV5_DP_CTRLSTAT_STICKYCMP)
 800095e:	06c1      	lsls	r1, r0, #27
 8000960:	d500      	bpl.n	8000964 <adiv5_swdp_error+0x20>
		clr |= ADIV5_DP_ABORT_STKCMPCLR;
 8000962:	431a      	orrs	r2, r3
	if(err & ADIV5_DP_CTRLSTAT_STICKYERR)
 8000964:	0683      	lsls	r3, r0, #26
 8000966:	d501      	bpl.n	800096c <adiv5_swdp_error+0x28>
		clr |= ADIV5_DP_ABORT_STKERRCLR;
 8000968:	2304      	movs	r3, #4
 800096a:	431a      	orrs	r2, r3
	if(err & ADIV5_DP_CTRLSTAT_WDATAERR)
 800096c:	0603      	lsls	r3, r0, #24
 800096e:	d501      	bpl.n	8000974 <adiv5_swdp_error+0x30>
		clr |= ADIV5_DP_ABORT_WDERRCLR;
 8000970:	2308      	movs	r3, #8
 8000972:	431a      	orrs	r2, r3

	adiv5_dp_write(dp, ADIV5_DP_ABORT, clr);
 8000974:	1c28      	adds	r0, r5, #0
 8000976:	2100      	movs	r1, #0
 8000978:	f7ff fbe2 	bl	8000140 <adiv5_dp_write>
	dp->fault = 0;
 800097c:	2300      	movs	r3, #0

	return err;
}
 800097e:	1c20      	adds	r0, r4, #0
		clr |= ADIV5_DP_ABORT_STKERRCLR;
	if(err & ADIV5_DP_CTRLSTAT_WDATAERR)
		clr |= ADIV5_DP_ABORT_WDERRCLR;

	adiv5_dp_write(dp, ADIV5_DP_ABORT, clr);
	dp->fault = 0;
 8000980:	762b      	strb	r3, [r5, #24]

	return err;
}
 8000982:	bd38      	pop	{r3, r4, r5, pc}

08000984 <adiv5_swdp_scan>:
				      uint16_t addr, uint32_t value);

static void adiv5_swdp_abort(ADIv5_DP_t *dp, uint32_t abort);

int adiv5_swdp_scan(void)
{
 8000984:	b538      	push	{r3, r4, r5, lr}
	uint8_t ack;

	target_list_free();
 8000986:	f007 fb47 	bl	8008018 <target_list_free>
	ADIv5_DP_t *dp = (void*)calloc(1, sizeof(*dp));
 800098a:	211c      	movs	r1, #28
 800098c:	2001      	movs	r0, #1
 800098e:	f00b ff73 	bl	800c878 <calloc>
 8000992:	1c04      	adds	r4, r0, #0

	swdptap_init();
 8000994:	f007 fa9c 	bl	8007ed0 <swdptap_init>

	/* Switch from JTAG to SWD mode */
	swdptap_seq_out(0xFFFF, 16);
 8000998:	4822      	ldr	r0, [pc, #136]	; (8000a24 <adiv5_swdp_scan+0xa0>)
 800099a:	2110      	movs	r1, #16
 800099c:	f004 ff7c 	bl	8005898 <swdptap_seq_out>
 80009a0:	2532      	movs	r5, #50	; 0x32
	for(int i = 0; i < 50; i++)
		swdptap_bit_out(1);
 80009a2:	2001      	movs	r0, #1
 80009a4:	3d01      	subs	r5, #1
 80009a6:	f007 fac9 	bl	8007f3c <swdptap_bit_out>

	swdptap_init();

	/* Switch from JTAG to SWD mode */
	swdptap_seq_out(0xFFFF, 16);
	for(int i = 0; i < 50; i++)
 80009aa:	2d00      	cmp	r5, #0
 80009ac:	d1f9      	bne.n	80009a2 <adiv5_swdp_scan+0x1e>
		swdptap_bit_out(1);
	swdptap_seq_out(0xE79E, 16); /* 0b0111100111100111 */
 80009ae:	481e      	ldr	r0, [pc, #120]	; (8000a28 <adiv5_swdp_scan+0xa4>)
 80009b0:	2110      	movs	r1, #16
 80009b2:	f004 ff71 	bl	8005898 <swdptap_seq_out>
 80009b6:	3532      	adds	r5, #50	; 0x32
	for(int i = 0; i < 50; i++)
		swdptap_bit_out(1);
 80009b8:	2001      	movs	r0, #1
 80009ba:	3d01      	subs	r5, #1
 80009bc:	f007 fabe 	bl	8007f3c <swdptap_bit_out>
	/* Switch from JTAG to SWD mode */
	swdptap_seq_out(0xFFFF, 16);
	for(int i = 0; i < 50; i++)
		swdptap_bit_out(1);
	swdptap_seq_out(0xE79E, 16); /* 0b0111100111100111 */
	for(int i = 0; i < 50; i++)
 80009c0:	2d00      	cmp	r5, #0
 80009c2:	d1f9      	bne.n	80009b8 <adiv5_swdp_scan+0x34>
		swdptap_bit_out(1);
	swdptap_seq_out(0, 16);
 80009c4:	1c28      	adds	r0, r5, #0
 80009c6:	2110      	movs	r1, #16
 80009c8:	f004 ff66 	bl	8005898 <swdptap_seq_out>

	/* Read the SW-DP IDCODE register to syncronise */
	/* This could be done with adiv_swdp_low_access(), but this doesn't
	 * allow the ack to be checked here. */
	swdptap_seq_out(0xA5, 8);
 80009cc:	20a5      	movs	r0, #165	; 0xa5
 80009ce:	2108      	movs	r1, #8
 80009d0:	f004 ff62 	bl	8005898 <swdptap_seq_out>
	ack = swdptap_seq_in(3);
 80009d4:	2003      	movs	r0, #3
 80009d6:	f004 fe7c 	bl	80056d2 <swdptap_seq_in>
	if((ack != SWDP_ACK_OK) || swdptap_seq_in_parity(&dp->idcode, 32)) {
 80009da:	b2c0      	uxtb	r0, r0
 80009dc:	2801      	cmp	r0, #1
 80009de:	d008      	beq.n	80009f2 <adiv5_swdp_scan+0x6e>
		DEBUG("\n");
 80009e0:	200a      	movs	r0, #10
 80009e2:	f00c f855 	bl	800ca90 <putchar>
		free(dp);
 80009e6:	1c20      	adds	r0, r4, #0
 80009e8:	f00b ff5c 	bl	800c8a4 <free>
		return -1;
 80009ec:	2001      	movs	r0, #1
 80009ee:	4240      	negs	r0, r0
 80009f0:	e017      	b.n	8000a22 <adiv5_swdp_scan+0x9e>
	/* Read the SW-DP IDCODE register to syncronise */
	/* This could be done with adiv_swdp_low_access(), but this doesn't
	 * allow the ack to be checked here. */
	swdptap_seq_out(0xA5, 8);
	ack = swdptap_seq_in(3);
	if((ack != SWDP_ACK_OK) || swdptap_seq_in_parity(&dp->idcode, 32)) {
 80009f2:	1d20      	adds	r0, r4, #4
 80009f4:	2120      	movs	r1, #32
 80009f6:	f004 fee1 	bl	80057bc <swdptap_seq_in_parity>
 80009fa:	2800      	cmp	r0, #0
 80009fc:	d1f0      	bne.n	80009e0 <adiv5_swdp_scan+0x5c>
		DEBUG("\n");
		free(dp);
		return -1;
	}

	dp->dp_read = adiv5_swdp_read;
 80009fe:	4b0b      	ldr	r3, [pc, #44]	; (8000a2c <adiv5_swdp_scan+0xa8>)
	dp->error = adiv5_swdp_error;
	dp->low_access = adiv5_swdp_low_access;
	dp->abort = adiv5_swdp_abort;

	adiv5_swdp_error(dp);
 8000a00:	1c20      	adds	r0, r4, #0
		DEBUG("\n");
		free(dp);
		return -1;
	}

	dp->dp_read = adiv5_swdp_read;
 8000a02:	60a3      	str	r3, [r4, #8]
	dp->error = adiv5_swdp_error;
 8000a04:	4b0a      	ldr	r3, [pc, #40]	; (8000a30 <adiv5_swdp_scan+0xac>)
 8000a06:	60e3      	str	r3, [r4, #12]
	dp->low_access = adiv5_swdp_low_access;
 8000a08:	4b0a      	ldr	r3, [pc, #40]	; (8000a34 <adiv5_swdp_scan+0xb0>)
 8000a0a:	6123      	str	r3, [r4, #16]
	dp->abort = adiv5_swdp_abort;
 8000a0c:	4b0a      	ldr	r3, [pc, #40]	; (8000a38 <adiv5_swdp_scan+0xb4>)
 8000a0e:	6163      	str	r3, [r4, #20]

	adiv5_swdp_error(dp);
 8000a10:	f7ff ff98 	bl	8000944 <adiv5_swdp_error>
	adiv5_dp_init(dp);
 8000a14:	1c20      	adds	r0, r4, #0
 8000a16:	f7ff fe23 	bl	8000660 <adiv5_dp_init>

	return target_list?1:0;
 8000a1a:	4b08      	ldr	r3, [pc, #32]	; (8000a3c <adiv5_swdp_scan+0xb8>)
 8000a1c:	6818      	ldr	r0, [r3, #0]
 8000a1e:	1e43      	subs	r3, r0, #1
 8000a20:	4198      	sbcs	r0, r3
}
 8000a22:	bd38      	pop	{r3, r4, r5, pc}
 8000a24:	0000ffff 	.word	0x0000ffff
 8000a28:	0000e79e 	.word	0x0000e79e
 8000a2c:	08000919 	.word	0x08000919
 8000a30:	08000945 	.word	0x08000945
 8000a34:	08000859 	.word	0x08000859
 8000a38:	0800084d 	.word	0x0800084d
 8000a3c:	200011e0 	.word	0x200011e0

08000a40 <cmd_debug_bmp>:
}
#endif

#ifdef PLATFORM_HAS_DEBUG
static bool cmd_debug_bmp(target *t, int argc, const char **argv)
{
 8000a40:	b510      	push	{r4, lr}
 8000a42:	4c0a      	ldr	r4, [pc, #40]	; (8000a6c <cmd_debug_bmp+0x2c>)
	(void)t;
	if (argc > 1) {
 8000a44:	2901      	cmp	r1, #1
 8000a46:	dd06      	ble.n	8000a56 <cmd_debug_bmp+0x16>
		debug_bmp = !strcmp(argv[1], "enable");
 8000a48:	6850      	ldr	r0, [r2, #4]
 8000a4a:	4909      	ldr	r1, [pc, #36]	; (8000a70 <cmd_debug_bmp+0x30>)
 8000a4c:	f00c f9e2 	bl	800ce14 <strcmp>
 8000a50:	4243      	negs	r3, r0
 8000a52:	4143      	adcs	r3, r0
 8000a54:	7023      	strb	r3, [r4, #0]
	}
	gdb_outf("Debug mode is %s\n",
 8000a56:	7823      	ldrb	r3, [r4, #0]
 8000a58:	4906      	ldr	r1, [pc, #24]	; (8000a74 <cmd_debug_bmp+0x34>)
 8000a5a:	2b00      	cmp	r3, #0
 8000a5c:	d100      	bne.n	8000a60 <cmd_debug_bmp+0x20>
 8000a5e:	4906      	ldr	r1, [pc, #24]	; (8000a78 <cmd_debug_bmp+0x38>)
 8000a60:	4806      	ldr	r0, [pc, #24]	; (8000a7c <cmd_debug_bmp+0x3c>)
 8000a62:	f003 f80b 	bl	8003a7c <gdb_outf>
		 debug_bmp ? "enabled" : "disabled");
	return true;
}
 8000a66:	2001      	movs	r0, #1
 8000a68:	bd10      	pop	{r4, pc}
 8000a6a:	46c0      	nop			; (mov r8, r8)
 8000a6c:	20001d98 	.word	0x20001d98
 8000a70:	0800fba1 	.word	0x0800fba1
 8000a74:	0800fb90 	.word	0x0800fb90
 8000a78:	0800fb98 	.word	0x0800fb98
 8000a7c:	0800fba8 	.word	0x0800fba8

08000a80 <cmd_morse>:

	return true;
}

bool cmd_morse(void)
{
 8000a80:	b508      	push	{r3, lr}
	if(morse_msg)
 8000a82:	4b04      	ldr	r3, [pc, #16]	; (8000a94 <cmd_morse+0x14>)
 8000a84:	6819      	ldr	r1, [r3, #0]
 8000a86:	2900      	cmp	r1, #0
 8000a88:	d002      	beq.n	8000a90 <cmd_morse+0x10>
		gdb_outf("%s\n", morse_msg);
 8000a8a:	4803      	ldr	r0, [pc, #12]	; (8000a98 <cmd_morse+0x18>)
 8000a8c:	f002 fff6 	bl	8003a7c <gdb_outf>
	return true;
}
 8000a90:	2001      	movs	r0, #1
 8000a92:	bd08      	pop	{r3, pc}
 8000a94:	20002060 	.word	0x20002060
 8000a98:	0800fcd6 	.word	0x0800fcd6

08000a9c <cmd_hard_srst>:
		connect_assert_srst = !strcmp(argv[1], "enable");
	return true;
}

static bool cmd_hard_srst(void)
{
 8000a9c:	b508      	push	{r3, lr}
	target_list_free();
 8000a9e:	f007 fabb 	bl	8008018 <target_list_free>
	platform_srst_set_val(true);
 8000aa2:	2001      	movs	r0, #1
 8000aa4:	f004 fdf6 	bl	8005694 <platform_srst_set_val>
	platform_srst_set_val(false);
 8000aa8:	2000      	movs	r0, #0
 8000aaa:	f004 fdf3 	bl	8005694 <platform_srst_set_val>
	return true;
}
 8000aae:	2001      	movs	r0, #1
 8000ab0:	bd08      	pop	{r3, pc}

08000ab2 <cmd_version>:

	return target_command(t, argc, argv);
}

bool cmd_version(void)
{
 8000ab2:	b508      	push	{r3, lr}
	gdb_outf("Black Magic Probe (Firmware " FIRMWARE_VERSION ") (Hardware Version %d)\n", platform_hwversion());
 8000ab4:	2100      	movs	r1, #0
 8000ab6:	4805      	ldr	r0, [pc, #20]	; (8000acc <cmd_version+0x1a>)
 8000ab8:	f002 ffe0 	bl	8003a7c <gdb_outf>
	gdb_out("Copyright (C) 2015  Black Sphere Technologies Ltd.\n");
 8000abc:	4804      	ldr	r0, [pc, #16]	; (8000ad0 <cmd_version+0x1e>)
 8000abe:	f002 ffa4 	bl	8003a0a <gdb_out>
	gdb_out("License GPLv3+: GNU GPL version 3 or later "
 8000ac2:	4804      	ldr	r0, [pc, #16]	; (8000ad4 <cmd_version+0x22>)
 8000ac4:	f002 ffa1 	bl	8003a0a <gdb_out>
		"<http://gnu.org/licenses/gpl.html>\n\n");

	return true;
}
 8000ac8:	2001      	movs	r0, #1
 8000aca:	bd08      	pop	{r3, pc}
 8000acc:	0800fbba 	.word	0x0800fbba
 8000ad0:	0800fc0a 	.word	0x0800fc0a
 8000ad4:	0800fc3e 	.word	0x0800fc3e

08000ad8 <cmd_targets>:
	(void)context;
	gdb_outf("%2d   %c  %s\n", i, target_attached(t)?'*':' ', target_driver_name(t));
}

bool cmd_targets(void)
{
 8000ad8:	b510      	push	{r4, lr}
	gdb_out("Available Targets:\n");
 8000ada:	4808      	ldr	r0, [pc, #32]	; (8000afc <cmd_targets+0x24>)
 8000adc:	f002 ff95 	bl	8003a0a <gdb_out>
	gdb_out("No. Att Driver\n");
 8000ae0:	4807      	ldr	r0, [pc, #28]	; (8000b00 <cmd_targets+0x28>)
 8000ae2:	f002 ff92 	bl	8003a0a <gdb_out>
	if (!target_foreach(display_target, NULL)) {
 8000ae6:	4807      	ldr	r0, [pc, #28]	; (8000b04 <cmd_targets+0x2c>)
 8000ae8:	2100      	movs	r1, #0
 8000aea:	f007 fa7d 	bl	8007fe8 <target_foreach>
 8000aee:	1e04      	subs	r4, r0, #0
 8000af0:	d102      	bne.n	8000af8 <cmd_targets+0x20>
		gdb_out("No usable targets found.\n");
 8000af2:	4805      	ldr	r0, [pc, #20]	; (8000b08 <cmd_targets+0x30>)
 8000af4:	f002 ff89 	bl	8003a0a <gdb_out>
		return false;
	}

	return true;
}
 8000af8:	1c20      	adds	r0, r4, #0
 8000afa:	bd10      	pop	{r4, pc}
 8000afc:	0800fc8e 	.word	0x0800fc8e
 8000b00:	0800fca2 	.word	0x0800fca2
 8000b04:	08000b0d 	.word	0x08000b0d
 8000b08:	0800fcb2 	.word	0x0800fcb2

08000b0c <display_target>:
	return true;

}

static void display_target(int i, target *t, void *context)
{
 8000b0c:	b570      	push	{r4, r5, r6, lr}
 8000b0e:	1c06      	adds	r6, r0, #0
	(void)context;
	gdb_outf("%2d   %c  %s\n", i, target_attached(t)?'*':' ', target_driver_name(t));
 8000b10:	1c08      	adds	r0, r1, #0
	return true;

}

static void display_target(int i, target *t, void *context)
{
 8000b12:	1c0d      	adds	r5, r1, #0
	(void)context;
	gdb_outf("%2d   %c  %s\n", i, target_attached(t)?'*':' ', target_driver_name(t));
 8000b14:	f007 fc84 	bl	8008420 <target_attached>
 8000b18:	242a      	movs	r4, #42	; 0x2a
 8000b1a:	2800      	cmp	r0, #0
 8000b1c:	d100      	bne.n	8000b20 <display_target+0x14>
 8000b1e:	3c0a      	subs	r4, #10
 8000b20:	1c28      	adds	r0, r5, #0
 8000b22:	f007 fd01 	bl	8008528 <target_driver_name>
 8000b26:	1c31      	adds	r1, r6, #0
 8000b28:	1c03      	adds	r3, r0, #0
 8000b2a:	1c22      	adds	r2, r4, #0
 8000b2c:	4801      	ldr	r0, [pc, #4]	; (8000b34 <display_target+0x28>)
 8000b2e:	f002 ffa5 	bl	8003a7c <gdb_outf>
}
 8000b32:	bd70      	pop	{r4, r5, r6, pc}
 8000b34:	0800fccc 	.word	0x0800fccc

08000b38 <cmd_swdp_scan>:
	morse(NULL, false);
	return true;
}

bool cmd_swdp_scan(void)
{
 8000b38:	b530      	push	{r4, r5, lr}
 8000b3a:	b09f      	sub	sp, #124	; 0x7c
	gdb_outf("Target voltage: %s\n", platform_target_voltage());
 8000b3c:	f004 fdc3 	bl	80056c6 <platform_target_voltage>
 8000b40:	1c01      	adds	r1, r0, #0
 8000b42:	4823      	ldr	r0, [pc, #140]	; (8000bd0 <cmd_swdp_scan+0x98>)
 8000b44:	f002 ff9a 	bl	8003a7c <gdb_outf>

	if(connect_assert_srst)
 8000b48:	4b22      	ldr	r3, [pc, #136]	; (8000bd4 <cmd_swdp_scan+0x9c>)
 8000b4a:	781b      	ldrb	r3, [r3, #0]
 8000b4c:	2b00      	cmp	r3, #0
 8000b4e:	d10f      	bne.n	8000b70 <cmd_swdp_scan+0x38>
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000b50:	2200      	movs	r2, #0
 8000b52:	4921      	ldr	r1, [pc, #132]	; (8000bd8 <cmd_swdp_scan+0xa0>)
 8000b54:	9203      	str	r2, [sp, #12]
 8000b56:	6808      	ldr	r0, [r1, #0]
 8000b58:	3a01      	subs	r2, #1
 8000b5a:	ab03      	add	r3, sp, #12
 8000b5c:	9205      	str	r2, [sp, #20]
 8000b5e:	901d      	str	r0, [sp, #116]	; 0x74
 8000b60:	a806      	add	r0, sp, #24
 8000b62:	600b      	str	r3, [r1, #0]
	gdb_outf("Target voltage: %s\n", platform_target_voltage());

	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
 8000b64:	9201      	str	r2, [sp, #4]
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000b66:	f00c f825 	bl	800cbb4 <setjmp>
 8000b6a:	2800      	cmp	r0, #0
 8000b6c:	d10f      	bne.n	8000b8e <cmd_swdp_scan+0x56>
 8000b6e:	e003      	b.n	8000b78 <cmd_swdp_scan+0x40>
bool cmd_swdp_scan(void)
{
	gdb_outf("Target voltage: %s\n", platform_target_voltage());

	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */
 8000b70:	2001      	movs	r0, #1
 8000b72:	f004 fd8f 	bl	8005694 <platform_srst_set_val>
 8000b76:	e7eb      	b.n	8000b50 <cmd_swdp_scan+0x18>

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000b78:	4d17      	ldr	r5, [pc, #92]	; (8000bd8 <cmd_swdp_scan+0xa0>)
 8000b7a:	ab03      	add	r3, sp, #12
 8000b7c:	682c      	ldr	r4, [r5, #0]
 8000b7e:	429c      	cmp	r4, r3
 8000b80:	d105      	bne.n	8000b8e <cmd_swdp_scan+0x56>
		devs = adiv5_swdp_scan();
 8000b82:	f7ff feff 	bl	8000984 <adiv5_swdp_scan>
	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000b86:	6ea3      	ldr	r3, [r4, #104]	; 0x68
		devs = adiv5_swdp_scan();
 8000b88:	9001      	str	r0, [sp, #4]
	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000b8a:	602b      	str	r3, [r5, #0]
 8000b8c:	e7f4      	b.n	8000b78 <cmd_swdp_scan+0x40>
		devs = adiv5_swdp_scan();
	}
	switch (e.type) {
 8000b8e:	9b03      	ldr	r3, [sp, #12]
 8000b90:	2b01      	cmp	r3, #1
 8000b92:	d005      	beq.n	8000ba0 <cmd_swdp_scan+0x68>
 8000b94:	2b02      	cmp	r3, #2
 8000b96:	d107      	bne.n	8000ba8 <cmd_swdp_scan+0x70>
	case EXCEPTION_TIMEOUT:
		gdb_outf("Timeout during scan. Is target stuck in WFI?\n");
 8000b98:	4810      	ldr	r0, [pc, #64]	; (8000bdc <cmd_swdp_scan+0xa4>)
 8000b9a:	f002 ff6f 	bl	8003a7c <gdb_outf>
 8000b9e:	e003      	b.n	8000ba8 <cmd_swdp_scan+0x70>
		break;
	case EXCEPTION_ERROR:
		gdb_outf("Exception: %s\n", e.msg);
 8000ba0:	9904      	ldr	r1, [sp, #16]
 8000ba2:	480f      	ldr	r0, [pc, #60]	; (8000be0 <cmd_swdp_scan+0xa8>)
 8000ba4:	f002 ff6a 	bl	8003a7c <gdb_outf>
		break;
	}

	if(devs <= 0) {
 8000ba8:	9b01      	ldr	r3, [sp, #4]
 8000baa:	2b00      	cmp	r3, #0
 8000bac:	dc07      	bgt.n	8000bbe <cmd_swdp_scan+0x86>
		platform_srst_set_val(false);
 8000bae:	2000      	movs	r0, #0
 8000bb0:	f004 fd70 	bl	8005694 <platform_srst_set_val>
		gdb_out("SW-DP scan failed!\n");
 8000bb4:	480b      	ldr	r0, [pc, #44]	; (8000be4 <cmd_swdp_scan+0xac>)
 8000bb6:	f002 ff28 	bl	8003a0a <gdb_out>
		return false;
 8000bba:	2000      	movs	r0, #0
 8000bbc:	e006      	b.n	8000bcc <cmd_swdp_scan+0x94>
	}

	cmd_targets();
 8000bbe:	f7ff ff8b 	bl	8000ad8 <cmd_targets>
	morse(NULL, false);
 8000bc2:	2000      	movs	r0, #0
 8000bc4:	1c01      	adds	r1, r0, #0
 8000bc6:	f004 f813 	bl	8004bf0 <morse>
	return true;
 8000bca:	2001      	movs	r0, #1

}
 8000bcc:	b01f      	add	sp, #124	; 0x7c
 8000bce:	bd30      	pop	{r4, r5, pc}
 8000bd0:	0800fcda 	.word	0x0800fcda
 8000bd4:	20000138 	.word	0x20000138
 8000bd8:	20001dc4 	.word	0x20001dc4
 8000bdc:	0800fcee 	.word	0x0800fcee
 8000be0:	0800fd1c 	.word	0x0800fd1c
 8000be4:	0800fd2b 	.word	0x0800fd2b

08000be8 <cmd_jtag_scan>:

	return true;
}

static bool cmd_jtag_scan(target *t, int argc, char **argv)
{
 8000be8:	b5b0      	push	{r4, r5, r7, lr}
	(void)t;
	uint8_t irlens[argc];
 8000bea:	1c0b      	adds	r3, r1, #0

	return true;
}

static bool cmd_jtag_scan(target *t, int argc, char **argv)
{
 8000bec:	b0a0      	sub	sp, #128	; 0x80
 8000bee:	1c15      	adds	r5, r2, #0
	(void)t;
	uint8_t irlens[argc];
 8000bf0:	466a      	mov	r2, sp
 8000bf2:	3307      	adds	r3, #7
 8000bf4:	08db      	lsrs	r3, r3, #3
 8000bf6:	00db      	lsls	r3, r3, #3
 8000bf8:	1ad3      	subs	r3, r2, r3

	return true;
}

static bool cmd_jtag_scan(target *t, int argc, char **argv)
{
 8000bfa:	af00      	add	r7, sp, #0
	(void)t;
	uint8_t irlens[argc];
 8000bfc:	469d      	mov	sp, r3
 8000bfe:	60bb      	str	r3, [r7, #8]

	return true;
}

static bool cmd_jtag_scan(target *t, int argc, char **argv)
{
 8000c00:	60f9      	str	r1, [r7, #12]
	(void)t;
	uint8_t irlens[argc];

	gdb_outf("Target voltage: %s\n", platform_target_voltage());
 8000c02:	f004 fd60 	bl	80056c6 <platform_target_voltage>
 8000c06:	1c01      	adds	r1, r0, #0
 8000c08:	4832      	ldr	r0, [pc, #200]	; (8000cd4 <cmd_jtag_scan+0xec>)
 8000c0a:	f002 ff37 	bl	8003a7c <gdb_outf>

	if (argc > 1) {
 8000c0e:	68fb      	ldr	r3, [r7, #12]
 8000c10:	2b01      	cmp	r3, #1
 8000c12:	dd11      	ble.n	8000c38 <cmd_jtag_scan+0x50>
 8000c14:	2401      	movs	r4, #1
 8000c16:	00a3      	lsls	r3, r4, #2
		/* Accept a list of IR lengths on command line */
		for (int i = 1; i < argc; i++)
			irlens[i-1] = atoi(argv[i]);
 8000c18:	58e8      	ldr	r0, [r5, r3]
 8000c1a:	f00b fe20 	bl	800c85e <atoi>
 8000c1e:	68ba      	ldr	r2, [r7, #8]
 8000c20:	1e63      	subs	r3, r4, #1
 8000c22:	54d0      	strb	r0, [r2, r3]

	gdb_outf("Target voltage: %s\n", platform_target_voltage());

	if (argc > 1) {
		/* Accept a list of IR lengths on command line */
		for (int i = 1; i < argc; i++)
 8000c24:	68fb      	ldr	r3, [r7, #12]
 8000c26:	3401      	adds	r4, #1
 8000c28:	429c      	cmp	r4, r3
 8000c2a:	d1f4      	bne.n	8000c16 <cmd_jtag_scan+0x2e>
			irlens[i-1] = atoi(argv[i]);
		irlens[argc-1] = 0;
 8000c2c:	1c13      	adds	r3, r2, #0
 8000c2e:	68fa      	ldr	r2, [r7, #12]
 8000c30:	189b      	adds	r3, r3, r2
 8000c32:	2200      	movs	r2, #0
 8000c34:	3b01      	subs	r3, #1
 8000c36:	701a      	strb	r2, [r3, #0]
	}

	if(connect_assert_srst)
 8000c38:	4b27      	ldr	r3, [pc, #156]	; (8000cd8 <cmd_jtag_scan+0xf0>)
 8000c3a:	781b      	ldrb	r3, [r3, #0]
 8000c3c:	2b00      	cmp	r3, #0
 8000c3e:	d112      	bne.n	8000c66 <cmd_jtag_scan+0x7e>
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000c40:	2200      	movs	r2, #0
 8000c42:	2314      	movs	r3, #20
 8000c44:	4925      	ldr	r1, [pc, #148]	; (8000cdc <cmd_jtag_scan+0xf4>)
 8000c46:	18fb      	adds	r3, r7, r3
 8000c48:	6808      	ldr	r0, [r1, #0]
 8000c4a:	617a      	str	r2, [r7, #20]
 8000c4c:	3a01      	subs	r2, #1
 8000c4e:	609a      	str	r2, [r3, #8]
 8000c50:	600b      	str	r3, [r1, #0]
 8000c52:	6698      	str	r0, [r3, #104]	; 0x68
 8000c54:	2310      	movs	r3, #16
	}

	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
 8000c56:	607a      	str	r2, [r7, #4]
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000c58:	18fa      	adds	r2, r7, r3
 8000c5a:	18d0      	adds	r0, r2, r3
 8000c5c:	f00b ffaa 	bl	800cbb4 <setjmp>
 8000c60:	2800      	cmp	r0, #0
 8000c62:	d115      	bne.n	8000c90 <cmd_jtag_scan+0xa8>
 8000c64:	e00e      	b.n	8000c84 <cmd_jtag_scan+0x9c>
			irlens[i-1] = atoi(argv[i]);
		irlens[argc-1] = 0;
	}

	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */
 8000c66:	2001      	movs	r0, #1
 8000c68:	f004 fd14 	bl	8005694 <platform_srst_set_val>
 8000c6c:	e7e8      	b.n	8000c40 <cmd_jtag_scan+0x58>

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
		devs = jtag_scan(argc > 1 ? irlens : NULL);
 8000c6e:	68fb      	ldr	r3, [r7, #12]
 8000c70:	2000      	movs	r0, #0
 8000c72:	2b01      	cmp	r3, #1
 8000c74:	dd00      	ble.n	8000c78 <cmd_jtag_scan+0x90>
}

static bool cmd_jtag_scan(target *t, int argc, char **argv)
{
	(void)t;
	uint8_t irlens[argc];
 8000c76:	68b8      	ldr	r0, [r7, #8]
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
		devs = jtag_scan(argc > 1 ? irlens : NULL);
 8000c78:	f002 ff4e 	bl	8003b18 <jtag_scan>
	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000c7c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8000c7e:	4b17      	ldr	r3, [pc, #92]	; (8000cdc <cmd_jtag_scan+0xf4>)
		devs = jtag_scan(argc > 1 ? irlens : NULL);
 8000c80:	6078      	str	r0, [r7, #4]
	if(connect_assert_srst)
		platform_srst_set_val(true); /* will be deasserted after attach */

	int devs = -1;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8000c82:	601a      	str	r2, [r3, #0]
 8000c84:	4b15      	ldr	r3, [pc, #84]	; (8000cdc <cmd_jtag_scan+0xf4>)
 8000c86:	681a      	ldr	r2, [r3, #0]
 8000c88:	2314      	movs	r3, #20
 8000c8a:	18fb      	adds	r3, r7, r3
 8000c8c:	429a      	cmp	r2, r3
 8000c8e:	d0ee      	beq.n	8000c6e <cmd_jtag_scan+0x86>
		devs = jtag_scan(argc > 1 ? irlens : NULL);
	}
	switch (e.type) {
 8000c90:	697b      	ldr	r3, [r7, #20]
 8000c92:	2b01      	cmp	r3, #1
 8000c94:	d005      	beq.n	8000ca2 <cmd_jtag_scan+0xba>
 8000c96:	2b02      	cmp	r3, #2
 8000c98:	d107      	bne.n	8000caa <cmd_jtag_scan+0xc2>
	case EXCEPTION_TIMEOUT:
		gdb_outf("Timeout during scan. Is target stuck in WFI?\n");
 8000c9a:	4811      	ldr	r0, [pc, #68]	; (8000ce0 <cmd_jtag_scan+0xf8>)
 8000c9c:	f002 feee 	bl	8003a7c <gdb_outf>
 8000ca0:	e003      	b.n	8000caa <cmd_jtag_scan+0xc2>
		break;
	case EXCEPTION_ERROR:
		gdb_outf("Exception: %s\n", e.msg);
 8000ca2:	69b9      	ldr	r1, [r7, #24]
 8000ca4:	480f      	ldr	r0, [pc, #60]	; (8000ce4 <cmd_jtag_scan+0xfc>)
 8000ca6:	f002 fee9 	bl	8003a7c <gdb_outf>
		break;
	}

	if(devs <= 0) {
 8000caa:	687b      	ldr	r3, [r7, #4]
 8000cac:	2b00      	cmp	r3, #0
 8000cae:	dc07      	bgt.n	8000cc0 <cmd_jtag_scan+0xd8>
		platform_srst_set_val(false);
 8000cb0:	2000      	movs	r0, #0
 8000cb2:	f004 fcef 	bl	8005694 <platform_srst_set_val>
		gdb_out("JTAG device scan failed!\n");
 8000cb6:	480c      	ldr	r0, [pc, #48]	; (8000ce8 <cmd_jtag_scan+0x100>)
 8000cb8:	f002 fea7 	bl	8003a0a <gdb_out>
		return false;
 8000cbc:	2000      	movs	r0, #0
 8000cbe:	e006      	b.n	8000cce <cmd_jtag_scan+0xe6>
	}
	cmd_targets();
 8000cc0:	f7ff ff0a 	bl	8000ad8 <cmd_targets>
	morse(NULL, false);
 8000cc4:	2000      	movs	r0, #0
 8000cc6:	1c01      	adds	r1, r0, #0
 8000cc8:	f003 ff92 	bl	8004bf0 <morse>
	return true;
 8000ccc:	2001      	movs	r0, #1
}
 8000cce:	46bd      	mov	sp, r7
 8000cd0:	b020      	add	sp, #128	; 0x80
 8000cd2:	bdb0      	pop	{r4, r5, r7, pc}
 8000cd4:	0800fcda 	.word	0x0800fcda
 8000cd8:	20000138 	.word	0x20000138
 8000cdc:	20001dc4 	.word	0x20001dc4
 8000ce0:	0800fcee 	.word	0x0800fcee
 8000ce4:	0800fd1c 	.word	0x0800fd1c
 8000ce8:	0800fd3f 	.word	0x0800fd3f

08000cec <cmd_help>:

	return true;
}

bool cmd_help(target *t)
{
 8000cec:	b538      	push	{r3, r4, r5, lr}
 8000cee:	1c05      	adds	r5, r0, #0
	const struct command_s *c;

	gdb_out("General commands:\n");
 8000cf0:	480b      	ldr	r0, [pc, #44]	; (8000d20 <cmd_help+0x34>)
 8000cf2:	f002 fe8a 	bl	8003a0a <gdb_out>
 8000cf6:	4c0b      	ldr	r4, [pc, #44]	; (8000d24 <cmd_help+0x38>)
 8000cf8:	3408      	adds	r4, #8
 8000cfa:	1c23      	adds	r3, r4, #0
 8000cfc:	3b08      	subs	r3, #8
	for(c = cmd_list; c->cmd; c++)
 8000cfe:	6819      	ldr	r1, [r3, #0]
 8000d00:	2900      	cmp	r1, #0
 8000d02:	d005      	beq.n	8000d10 <cmd_help+0x24>
		gdb_outf("\t%s -- %s\n", c->cmd, c->help);
 8000d04:	6822      	ldr	r2, [r4, #0]
 8000d06:	4808      	ldr	r0, [pc, #32]	; (8000d28 <cmd_help+0x3c>)
 8000d08:	f002 feb8 	bl	8003a7c <gdb_outf>
 8000d0c:	340c      	adds	r4, #12
 8000d0e:	e7f4      	b.n	8000cfa <cmd_help+0xe>

	if (!t)
 8000d10:	2d00      	cmp	r5, #0
 8000d12:	d002      	beq.n	8000d1a <cmd_help+0x2e>
		return -1;

	target_command_help(t);
 8000d14:	1c28      	adds	r0, r5, #0
 8000d16:	f007 fc76 	bl	8008606 <target_command_help>

	return true;
}
 8000d1a:	2001      	movs	r0, #1
 8000d1c:	bd38      	pop	{r3, r4, r5, pc}
 8000d1e:	46c0      	nop			; (mov r8, r8)
 8000d20:	0800fd59 	.word	0x0800fd59
 8000d24:	0800fb18 	.word	0x0800fb18
 8000d28:	0800fd6c 	.word	0x0800fd6c

08000d2c <cmd_connect_srst>:
		gdb_outf("%s\n", morse_msg);
	return true;
}

static bool cmd_connect_srst(target *t, int argc, const char **argv)
{
 8000d2c:	b510      	push	{r4, lr}
 8000d2e:	4c0a      	ldr	r4, [pc, #40]	; (8000d58 <cmd_connect_srst+0x2c>)
	(void)t;
	if (argc == 1)
 8000d30:	2901      	cmp	r1, #1
 8000d32:	d108      	bne.n	8000d46 <cmd_connect_srst+0x1a>
		gdb_outf("Assert SRST during connect: %s\n",
 8000d34:	7823      	ldrb	r3, [r4, #0]
 8000d36:	4909      	ldr	r1, [pc, #36]	; (8000d5c <cmd_connect_srst+0x30>)
 8000d38:	2b00      	cmp	r3, #0
 8000d3a:	d100      	bne.n	8000d3e <cmd_connect_srst+0x12>
 8000d3c:	4908      	ldr	r1, [pc, #32]	; (8000d60 <cmd_connect_srst+0x34>)
 8000d3e:	4809      	ldr	r0, [pc, #36]	; (8000d64 <cmd_connect_srst+0x38>)
 8000d40:	f002 fe9c 	bl	8003a7c <gdb_outf>
 8000d44:	e006      	b.n	8000d54 <cmd_connect_srst+0x28>
			 connect_assert_srst ? "enabled" : "disabled");
	else
		connect_assert_srst = !strcmp(argv[1], "enable");
 8000d46:	6850      	ldr	r0, [r2, #4]
 8000d48:	4907      	ldr	r1, [pc, #28]	; (8000d68 <cmd_connect_srst+0x3c>)
 8000d4a:	f00c f863 	bl	800ce14 <strcmp>
 8000d4e:	4243      	negs	r3, r0
 8000d50:	4143      	adcs	r3, r0
 8000d52:	7023      	strb	r3, [r4, #0]
	return true;
}
 8000d54:	2001      	movs	r0, #1
 8000d56:	bd10      	pop	{r4, pc}
 8000d58:	20000138 	.word	0x20000138
 8000d5c:	0800fb90 	.word	0x0800fb90
 8000d60:	0800fb98 	.word	0x0800fb98
 8000d64:	0800fd77 	.word	0x0800fd77
 8000d68:	0800fba1 	.word	0x0800fba1

08000d6c <command_process>:
	const struct command_s *c;
	int argc = 0;
	const char **argv;

	/* Initial estimate for argc */
	for(char *s = cmd; *s; s++)
 8000d6c:	1c0a      	adds	r2, r1, #0
#endif

int command_process(target *t, char *cmd)
{
	const struct command_s *c;
	int argc = 0;
 8000d6e:	2300      	movs	r3, #0
#ifdef PLATFORM_HAS_DEBUG
bool debug_bmp;
#endif

int command_process(target *t, char *cmd)
{
 8000d70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d72:	b085      	sub	sp, #20
 8000d74:	af00      	add	r7, sp, #0
 8000d76:	60f8      	str	r0, [r7, #12]
	const struct command_s *c;
	int argc = 0;
	const char **argv;

	/* Initial estimate for argc */
	for(char *s = cmd; *s; s++)
 8000d78:	7814      	ldrb	r4, [r2, #0]
 8000d7a:	2c00      	cmp	r4, #0
 8000d7c:	d006      	beq.n	8000d8c <command_process+0x20>
		if((*s == ' ') || (*s == '\t')) argc++;
 8000d7e:	2c20      	cmp	r4, #32
 8000d80:	d001      	beq.n	8000d86 <command_process+0x1a>
 8000d82:	2c09      	cmp	r4, #9
 8000d84:	d100      	bne.n	8000d88 <command_process+0x1c>
 8000d86:	3301      	adds	r3, #1
	const struct command_s *c;
	int argc = 0;
	const char **argv;

	/* Initial estimate for argc */
	for(char *s = cmd; *s; s++)
 8000d88:	3201      	adds	r2, #1
 8000d8a:	e7f5      	b.n	8000d78 <command_process+0xc>
		if((*s == ' ') || (*s == '\t')) argc++;

	argv = alloca(sizeof(const char *) * argc);
 8000d8c:	466a      	mov	r2, sp
 8000d8e:	009b      	lsls	r3, r3, #2
 8000d90:	330e      	adds	r3, #14
 8000d92:	08db      	lsrs	r3, r3, #3
 8000d94:	00db      	lsls	r3, r3, #3
 8000d96:	1ad3      	subs	r3, r2, r3
 8000d98:	469d      	mov	sp, r3

	/* Tokenize cmd to find argv */
	for(argc = 0, argv[argc] = strtok(cmd, " \t");
 8000d9a:	1c08      	adds	r0, r1, #0
 8000d9c:	491f      	ldr	r1, [pc, #124]	; (8000e1c <command_process+0xb0>)
 8000d9e:	f00c f899 	bl	800ced4 <strtok>

	/* Initial estimate for argc */
	for(char *s = cmd; *s; s++)
		if((*s == ' ') || (*s == '\t')) argc++;

	argv = alloca(sizeof(const char *) * argc);
 8000da2:	466d      	mov	r5, sp
 8000da4:	466e      	mov	r6, sp
 8000da6:	4b1d      	ldr	r3, [pc, #116]	; (8000e1c <command_process+0xb0>)

	/* Tokenize cmd to find argv */
	for(argc = 0, argv[argc] = strtok(cmd, " \t");
 8000da8:	9000      	str	r0, [sp, #0]
 8000daa:	60bb      	str	r3, [r7, #8]
 8000dac:	3604      	adds	r6, #4
 8000dae:	1f33      	subs	r3, r6, #4
 8000db0:	681b      	ldr	r3, [r3, #0]
 8000db2:	2b00      	cmp	r3, #0
 8000db4:	d006      	beq.n	8000dc4 <command_process+0x58>
		argv[argc]; argv[++argc] = strtok(NULL, " \t"));
 8000db6:	2000      	movs	r0, #0
 8000db8:	68b9      	ldr	r1, [r7, #8]
 8000dba:	f00c f88b 	bl	800ced4 <strtok>
 8000dbe:	3401      	adds	r4, #1
 8000dc0:	6030      	str	r0, [r6, #0]
 8000dc2:	e7f3      	b.n	8000dac <command_process+0x40>
		if((*s == ' ') || (*s == '\t')) argc++;

	argv = alloca(sizeof(const char *) * argc);

	/* Tokenize cmd to find argv */
	for(argc = 0, argv[argc] = strtok(cmd, " \t");
 8000dc4:	4e16      	ldr	r6, [pc, #88]	; (8000e20 <command_process+0xb4>)
		argv[argc]; argv[++argc] = strtok(NULL, " \t"));

	/* Look for match and call handler */
	for(c = cmd_list; c->cmd; c++) {
 8000dc6:	6833      	ldr	r3, [r6, #0]
 8000dc8:	60bb      	str	r3, [r7, #8]
 8000dca:	2b00      	cmp	r3, #0
 8000dcc:	d018      	beq.n	8000e00 <command_process+0x94>
		/* Accept a partial match as GDB does.
		 * So 'mon ver' will match 'monitor version'
		 */
		if ((argc == 0) || !strncmp(argv[0], c->cmd, strlen(argv[0])))
 8000dce:	2c00      	cmp	r4, #0
 8000dd0:	d108      	bne.n	8000de4 <command_process+0x78>
			return !c->handler(t, argc, argv);
 8000dd2:	6873      	ldr	r3, [r6, #4]
 8000dd4:	68f8      	ldr	r0, [r7, #12]
 8000dd6:	1c21      	adds	r1, r4, #0
 8000dd8:	1c2a      	adds	r2, r5, #0
 8000dda:	4798      	blx	r3
 8000ddc:	2301      	movs	r3, #1
 8000dde:	4058      	eors	r0, r3
 8000de0:	b2c0      	uxtb	r0, r0
 8000de2:	e018      	b.n	8000e16 <command_process+0xaa>
	/* Look for match and call handler */
	for(c = cmd_list; c->cmd; c++) {
		/* Accept a partial match as GDB does.
		 * So 'mon ver' will match 'monitor version'
		 */
		if ((argc == 0) || !strncmp(argv[0], c->cmd, strlen(argv[0])))
 8000de4:	682b      	ldr	r3, [r5, #0]
 8000de6:	1c18      	adds	r0, r3, #0
 8000de8:	607b      	str	r3, [r7, #4]
 8000dea:	f00c f81d 	bl	800ce28 <strlen>
 8000dee:	68b9      	ldr	r1, [r7, #8]
 8000df0:	1c02      	adds	r2, r0, #0
 8000df2:	6878      	ldr	r0, [r7, #4]
 8000df4:	f00c f846 	bl	800ce84 <strncmp>
 8000df8:	2800      	cmp	r0, #0
 8000dfa:	d0ea      	beq.n	8000dd2 <command_process+0x66>
	/* Tokenize cmd to find argv */
	for(argc = 0, argv[argc] = strtok(cmd, " \t");
		argv[argc]; argv[++argc] = strtok(NULL, " \t"));

	/* Look for match and call handler */
	for(c = cmd_list; c->cmd; c++) {
 8000dfc:	360c      	adds	r6, #12
 8000dfe:	e7e2      	b.n	8000dc6 <command_process+0x5a>
		 */
		if ((argc == 0) || !strncmp(argv[0], c->cmd, strlen(argv[0])))
			return !c->handler(t, argc, argv);
	}

	if (!t)
 8000e00:	68fb      	ldr	r3, [r7, #12]
 8000e02:	2b00      	cmp	r3, #0
 8000e04:	d005      	beq.n	8000e12 <command_process+0xa6>
		return -1;

	return target_command(t, argc, argv);
 8000e06:	1c18      	adds	r0, r3, #0
 8000e08:	1c21      	adds	r1, r4, #0
 8000e0a:	1c2a      	adds	r2, r5, #0
 8000e0c:	f007 fbc3 	bl	8008596 <target_command>
 8000e10:	e001      	b.n	8000e16 <command_process+0xaa>
		if ((argc == 0) || !strncmp(argv[0], c->cmd, strlen(argv[0])))
			return !c->handler(t, argc, argv);
	}

	if (!t)
		return -1;
 8000e12:	2001      	movs	r0, #1
 8000e14:	4240      	negs	r0, r0

	return target_command(t, argc, argv);
}
 8000e16:	46bd      	mov	sp, r7
 8000e18:	b005      	add	sp, #20
 8000e1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e1c:	0800fd97 	.word	0x0800fd97
 8000e20:	0800fb18 	.word	0x0800fb18

08000e24 <cortexa_check_error>:
		priv->mmu_fault = true;
	}
}

static bool cortexa_check_error(target *t)
{
 8000e24:	b510      	push	{r4, lr}
	struct cortexa_priv *priv = t->priv;
 8000e26:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
	ADIv5_AP_t *ahb = priv->ahb;
 8000e28:	68a3      	ldr	r3, [r4, #8]
 8000e2a:	34e8      	adds	r4, #232	; 0xe8
	bool err = (ahb && (adiv5_dp_error(ahb->dp)) != 0) || priv->mmu_fault;
 8000e2c:	2b00      	cmp	r3, #0
 8000e2e:	d101      	bne.n	8000e34 <cortexa_check_error+0x10>
 8000e30:	7820      	ldrb	r0, [r4, #0]
 8000e32:	e005      	b.n	8000e40 <cortexa_check_error+0x1c>
 8000e34:	6858      	ldr	r0, [r3, #4]
	return dp->dp_read(dp, addr);
}

static inline uint32_t adiv5_dp_error(ADIv5_DP_t *dp)
{
	return dp->error(dp);
 8000e36:	68c3      	ldr	r3, [r0, #12]
 8000e38:	4798      	blx	r3
 8000e3a:	2800      	cmp	r0, #0
 8000e3c:	d0f8      	beq.n	8000e30 <cortexa_check_error+0xc>
 8000e3e:	2001      	movs	r0, #1
	priv->mmu_fault = false;
 8000e40:	2300      	movs	r3, #0
 8000e42:	7023      	strb	r3, [r4, #0]
	return err;
 8000e44:	3301      	adds	r3, #1
 8000e46:	4018      	ands	r0, r3
}
 8000e48:	bd10      	pop	{r4, pc}

08000e4a <cortexa_regs_write>:
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	memcpy(data, &priv->reg_cache, t->regs_size);
}

static void cortexa_regs_write(target *t, const void *data)
{
 8000e4a:	b508      	push	{r3, lr}
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	memcpy(&priv->reg_cache, data, t->regs_size);
 8000e4c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8000e4e:	69c2      	ldr	r2, [r0, #28]
 8000e50:	3310      	adds	r3, #16
 8000e52:	1c18      	adds	r0, r3, #0
 8000e54:	f00b fd30 	bl	800c8b8 <memcpy>
}
 8000e58:	bd08      	pop	{r3, pc}

08000e5a <cortexa_regs_read>:
	uint32_t instr = MRC | DBGDTRRXint | ((regno & 0xf) << 12);
	apb_write(t, DBGITR, instr);
}

static void cortexa_regs_read(target *t, void *data)
{
 8000e5a:	b508      	push	{r3, lr}
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	memcpy(data, &priv->reg_cache, t->regs_size);
 8000e5c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8000e5e:	69c2      	ldr	r2, [r0, #28]
 8000e60:	3310      	adds	r3, #16
 8000e62:	1c08      	adds	r0, r1, #0
 8000e64:	1c19      	adds	r1, r3, #0
 8000e66:	f00b fd27 	bl	800c8b8 <memcpy>
}
 8000e6a:	bd08      	pop	{r3, pc}

08000e6c <apb_write.isra.0>:
	"    <reg name=\"d14\" bitsize=\"64\" type=\"float\"/>"
	"    <reg name=\"d15\" bitsize=\"64\" type=\"float\"/>"
	"  </feature>"
	"</target>";

static void apb_write(target *t, uint16_t reg, uint32_t val)
 8000e6c:	b538      	push	{r3, r4, r5, lr}
{
	struct cortexa_priv *priv = t->priv;
	ADIv5_AP_t *ap = priv->apb;
	uint32_t addr = priv->base + 4*reg;
 8000e6e:	6803      	ldr	r3, [r0, #0]
 8000e70:	0089      	lsls	r1, r1, #2
	"    <reg name=\"d14\" bitsize=\"64\" type=\"float\"/>"
	"    <reg name=\"d15\" bitsize=\"64\" type=\"float\"/>"
	"  </feature>"
	"</target>";

static void apb_write(target *t, uint16_t reg, uint32_t val)
 8000e72:	1c15      	adds	r5, r2, #0
{
	struct cortexa_priv *priv = t->priv;
	ADIv5_AP_t *ap = priv->apb;
	uint32_t addr = priv->base + 4*reg;
 8000e74:	18ca      	adds	r2, r1, r3
	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
 8000e76:	2182      	movs	r1, #130	; 0x82
	"</target>";

static void apb_write(target *t, uint16_t reg, uint32_t val)
{
	struct cortexa_priv *priv = t->priv;
	ADIv5_AP_t *ap = priv->apb;
 8000e78:	6844      	ldr	r4, [r0, #4]
	uint32_t addr = priv->base + 4*reg;
	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
 8000e7a:	0049      	lsls	r1, r1, #1
 8000e7c:	1c20      	adds	r0, r4, #0
 8000e7e:	f7ff f967 	bl	8000150 <adiv5_ap_write>
}

static inline uint32_t adiv5_dp_low_access(struct ADIv5_DP_s *dp, uint8_t RnW,
                                           uint16_t addr, uint32_t value)
{
	return dp->low_access(dp, RnW, addr, value);
 8000e82:	2286      	movs	r2, #134	; 0x86
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, val);
 8000e84:	6860      	ldr	r0, [r4, #4]
 8000e86:	1c2b      	adds	r3, r5, #0
 8000e88:	6904      	ldr	r4, [r0, #16]
 8000e8a:	2100      	movs	r1, #0
 8000e8c:	0052      	lsls	r2, r2, #1
 8000e8e:	47a0      	blx	r4
}
 8000e90:	bd38      	pop	{r3, r4, r5, pc}

08000e92 <write_gpreg>:
	/* Return value read from DCC channel */
	return apb_read(t, DBGDTRTX);
}

static void write_gpreg(target *t, uint8_t regno, uint32_t val)
{
 8000e92:	b538      	push	{r3, r4, r5, lr}
 8000e94:	1c0c      	adds	r4, r1, #0
 8000e96:	1c05      	adds	r5, r0, #0
	/* Write value to DCC channel */
	apb_write(t, DBGDTRRX, val);
 8000e98:	2120      	movs	r1, #32
 8000e9a:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8000e9c:	f7ff ffe6 	bl	8000e6c <apb_write.isra.0>
	/* Run instruction to load register */
	uint32_t instr = MRC | DBGDTRRXint | ((regno & 0xf) << 12);
 8000ea0:	0724      	lsls	r4, r4, #28
 8000ea2:	4a04      	ldr	r2, [pc, #16]	; (8000eb4 <write_gpreg+0x22>)
 8000ea4:	0c24      	lsrs	r4, r4, #16
	apb_write(t, DBGITR, instr);
 8000ea6:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
static void write_gpreg(target *t, uint8_t regno, uint32_t val)
{
	/* Write value to DCC channel */
	apb_write(t, DBGDTRRX, val);
	/* Run instruction to load register */
	uint32_t instr = MRC | DBGDTRRXint | ((regno & 0xf) << 12);
 8000ea8:	4322      	orrs	r2, r4
	apb_write(t, DBGITR, instr);
 8000eaa:	2121      	movs	r1, #33	; 0x21
 8000eac:	f7ff ffde 	bl	8000e6c <apb_write.isra.0>
}
 8000eb0:	bd38      	pop	{r3, r4, r5, pc}
 8000eb2:	46c0      	nop			; (mov r8, r8)
 8000eb4:	ee100e15 	.word	0xee100e15

08000eb8 <cortexa_regs_write_internal>:
	}
	priv->reg_cache.r[15] -= (priv->reg_cache.cpsr & CPSR_THUMB) ? 4 : 8;
}

static void cortexa_regs_write_internal(target *t)
{
 8000eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
 8000eba:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
	}
	priv->reg_cache.r[15] -= (priv->reg_cache.cpsr & CPSR_THUMB) ? 4 : 8;
}

static void cortexa_regs_write_internal(target *t)
{
 8000ebc:	1c04      	adds	r4, r0, #0
 8000ebe:	1c37      	adds	r7, r6, #0
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	/* First write back floats */
	for (int i = 0; i < 16; i++) {
 8000ec0:	2500      	movs	r5, #0
 8000ec2:	3758      	adds	r7, #88	; 0x58
		write_gpreg(t, 1, priv->reg_cache.d[i] >> 32);
 8000ec4:	687a      	ldr	r2, [r7, #4]
 8000ec6:	1c20      	adds	r0, r4, #0
 8000ec8:	2101      	movs	r1, #1
 8000eca:	f7ff ffe2 	bl	8000e92 <write_gpreg>
		write_gpreg(t, 0, priv->reg_cache.d[i]);
 8000ece:	683a      	ldr	r2, [r7, #0]
 8000ed0:	1c20      	adds	r0, r4, #0
 8000ed2:	2100      	movs	r1, #0
 8000ed4:	f7ff ffdd 	bl	8000e92 <write_gpreg>
		apb_write(t, DBGITR, 0xec410b10 | i); /* vmov d[i], r0, r1 */
 8000ed8:	4a19      	ldr	r2, [pc, #100]	; (8000f40 <cortexa_regs_write_internal+0x88>)
 8000eda:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8000edc:	432a      	orrs	r2, r5
 8000ede:	2121      	movs	r1, #33	; 0x21

static void cortexa_regs_write_internal(target *t)
{
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	/* First write back floats */
	for (int i = 0; i < 16; i++) {
 8000ee0:	3501      	adds	r5, #1
		write_gpreg(t, 1, priv->reg_cache.d[i] >> 32);
		write_gpreg(t, 0, priv->reg_cache.d[i]);
		apb_write(t, DBGITR, 0xec410b10 | i); /* vmov d[i], r0, r1 */
 8000ee2:	f7ff ffc3 	bl	8000e6c <apb_write.isra.0>
 8000ee6:	3708      	adds	r7, #8

static void cortexa_regs_write_internal(target *t)
{
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	/* First write back floats */
	for (int i = 0; i < 16; i++) {
 8000ee8:	2d10      	cmp	r5, #16
 8000eea:	d1eb      	bne.n	8000ec4 <cortexa_regs_write_internal+0xc>
		write_gpreg(t, 1, priv->reg_cache.d[i] >> 32);
		write_gpreg(t, 0, priv->reg_cache.d[i]);
		apb_write(t, DBGITR, 0xec410b10 | i); /* vmov d[i], r0, r1 */
	}
	/* Write back FPSCR */
	write_gpreg(t, 0, priv->reg_cache.fpscr);
 8000eec:	1c20      	adds	r0, r4, #0
 8000eee:	2100      	movs	r1, #0
 8000ef0:	6d72      	ldr	r2, [r6, #84]	; 0x54
 8000ef2:	f7ff ffce 	bl	8000e92 <write_gpreg>
	apb_write(t, DBGITR, 0xeee10a10); /* vmsr fpscr, r0 */
 8000ef6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8000ef8:	2121      	movs	r1, #33	; 0x21
 8000efa:	4a12      	ldr	r2, [pc, #72]	; (8000f44 <cortexa_regs_write_internal+0x8c>)
 8000efc:	f7ff ffb6 	bl	8000e6c <apb_write.isra.0>
	/* Write back the CPSR */
	write_gpreg(t, 0, priv->reg_cache.cpsr);
 8000f00:	1c20      	adds	r0, r4, #0
 8000f02:	2100      	movs	r1, #0
 8000f04:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8000f06:	f7ff ffc4 	bl	8000e92 <write_gpreg>
	apb_write(t, DBGITR, 0xe12ff000); /* msr CPSR_fsxc, r0 */
 8000f0a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8000f0c:	2121      	movs	r1, #33	; 0x21
 8000f0e:	4a0e      	ldr	r2, [pc, #56]	; (8000f48 <cortexa_regs_write_internal+0x90>)
 8000f10:	f7ff ffac 	bl	8000e6c <apb_write.isra.0>
	/* Write back PC, via r0.  MRC clobbers CPSR instead */
	write_gpreg(t, 0, priv->reg_cache.r[15]);
 8000f14:	1c20      	adds	r0, r4, #0
 8000f16:	2100      	movs	r1, #0
 8000f18:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 8000f1a:	f7ff ffba 	bl	8000e92 <write_gpreg>
	apb_write(t, DBGITR, 0xe1a0f000); /* mov pc, r0 */
 8000f1e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8000f20:	2121      	movs	r1, #33	; 0x21
 8000f22:	4a0a      	ldr	r2, [pc, #40]	; (8000f4c <cortexa_regs_write_internal+0x94>)
 8000f24:	f7ff ffa2 	bl	8000e6c <apb_write.isra.0>
	/* Finally the GP registers now that we're done using them */
	for (int i = 0; i < 15; i++) {
 8000f28:	2500      	movs	r5, #0
 8000f2a:	00ab      	lsls	r3, r5, #2
 8000f2c:	18f3      	adds	r3, r6, r3
		write_gpreg(t, i, priv->reg_cache.r[i]);
 8000f2e:	b2e9      	uxtb	r1, r5
 8000f30:	1c20      	adds	r0, r4, #0
 8000f32:	691a      	ldr	r2, [r3, #16]
	apb_write(t, DBGITR, 0xe12ff000); /* msr CPSR_fsxc, r0 */
	/* Write back PC, via r0.  MRC clobbers CPSR instead */
	write_gpreg(t, 0, priv->reg_cache.r[15]);
	apb_write(t, DBGITR, 0xe1a0f000); /* mov pc, r0 */
	/* Finally the GP registers now that we're done using them */
	for (int i = 0; i < 15; i++) {
 8000f34:	3501      	adds	r5, #1
		write_gpreg(t, i, priv->reg_cache.r[i]);
 8000f36:	f7ff ffac 	bl	8000e92 <write_gpreg>
	apb_write(t, DBGITR, 0xe12ff000); /* msr CPSR_fsxc, r0 */
	/* Write back PC, via r0.  MRC clobbers CPSR instead */
	write_gpreg(t, 0, priv->reg_cache.r[15]);
	apb_write(t, DBGITR, 0xe1a0f000); /* mov pc, r0 */
	/* Finally the GP registers now that we're done using them */
	for (int i = 0; i < 15; i++) {
 8000f3a:	2d0f      	cmp	r5, #15
 8000f3c:	d1f5      	bne.n	8000f2a <cortexa_regs_write_internal+0x72>
		write_gpreg(t, i, priv->reg_cache.r[i]);
	}
}
 8000f3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000f40:	ec410b10 	.word	0xec410b10
 8000f44:	eee10a10 	.word	0xeee10a10
 8000f48:	e12ff000 	.word	0xe12ff000
 8000f4c:	e1a0f000 	.word	0xe1a0f000

08000f50 <cortexa_breakwatch_clear>:
		return 1;
	}
}

static int cortexa_breakwatch_clear(target *t, struct breakwatch *bw)
{
 8000f50:	b570      	push	{r4, r5, r6, lr}
	struct cortexa_priv *priv = t->priv;
	unsigned i = bw->reserved[0];
	switch (bw->type) {
 8000f52:	790c      	ldrb	r4, [r1, #4]
	}
}

static int cortexa_breakwatch_clear(target *t, struct breakwatch *bw)
{
	struct cortexa_priv *priv = t->priv;
 8000f54:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
	unsigned i = bw->reserved[0];
 8000f56:	690d      	ldr	r5, [r1, #16]
	switch (bw->type) {
 8000f58:	2c00      	cmp	r4, #0
 8000f5a:	d002      	beq.n	8000f62 <cortexa_breakwatch_clear+0x12>
 8000f5c:	2c01      	cmp	r4, #1
 8000f5e:	d010      	beq.n	8000f82 <cortexa_breakwatch_clear+0x32>
 8000f60:	e023      	b.n	8000faa <cortexa_breakwatch_clear+0x5a>
	case TARGET_BREAK_SOFT:
		switch (bw->size) {
 8000f62:	68cb      	ldr	r3, [r1, #12]
 8000f64:	2b02      	cmp	r3, #2
 8000f66:	d006      	beq.n	8000f76 <cortexa_breakwatch_clear+0x26>
 8000f68:	2b04      	cmp	r3, #4
 8000f6a:	d120      	bne.n	8000fae <cortexa_breakwatch_clear+0x5e>
		case 2:
			target_mem_write16(t, bw->addr, i);
			return 0;
		case 4:
			target_mem_write32(t, bw->addr, i);
 8000f6c:	6889      	ldr	r1, [r1, #8]
 8000f6e:	1c2a      	adds	r2, r5, #0
 8000f70:	f007 fae4 	bl	800853c <target_mem_write32>
 8000f74:	e003      	b.n	8000f7e <cortexa_breakwatch_clear+0x2e>
	unsigned i = bw->reserved[0];
	switch (bw->type) {
	case TARGET_BREAK_SOFT:
		switch (bw->size) {
		case 2:
			target_mem_write16(t, bw->addr, i);
 8000f76:	b2aa      	uxth	r2, r5
 8000f78:	6889      	ldr	r1, [r1, #8]
 8000f7a:	f007 faf0 	bl	800855e <target_mem_write16>
			return 0;
		case 4:
			target_mem_write32(t, bw->addr, i);
			return 0;
 8000f7e:	1c20      	adds	r0, r4, #0
 8000f80:	e017      	b.n	8000fb2 <cortexa_breakwatch_clear+0x62>
		default:
			return -1;
		}
	case TARGET_BREAK_HARD:
		priv->hw_breakpoint_mask &= ~(1 << i);
 8000f82:	1c20      	adds	r0, r4, #0
 8000f84:	1c32      	adds	r2, r6, #0
 8000f86:	40a8      	lsls	r0, r5
		apb_write(t, DBGBCR(i), 0);
 8000f88:	1c29      	adds	r1, r5, #0
			return 0;
		default:
			return -1;
		}
	case TARGET_BREAK_HARD:
		priv->hw_breakpoint_mask &= ~(1 << i);
 8000f8a:	32dc      	adds	r2, #220	; 0xdc
 8000f8c:	8813      	ldrh	r3, [r2, #0]
		apb_write(t, DBGBCR(i), 0);
 8000f8e:	3150      	adds	r1, #80	; 0x50
			return 0;
		default:
			return -1;
		}
	case TARGET_BREAK_HARD:
		priv->hw_breakpoint_mask &= ~(1 << i);
 8000f90:	4383      	bics	r3, r0
 8000f92:	8013      	strh	r3, [r2, #0]
		apb_write(t, DBGBCR(i), 0);
 8000f94:	1c30      	adds	r0, r6, #0
 8000f96:	b289      	uxth	r1, r1
 8000f98:	2200      	movs	r2, #0
 8000f9a:	f7ff ff67 	bl	8000e6c <apb_write.isra.0>
		if (i == 0)
			priv->bcr0 = 0;
		return 0;
 8000f9e:	2000      	movs	r0, #0
			return -1;
		}
	case TARGET_BREAK_HARD:
		priv->hw_breakpoint_mask &= ~(1 << i);
		apb_write(t, DBGBCR(i), 0);
		if (i == 0)
 8000fa0:	4285      	cmp	r5, r0
 8000fa2:	d106      	bne.n	8000fb2 <cortexa_breakwatch_clear+0x62>
			priv->bcr0 = 0;
 8000fa4:	36e0      	adds	r6, #224	; 0xe0
 8000fa6:	6030      	str	r0, [r6, #0]
 8000fa8:	e003      	b.n	8000fb2 <cortexa_breakwatch_clear+0x62>
		return 0;
	default:
		return 1;
 8000faa:	2001      	movs	r0, #1
 8000fac:	e001      	b.n	8000fb2 <cortexa_breakwatch_clear+0x62>
			return 0;
		case 4:
			target_mem_write32(t, bw->addr, i);
			return 0;
		default:
			return -1;
 8000fae:	2001      	movs	r0, #1
 8000fb0:	4240      	negs	r0, r0
			priv->bcr0 = 0;
		return 0;
	default:
		return 1;
	}
}
 8000fb2:	bd70      	pop	{r4, r5, r6, pc}

08000fb4 <cortexa_halt_request>:
}

static void cortexa_halt_request(target *t)
{
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000fb4:	2200      	movs	r2, #0

	cortexa_attach(t);
}

static void cortexa_halt_request(target *t)
{
 8000fb6:	b530      	push	{r4, r5, lr}
 8000fb8:	b09f      	sub	sp, #124	; 0x7c
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000fba:	9203      	str	r2, [sp, #12]
 8000fbc:	3202      	adds	r2, #2
 8000fbe:	9205      	str	r2, [sp, #20]
 8000fc0:	4a11      	ldr	r2, [pc, #68]	; (8001008 <cortexa_halt_request+0x54>)

	cortexa_attach(t);
}

static void cortexa_halt_request(target *t)
{
 8000fc2:	9001      	str	r0, [sp, #4]
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000fc4:	6811      	ldr	r1, [r2, #0]
 8000fc6:	ab03      	add	r3, sp, #12
 8000fc8:	a806      	add	r0, sp, #24
 8000fca:	911d      	str	r1, [sp, #116]	; 0x74
 8000fcc:	6013      	str	r3, [r2, #0]
 8000fce:	f00b fdf1 	bl	800cbb4 <setjmp>
 8000fd2:	2800      	cmp	r0, #0
 8000fd4:	d007      	beq.n	8000fe6 <cortexa_halt_request+0x32>
		apb_write(t, DBGDRCR, DBGDRCR_HRQ);
	}
	if (e.type) {
 8000fd6:	9b03      	ldr	r3, [sp, #12]
 8000fd8:	2b00      	cmp	r3, #0
 8000fda:	d012      	beq.n	8001002 <cortexa_halt_request+0x4e>
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
 8000fdc:	9801      	ldr	r0, [sp, #4]
 8000fde:	490b      	ldr	r1, [pc, #44]	; (800100c <cortexa_halt_request+0x58>)
 8000fe0:	f007 fb03 	bl	80085ea <tc_printf>
 8000fe4:	e00d      	b.n	8001002 <cortexa_halt_request+0x4e>
}

static void cortexa_halt_request(target *t)
{
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000fe6:	4d08      	ldr	r5, [pc, #32]	; (8001008 <cortexa_halt_request+0x54>)
 8000fe8:	ab03      	add	r3, sp, #12
 8000fea:	682c      	ldr	r4, [r5, #0]
 8000fec:	429c      	cmp	r4, r3
 8000fee:	d1f2      	bne.n	8000fd6 <cortexa_halt_request+0x22>
		apb_write(t, DBGDRCR, DBGDRCR_HRQ);
 8000ff0:	9b01      	ldr	r3, [sp, #4]
 8000ff2:	2124      	movs	r1, #36	; 0x24
 8000ff4:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8000ff6:	2201      	movs	r2, #1
 8000ff8:	f7ff ff38 	bl	8000e6c <apb_write.isra.0>
}

static void cortexa_halt_request(target *t)
{
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8000ffc:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8000ffe:	602b      	str	r3, [r5, #0]
 8001000:	e7f1      	b.n	8000fe6 <cortexa_halt_request+0x32>
		apb_write(t, DBGDRCR, DBGDRCR_HRQ);
	}
	if (e.type) {
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}
 8001002:	b01f      	add	sp, #124	; 0x7c
 8001004:	bd30      	pop	{r4, r5, pc}
 8001006:	46c0      	nop			; (mov r8, r8)
 8001008:	20001dc4 	.word	0x20001dc4
 800100c:	080105b2 	.word	0x080105b2

08001010 <apb_read.isra.1>:
	uint32_t addr = priv->base + 4*reg;
	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DRW, val);
}

static uint32_t apb_read(target *t, uint16_t reg)
 8001010:	b538      	push	{r3, r4, r5, lr}
{
	struct cortexa_priv *priv = t->priv;
	ADIv5_AP_t *ap = priv->apb;
	uint32_t addr = priv->base + 4*reg;
 8001012:	6803      	ldr	r3, [r0, #0]
 8001014:	0089      	lsls	r1, r1, #2
 8001016:	18ca      	adds	r2, r1, r3
	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
 8001018:	2182      	movs	r1, #130	; 0x82
}

static uint32_t apb_read(target *t, uint16_t reg)
{
	struct cortexa_priv *priv = t->priv;
	ADIv5_AP_t *ap = priv->apb;
 800101a:	6844      	ldr	r4, [r0, #4]
	uint32_t addr = priv->base + 4*reg;
	adiv5_ap_write(ap, ADIV5_AP_TAR, addr);
 800101c:	0049      	lsls	r1, r1, #1
 800101e:	1c20      	adds	r0, r4, #0
 8001020:	f7ff f896 	bl	8000150 <adiv5_ap_write>
 8001024:	2286      	movs	r2, #134	; 0x86
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_AP_DRW, 0);
 8001026:	6860      	ldr	r0, [r4, #4]
 8001028:	2101      	movs	r1, #1
 800102a:	6905      	ldr	r5, [r0, #16]
 800102c:	0052      	lsls	r2, r2, #1
 800102e:	2300      	movs	r3, #0
 8001030:	47a8      	blx	r5
	return adiv5_dp_low_access(ap->dp, ADIV5_LOW_READ, ADIV5_DP_RDBUFF, 0);
 8001032:	6860      	ldr	r0, [r4, #4]
 8001034:	2101      	movs	r1, #1
 8001036:	6904      	ldr	r4, [r0, #16]
 8001038:	220c      	movs	r2, #12
 800103a:	2300      	movs	r3, #0
 800103c:	47a0      	blx	r4
}
 800103e:	bd38      	pop	{r3, r4, r5, pc}

08001040 <read_gpreg>:
	apb_write(t, DBGDRCR, DBGDRCR_CSE | DBGDRCR_RRQ);
}


static uint32_t read_gpreg(target *t, uint8_t regno)
{
 8001040:	b510      	push	{r4, lr}
 8001042:	1c04      	adds	r4, r0, #0
	/* To read a register we use DBGITR to load an MCR instruction
	 * that sends the value via DCC DBGDTRTX using the CP14 interface.
	 */
	uint32_t instr = MCR | DBGDTRTXint | ((regno & 0xf) << 12);
 8001044:	070a      	lsls	r2, r1, #28
 8001046:	0c11      	lsrs	r1, r2, #16
 8001048:	4a05      	ldr	r2, [pc, #20]	; (8001060 <read_gpreg+0x20>)
	apb_write(t, DBGITR, instr);
 800104a:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
static uint32_t read_gpreg(target *t, uint8_t regno)
{
	/* To read a register we use DBGITR to load an MCR instruction
	 * that sends the value via DCC DBGDTRTX using the CP14 interface.
	 */
	uint32_t instr = MCR | DBGDTRTXint | ((regno & 0xf) << 12);
 800104c:	430a      	orrs	r2, r1
	apb_write(t, DBGITR, instr);
 800104e:	2121      	movs	r1, #33	; 0x21
 8001050:	f7ff ff0c 	bl	8000e6c <apb_write.isra.0>
	/* Return value read from DCC channel */
	return apb_read(t, DBGDTRTX);
 8001054:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001056:	2123      	movs	r1, #35	; 0x23
 8001058:	f7ff ffda 	bl	8001010 <apb_read.isra.1>
}
 800105c:	bd10      	pop	{r4, pc}
 800105e:	46c0      	nop			; (mov r8, r8)
 8001060:	ee000e15 	.word	0xee000e15

08001064 <cortexa_slow_mem_write>:
		}
	}
}

static void cortexa_slow_mem_write(target *t, target_addr dest, const void *src, size_t len)
{
 8001064:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct cortexa_priv *priv = t->priv;
 8001066:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 8001068:	9400      	str	r4, [sp, #0]
	if (len == 0)
 800106a:	2b00      	cmp	r3, #0
 800106c:	d055      	beq.n	800111a <cortexa_slow_mem_write+0xb6>
 800106e:	1c15      	adds	r5, r2, #0
 8001070:	1c0a      	adds	r2, r1, #0
		return;

	if ((dest & 3) || (len & 3)) {
 8001072:	2103      	movs	r1, #3
 8001074:	1c1e      	adds	r6, r3, #0
 8001076:	1c04      	adds	r4, r0, #0
 8001078:	420a      	tst	r2, r1
 800107a:	d101      	bne.n	8001080 <cortexa_slow_mem_write+0x1c>
 800107c:	4019      	ands	r1, r3
 800107e:	d017      	beq.n	80010b0 <cortexa_slow_mem_write+0x4c>
static void cortexa_slow_mem_write_bytes(target *t, target_addr dest, const uint8_t *src, size_t len)
{
	struct cortexa_priv *priv = t->priv;

	/* Set r13 to dest address */
	write_gpreg(t, 13, dest);
 8001080:	210d      	movs	r1, #13
 8001082:	f7ff ff06 	bl	8000e92 <write_gpreg>
 8001086:	19ae      	adds	r6, r5, r6

	while (len--) {
 8001088:	42b5      	cmp	r5, r6
 800108a:	d046      	beq.n	800111a <cortexa_slow_mem_write+0xb6>
		write_gpreg(t, 0, *src++);
 800108c:	782a      	ldrb	r2, [r5, #0]
 800108e:	1c20      	adds	r0, r4, #0
 8001090:	2100      	movs	r1, #0
 8001092:	f7ff fefe 	bl	8000e92 <write_gpreg>
		apb_write(t, DBGITR, 0xe4cd0001); /* strb r0, [sp], #1 */
 8001096:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001098:	2121      	movs	r1, #33	; 0x21
 800109a:	4a20      	ldr	r2, [pc, #128]	; (800111c <cortexa_slow_mem_write+0xb8>)
 800109c:	f7ff fee6 	bl	8000e6c <apb_write.isra.0>
		if (apb_read(t, DBGDSCR) & DBGDSCR_SDABORT_L) {
 80010a0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010a2:	2122      	movs	r1, #34	; 0x22
 80010a4:	f7ff ffb4 	bl	8001010 <apb_read.isra.1>
 80010a8:	3501      	adds	r5, #1
 80010aa:	0643      	lsls	r3, r0, #25
 80010ac:	d5ec      	bpl.n	8001088 <cortexa_slow_mem_write+0x24>
 80010ae:	e02b      	b.n	8001108 <cortexa_slow_mem_write+0xa4>
	if ((dest & 3) || (len & 3)) {
		cortexa_slow_mem_write_bytes(t, dest, src, len);
		return;
	}

	write_gpreg(t, 0, dest);
 80010b0:	f7ff feef 	bl	8000e92 <write_gpreg>
	const uint32_t *src32 = src;

	/* Switch to fast DCC mode */
	uint32_t dbgdscr = apb_read(t, DBGDSCR);
 80010b4:	2122      	movs	r1, #34	; 0x22
 80010b6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010b8:	f7ff ffaa 	bl	8001010 <apb_read.isra.1>
	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_FAST;
 80010bc:	2280      	movs	r2, #128	; 0x80
 80010be:	4b18      	ldr	r3, [pc, #96]	; (8001120 <cortexa_slow_mem_write+0xbc>)
 80010c0:	0392      	lsls	r2, r2, #14
 80010c2:	4018      	ands	r0, r3
 80010c4:	4302      	orrs	r2, r0
 80010c6:	9001      	str	r0, [sp, #4]
	apb_write(t, DBGDSCR, dbgdscr);
 80010c8:	2122      	movs	r1, #34	; 0x22
 80010ca:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010cc:	f7ff fece 	bl	8000e6c <apb_write.isra.0>

	apb_write(t, DBGITR, 0xeca05e01); /* stc 14, cr5, [r0], #4 */
 80010d0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010d2:	2121      	movs	r1, #33	; 0x21
 80010d4:	4a13      	ldr	r2, [pc, #76]	; (8001124 <cortexa_slow_mem_write+0xc0>)
 80010d6:	f7ff fec9 	bl	8000e6c <apb_write.isra.0>
 80010da:	1c2f      	adds	r7, r5, #0

	for (; len; len -= 4)
		apb_write(t, DBGDTRRX, *src32++);
 80010dc:	cf04      	ldmia	r7!, {r2}
 80010de:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010e0:	2120      	movs	r1, #32
 80010e2:	f7ff fec3 	bl	8000e6c <apb_write.isra.0>
 80010e6:	1bbb      	subs	r3, r7, r6
	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_FAST;
	apb_write(t, DBGDSCR, dbgdscr);

	apb_write(t, DBGITR, 0xeca05e01); /* stc 14, cr5, [r0], #4 */

	for (; len; len -= 4)
 80010e8:	42ab      	cmp	r3, r5
 80010ea:	d1f7      	bne.n	80010dc <cortexa_slow_mem_write+0x78>
		apb_write(t, DBGDTRRX, *src32++);

	/* Switch back to stalling DCC mode */
	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_STALL;
 80010ec:	2280      	movs	r2, #128	; 0x80
 80010ee:	9b01      	ldr	r3, [sp, #4]
 80010f0:	0352      	lsls	r2, r2, #13
 80010f2:	431a      	orrs	r2, r3
	apb_write(t, DBGDSCR, dbgdscr);
 80010f4:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010f6:	2122      	movs	r1, #34	; 0x22
 80010f8:	f7ff feb8 	bl	8000e6c <apb_write.isra.0>

	if (apb_read(t, DBGDSCR) & DBGDSCR_SDABORT_L) {
 80010fc:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80010fe:	2122      	movs	r1, #34	; 0x22
 8001100:	f7ff ff86 	bl	8001010 <apb_read.isra.1>
 8001104:	0643      	lsls	r3, r0, #25
 8001106:	d508      	bpl.n	800111a <cortexa_slow_mem_write+0xb6>
		/* Memory access aborted, flag a fault */
		apb_write(t, DBGDRCR, DBGDRCR_CSE);
 8001108:	2204      	movs	r2, #4
 800110a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800110c:	2124      	movs	r1, #36	; 0x24
 800110e:	f7ff fead 	bl	8000e6c <apb_write.isra.0>
		priv->mmu_fault = true;
 8001112:	2201      	movs	r2, #1
 8001114:	9b00      	ldr	r3, [sp, #0]
 8001116:	33e8      	adds	r3, #232	; 0xe8
 8001118:	701a      	strb	r2, [r3, #0]
	}
}
 800111a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800111c:	e4cd0001 	.word	0xe4cd0001
 8001120:	ffcfffff 	.word	0xffcfffff
 8001124:	eca05e01 	.word	0xeca05e01

08001128 <cortexa_halt_resume>:

	return reason;
}

void cortexa_halt_resume(target *t, bool step)
{
 8001128:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800112a:	1c04      	adds	r4, r0, #0
 800112c:	1e0e      	subs	r6, r1, #0
	struct cortexa_priv *priv = t->priv;
 800112e:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	/* Set breakpoint comarator for single stepping if needed */
	if (step) {
 8001130:	d019      	beq.n	8001166 <cortexa_halt_resume+0x3e>
		uint32_t addr = priv->reg_cache.r[15];
		uint32_t bas = bp_bas(addr, (priv->reg_cache.cpsr & CPSR_THUMB) ? 2 : 4);
 8001132:	6d2b      	ldr	r3, [r5, #80]	; 0x50
void cortexa_halt_resume(target *t, bool step)
{
	struct cortexa_priv *priv = t->priv;
	/* Set breakpoint comarator for single stepping if needed */
	if (step) {
		uint32_t addr = priv->reg_cache.r[15];
 8001134:	6ce9      	ldr	r1, [r5, #76]	; 0x4c

/* Breakpoints */
static uint32_t bp_bas(uint32_t addr, uint8_t len)
{
	if (len == 4)
		return DBGBCR_BAS_ANY;
 8001136:	27f0      	movs	r7, #240	; 0xf0
{
	struct cortexa_priv *priv = t->priv;
	/* Set breakpoint comarator for single stepping if needed */
	if (step) {
		uint32_t addr = priv->reg_cache.r[15];
		uint32_t bas = bp_bas(addr, (priv->reg_cache.cpsr & CPSR_THUMB) ? 2 : 4);
 8001138:	069b      	lsls	r3, r3, #26
 800113a:	d503      	bpl.n	8001144 <cortexa_halt_resume+0x1c>
	if (len == 4)
		return DBGBCR_BAS_ANY;
	else if (addr & 2)
		return DBGBCR_BAS_HIGH_HW;
	else
		return DBGBCR_BAS_LOW_HW;
 800113c:	2760      	movs	r7, #96	; 0x60
/* Breakpoints */
static uint32_t bp_bas(uint32_t addr, uint8_t len)
{
	if (len == 4)
		return DBGBCR_BAS_ANY;
	else if (addr & 2)
 800113e:	078b      	lsls	r3, r1, #30
 8001140:	d501      	bpl.n	8001146 <cortexa_halt_resume+0x1e>
		return DBGBCR_BAS_HIGH_HW;
 8001142:	27c0      	movs	r7, #192	; 0xc0
 8001144:	007f      	lsls	r7, r7, #1
	struct cortexa_priv *priv = t->priv;
	/* Set breakpoint comarator for single stepping if needed */
	if (step) {
		uint32_t addr = priv->reg_cache.r[15];
		uint32_t bas = bp_bas(addr, (priv->reg_cache.cpsr & CPSR_THUMB) ? 2 : 4);
		DEBUG("step 0x%08"PRIx32"  %"PRIx32"\n", addr, bas);
 8001146:	1c3a      	adds	r2, r7, #0
 8001148:	482c      	ldr	r0, [pc, #176]	; (80011fc <cortexa_halt_resume+0xd4>)
 800114a:	f00b fc87 	bl	800ca5c <iprintf>
		/* Set match any breakpoint */
		apb_write(t, DBGBVR(0), priv->reg_cache.r[15] & ~3);
 800114e:	2303      	movs	r3, #3
 8001150:	6cea      	ldr	r2, [r5, #76]	; 0x4c
 8001152:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001154:	439a      	bics	r2, r3
 8001156:	2140      	movs	r1, #64	; 0x40
 8001158:	f7ff fe88 	bl	8000e6c <apb_write.isra.0>
		apb_write(t, DBGBCR(0), DBGBCR_INST_MISMATCH | bas |
 800115c:	4a28      	ldr	r2, [pc, #160]	; (8001200 <cortexa_halt_resume+0xd8>)
 800115e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001160:	433a      	orrs	r2, r7
 8001162:	2150      	movs	r1, #80	; 0x50
 8001164:	e00a      	b.n	800117c <cortexa_halt_resume+0x54>
		                             DBGBCR_EN);
	} else {
		apb_write(t, DBGBVR(0), priv->bvr0);
 8001166:	1c2b      	adds	r3, r5, #0
 8001168:	33e4      	adds	r3, #228	; 0xe4
 800116a:	1c28      	adds	r0, r5, #0
 800116c:	2140      	movs	r1, #64	; 0x40
 800116e:	681a      	ldr	r2, [r3, #0]
 8001170:	f7ff fe7c 	bl	8000e6c <apb_write.isra.0>
		apb_write(t, DBGBCR(0), priv->bcr0);
 8001174:	2150      	movs	r1, #80	; 0x50
 8001176:	35e0      	adds	r5, #224	; 0xe0
 8001178:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800117a:	682a      	ldr	r2, [r5, #0]
 800117c:	f7ff fe76 	bl	8000e6c <apb_write.isra.0>
	}

	/* Write back register cache */
	cortexa_regs_write_internal(t);
 8001180:	1c20      	adds	r0, r4, #0
 8001182:	f7ff fe99 	bl	8000eb8 <cortexa_regs_write_internal>

	apb_write(t, DBGITR, MCR | ICIALLU); /* invalidate cache */
 8001186:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001188:	2121      	movs	r1, #33	; 0x21
 800118a:	4a1e      	ldr	r2, [pc, #120]	; (8001204 <cortexa_halt_resume+0xdc>)
 800118c:	f7ff fe6e 	bl	8000e6c <apb_write.isra.0>

	platform_timeout to;
	platform_timeout_set(&to, 200);
 8001190:	a801      	add	r0, sp, #4
 8001192:	21c8      	movs	r1, #200	; 0xc8
 8001194:	f00a f97c 	bl	800b490 <platform_timeout_set>

	/* Wait for instruction to complete */
	uint32_t dbgdscr;
	do {
		dbgdscr = apb_read(t, DBGDSCR);
 8001198:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800119a:	2122      	movs	r1, #34	; 0x22
 800119c:	f7ff ff38 	bl	8001010 <apb_read.isra.1>
 80011a0:	1c05      	adds	r5, r0, #0
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
	         !platform_timeout_is_expired(&to));
 80011a2:	01c3      	lsls	r3, r0, #7
 80011a4:	d505      	bpl.n	80011b2 <cortexa_halt_resume+0x8a>

	 /* Disable DBGITR.  Not sure why, but RRQ is ignored otherwise. */
	if (step)
 80011a6:	2e00      	cmp	r6, #0
 80011a8:	d009      	beq.n	80011be <cortexa_halt_resume+0x96>
		dbgdscr |= DBGDSCR_INTDIS;
 80011aa:	2280      	movs	r2, #128	; 0x80
 80011ac:	0112      	lsls	r2, r2, #4
 80011ae:	4315      	orrs	r5, r2
 80011b0:	e007      	b.n	80011c2 <cortexa_halt_resume+0x9a>
	/* Wait for instruction to complete */
	uint32_t dbgdscr;
	do {
		dbgdscr = apb_read(t, DBGDSCR);
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
	         !platform_timeout_is_expired(&to));
 80011b2:	a801      	add	r0, sp, #4
 80011b4:	f00a f974 	bl	800b4a0 <platform_timeout_is_expired>

	/* Wait for instruction to complete */
	uint32_t dbgdscr;
	do {
		dbgdscr = apb_read(t, DBGDSCR);
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
 80011b8:	2800      	cmp	r0, #0
 80011ba:	d0ed      	beq.n	8001198 <cortexa_halt_resume+0x70>
 80011bc:	e7f3      	b.n	80011a6 <cortexa_halt_resume+0x7e>

	 /* Disable DBGITR.  Not sure why, but RRQ is ignored otherwise. */
	if (step)
		dbgdscr |= DBGDSCR_INTDIS;
	else
		dbgdscr &= ~DBGDSCR_INTDIS;
 80011be:	4a12      	ldr	r2, [pc, #72]	; (8001208 <cortexa_halt_resume+0xe0>)
 80011c0:	4015      	ands	r5, r2
	dbgdscr &= ~DBGDSCR_ITREN;
 80011c2:	4a12      	ldr	r2, [pc, #72]	; (800120c <cortexa_halt_resume+0xe4>)
	apb_write(t, DBGDSCR, dbgdscr);
 80011c4:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
	 /* Disable DBGITR.  Not sure why, but RRQ is ignored otherwise. */
	if (step)
		dbgdscr |= DBGDSCR_INTDIS;
	else
		dbgdscr &= ~DBGDSCR_INTDIS;
	dbgdscr &= ~DBGDSCR_ITREN;
 80011c6:	402a      	ands	r2, r5
	apb_write(t, DBGDSCR, dbgdscr);
 80011c8:	2122      	movs	r1, #34	; 0x22
 80011ca:	f7ff fe4f 	bl	8000e6c <apb_write.isra.0>

	do {
		apb_write(t, DBGDRCR, DBGDRCR_CSE | DBGDRCR_RRQ);
 80011ce:	2206      	movs	r2, #6
 80011d0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80011d2:	2124      	movs	r1, #36	; 0x24
 80011d4:	f7ff fe4a 	bl	8000e6c <apb_write.isra.0>
		dbgdscr = apb_read(t, DBGDSCR);
 80011d8:	2122      	movs	r1, #34	; 0x22
 80011da:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80011dc:	f7ff ff18 	bl	8001010 <apb_read.isra.1>
 80011e0:	1c05      	adds	r5, r0, #0
		DEBUG("%s: DBGDSCR = 0x%08"PRIx32"\n", __func__, dbgdscr);
 80011e2:	490b      	ldr	r1, [pc, #44]	; (8001210 <cortexa_halt_resume+0xe8>)
 80011e4:	480b      	ldr	r0, [pc, #44]	; (8001214 <cortexa_halt_resume+0xec>)
 80011e6:	1c2a      	adds	r2, r5, #0
 80011e8:	f00b fc38 	bl	800ca5c <iprintf>
	} while (!(dbgdscr & DBGDSCR_RESTARTED) &&
	         !platform_timeout_is_expired(&to));
 80011ec:	07ab      	lsls	r3, r5, #30
 80011ee:	d404      	bmi.n	80011fa <cortexa_halt_resume+0xd2>
 80011f0:	a801      	add	r0, sp, #4
 80011f2:	f00a f955 	bl	800b4a0 <platform_timeout_is_expired>

	do {
		apb_write(t, DBGDRCR, DBGDRCR_CSE | DBGDRCR_RRQ);
		dbgdscr = apb_read(t, DBGDSCR);
		DEBUG("%s: DBGDSCR = 0x%08"PRIx32"\n", __func__, dbgdscr);
	} while (!(dbgdscr & DBGDSCR_RESTARTED) &&
 80011f6:	2800      	cmp	r0, #0
 80011f8:	d0e9      	beq.n	80011ce <cortexa_halt_resume+0xa6>
	         !platform_timeout_is_expired(&to));
}
 80011fa:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 80011fc:	080105e0 	.word	0x080105e0
 8001200:	00400001 	.word	0x00400001
 8001204:	ee070f15 	.word	0xee070f15
 8001208:	fffff7ff 	.word	0xfffff7ff
 800120c:	ffffdfff 	.word	0xffffdfff
 8001210:	0800ff3b 	.word	0x0800ff3b
 8001214:	080105f3 	.word	0x080105f3

08001218 <cortexa_detach>:

	return true;
}

void cortexa_detach(target *t)
{
 8001218:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800121a:	1c04      	adds	r4, r0, #0
	struct cortexa_priv *priv = t->priv;

	/* Clear any stale breakpoints */
	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
 800121c:	2500      	movs	r5, #0
	return true;
}

void cortexa_detach(target *t)
{
	struct cortexa_priv *priv = t->priv;
 800121e:	6ec6      	ldr	r6, [r0, #108]	; 0x6c

	/* Clear any stale breakpoints */
	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
 8001220:	1c33      	adds	r3, r6, #0
 8001222:	33d8      	adds	r3, #216	; 0xd8
 8001224:	681b      	ldr	r3, [r3, #0]
 8001226:	429d      	cmp	r5, r3
 8001228:	d208      	bcs.n	800123c <cortexa_detach+0x24>
 800122a:	1c29      	adds	r1, r5, #0
 800122c:	3150      	adds	r1, #80	; 0x50
		apb_write(t, DBGBCR(i), 0);
 800122e:	b289      	uxth	r1, r1
 8001230:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001232:	2200      	movs	r2, #0
 8001234:	f7ff fe1a 	bl	8000e6c <apb_write.isra.0>
void cortexa_detach(target *t)
{
	struct cortexa_priv *priv = t->priv;

	/* Clear any stale breakpoints */
	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
 8001238:	3501      	adds	r5, #1
 800123a:	e7f1      	b.n	8001220 <cortexa_detach+0x8>
		apb_write(t, DBGBCR(i), 0);
	}

	/* Restore any clobbered registers */
	cortexa_regs_write_internal(t);
 800123c:	1c20      	adds	r0, r4, #0
 800123e:	f7ff fe3b 	bl	8000eb8 <cortexa_regs_write_internal>
	/* Invalidate cache */
	apb_write(t, DBGITR, MCR | ICIALLU);
 8001242:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001244:	2121      	movs	r1, #33	; 0x21
 8001246:	4a10      	ldr	r2, [pc, #64]	; (8001288 <cortexa_detach+0x70>)
 8001248:	f7ff fe10 	bl	8000e6c <apb_write.isra.0>

	platform_timeout to;
	platform_timeout_set(&to, 200);
 800124c:	a801      	add	r0, sp, #4
 800124e:	21c8      	movs	r1, #200	; 0xc8
 8001250:	f00a f91e 	bl	800b490 <platform_timeout_set>

	/* Wait for instruction to complete */
	uint32_t dbgdscr;
	do {
		dbgdscr = apb_read(t, DBGDSCR);
 8001254:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001256:	2122      	movs	r1, #34	; 0x22
 8001258:	f7ff feda 	bl	8001010 <apb_read.isra.1>
 800125c:	1c05      	adds	r5, r0, #0
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
	         !platform_timeout_is_expired(&to));
 800125e:	01c3      	lsls	r3, r0, #7
 8001260:	d50b      	bpl.n	800127a <cortexa_detach+0x62>

	/* Disable halting debug mode */
	dbgdscr &= ~(DBGDSCR_HDBGEN | DBGDSCR_ITREN);
 8001262:	4a0a      	ldr	r2, [pc, #40]	; (800128c <cortexa_detach+0x74>)
	apb_write(t, DBGDSCR, dbgdscr);
 8001264:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
		dbgdscr = apb_read(t, DBGDSCR);
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
	         !platform_timeout_is_expired(&to));

	/* Disable halting debug mode */
	dbgdscr &= ~(DBGDSCR_HDBGEN | DBGDSCR_ITREN);
 8001266:	402a      	ands	r2, r5
	apb_write(t, DBGDSCR, dbgdscr);
 8001268:	2122      	movs	r1, #34	; 0x22
 800126a:	f7ff fdff 	bl	8000e6c <apb_write.isra.0>
	/* Clear sticky error and resume */
	apb_write(t, DBGDRCR, DBGDRCR_CSE | DBGDRCR_RRQ);
 800126e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001270:	2124      	movs	r1, #36	; 0x24
 8001272:	2206      	movs	r2, #6
 8001274:	f7ff fdfa 	bl	8000e6c <apb_write.isra.0>
}
 8001278:	bd73      	pop	{r0, r1, r4, r5, r6, pc}
	/* Wait for instruction to complete */
	uint32_t dbgdscr;
	do {
		dbgdscr = apb_read(t, DBGDSCR);
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
	         !platform_timeout_is_expired(&to));
 800127a:	a801      	add	r0, sp, #4
 800127c:	f00a f910 	bl	800b4a0 <platform_timeout_is_expired>

	/* Wait for instruction to complete */
	uint32_t dbgdscr;
	do {
		dbgdscr = apb_read(t, DBGDSCR);
	} while (!(dbgdscr & DBGDSCR_INSTRCOMPL) &&
 8001280:	2800      	cmp	r0, #0
 8001282:	d0e7      	beq.n	8001254 <cortexa_detach+0x3c>
 8001284:	e7ed      	b.n	8001262 <cortexa_detach+0x4a>
 8001286:	46c0      	nop			; (mov r8, r8)
 8001288:	ee070f15 	.word	0xee070f15
 800128c:	ffff9fff 	.word	0xffff9fff

08001290 <cortexa_halt_poll>:

static enum target_halt_reason cortexa_halt_poll(target *t, target_addr *watch)
{
	(void)watch; /* No watchpoint support yet */

	volatile uint32_t dbgdscr = 0;
 8001290:	2200      	movs	r2, #0
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}

static enum target_halt_reason cortexa_halt_poll(target *t, target_addr *watch)
{
 8001292:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001294:	b09f      	sub	sp, #124	; 0x7c
	(void)watch; /* No watchpoint support yet */

	volatile uint32_t dbgdscr = 0;
 8001296:	9202      	str	r2, [sp, #8]
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001298:	9203      	str	r2, [sp, #12]
 800129a:	3a01      	subs	r2, #1
 800129c:	9205      	str	r2, [sp, #20]
 800129e:	4a49      	ldr	r2, [pc, #292]	; (80013c4 <cortexa_halt_poll+0x134>)
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}

static enum target_halt_reason cortexa_halt_poll(target *t, target_addr *watch)
{
 80012a0:	9000      	str	r0, [sp, #0]
	(void)watch; /* No watchpoint support yet */

	volatile uint32_t dbgdscr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 80012a2:	6811      	ldr	r1, [r2, #0]
 80012a4:	ab03      	add	r3, sp, #12
 80012a6:	a806      	add	r0, sp, #24
 80012a8:	911d      	str	r1, [sp, #116]	; 0x74
 80012aa:	6013      	str	r3, [r2, #0]
 80012ac:	f00b fc82 	bl	800cbb4 <setjmp>
 80012b0:	2800      	cmp	r0, #0
 80012b2:	d006      	beq.n	80012c2 <cortexa_halt_poll+0x32>
		/* If this times out because the target is in WFI then
		 * the target is still running. */
		dbgdscr = apb_read(t, DBGDSCR);
	}
	switch (e.type) {
 80012b4:	9c03      	ldr	r4, [sp, #12]
 80012b6:	2c01      	cmp	r4, #1
 80012b8:	d011      	beq.n	80012de <cortexa_halt_poll+0x4e>
		/* Oh crap, there's no recovery from this... */
		target_list_free();
		return TARGET_HALT_ERROR;
	case EXCEPTION_TIMEOUT:
		/* Timeout isn't a problem, target could be in WFI */
		return TARGET_HALT_RUNNING;
 80012ba:	2000      	movs	r0, #0
	TRY_CATCH (e, EXCEPTION_ALL) {
		/* If this times out because the target is in WFI then
		 * the target is still running. */
		dbgdscr = apb_read(t, DBGDSCR);
	}
	switch (e.type) {
 80012bc:	2c02      	cmp	r4, #2
 80012be:	d07e      	beq.n	80013be <cortexa_halt_poll+0x12e>
 80012c0:	e011      	b.n	80012e6 <cortexa_halt_poll+0x56>
{
	(void)watch; /* No watchpoint support yet */

	volatile uint32_t dbgdscr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 80012c2:	4d40      	ldr	r5, [pc, #256]	; (80013c4 <cortexa_halt_poll+0x134>)
 80012c4:	ab03      	add	r3, sp, #12
 80012c6:	682c      	ldr	r4, [r5, #0]
 80012c8:	429c      	cmp	r4, r3
 80012ca:	d1f3      	bne.n	80012b4 <cortexa_halt_poll+0x24>
		/* If this times out because the target is in WFI then
		 * the target is still running. */
		dbgdscr = apb_read(t, DBGDSCR);
 80012cc:	9b00      	ldr	r3, [sp, #0]
 80012ce:	2122      	movs	r1, #34	; 0x22
 80012d0:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 80012d2:	f7ff fe9d 	bl	8001010 <apb_read.isra.1>
 80012d6:	9002      	str	r0, [sp, #8]
{
	(void)watch; /* No watchpoint support yet */

	volatile uint32_t dbgdscr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 80012d8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80012da:	602b      	str	r3, [r5, #0]
 80012dc:	e7f1      	b.n	80012c2 <cortexa_halt_poll+0x32>
		dbgdscr = apb_read(t, DBGDSCR);
	}
	switch (e.type) {
	case EXCEPTION_ERROR:
		/* Oh crap, there's no recovery from this... */
		target_list_free();
 80012de:	f006 fe9b 	bl	8008018 <target_list_free>
		return TARGET_HALT_ERROR;
 80012e2:	1c20      	adds	r0, r4, #0
 80012e4:	e06b      	b.n	80013be <cortexa_halt_poll+0x12e>
	case EXCEPTION_TIMEOUT:
		/* Timeout isn't a problem, target could be in WFI */
		return TARGET_HALT_RUNNING;
	}

	if (!(dbgdscr & DBGDSCR_HALTED)) /* Not halted */
 80012e6:	2301      	movs	r3, #1
 80012e8:	9802      	ldr	r0, [sp, #8]
 80012ea:	4018      	ands	r0, r3
 80012ec:	d067      	beq.n	80013be <cortexa_halt_poll+0x12e>
		return TARGET_HALT_RUNNING;

	DEBUG("%s: DBGDSCR = 0x%08"PRIx32"\n", __func__, dbgdscr);
 80012ee:	4936      	ldr	r1, [pc, #216]	; (80013c8 <cortexa_halt_poll+0x138>)
 80012f0:	9a02      	ldr	r2, [sp, #8]
 80012f2:	3114      	adds	r1, #20
 80012f4:	4835      	ldr	r0, [pc, #212]	; (80013cc <cortexa_halt_poll+0x13c>)
 80012f6:	f00b fbb1 	bl	800ca5c <iprintf>
	/* Reenable DBGITR */
	dbgdscr |= DBGDSCR_ITREN;
 80012fa:	2280      	movs	r2, #128	; 0x80
 80012fc:	9b02      	ldr	r3, [sp, #8]
 80012fe:	0192      	lsls	r2, r2, #6
 8001300:	4313      	orrs	r3, r2
 8001302:	9302      	str	r3, [sp, #8]
	apb_write(t, DBGDSCR, dbgdscr);
 8001304:	9b00      	ldr	r3, [sp, #0]
 8001306:	9a02      	ldr	r2, [sp, #8]
 8001308:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 800130a:	2122      	movs	r1, #34	; 0x22
 800130c:	f7ff fdae 	bl	8000e6c <apb_write.isra.0>

	/* Find out why we halted */
	enum target_halt_reason reason;
	switch (dbgdscr & DBGDSCR_MOE_MASK) {
 8001310:	233c      	movs	r3, #60	; 0x3c
 8001312:	9a02      	ldr	r2, [sp, #8]
	case DBGDSCR_MOE_HALT_REQ:
		reason = TARGET_HALT_REQUEST;
 8001314:	2702      	movs	r7, #2
	dbgdscr |= DBGDSCR_ITREN;
	apb_write(t, DBGDSCR, dbgdscr);

	/* Find out why we halted */
	enum target_halt_reason reason;
	switch (dbgdscr & DBGDSCR_MOE_MASK) {
 8001316:	421a      	tst	r2, r3
 8001318:	d000      	beq.n	800131c <cortexa_halt_poll+0x8c>
	case DBGDSCR_MOE_HALT_REQ:
		reason = TARGET_HALT_REQUEST;
		break;
	default:
		reason = TARGET_HALT_BREAKPOINT;
 800131a:	19ff      	adds	r7, r7, r7

static void cortexa_regs_read_internal(target *t)
{
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	/* Read general purpose registers */
	for (int i = 0; i < 15; i++) {
 800131c:	2500      	movs	r5, #0
	memcpy(&priv->reg_cache, data, t->regs_size);
}

static void cortexa_regs_read_internal(target *t)
{
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
 800131e:	9b00      	ldr	r3, [sp, #0]
 8001320:	6edc      	ldr	r4, [r3, #108]	; 0x6c
	/* Read general purpose registers */
	for (int i = 0; i < 15; i++) {
		priv->reg_cache.r[i] = read_gpreg(t, i);
 8001322:	b2e9      	uxtb	r1, r5
 8001324:	9800      	ldr	r0, [sp, #0]
 8001326:	f7ff fe8b 	bl	8001040 <read_gpreg>
 800132a:	00ab      	lsls	r3, r5, #2
 800132c:	18e3      	adds	r3, r4, r3

static void cortexa_regs_read_internal(target *t)
{
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	/* Read general purpose registers */
	for (int i = 0; i < 15; i++) {
 800132e:	3501      	adds	r5, #1
		priv->reg_cache.r[i] = read_gpreg(t, i);
 8001330:	6118      	str	r0, [r3, #16]

static void cortexa_regs_read_internal(target *t)
{
	struct cortexa_priv *priv = (struct cortexa_priv *)t->priv;
	/* Read general purpose registers */
	for (int i = 0; i < 15; i++) {
 8001332:	2d0f      	cmp	r5, #15
 8001334:	d1f5      	bne.n	8001322 <cortexa_halt_poll+0x92>
		priv->reg_cache.r[i] = read_gpreg(t, i);
	}
	/* Read PC, via r0.  MCR is UNPREDICTABLE for Rt = r15. */
	apb_write(t, DBGITR, 0xe1a0000f); /* mov r0, pc */
 8001336:	9b00      	ldr	r3, [sp, #0]
 8001338:	4a25      	ldr	r2, [pc, #148]	; (80013d0 <cortexa_halt_poll+0x140>)
 800133a:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 800133c:	2121      	movs	r1, #33	; 0x21
 800133e:	f7ff fd95 	bl	8000e6c <apb_write.isra.0>
	priv->reg_cache.r[15] = read_gpreg(t, 0);
 8001342:	2100      	movs	r1, #0
 8001344:	9800      	ldr	r0, [sp, #0]
 8001346:	f7ff fe7b 	bl	8001040 <read_gpreg>
	/* Read CPSR */
	apb_write(t, DBGITR, 0xE10F0000); /* mrs r0, CPSR */
 800134a:	9b00      	ldr	r3, [sp, #0]
 800134c:	4a21      	ldr	r2, [pc, #132]	; (80013d4 <cortexa_halt_poll+0x144>)
	for (int i = 0; i < 15; i++) {
		priv->reg_cache.r[i] = read_gpreg(t, i);
	}
	/* Read PC, via r0.  MCR is UNPREDICTABLE for Rt = r15. */
	apb_write(t, DBGITR, 0xe1a0000f); /* mov r0, pc */
	priv->reg_cache.r[15] = read_gpreg(t, 0);
 800134e:	64e0      	str	r0, [r4, #76]	; 0x4c
	/* Read CPSR */
	apb_write(t, DBGITR, 0xE10F0000); /* mrs r0, CPSR */
 8001350:	2121      	movs	r1, #33	; 0x21
 8001352:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8001354:	f7ff fd8a 	bl	8000e6c <apb_write.isra.0>
	priv->reg_cache.cpsr = read_gpreg(t, 0);
 8001358:	2100      	movs	r1, #0
 800135a:	9800      	ldr	r0, [sp, #0]
 800135c:	f7ff fe70 	bl	8001040 <read_gpreg>
	/* Read FPSCR */
	apb_write(t, DBGITR, 0xeef10a10); /* vmrs r0, fpscr */
 8001360:	9b00      	ldr	r3, [sp, #0]
	/* Read PC, via r0.  MCR is UNPREDICTABLE for Rt = r15. */
	apb_write(t, DBGITR, 0xe1a0000f); /* mov r0, pc */
	priv->reg_cache.r[15] = read_gpreg(t, 0);
	/* Read CPSR */
	apb_write(t, DBGITR, 0xE10F0000); /* mrs r0, CPSR */
	priv->reg_cache.cpsr = read_gpreg(t, 0);
 8001362:	6520      	str	r0, [r4, #80]	; 0x50
	/* Read FPSCR */
	apb_write(t, DBGITR, 0xeef10a10); /* vmrs r0, fpscr */
 8001364:	2121      	movs	r1, #33	; 0x21
 8001366:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8001368:	4a1b      	ldr	r2, [pc, #108]	; (80013d8 <cortexa_halt_poll+0x148>)
 800136a:	f7ff fd7f 	bl	8000e6c <apb_write.isra.0>
	priv->reg_cache.fpscr = read_gpreg(t, 0);
 800136e:	9800      	ldr	r0, [sp, #0]
 8001370:	2100      	movs	r1, #0
 8001372:	f7ff fe65 	bl	8001040 <read_gpreg>
 8001376:	1c26      	adds	r6, r4, #0
	/* Read out VFP registers */
	for (int i = 0; i < 16; i++) {
 8001378:	2500      	movs	r5, #0
	/* Read CPSR */
	apb_write(t, DBGITR, 0xE10F0000); /* mrs r0, CPSR */
	priv->reg_cache.cpsr = read_gpreg(t, 0);
	/* Read FPSCR */
	apb_write(t, DBGITR, 0xeef10a10); /* vmrs r0, fpscr */
	priv->reg_cache.fpscr = read_gpreg(t, 0);
 800137a:	6560      	str	r0, [r4, #84]	; 0x54
 800137c:	3658      	adds	r6, #88	; 0x58
	/* Read out VFP registers */
	for (int i = 0; i < 16; i++) {
		/* Read D[i] to R0/R1 */
		apb_write(t, DBGITR, 0xEC510B10 | i); /* vmov r0, r1, d0 */
 800137e:	9b00      	ldr	r3, [sp, #0]
 8001380:	4a16      	ldr	r2, [pc, #88]	; (80013dc <cortexa_halt_poll+0x14c>)
 8001382:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8001384:	432a      	orrs	r2, r5
 8001386:	2121      	movs	r1, #33	; 0x21
 8001388:	f7ff fd70 	bl	8000e6c <apb_write.isra.0>
		priv->reg_cache.d[i] = ((uint64_t)read_gpreg(t, 1) << 32) | read_gpreg(t, 0);
 800138c:	2101      	movs	r1, #1
 800138e:	9800      	ldr	r0, [sp, #0]
 8001390:	f7ff fe56 	bl	8001040 <read_gpreg>
 8001394:	2100      	movs	r1, #0
 8001396:	9001      	str	r0, [sp, #4]
 8001398:	9800      	ldr	r0, [sp, #0]
 800139a:	f7ff fe51 	bl	8001040 <read_gpreg>
 800139e:	9b01      	ldr	r3, [sp, #4]
	priv->reg_cache.cpsr = read_gpreg(t, 0);
	/* Read FPSCR */
	apb_write(t, DBGITR, 0xeef10a10); /* vmrs r0, fpscr */
	priv->reg_cache.fpscr = read_gpreg(t, 0);
	/* Read out VFP registers */
	for (int i = 0; i < 16; i++) {
 80013a0:	3501      	adds	r5, #1
		/* Read D[i] to R0/R1 */
		apb_write(t, DBGITR, 0xEC510B10 | i); /* vmov r0, r1, d0 */
		priv->reg_cache.d[i] = ((uint64_t)read_gpreg(t, 1) << 32) | read_gpreg(t, 0);
 80013a2:	6030      	str	r0, [r6, #0]
 80013a4:	6073      	str	r3, [r6, #4]
 80013a6:	3608      	adds	r6, #8
	priv->reg_cache.cpsr = read_gpreg(t, 0);
	/* Read FPSCR */
	apb_write(t, DBGITR, 0xeef10a10); /* vmrs r0, fpscr */
	priv->reg_cache.fpscr = read_gpreg(t, 0);
	/* Read out VFP registers */
	for (int i = 0; i < 16; i++) {
 80013a8:	2d10      	cmp	r5, #16
 80013aa:	d1e8      	bne.n	800137e <cortexa_halt_poll+0xee>
		/* Read D[i] to R0/R1 */
		apb_write(t, DBGITR, 0xEC510B10 | i); /* vmov r0, r1, d0 */
		priv->reg_cache.d[i] = ((uint64_t)read_gpreg(t, 1) << 32) | read_gpreg(t, 0);
	}
	priv->reg_cache.r[15] -= (priv->reg_cache.cpsr & CPSR_THUMB) ? 4 : 8;
 80013ac:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80013ae:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80013b0:	2204      	movs	r2, #4
 80013b2:	0689      	lsls	r1, r1, #26
 80013b4:	d400      	bmi.n	80013b8 <cortexa_halt_poll+0x128>
 80013b6:	1892      	adds	r2, r2, r2
		reason = TARGET_HALT_BREAKPOINT;
	}

	cortexa_regs_read_internal(t);

	return reason;
 80013b8:	1c38      	adds	r0, r7, #0
	for (int i = 0; i < 16; i++) {
		/* Read D[i] to R0/R1 */
		apb_write(t, DBGITR, 0xEC510B10 | i); /* vmov r0, r1, d0 */
		priv->reg_cache.d[i] = ((uint64_t)read_gpreg(t, 1) << 32) | read_gpreg(t, 0);
	}
	priv->reg_cache.r[15] -= (priv->reg_cache.cpsr & CPSR_THUMB) ? 4 : 8;
 80013ba:	1a9b      	subs	r3, r3, r2
 80013bc:	64e3      	str	r3, [r4, #76]	; 0x4c
	}

	cortexa_regs_read_internal(t);

	return reason;
}
 80013be:	b01f      	add	sp, #124	; 0x7c
 80013c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80013c2:	46c0      	nop			; (mov r8, r8)
 80013c4:	20001dc4 	.word	0x20001dc4
 80013c8:	0800ff3b 	.word	0x0800ff3b
 80013cc:	080105f3 	.word	0x080105f3
 80013d0:	e1a0000f 	.word	0xe1a0000f
 80013d4:	e10f0000 	.word	0xe10f0000
 80013d8:	eef10a10 	.word	0xeef10a10
 80013dc:	ec510b10 	.word	0xec510b10

080013e0 <cortexa_attach>:

	return true;
}

bool cortexa_attach(target *t)
{
 80013e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80013e2:	1c04      	adds	r4, r0, #0
	struct cortexa_priv *priv = t->priv;
 80013e4:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
	int tries;

	/* Clear any pending fault condition */
	target_check_error(t);
 80013e6:	f007 f817 	bl	8008418 <target_check_error>

	/* Enable halting debug mode */
	uint32_t dbgdscr = apb_read(t, DBGDSCR);
 80013ea:	2122      	movs	r1, #34	; 0x22
 80013ec:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80013ee:	f7ff fe0f 	bl	8001010 <apb_read.isra.1>
	dbgdscr |= DBGDSCR_HDBGEN | DBGDSCR_ITREN;
	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_STALL;
 80013f2:	2583      	movs	r5, #131	; 0x83
 80013f4:	4b1d      	ldr	r3, [pc, #116]	; (800146c <cortexa_attach+0x8c>)
 80013f6:	036d      	lsls	r5, r5, #13
 80013f8:	4018      	ands	r0, r3
 80013fa:	4305      	orrs	r5, r0
	apb_write(t, DBGDSCR, dbgdscr);
 80013fc:	1c2a      	adds	r2, r5, #0
 80013fe:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001400:	2122      	movs	r1, #34	; 0x22
 8001402:	f7ff fd33 	bl	8000e6c <apb_write.isra.0>
	DEBUG("DBGDSCR = 0x%08"PRIx32"\n", dbgdscr);
 8001406:	1c29      	adds	r1, r5, #0
 8001408:	4819      	ldr	r0, [pc, #100]	; (8001470 <cortexa_attach+0x90>)
 800140a:	f00b fb27 	bl	800ca5c <iprintf>

	target_halt_request(t);
 800140e:	1c20      	adds	r0, r4, #0
 8001410:	f007 f824 	bl	800845c <target_halt_request>
	tries = 10;
	while(!platform_srst_get_val() && !target_halt_poll(t, NULL) && --tries)
 8001414:	270a      	movs	r7, #10
 8001416:	f004 f94c 	bl	80056b2 <platform_srst_get_val>
 800141a:	1e05      	subs	r5, r0, #0
 800141c:	d10c      	bne.n	8001438 <cortexa_attach+0x58>
 800141e:	1c20      	adds	r0, r4, #0
 8001420:	1c29      	adds	r1, r5, #0
 8001422:	f007 f81f 	bl	8008464 <target_halt_poll>
 8001426:	2800      	cmp	r0, #0
 8001428:	d106      	bne.n	8001438 <cortexa_attach+0x58>
 800142a:	3f01      	subs	r7, #1
 800142c:	2f00      	cmp	r7, #0
 800142e:	d01b      	beq.n	8001468 <cortexa_attach+0x88>
		platform_delay(200);
 8001430:	20c8      	movs	r0, #200	; 0xc8
 8001432:	f00a f859 	bl	800b4e8 <platform_delay>
 8001436:	e7ee      	b.n	8001416 <cortexa_attach+0x36>
	apb_write(t, DBGDSCR, dbgdscr);
	DEBUG("DBGDSCR = 0x%08"PRIx32"\n", dbgdscr);

	target_halt_request(t);
	tries = 10;
	while(!platform_srst_get_val() && !target_halt_poll(t, NULL) && --tries)
 8001438:	2500      	movs	r5, #0
		platform_delay(200);
	if(!tries)
		return false;

	/* Clear any stale breakpoints */
	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
 800143a:	1c33      	adds	r3, r6, #0
 800143c:	33d8      	adds	r3, #216	; 0xd8
 800143e:	681b      	ldr	r3, [r3, #0]
 8001440:	429d      	cmp	r5, r3
 8001442:	d208      	bcs.n	8001456 <cortexa_attach+0x76>
 8001444:	1c29      	adds	r1, r5, #0
 8001446:	3150      	adds	r1, #80	; 0x50
		apb_write(t, DBGBCR(i), 0);
 8001448:	b289      	uxth	r1, r1
 800144a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800144c:	2200      	movs	r2, #0
 800144e:	f7ff fd0d 	bl	8000e6c <apb_write.isra.0>
		platform_delay(200);
	if(!tries)
		return false;

	/* Clear any stale breakpoints */
	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
 8001452:	3501      	adds	r5, #1
 8001454:	e7f1      	b.n	800143a <cortexa_attach+0x5a>
		apb_write(t, DBGBCR(i), 0);
	}
	priv->hw_breakpoint_mask = 0;
 8001456:	1c33      	adds	r3, r6, #0
 8001458:	2000      	movs	r0, #0
 800145a:	33dc      	adds	r3, #220	; 0xdc
	priv->bcr0 = 0;
 800145c:	36e0      	adds	r6, #224	; 0xe0

	/* Clear any stale breakpoints */
	for(unsigned i = 0; i < priv->hw_breakpoint_max; i++) {
		apb_write(t, DBGBCR(i), 0);
	}
	priv->hw_breakpoint_mask = 0;
 800145e:	8018      	strh	r0, [r3, #0]
	priv->bcr0 = 0;
 8001460:	6030      	str	r0, [r6, #0]

	platform_srst_set_val(false);
 8001462:	f004 f917 	bl	8005694 <platform_srst_set_val>

	return true;
 8001466:	2501      	movs	r5, #1
}
 8001468:	1c28      	adds	r0, r5, #0
 800146a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800146c:	ffcfffff 	.word	0xffcfffff
 8001470:	080105f7 	.word	0x080105f7

08001474 <cortexa_reset>:
		write_gpreg(t, i, priv->reg_cache.r[i]);
	}
}

static void cortexa_reset(target *t)
{
 8001474:	b530      	push	{r4, r5, lr}
	 * See Zynq-7000 TRM, Xilinx doc UG585
	 */
#define ZYNQ_SLCR_UNLOCK       0xf8000008
#define ZYNQ_SLCR_UNLOCK_KEY   0xdf0d
#define ZYNQ_SLCR_PSS_RST_CTRL 0xf8000200
	target_mem_write32(t, ZYNQ_SLCR_UNLOCK, ZYNQ_SLCR_UNLOCK_KEY);
 8001476:	4924      	ldr	r1, [pc, #144]	; (8001508 <cortexa_reset+0x94>)
		write_gpreg(t, i, priv->reg_cache.r[i]);
	}
}

static void cortexa_reset(target *t)
{
 8001478:	b09f      	sub	sp, #124	; 0x7c
	 * See Zynq-7000 TRM, Xilinx doc UG585
	 */
#define ZYNQ_SLCR_UNLOCK       0xf8000008
#define ZYNQ_SLCR_UNLOCK_KEY   0xdf0d
#define ZYNQ_SLCR_PSS_RST_CTRL 0xf8000200
	target_mem_write32(t, ZYNQ_SLCR_UNLOCK, ZYNQ_SLCR_UNLOCK_KEY);
 800147a:	4a24      	ldr	r2, [pc, #144]	; (800150c <cortexa_reset+0x98>)
		write_gpreg(t, i, priv->reg_cache.r[i]);
	}
}

static void cortexa_reset(target *t)
{
 800147c:	9001      	str	r0, [sp, #4]
	 * See Zynq-7000 TRM, Xilinx doc UG585
	 */
#define ZYNQ_SLCR_UNLOCK       0xf8000008
#define ZYNQ_SLCR_UNLOCK_KEY   0xdf0d
#define ZYNQ_SLCR_PSS_RST_CTRL 0xf8000200
	target_mem_write32(t, ZYNQ_SLCR_UNLOCK, ZYNQ_SLCR_UNLOCK_KEY);
 800147e:	f007 f85d 	bl	800853c <target_mem_write32>
	target_mem_write32(t, ZYNQ_SLCR_PSS_RST_CTRL, 1);
 8001482:	4923      	ldr	r1, [pc, #140]	; (8001510 <cortexa_reset+0x9c>)
 8001484:	2201      	movs	r2, #1
 8001486:	9801      	ldr	r0, [sp, #4]
 8001488:	f007 f858 	bl	800853c <target_mem_write32>

	/* Try hard reset too */
	platform_srst_set_val(true);
 800148c:	2001      	movs	r0, #1
 800148e:	f004 f901 	bl	8005694 <platform_srst_set_val>
	platform_srst_set_val(false);
 8001492:	2000      	movs	r0, #0
 8001494:	f004 f8fe 	bl	8005694 <platform_srst_set_val>

	/* Spin until Xilinx reconnects us */
	platform_timeout timeout;
	platform_timeout_set(&timeout, 1000);
 8001498:	21fa      	movs	r1, #250	; 0xfa
 800149a:	a802      	add	r0, sp, #8
 800149c:	0089      	lsls	r1, r1, #2
 800149e:	f009 fff7 	bl	800b490 <platform_timeout_set>
	volatile struct exception e;
	do {
		TRY_CATCH (e, EXCEPTION_ALL) {
 80014a2:	2200      	movs	r2, #0
 80014a4:	9203      	str	r2, [sp, #12]
 80014a6:	3a01      	subs	r2, #1
 80014a8:	9205      	str	r2, [sp, #20]
 80014aa:	4a1a      	ldr	r2, [pc, #104]	; (8001514 <cortexa_reset+0xa0>)
 80014ac:	ab03      	add	r3, sp, #12
 80014ae:	6811      	ldr	r1, [r2, #0]
 80014b0:	a806      	add	r0, sp, #24
 80014b2:	911d      	str	r1, [sp, #116]	; 0x74
 80014b4:	6013      	str	r3, [r2, #0]
 80014b6:	f00b fb7d 	bl	800cbb4 <setjmp>
 80014ba:	2800      	cmp	r0, #0
 80014bc:	d005      	beq.n	80014ca <cortexa_reset+0x56>
			apb_read(t, DBGDIDR);
		}
	} while (!platform_timeout_is_expired(&timeout) && e.type == EXCEPTION_ERROR);
 80014be:	a802      	add	r0, sp, #8
 80014c0:	f009 ffee 	bl	800b4a0 <platform_timeout_is_expired>
 80014c4:	2800      	cmp	r0, #0
 80014c6:	d110      	bne.n	80014ea <cortexa_reset+0x76>
 80014c8:	e00c      	b.n	80014e4 <cortexa_reset+0x70>
	/* Spin until Xilinx reconnects us */
	platform_timeout timeout;
	platform_timeout_set(&timeout, 1000);
	volatile struct exception e;
	do {
		TRY_CATCH (e, EXCEPTION_ALL) {
 80014ca:	4d12      	ldr	r5, [pc, #72]	; (8001514 <cortexa_reset+0xa0>)
 80014cc:	ab03      	add	r3, sp, #12
 80014ce:	682c      	ldr	r4, [r5, #0]
 80014d0:	429c      	cmp	r4, r3
 80014d2:	d1f4      	bne.n	80014be <cortexa_reset+0x4a>
			apb_read(t, DBGDIDR);
 80014d4:	9b01      	ldr	r3, [sp, #4]
 80014d6:	2100      	movs	r1, #0
 80014d8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 80014da:	f7ff fd99 	bl	8001010 <apb_read.isra.1>
	/* Spin until Xilinx reconnects us */
	platform_timeout timeout;
	platform_timeout_set(&timeout, 1000);
	volatile struct exception e;
	do {
		TRY_CATCH (e, EXCEPTION_ALL) {
 80014de:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80014e0:	602b      	str	r3, [r5, #0]
 80014e2:	e7f2      	b.n	80014ca <cortexa_reset+0x56>
			apb_read(t, DBGDIDR);
		}
	} while (!platform_timeout_is_expired(&timeout) && e.type == EXCEPTION_ERROR);
 80014e4:	9b03      	ldr	r3, [sp, #12]
 80014e6:	2b01      	cmp	r3, #1
 80014e8:	d0db      	beq.n	80014a2 <cortexa_reset+0x2e>
	if (e.type == EXCEPTION_ERROR)
 80014ea:	9b03      	ldr	r3, [sp, #12]
 80014ec:	2b01      	cmp	r3, #1
 80014ee:	d103      	bne.n	80014f8 <cortexa_reset+0x84>
		raise_exception(e.type, e.msg);
 80014f0:	9803      	ldr	r0, [sp, #12]
 80014f2:	9904      	ldr	r1, [sp, #16]
 80014f4:	f001 f9f0 	bl	80028d8 <raise_exception>

	platform_delay(100);
 80014f8:	2064      	movs	r0, #100	; 0x64
 80014fa:	f009 fff5 	bl	800b4e8 <platform_delay>

	cortexa_attach(t);
 80014fe:	9801      	ldr	r0, [sp, #4]
 8001500:	f7ff ff6e 	bl	80013e0 <cortexa_attach>
}
 8001504:	b01f      	add	sp, #124	; 0x7c
 8001506:	bd30      	pop	{r4, r5, pc}
 8001508:	f8000008 	.word	0xf8000008
 800150c:	0000df0d 	.word	0x0000df0d
 8001510:	f8000200 	.word	0xf8000200
 8001514:	20001dc4 	.word	0x20001dc4

08001518 <cortexa_slow_mem_read>:
	ADIv5_AP_t *ahb = ((struct cortexa_priv*)t->priv)->ahb;
	adiv5_mem_read(ahb, dest, va_to_pa(t, src), len);
}

static void cortexa_slow_mem_read(target *t, void *dest, target_addr src, size_t len)
{
 8001518:	b5f0      	push	{r4, r5, r6, r7, lr}
 800151a:	b087      	sub	sp, #28
 800151c:	af00      	add	r7, sp, #0
 800151e:	60bb      	str	r3, [r7, #8]
	struct cortexa_priv *priv = t->priv;
 8001520:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
	ADIv5_AP_t *ahb = ((struct cortexa_priv*)t->priv)->ahb;
	adiv5_mem_read(ahb, dest, va_to_pa(t, src), len);
}

static void cortexa_slow_mem_read(target *t, void *dest, target_addr src, size_t len)
{
 8001522:	6039      	str	r1, [r7, #0]
	struct cortexa_priv *priv = t->priv;
 8001524:	607b      	str	r3, [r7, #4]
	unsigned words = (len + (src & 3) + 3) / 4;
 8001526:	2103      	movs	r1, #3
 8001528:	1c13      	adds	r3, r2, #0
 800152a:	400b      	ands	r3, r1
 800152c:	613b      	str	r3, [r7, #16]
 800152e:	68bb      	ldr	r3, [r7, #8]
	ADIv5_AP_t *ahb = ((struct cortexa_priv*)t->priv)->ahb;
	adiv5_mem_read(ahb, dest, va_to_pa(t, src), len);
}

static void cortexa_slow_mem_read(target *t, void *dest, target_addr src, size_t len)
{
 8001530:	1c04      	adds	r4, r0, #0
 8001532:	185d      	adds	r5, r3, r1
	struct cortexa_priv *priv = t->priv;
	unsigned words = (len + (src & 3) + 3) / 4;
 8001534:	693b      	ldr	r3, [r7, #16]
	uint32_t dest32[words];
 8001536:	4668      	mov	r0, sp
}

static void cortexa_slow_mem_read(target *t, void *dest, target_addr src, size_t len)
{
	struct cortexa_priv *priv = t->priv;
	unsigned words = (len + (src & 3) + 3) / 4;
 8001538:	18ed      	adds	r5, r5, r3
 800153a:	08ad      	lsrs	r5, r5, #2
	uint32_t dest32[words];
 800153c:	00ad      	lsls	r5, r5, #2
 800153e:	1c2b      	adds	r3, r5, #0
 8001540:	330a      	adds	r3, #10
 8001542:	40cb      	lsrs	r3, r1
 8001544:	408b      	lsls	r3, r1
 8001546:	1ac3      	subs	r3, r0, r3
 8001548:	469d      	mov	sp, r3

	/* Set r0 to aligned src address */
	write_gpreg(t, 0, src & ~3);
 800154a:	438a      	bics	r2, r1
 800154c:	1c20      	adds	r0, r4, #0
 800154e:	2100      	movs	r1, #0

static void cortexa_slow_mem_read(target *t, void *dest, target_addr src, size_t len)
{
	struct cortexa_priv *priv = t->priv;
	unsigned words = (len + (src & 3) + 3) / 4;
	uint32_t dest32[words];
 8001550:	617b      	str	r3, [r7, #20]

	/* Set r0 to aligned src address */
	write_gpreg(t, 0, src & ~3);
 8001552:	f7ff fc9e 	bl	8000e92 <write_gpreg>

	/* Switch to fast DCC mode */
	uint32_t dbgdscr = apb_read(t, DBGDSCR);
 8001556:	2122      	movs	r1, #34	; 0x22
 8001558:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800155a:	f7ff fd59 	bl	8001010 <apb_read.isra.1>
	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_FAST;
 800155e:	2280      	movs	r2, #128	; 0x80
 8001560:	4b21      	ldr	r3, [pc, #132]	; (80015e8 <cortexa_slow_mem_read+0xd0>)
 8001562:	0392      	lsls	r2, r2, #14
 8001564:	4018      	ands	r0, r3
 8001566:	4302      	orrs	r2, r0
 8001568:	60f8      	str	r0, [r7, #12]
	apb_write(t, DBGDSCR, dbgdscr);
 800156a:	2122      	movs	r1, #34	; 0x22
 800156c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800156e:	f7ff fc7d 	bl	8000e6c <apb_write.isra.0>

	apb_write(t, DBGITR, 0xecb05e01); /* ldc 14, cr5, [r0], #4 */
 8001572:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001574:	2121      	movs	r1, #33	; 0x21
 8001576:	4a1d      	ldr	r2, [pc, #116]	; (80015ec <cortexa_slow_mem_read+0xd4>)
 8001578:	f7ff fc78 	bl	8000e6c <apb_write.isra.0>
	/* According to the ARMv7-A ARM, in fast mode, the first read from
	 * DBGDTRTX is  supposed to block until the instruction is complete,
	 * but we see the first read returns junk, so it's read here and
	 * ignored. */
	apb_read(t, DBGDTRTX);
 800157c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800157e:	2123      	movs	r1, #35	; 0x23
 8001580:	f7ff fd46 	bl	8001010 <apb_read.isra.1>
 8001584:	697e      	ldr	r6, [r7, #20]
 8001586:	1975      	adds	r5, r6, r5

	for (unsigned i = 0; i < words; i++)
 8001588:	42ae      	cmp	r6, r5
 800158a:	d005      	beq.n	8001598 <cortexa_slow_mem_read+0x80>
		dest32[i] = apb_read(t, DBGDTRTX);
 800158c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800158e:	2123      	movs	r1, #35	; 0x23
 8001590:	f7ff fd3e 	bl	8001010 <apb_read.isra.1>
 8001594:	c601      	stmia	r6!, {r0}
 8001596:	e7f7      	b.n	8001588 <cortexa_slow_mem_read+0x70>

	memcpy(dest, (uint8_t*)dest32 + (src & 3), len);
 8001598:	693a      	ldr	r2, [r7, #16]
 800159a:	697b      	ldr	r3, [r7, #20]
 800159c:	4694      	mov	ip, r2
 800159e:	4463      	add	r3, ip
 80015a0:	1c19      	adds	r1, r3, #0
 80015a2:	68ba      	ldr	r2, [r7, #8]
 80015a4:	6838      	ldr	r0, [r7, #0]
 80015a6:	f00b f987 	bl	800c8b8 <memcpy>

	/* Switch back to stalling DCC mode */
	dbgdscr = (dbgdscr & ~DBGDSCR_EXTDCCMODE_MASK) | DBGDSCR_EXTDCCMODE_STALL;
 80015aa:	2280      	movs	r2, #128	; 0x80
 80015ac:	68fb      	ldr	r3, [r7, #12]
 80015ae:	0352      	lsls	r2, r2, #13
 80015b0:	431a      	orrs	r2, r3
	apb_write(t, DBGDSCR, dbgdscr);
 80015b2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80015b4:	2122      	movs	r1, #34	; 0x22
 80015b6:	f7ff fc59 	bl	8000e6c <apb_write.isra.0>

	if (apb_read(t, DBGDSCR) & DBGDSCR_SDABORT_L) {
 80015ba:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80015bc:	2122      	movs	r1, #34	; 0x22
 80015be:	f7ff fd27 	bl	8001010 <apb_read.isra.1>
 80015c2:	0643      	lsls	r3, r0, #25
 80015c4:	d509      	bpl.n	80015da <cortexa_slow_mem_read+0xc2>
		/* Memory access aborted, flag a fault */
		apb_write(t, DBGDRCR, DBGDRCR_CSE);
 80015c6:	2204      	movs	r2, #4
 80015c8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80015ca:	2124      	movs	r1, #36	; 0x24
 80015cc:	f7ff fc4e 	bl	8000e6c <apb_write.isra.0>
		priv->mmu_fault = true;
 80015d0:	2201      	movs	r2, #1
 80015d2:	687b      	ldr	r3, [r7, #4]
 80015d4:	33e8      	adds	r3, #232	; 0xe8
 80015d6:	701a      	strb	r2, [r3, #0]
 80015d8:	e003      	b.n	80015e2 <cortexa_slow_mem_read+0xca>
	} else {
		apb_read(t, DBGDTRTX);
 80015da:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80015dc:	2123      	movs	r1, #35	; 0x23
 80015de:	f7ff fd17 	bl	8001010 <apb_read.isra.1>
	}
}
 80015e2:	46bd      	mov	sp, r7
 80015e4:	b007      	add	sp, #28
 80015e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80015e8:	ffcfffff 	.word	0xffcfffff
 80015ec:	ecb05e01 	.word	0xecb05e01

080015f0 <cortexa_breakwatch_set>:
	else
		return DBGBCR_BAS_LOW_HW;
}

static int cortexa_breakwatch_set(target *t, struct breakwatch *bw)
{
 80015f0:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct cortexa_priv *priv = t->priv;
 80015f2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
	else
		return DBGBCR_BAS_LOW_HW;
}

static int cortexa_breakwatch_set(target *t, struct breakwatch *bw)
{
 80015f4:	b087      	sub	sp, #28
	struct cortexa_priv *priv = t->priv;
 80015f6:	9304      	str	r3, [sp, #16]
	unsigned i;

	switch (bw->type) {
 80015f8:	790d      	ldrb	r5, [r1, #4]
	else
		return DBGBCR_BAS_LOW_HW;
}

static int cortexa_breakwatch_set(target *t, struct breakwatch *bw)
{
 80015fa:	1c04      	adds	r4, r0, #0
 80015fc:	1c0e      	adds	r6, r1, #0
	struct cortexa_priv *priv = t->priv;
	unsigned i;

	switch (bw->type) {
 80015fe:	2d00      	cmp	r5, #0
 8001600:	d002      	beq.n	8001608 <cortexa_breakwatch_set+0x18>
 8001602:	2d01      	cmp	r5, #1
 8001604:	d01b      	beq.n	800163e <cortexa_breakwatch_set+0x4e>
 8001606:	e031      	b.n	800166c <cortexa_breakwatch_set+0x7c>
	case TARGET_BREAK_SOFT:
		switch (bw->size) {
 8001608:	68cb      	ldr	r3, [r1, #12]
 800160a:	2b02      	cmp	r3, #2
 800160c:	d00b      	beq.n	8001626 <cortexa_breakwatch_set+0x36>
 800160e:	2b04      	cmp	r3, #4
 8001610:	d12e      	bne.n	8001670 <cortexa_breakwatch_set+0x80>
		case 2:
			bw->reserved[0] = target_mem_read16(t, bw->addr);
			target_mem_write16(t, bw->addr, 0xBE00);
			return 0;
		case 4:
			bw->reserved[0] = target_mem_read32(t, bw->addr);
 8001612:	6889      	ldr	r1, [r1, #8]
 8001614:	f006 ff8a 	bl	800852c <target_mem_read32>
			target_mem_write32(t, bw->addr, 0xE1200070);
 8001618:	68b1      	ldr	r1, [r6, #8]
		case 2:
			bw->reserved[0] = target_mem_read16(t, bw->addr);
			target_mem_write16(t, bw->addr, 0xBE00);
			return 0;
		case 4:
			bw->reserved[0] = target_mem_read32(t, bw->addr);
 800161a:	6130      	str	r0, [r6, #16]
			target_mem_write32(t, bw->addr, 0xE1200070);
 800161c:	4a44      	ldr	r2, [pc, #272]	; (8001730 <cortexa_breakwatch_set+0x140>)
 800161e:	1c20      	adds	r0, r4, #0
 8001620:	f006 ff8c 	bl	800853c <target_mem_write32>
 8001624:	e009      	b.n	800163a <cortexa_breakwatch_set+0x4a>

	switch (bw->type) {
	case TARGET_BREAK_SOFT:
		switch (bw->size) {
		case 2:
			bw->reserved[0] = target_mem_read16(t, bw->addr);
 8001626:	6889      	ldr	r1, [r1, #8]
 8001628:	f006 ff8f 	bl	800854a <target_mem_read16>
			target_mem_write16(t, bw->addr, 0xBE00);
 800162c:	22be      	movs	r2, #190	; 0xbe

	switch (bw->type) {
	case TARGET_BREAK_SOFT:
		switch (bw->size) {
		case 2:
			bw->reserved[0] = target_mem_read16(t, bw->addr);
 800162e:	6130      	str	r0, [r6, #16]
			target_mem_write16(t, bw->addr, 0xBE00);
 8001630:	68b1      	ldr	r1, [r6, #8]
 8001632:	1c20      	adds	r0, r4, #0
 8001634:	0212      	lsls	r2, r2, #8
 8001636:	f006 ff92 	bl	800855e <target_mem_write16>
			return 0;
		case 4:
			bw->reserved[0] = target_mem_read32(t, bw->addr);
			target_mem_write32(t, bw->addr, 0xE1200070);
			return 0;
 800163a:	1c2f      	adds	r7, r5, #0
 800163c:	e075      	b.n	800172a <cortexa_breakwatch_set+0x13a>
		default:
			return -1;
		}
	case TARGET_BREAK_HARD:
		if ((bw->size != 4) && (bw->size != 2))
 800163e:	2202      	movs	r2, #2
 8001640:	68cb      	ldr	r3, [r1, #12]
 8001642:	3b02      	subs	r3, #2
 8001644:	4393      	bics	r3, r2
 8001646:	d113      	bne.n	8001670 <cortexa_breakwatch_set+0x80>
			return -1;

		for (i = 0; i < priv->hw_breakpoint_max; i++)
 8001648:	9a04      	ldr	r2, [sp, #16]
 800164a:	32d8      	adds	r2, #216	; 0xd8
 800164c:	6811      	ldr	r1, [r2, #0]
 800164e:	9303      	str	r3, [sp, #12]
 8001650:	9b03      	ldr	r3, [sp, #12]
 8001652:	428b      	cmp	r3, r1
 8001654:	d00c      	beq.n	8001670 <cortexa_breakwatch_set+0x80>
			if ((priv->hw_breakpoint_mask & (1 << i)) == 0)
 8001656:	9b04      	ldr	r3, [sp, #16]
 8001658:	9803      	ldr	r0, [sp, #12]
 800165a:	33dc      	adds	r3, #220	; 0xdc
 800165c:	881a      	ldrh	r2, [r3, #0]
 800165e:	2501      	movs	r5, #1
 8001660:	4102      	asrs	r2, r0
 8001662:	402a      	ands	r2, r5
 8001664:	1e17      	subs	r7, r2, #0
 8001666:	d006      	beq.n	8001676 <cortexa_breakwatch_set+0x86>
		}
	case TARGET_BREAK_HARD:
		if ((bw->size != 4) && (bw->size != 2))
			return -1;

		for (i = 0; i < priv->hw_breakpoint_max; i++)
 8001668:	1943      	adds	r3, r0, r5
 800166a:	e7f0      	b.n	800164e <cortexa_breakwatch_set+0x5e>
			priv->bvr0 = addr & ~3;
		}

		return 0;
	default:
		return 1;
 800166c:	2701      	movs	r7, #1
 800166e:	e05c      	b.n	800172a <cortexa_breakwatch_set+0x13a>
		default:
			return -1;
		}
	case TARGET_BREAK_HARD:
		if ((bw->size != 4) && (bw->size != 2))
			return -1;
 8001670:	2701      	movs	r7, #1
 8001672:	427f      	negs	r7, r7
 8001674:	e059      	b.n	800172a <cortexa_breakwatch_set+0x13a>

		if (i == priv->hw_breakpoint_max)
			return -1;

		bw->reserved[0] = i;
		priv->hw_breakpoint_mask |= (1 << i);
 8001676:	1c29      	adds	r1, r5, #0
 8001678:	9803      	ldr	r0, [sp, #12]
				break;

		if (i == priv->hw_breakpoint_max)
			return -1;

		bw->reserved[0] = i;
 800167a:	9a03      	ldr	r2, [sp, #12]
		priv->hw_breakpoint_mask |= (1 << i);
 800167c:	4081      	lsls	r1, r0
				break;

		if (i == priv->hw_breakpoint_max)
			return -1;

		bw->reserved[0] = i;
 800167e:	6132      	str	r2, [r6, #16]
		priv->hw_breakpoint_mask |= (1 << i);
 8001680:	881a      	ldrh	r2, [r3, #0]
}

static uint32_t va_to_pa(target *t, uint32_t va)
{
	struct cortexa_priv *priv = t->priv;
	write_gpreg(t, 0, va);
 8001682:	1c20      	adds	r0, r4, #0

		if (i == priv->hw_breakpoint_max)
			return -1;

		bw->reserved[0] = i;
		priv->hw_breakpoint_mask |= (1 << i);
 8001684:	430a      	orrs	r2, r1
 8001686:	801a      	strh	r2, [r3, #0]

		uint32_t addr = va_to_pa(t, bw->addr);
 8001688:	68b3      	ldr	r3, [r6, #8]
}

static uint32_t va_to_pa(target *t, uint32_t va)
{
	struct cortexa_priv *priv = t->priv;
	write_gpreg(t, 0, va);
 800168a:	1c39      	adds	r1, r7, #0
 800168c:	1c1a      	adds	r2, r3, #0
			return -1;

		bw->reserved[0] = i;
		priv->hw_breakpoint_mask |= (1 << i);

		uint32_t addr = va_to_pa(t, bw->addr);
 800168e:	9305      	str	r3, [sp, #20]
}

static uint32_t va_to_pa(target *t, uint32_t va)
{
	struct cortexa_priv *priv = t->priv;
	write_gpreg(t, 0, va);
 8001690:	f7ff fbff 	bl	8000e92 <write_gpreg>
	apb_write(t, DBGITR, MCR | ATS1CPR);
 8001694:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8001696:	2121      	movs	r1, #33	; 0x21
 8001698:	4a26      	ldr	r2, [pc, #152]	; (8001734 <cortexa_breakwatch_set+0x144>)
 800169a:	f7ff fbe7 	bl	8000e6c <apb_write.isra.0>
	apb_write(t, DBGITR, MRC | PAR);
 800169e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80016a0:	2121      	movs	r1, #33	; 0x21
 80016a2:	4a25      	ldr	r2, [pc, #148]	; (8001738 <cortexa_breakwatch_set+0x148>)
 80016a4:	f7ff fbe2 	bl	8000e6c <apb_write.isra.0>
	uint32_t par = read_gpreg(t, 0);
 80016a8:	1c20      	adds	r0, r4, #0
 80016aa:	1c39      	adds	r1, r7, #0
 80016ac:	f7ff fcc8 	bl	8001040 <read_gpreg>
 80016b0:	1c03      	adds	r3, r0, #0
	if (par & 1)
 80016b2:	4228      	tst	r0, r5
 80016b4:	d002      	beq.n	80016bc <cortexa_breakwatch_set+0xcc>
		priv->mmu_fault = true;
 80016b6:	9a04      	ldr	r2, [sp, #16]
 80016b8:	32e8      	adds	r2, #232	; 0xe8
 80016ba:	7015      	strb	r5, [r2, #0]
	uint32_t pa = (par & ~0xfff) | (va & 0xfff);
 80016bc:	9a05      	ldr	r2, [sp, #20]
 80016be:	0b1d      	lsrs	r5, r3, #12
 80016c0:	0512      	lsls	r2, r2, #20
 80016c2:	0d12      	lsrs	r2, r2, #20
	DEBUG("%s: VA = 0x%08"PRIx32", PAR = 0x%08"PRIx32", PA = 0x%08"PRIX32"\n",
 80016c4:	491d      	ldr	r1, [pc, #116]	; (800173c <cortexa_breakwatch_set+0x14c>)
	apb_write(t, DBGITR, MCR | ATS1CPR);
	apb_write(t, DBGITR, MRC | PAR);
	uint32_t par = read_gpreg(t, 0);
	if (par & 1)
		priv->mmu_fault = true;
	uint32_t pa = (par & ~0xfff) | (va & 0xfff);
 80016c6:	032d      	lsls	r5, r5, #12
 80016c8:	4315      	orrs	r5, r2
	DEBUG("%s: VA = 0x%08"PRIx32", PAR = 0x%08"PRIx32", PA = 0x%08"PRIX32"\n",
 80016ca:	9500      	str	r5, [sp, #0]
 80016cc:	481c      	ldr	r0, [pc, #112]	; (8001740 <cortexa_breakwatch_set+0x150>)
 80016ce:	3126      	adds	r1, #38	; 0x26
 80016d0:	9a05      	ldr	r2, [sp, #20]
 80016d2:	f00b f9c3 	bl	800ca5c <iprintf>

		bw->reserved[0] = i;
		priv->hw_breakpoint_mask |= (1 << i);

		uint32_t addr = va_to_pa(t, bw->addr);
		uint32_t bcr =  bp_bas(addr, bw->size) | DBGBCR_EN;
 80016d6:	68f3      	ldr	r3, [r6, #12]
}

/* Breakpoints */
static uint32_t bp_bas(uint32_t addr, uint8_t len)
{
	if (len == 4)
 80016d8:	b2db      	uxtb	r3, r3
 80016da:	2b04      	cmp	r3, #4
 80016dc:	d003      	beq.n	80016e6 <cortexa_breakwatch_set+0xf6>
		return DBGBCR_BAS_ANY;
	else if (addr & 2)
 80016de:	07ab      	lsls	r3, r5, #30
 80016e0:	d403      	bmi.n	80016ea <cortexa_breakwatch_set+0xfa>
		return DBGBCR_BAS_HIGH_HW;
	else
		return DBGBCR_BAS_LOW_HW;
 80016e2:	2360      	movs	r3, #96	; 0x60
 80016e4:	e003      	b.n	80016ee <cortexa_breakwatch_set+0xfe>

/* Breakpoints */
static uint32_t bp_bas(uint32_t addr, uint8_t len)
{
	if (len == 4)
		return DBGBCR_BAS_ANY;
 80016e6:	23f0      	movs	r3, #240	; 0xf0
 80016e8:	e000      	b.n	80016ec <cortexa_breakwatch_set+0xfc>
	else if (addr & 2)
		return DBGBCR_BAS_HIGH_HW;
 80016ea:	23c0      	movs	r3, #192	; 0xc0
 80016ec:	005b      	lsls	r3, r3, #1

		bw->reserved[0] = i;
		priv->hw_breakpoint_mask |= (1 << i);

		uint32_t addr = va_to_pa(t, bw->addr);
		uint32_t bcr =  bp_bas(addr, bw->size) | DBGBCR_EN;
 80016ee:	2601      	movs	r6, #1
 80016f0:	431e      	orrs	r6, r3
		apb_write(t, DBGBVR(i), addr & ~3);
 80016f2:	466b      	mov	r3, sp
 80016f4:	899b      	ldrh	r3, [r3, #12]
 80016f6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80016f8:	9305      	str	r3, [sp, #20]
 80016fa:	2303      	movs	r3, #3
 80016fc:	9905      	ldr	r1, [sp, #20]
 80016fe:	439d      	bics	r5, r3
 8001700:	3140      	adds	r1, #64	; 0x40
 8001702:	b289      	uxth	r1, r1
 8001704:	1c2a      	adds	r2, r5, #0
 8001706:	f7ff fbb1 	bl	8000e6c <apb_write.isra.0>
		apb_write(t, DBGBCR(i), bcr);
 800170a:	9b05      	ldr	r3, [sp, #20]
 800170c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800170e:	3350      	adds	r3, #80	; 0x50
 8001710:	b299      	uxth	r1, r3
 8001712:	1c32      	adds	r2, r6, #0
 8001714:	f7ff fbaa 	bl	8000e6c <apb_write.isra.0>
		if (i == 0) {
 8001718:	9b03      	ldr	r3, [sp, #12]
 800171a:	2b00      	cmp	r3, #0
 800171c:	d105      	bne.n	800172a <cortexa_breakwatch_set+0x13a>
			priv->bcr0 = bcr;
 800171e:	9b04      	ldr	r3, [sp, #16]
 8001720:	33e0      	adds	r3, #224	; 0xe0
 8001722:	601e      	str	r6, [r3, #0]
			priv->bvr0 = addr & ~3;
 8001724:	9b04      	ldr	r3, [sp, #16]
 8001726:	33e4      	adds	r3, #228	; 0xe4
 8001728:	601d      	str	r5, [r3, #0]

		return 0;
	default:
		return 1;
	}
}
 800172a:	1c38      	adds	r0, r7, #0
 800172c:	b007      	add	sp, #28
 800172e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001730:	e1200070 	.word	0xe1200070
 8001734:	ee070f18 	.word	0xee070f18
 8001738:	ee170f14 	.word	0xee170f14
 800173c:	0800ff3b 	.word	0x0800ff3b
 8001740:	0801060a 	.word	0x0801060a

08001744 <cortexa_probe>:
	return err;
}


bool cortexa_probe(ADIv5_AP_t *apb, uint32_t debug_base)
{
 8001744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8001746:	1c06      	adds	r6, r0, #0
 8001748:	9101      	str	r1, [sp, #4]
	target *t;

	t = target_new();
 800174a:	f006 fc41 	bl	8007fd0 <target_new>
 800174e:	1c04      	adds	r4, r0, #0
	adiv5_ap_ref(apb);
 8001750:	1c30      	adds	r0, r6, #0
 8001752:	f7fe fcd9 	bl	8000108 <adiv5_ap_ref>
	struct cortexa_priv *priv = calloc(1, sizeof(*priv));
 8001756:	21f0      	movs	r1, #240	; 0xf0
 8001758:	2001      	movs	r0, #1
 800175a:	f00b f88d 	bl	800c878 <calloc>
	t->priv = priv;
	t->priv_free = free;
 800175e:	4b23      	ldr	r3, [pc, #140]	; (80017ec <cortexa_probe+0xa8>)
{
	target *t;

	t = target_new();
	adiv5_ap_ref(apb);
	struct cortexa_priv *priv = calloc(1, sizeof(*priv));
 8001760:	1c05      	adds	r5, r0, #0
	t->priv = priv;
	t->priv_free = free;
 8001762:	6723      	str	r3, [r4, #112]	; 0x70
	target *t;

	t = target_new();
	adiv5_ap_ref(apb);
	struct cortexa_priv *priv = calloc(1, sizeof(*priv));
	t->priv = priv;
 8001764:	66e0      	str	r0, [r4, #108]	; 0x6c
	t->priv_free = free;
	priv->apb = apb;
	/* FIXME Find a better way to find the AHB.  This is likely to be
	 * device specific. */
	priv->ahb = adiv5_new_ap(apb->dp, 0);
 8001766:	2100      	movs	r1, #0
	t = target_new();
	adiv5_ap_ref(apb);
	struct cortexa_priv *priv = calloc(1, sizeof(*priv));
	t->priv = priv;
	t->priv_free = free;
	priv->apb = apb;
 8001768:	6046      	str	r6, [r0, #4]
	/* FIXME Find a better way to find the AHB.  This is likely to be
	 * device specific. */
	priv->ahb = adiv5_new_ap(apb->dp, 0);
 800176a:	6870      	ldr	r0, [r6, #4]
 800176c:	f7fe ff15 	bl	800059a <adiv5_new_ap>
		t->mem_read = cortexa_mem_read;
		t->mem_write = cortexa_mem_write;
	} else {
		/* This is not an AHB, fall back to slow APB access */
		adiv5_ap_unref(priv->ahb);
		priv->ahb = NULL;
 8001770:	2700      	movs	r7, #0
	t->priv = priv;
	t->priv_free = free;
	priv->apb = apb;
	/* FIXME Find a better way to find the AHB.  This is likely to be
	 * device specific. */
	priv->ahb = adiv5_new_ap(apb->dp, 0);
 8001772:	60a8      	str	r0, [r5, #8]
	adiv5_ap_ref(priv->ahb);
 8001774:	f7fe fcc8 	bl	8000108 <adiv5_ap_ref>
		/* This is an AHB */
		t->mem_read = cortexa_mem_read;
		t->mem_write = cortexa_mem_write;
	} else {
		/* This is not an AHB, fall back to slow APB access */
		adiv5_ap_unref(priv->ahb);
 8001778:	68a8      	ldr	r0, [r5, #8]
 800177a:	f7fe fcd3 	bl	8000124 <adiv5_ap_unref>
		t->mem_write = cortexa_slow_mem_write;
	}

	priv->base = debug_base;
	/* Set up APB CSW, we won't touch this again */
	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
 800177e:	2202      	movs	r2, #2
	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
 8001780:	2180      	movs	r1, #128	; 0x80
		t->mem_write = cortexa_mem_write;
	} else {
		/* This is not an AHB, fall back to slow APB access */
		adiv5_ap_unref(priv->ahb);
		priv->ahb = NULL;
		t->mem_read = cortexa_slow_mem_read;
 8001782:	4b1b      	ldr	r3, [pc, #108]	; (80017f0 <cortexa_probe+0xac>)
		t->mem_read = cortexa_mem_read;
		t->mem_write = cortexa_mem_write;
	} else {
		/* This is not an AHB, fall back to slow APB access */
		adiv5_ap_unref(priv->ahb);
		priv->ahb = NULL;
 8001784:	60af      	str	r7, [r5, #8]
		t->mem_read = cortexa_slow_mem_read;
 8001786:	6163      	str	r3, [r4, #20]
		t->mem_write = cortexa_slow_mem_write;
 8001788:	4b1a      	ldr	r3, [pc, #104]	; (80017f4 <cortexa_probe+0xb0>)
	}

	priv->base = debug_base;
	/* Set up APB CSW, we won't touch this again */
	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
 800178a:	1c30      	adds	r0, r6, #0
	} else {
		/* This is not an AHB, fall back to slow APB access */
		adiv5_ap_unref(priv->ahb);
		priv->ahb = NULL;
		t->mem_read = cortexa_slow_mem_read;
		t->mem_write = cortexa_slow_mem_write;
 800178c:	61a3      	str	r3, [r4, #24]
	}

	priv->base = debug_base;
 800178e:	9b01      	ldr	r3, [sp, #4]
	/* Set up APB CSW, we won't touch this again */
	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
 8001790:	0049      	lsls	r1, r1, #1
		priv->ahb = NULL;
		t->mem_read = cortexa_slow_mem_read;
		t->mem_write = cortexa_slow_mem_write;
	}

	priv->base = debug_base;
 8001792:	602b      	str	r3, [r5, #0]
	/* Set up APB CSW, we won't touch this again */
	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
 8001794:	69b3      	ldr	r3, [r6, #24]
	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
	uint32_t dbgdidr = apb_read(t, DBGDIDR);
	priv->hw_breakpoint_max = ((dbgdidr >> 24) & 15)+1;
 8001796:	35d8      	adds	r5, #216	; 0xd8
		t->mem_write = cortexa_slow_mem_write;
	}

	priv->base = debug_base;
	/* Set up APB CSW, we won't touch this again */
	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
 8001798:	431a      	orrs	r2, r3
	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
 800179a:	f7fe fcd9 	bl	8000150 <adiv5_ap_write>
	uint32_t dbgdidr = apb_read(t, DBGDIDR);
 800179e:	1c39      	adds	r1, r7, #0
 80017a0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80017a2:	f7ff fc35 	bl	8001010 <apb_read.isra.1>
	priv->hw_breakpoint_max = ((dbgdidr >> 24) & 15)+1;
 80017a6:	0100      	lsls	r0, r0, #4

	t->check_error = cortexa_check_error;
 80017a8:	4b13      	ldr	r3, [pc, #76]	; (80017f8 <cortexa_probe+0xb4>)
	priv->base = debug_base;
	/* Set up APB CSW, we won't touch this again */
	uint32_t csw = apb->csw | ADIV5_AP_CSW_SIZE_WORD;
	adiv5_ap_write(apb, ADIV5_AP_CSW, csw);
	uint32_t dbgdidr = apb_read(t, DBGDIDR);
	priv->hw_breakpoint_max = ((dbgdidr >> 24) & 15)+1;
 80017aa:	0f00      	lsrs	r0, r0, #28
 80017ac:	3001      	adds	r0, #1
 80017ae:	6028      	str	r0, [r5, #0]

	t->check_error = cortexa_check_error;
 80017b0:	6123      	str	r3, [r4, #16]

	t->driver = cortexa_driver_str;
 80017b2:	4b12      	ldr	r3, [pc, #72]	; (80017fc <cortexa_probe+0xb8>)

	t->breakwatch_set = cortexa_breakwatch_set;
	t->breakwatch_clear = cortexa_breakwatch_clear;

	return true;
}
 80017b4:	2001      	movs	r0, #1
	uint32_t dbgdidr = apb_read(t, DBGDIDR);
	priv->hw_breakpoint_max = ((dbgdidr >> 24) & 15)+1;

	t->check_error = cortexa_check_error;

	t->driver = cortexa_driver_str;
 80017b6:	6623      	str	r3, [r4, #96]	; 0x60

	t->attach = cortexa_attach;
 80017b8:	4b11      	ldr	r3, [pc, #68]	; (8001800 <cortexa_probe+0xbc>)
 80017ba:	60a3      	str	r3, [r4, #8]
	t->detach = cortexa_detach;
 80017bc:	4b11      	ldr	r3, [pc, #68]	; (8001804 <cortexa_probe+0xc0>)
 80017be:	60e3      	str	r3, [r4, #12]

	t->tdesc = tdesc_cortex_a;
 80017c0:	4b11      	ldr	r3, [pc, #68]	; (8001808 <cortexa_probe+0xc4>)
 80017c2:	332f      	adds	r3, #47	; 0x2f
 80017c4:	6223      	str	r3, [r4, #32]
	t->regs_read = cortexa_regs_read;
 80017c6:	4b11      	ldr	r3, [pc, #68]	; (800180c <cortexa_probe+0xc8>)
 80017c8:	6263      	str	r3, [r4, #36]	; 0x24
	t->regs_write = cortexa_regs_write;
 80017ca:	4b11      	ldr	r3, [pc, #68]	; (8001810 <cortexa_probe+0xcc>)
 80017cc:	62a3      	str	r3, [r4, #40]	; 0x28

	t->reset = cortexa_reset;
 80017ce:	4b11      	ldr	r3, [pc, #68]	; (8001814 <cortexa_probe+0xd0>)
 80017d0:	62e3      	str	r3, [r4, #44]	; 0x2c
	t->halt_request = cortexa_halt_request;
 80017d2:	4b11      	ldr	r3, [pc, #68]	; (8001818 <cortexa_probe+0xd4>)
 80017d4:	6363      	str	r3, [r4, #52]	; 0x34
	t->halt_poll = cortexa_halt_poll;
 80017d6:	4b11      	ldr	r3, [pc, #68]	; (800181c <cortexa_probe+0xd8>)
 80017d8:	63a3      	str	r3, [r4, #56]	; 0x38
	t->halt_resume = cortexa_halt_resume;
 80017da:	4b11      	ldr	r3, [pc, #68]	; (8001820 <cortexa_probe+0xdc>)
 80017dc:	63e3      	str	r3, [r4, #60]	; 0x3c
	t->regs_size = sizeof(priv->reg_cache);
 80017de:	23c8      	movs	r3, #200	; 0xc8
 80017e0:	61e3      	str	r3, [r4, #28]

	t->breakwatch_set = cortexa_breakwatch_set;
 80017e2:	4b10      	ldr	r3, [pc, #64]	; (8001824 <cortexa_probe+0xe0>)
 80017e4:	6423      	str	r3, [r4, #64]	; 0x40
	t->breakwatch_clear = cortexa_breakwatch_clear;
 80017e6:	4b10      	ldr	r3, [pc, #64]	; (8001828 <cortexa_probe+0xe4>)
 80017e8:	6463      	str	r3, [r4, #68]	; 0x44

	return true;
}
 80017ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80017ec:	0800c8a5 	.word	0x0800c8a5
 80017f0:	08001519 	.word	0x08001519
 80017f4:	08001065 	.word	0x08001065
 80017f8:	08000e25 	.word	0x08000e25
 80017fc:	20000000 	.word	0x20000000
 8001800:	080013e1 	.word	0x080013e1
 8001804:	08001219 	.word	0x08001219
 8001808:	0800ff3b 	.word	0x0800ff3b
 800180c:	08000e5b 	.word	0x08000e5b
 8001810:	08000e4b 	.word	0x08000e4b
 8001814:	08001475 	.word	0x08001475
 8001818:	08000fb5 	.word	0x08000fb5
 800181c:	08001291 	.word	0x08001291
 8001820:	08001129 	.word	0x08001129
 8001824:	080015f1 	.word	0x080015f1
 8001828:	08000f51 	.word	0x08000f51

0800182c <cortexm_check_error>:
{
	adiv5_mem_write(cortexm_ap(t), dest, src, len);
}

static bool cortexm_check_error(target *t)
{
 800182c:	b508      	push	{r3, lr}
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 800182e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
}

static bool cortexm_check_error(target *t)
{
	ADIv5_AP_t *ap = cortexm_ap(t);
	return adiv5_dp_error(ap->dp) != 0;
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	6858      	ldr	r0, [r3, #4]
	return dp->dp_read(dp, addr);
}

static inline uint32_t adiv5_dp_error(ADIv5_DP_t *dp)
{
	return dp->error(dp);
 8001834:	68c3      	ldr	r3, [r0, #12]
 8001836:	4798      	blx	r3
 8001838:	1e43      	subs	r3, r0, #1
 800183a:	4198      	sbcs	r0, r3
 800183c:	b2c0      	uxtb	r0, r0
}
 800183e:	bd08      	pop	{r3, pc}

08001840 <cortexm_vector_catch>:

	return target_mem_read32(t, CORTEXM_DWT_COMP(i));
}

static bool cortexm_vector_catch(target *t, int argc, char *argv[])
{
 8001840:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct cortexm_priv *priv = t->priv;
	const char *vectors[] = {"reset", NULL, NULL, NULL, "mm", "nocp",
 8001842:	4b34      	ldr	r3, [pc, #208]	; (8001914 <cortexm_vector_catch+0xd4>)

	return target_mem_read32(t, CORTEXM_DWT_COMP(i));
}

static bool cortexm_vector_catch(target *t, int argc, char *argv[])
{
 8001844:	b091      	sub	sp, #68	; 0x44
 8001846:	1c05      	adds	r5, r0, #0
	struct cortexm_priv *priv = t->priv;
 8001848:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
	const char *vectors[] = {"reset", NULL, NULL, NULL, "mm", "nocp",
 800184a:	a805      	add	r0, sp, #20

	return target_mem_read32(t, CORTEXM_DWT_COMP(i));
}

static bool cortexm_vector_catch(target *t, int argc, char *argv[])
{
 800184c:	4694      	mov	ip, r2
	struct cortexm_priv *priv = t->priv;
	const char *vectors[] = {"reset", NULL, NULL, NULL, "mm", "nocp",
 800184e:	cb94      	ldmia	r3!, {r2, r4, r7}
 8001850:	c094      	stmia	r0!, {r2, r4, r7}
 8001852:	cb94      	ldmia	r3!, {r2, r4, r7}
 8001854:	c094      	stmia	r0!, {r2, r4, r7}
 8001856:	cb94      	ldmia	r3!, {r2, r4, r7}
 8001858:	c094      	stmia	r0!, {r2, r4, r7}
 800185a:	cb14      	ldmia	r3!, {r2, r4}
 800185c:	c014      	stmia	r0!, {r2, r4}
				"chk", "stat", "bus", "int", "hard"};
	uint32_t tmp = 0;
	unsigned i;

	if ((argc < 3) || ((argv[1][0] != 'e') && (argv[1][0] != 'd'))) {
 800185e:	2902      	cmp	r1, #2
 8001860:	dd0d      	ble.n	800187e <cortexm_vector_catch+0x3e>
 8001862:	4663      	mov	r3, ip
 8001864:	685b      	ldr	r3, [r3, #4]
 8001866:	781b      	ldrb	r3, [r3, #0]
 8001868:	9302      	str	r3, [sp, #8]
 800186a:	3b64      	subs	r3, #100	; 0x64
 800186c:	2b01      	cmp	r3, #1
 800186e:	d806      	bhi.n	800187e <cortexm_vector_catch+0x3e>
 8001870:	4664      	mov	r4, ip
 8001872:	0089      	lsls	r1, r1, #2
 8001874:	1863      	adds	r3, r4, r1
 8001876:	9303      	str	r3, [sp, #12]
 8001878:	2300      	movs	r3, #0
 800187a:	9301      	str	r3, [sp, #4]
 800187c:	e010      	b.n	80018a0 <cortexm_vector_catch+0x60>
		tc_printf(t, "usage: monitor vector_catch (enable|disable) "
 800187e:	1c28      	adds	r0, r5, #0
 8001880:	4925      	ldr	r1, [pc, #148]	; (8001918 <cortexm_vector_catch+0xd8>)
 8001882:	f006 feb2 	bl	80085ea <tc_printf>
 8001886:	e027      	b.n	80018d8 <cortexm_vector_catch+0x98>
 8001888:	00bb      	lsls	r3, r7, #2
			     "(hard|int|bus|stat|chk|nocp|mm|reset)\n");
	} else {
		for (int j = 0; j < argc; j++)
			for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
				if (vectors[i] && !strcmp(vectors[i], argv[j]))
 800188a:	aa05      	add	r2, sp, #20
 800188c:	5898      	ldr	r0, [r3, r2]
 800188e:	2800      	cmp	r0, #0
 8001890:	d108      	bne.n	80018a4 <cortexm_vector_catch+0x64>
	if ((argc < 3) || ((argv[1][0] != 'e') && (argv[1][0] != 'd'))) {
		tc_printf(t, "usage: monitor vector_catch (enable|disable) "
			     "(hard|int|bus|stat|chk|nocp|mm|reset)\n");
	} else {
		for (int j = 0; j < argc; j++)
			for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
 8001892:	3701      	adds	r7, #1
 8001894:	2f0b      	cmp	r7, #11
 8001896:	d1f7      	bne.n	8001888 <cortexm_vector_catch+0x48>

	if ((argc < 3) || ((argv[1][0] != 'e') && (argv[1][0] != 'd'))) {
		tc_printf(t, "usage: monitor vector_catch (enable|disable) "
			     "(hard|int|bus|stat|chk|nocp|mm|reset)\n");
	} else {
		for (int j = 0; j < argc; j++)
 8001898:	9b03      	ldr	r3, [sp, #12]
 800189a:	3404      	adds	r4, #4
 800189c:	429c      	cmp	r4, r3
 800189e:	d00c      	beq.n	80018ba <cortexm_vector_catch+0x7a>

	return target_mem_read32(t, CORTEXM_DWT_COMP(i));
}

static bool cortexm_vector_catch(target *t, int argc, char *argv[])
{
 80018a0:	2700      	movs	r7, #0
 80018a2:	e7f1      	b.n	8001888 <cortexm_vector_catch+0x48>
		tc_printf(t, "usage: monitor vector_catch (enable|disable) "
			     "(hard|int|bus|stat|chk|nocp|mm|reset)\n");
	} else {
		for (int j = 0; j < argc; j++)
			for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
				if (vectors[i] && !strcmp(vectors[i], argv[j]))
 80018a4:	6821      	ldr	r1, [r4, #0]
 80018a6:	f00b fab5 	bl	800ce14 <strcmp>
 80018aa:	2800      	cmp	r0, #0
 80018ac:	d1f1      	bne.n	8001892 <cortexm_vector_catch+0x52>
					tmp |= 1 << i;
 80018ae:	2301      	movs	r3, #1
 80018b0:	40bb      	lsls	r3, r7
 80018b2:	9a01      	ldr	r2, [sp, #4]
 80018b4:	431a      	orrs	r2, r3
 80018b6:	9201      	str	r2, [sp, #4]
 80018b8:	e7eb      	b.n	8001892 <cortexm_vector_catch+0x52>
			}

		if (argv[1][0] == 'e')
 80018ba:	9a02      	ldr	r2, [sp, #8]
 80018bc:	6a33      	ldr	r3, [r6, #32]
 80018be:	2a65      	cmp	r2, #101	; 0x65
 80018c0:	d102      	bne.n	80018c8 <cortexm_vector_catch+0x88>
			priv->demcr |= tmp;
 80018c2:	9a01      	ldr	r2, [sp, #4]
 80018c4:	4313      	orrs	r3, r2
 80018c6:	e001      	b.n	80018cc <cortexm_vector_catch+0x8c>
		else
			priv->demcr &= ~tmp;
 80018c8:	9a01      	ldr	r2, [sp, #4]
 80018ca:	4393      	bics	r3, r2
 80018cc:	6233      	str	r3, [r6, #32]

		target_mem_write32(t, CORTEXM_DEMCR, priv->demcr);
 80018ce:	1c28      	adds	r0, r5, #0
 80018d0:	4912      	ldr	r1, [pc, #72]	; (800191c <cortexm_vector_catch+0xdc>)
 80018d2:	6a32      	ldr	r2, [r6, #32]
 80018d4:	f006 fe32 	bl	800853c <target_mem_write32>
	}

	tc_printf(t, "Catching vectors: ");
 80018d8:	1c28      	adds	r0, r5, #0
 80018da:	4911      	ldr	r1, [pc, #68]	; (8001920 <cortexm_vector_catch+0xe0>)
 80018dc:	f006 fe85 	bl	80085ea <tc_printf>
	for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
 80018e0:	2400      	movs	r4, #0
 80018e2:	00a3      	lsls	r3, r4, #2
		if (!vectors[i])
 80018e4:	aa05      	add	r2, sp, #20
 80018e6:	58d2      	ldr	r2, [r2, r3]
 80018e8:	2a00      	cmp	r2, #0
 80018ea:	d008      	beq.n	80018fe <cortexm_vector_catch+0xbe>
			continue;
		if (priv->demcr & (1 << i))
 80018ec:	2301      	movs	r3, #1
 80018ee:	40a3      	lsls	r3, r4
 80018f0:	6a31      	ldr	r1, [r6, #32]
 80018f2:	4219      	tst	r1, r3
 80018f4:	d003      	beq.n	80018fe <cortexm_vector_catch+0xbe>
			tc_printf(t, "%s ", vectors[i]);
 80018f6:	1c28      	adds	r0, r5, #0
 80018f8:	490a      	ldr	r1, [pc, #40]	; (8001924 <cortexm_vector_catch+0xe4>)
 80018fa:	f006 fe76 	bl	80085ea <tc_printf>

		target_mem_write32(t, CORTEXM_DEMCR, priv->demcr);
	}

	tc_printf(t, "Catching vectors: ");
	for (i = 0; i < sizeof(vectors) / sizeof(char*); i++) {
 80018fe:	3401      	adds	r4, #1
 8001900:	2c0b      	cmp	r4, #11
 8001902:	d1ee      	bne.n	80018e2 <cortexm_vector_catch+0xa2>
		if (!vectors[i])
			continue;
		if (priv->demcr & (1 << i))
			tc_printf(t, "%s ", vectors[i]);
	}
	tc_printf(t, "\n");
 8001904:	1c28      	adds	r0, r5, #0
 8001906:	4908      	ldr	r1, [pc, #32]	; (8001928 <cortexm_vector_catch+0xe8>)
 8001908:	f006 fe6f 	bl	80085ea <tc_printf>
	return true;
}
 800190c:	2001      	movs	r0, #1
 800190e:	b011      	add	sp, #68	; 0x44
 8001910:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001912:	46c0      	nop			; (mov r8, r8)
 8001914:	0801063c 	.word	0x0801063c
 8001918:	08011258 	.word	0x08011258
 800191c:	e000edfc 	.word	0xe000edfc
 8001920:	080112ac 	.word	0x080112ac
 8001924:	080112bf 	.word	0x080112bf
 8001928:	0800fc8c 	.word	0x0800fc8c

0800192c <cortexm_breakwatch_clear>:
		return 1;
	}
}

static int cortexm_breakwatch_clear(target *t, struct breakwatch *bw)
{
 800192c:	b510      	push	{r4, lr}
	struct cortexm_priv *priv = t->priv;
	unsigned i = bw->reserved[0];
 800192e:	690b      	ldr	r3, [r1, #16]
	switch (bw->type) {
 8001930:	7909      	ldrb	r1, [r1, #4]
	}
}

static int cortexm_breakwatch_clear(target *t, struct breakwatch *bw)
{
	struct cortexm_priv *priv = t->priv;
 8001932:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
	unsigned i = bw->reserved[0];
	switch (bw->type) {
 8001934:	2901      	cmp	r1, #1
 8001936:	d00a      	beq.n	800194e <cortexm_breakwatch_clear+0x22>
 8001938:	2900      	cmp	r1, #0
 800193a:	d013      	beq.n	8001964 <cortexm_breakwatch_clear+0x38>
 800193c:	2904      	cmp	r1, #4
 800193e:	d811      	bhi.n	8001964 <cortexm_breakwatch_clear+0x38>
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
		return 0;
	case TARGET_WATCH_WRITE:
	case TARGET_WATCH_READ:
	case TARGET_WATCH_ACCESS:
		priv->hw_watchpoint[i] = false;
 8001940:	2400      	movs	r4, #0
 8001942:	18d2      	adds	r2, r2, r3
 8001944:	7194      	strb	r4, [r2, #6]
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
 8001946:	4a08      	ldr	r2, [pc, #32]	; (8001968 <cortexm_breakwatch_clear+0x3c>)
 8001948:	011b      	lsls	r3, r3, #4
 800194a:	1899      	adds	r1, r3, r2
 800194c:	e005      	b.n	800195a <cortexm_breakwatch_clear+0x2e>
{
	struct cortexm_priv *priv = t->priv;
	unsigned i = bw->reserved[0];
	switch (bw->type) {
	case TARGET_BREAK_HARD:
		priv->hw_breakpoint[i] = false;
 800194e:	2400      	movs	r4, #0
 8001950:	18d2      	adds	r2, r2, r3
 8001952:	7514      	strb	r4, [r2, #20]
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
 8001954:	4a05      	ldr	r2, [pc, #20]	; (800196c <cortexm_breakwatch_clear+0x40>)
 8001956:	1899      	adds	r1, r3, r2
 8001958:	0089      	lsls	r1, r1, #2
		return 0;
	case TARGET_WATCH_WRITE:
	case TARGET_WATCH_READ:
	case TARGET_WATCH_ACCESS:
		priv->hw_watchpoint[i] = false;
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
 800195a:	1c22      	adds	r2, r4, #0
 800195c:	f006 fdee 	bl	800853c <target_mem_write32>
		return 0;
 8001960:	1c20      	adds	r0, r4, #0
 8001962:	e000      	b.n	8001966 <cortexm_breakwatch_clear+0x3a>
	default:
		return 1;
 8001964:	2001      	movs	r0, #1
	}
}
 8001966:	bd10      	pop	{r4, pc}
 8001968:	e0001028 	.word	0xe0001028
 800196c:	38000802 	.word	0x38000802

08001970 <cortexm_detach>:

	return true;
}

void cortexm_detach(target *t)
{
 8001970:	b570      	push	{r4, r5, r6, lr}
 8001972:	1c04      	adds	r4, r0, #0
	struct cortexm_priv *priv = t->priv;
	unsigned i;

	/* Clear any stale breakpoints */
	for(i = 0; i < priv->hw_breakpoint_max; i++)
 8001974:	2500      	movs	r5, #0
	return true;
}

void cortexm_detach(target *t)
{
	struct cortexm_priv *priv = t->priv;
 8001976:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
	unsigned i;

	/* Clear any stale breakpoints */
	for(i = 0; i < priv->hw_breakpoint_max; i++)
 8001978:	69f3      	ldr	r3, [r6, #28]
 800197a:	429d      	cmp	r5, r3
 800197c:	d208      	bcs.n	8001990 <cortexm_detach+0x20>
 800197e:	4b0e      	ldr	r3, [pc, #56]	; (80019b8 <cortexm_detach+0x48>)
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
 8001980:	1c20      	adds	r0, r4, #0
 8001982:	18e9      	adds	r1, r5, r3
 8001984:	0089      	lsls	r1, r1, #2
 8001986:	2200      	movs	r2, #0
 8001988:	f006 fdd8 	bl	800853c <target_mem_write32>
{
	struct cortexm_priv *priv = t->priv;
	unsigned i;

	/* Clear any stale breakpoints */
	for(i = 0; i < priv->hw_breakpoint_max; i++)
 800198c:	3501      	adds	r5, #1
 800198e:	e7f3      	b.n	8001978 <cortexm_detach+0x8>
 8001990:	2500      	movs	r5, #0
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);

	/* Clear any stale watchpoints */
	for(i = 0; i < priv->hw_watchpoint_max; i++)
 8001992:	6933      	ldr	r3, [r6, #16]
 8001994:	429d      	cmp	r5, r3
 8001996:	d208      	bcs.n	80019aa <cortexm_detach+0x3a>
 8001998:	4b08      	ldr	r3, [pc, #32]	; (80019bc <cortexm_detach+0x4c>)
 800199a:	0129      	lsls	r1, r5, #4
 800199c:	18c9      	adds	r1, r1, r3
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
 800199e:	1c20      	adds	r0, r4, #0
 80019a0:	2200      	movs	r2, #0
 80019a2:	f006 fdcb 	bl	800853c <target_mem_write32>
	/* Clear any stale breakpoints */
	for(i = 0; i < priv->hw_breakpoint_max; i++)
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);

	/* Clear any stale watchpoints */
	for(i = 0; i < priv->hw_watchpoint_max; i++)
 80019a6:	3501      	adds	r5, #1
 80019a8:	e7f3      	b.n	8001992 <cortexm_detach+0x22>
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);

	/* Disable debug */
	target_mem_write32(t, CORTEXM_DHCSR, CORTEXM_DHCSR_DBGKEY);
 80019aa:	1c20      	adds	r0, r4, #0
 80019ac:	4904      	ldr	r1, [pc, #16]	; (80019c0 <cortexm_detach+0x50>)
 80019ae:	4a05      	ldr	r2, [pc, #20]	; (80019c4 <cortexm_detach+0x54>)
 80019b0:	f006 fdc4 	bl	800853c <target_mem_write32>
}
 80019b4:	bd70      	pop	{r4, r5, r6, pc}
 80019b6:	46c0      	nop			; (mov r8, r8)
 80019b8:	38000802 	.word	0x38000802
 80019bc:	e0001028 	.word	0xe0001028
 80019c0:	e000edf0 	.word	0xe000edf0
 80019c4:	a05f0000 	.word	0xa05f0000

080019c8 <cortexm_pc_read>:
			                    0x10000 | regnum_cortex_mf[i]);
		}
}

static uint32_t cortexm_pc_read(target *t)
{
 80019c8:	b510      	push	{r4, lr}
 80019ca:	1c04      	adds	r4, r0, #0
	target_mem_write32(t, CORTEXM_DCRSR, 0x0F);
 80019cc:	220f      	movs	r2, #15
 80019ce:	4904      	ldr	r1, [pc, #16]	; (80019e0 <cortexm_pc_read+0x18>)
 80019d0:	f006 fdb4 	bl	800853c <target_mem_write32>
	return target_mem_read32(t, CORTEXM_DCRDR);
 80019d4:	1c20      	adds	r0, r4, #0
 80019d6:	4903      	ldr	r1, [pc, #12]	; (80019e4 <cortexm_pc_read+0x1c>)
 80019d8:	f006 fda8 	bl	800852c <target_mem_read32>
}
 80019dc:	bd10      	pop	{r4, pc}
 80019de:	46c0      	nop			; (mov r8, r8)
 80019e0:	e000edf4 	.word	0xe000edf4
 80019e4:	e000edf8 	.word	0xe000edf8

080019e8 <cortexm_halt_request>:
}

static void cortexm_halt_request(target *t)
{
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 80019e8:	2200      	movs	r2, #0
	/* Reset DFSR flags */
	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
}

static void cortexm_halt_request(target *t)
{
 80019ea:	b530      	push	{r4, r5, lr}
 80019ec:	b09f      	sub	sp, #124	; 0x7c
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 80019ee:	9203      	str	r2, [sp, #12]
 80019f0:	3202      	adds	r2, #2
 80019f2:	9205      	str	r2, [sp, #20]
 80019f4:	4a10      	ldr	r2, [pc, #64]	; (8001a38 <cortexm_halt_request+0x50>)
	/* Reset DFSR flags */
	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
}

static void cortexm_halt_request(target *t)
{
 80019f6:	9001      	str	r0, [sp, #4]
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 80019f8:	6811      	ldr	r1, [r2, #0]
 80019fa:	ab03      	add	r3, sp, #12
 80019fc:	a806      	add	r0, sp, #24
 80019fe:	911d      	str	r1, [sp, #116]	; 0x74
 8001a00:	6013      	str	r3, [r2, #0]
 8001a02:	f00b f8d7 	bl	800cbb4 <setjmp>
 8001a06:	2800      	cmp	r0, #0
 8001a08:	d007      	beq.n	8001a1a <cortexm_halt_request+0x32>
		target_mem_write32(t, CORTEXM_DHCSR, CORTEXM_DHCSR_DBGKEY |
		                                          CORTEXM_DHCSR_C_HALT |
		                                          CORTEXM_DHCSR_C_DEBUGEN);
	}
	if (e.type) {
 8001a0a:	9b03      	ldr	r3, [sp, #12]
 8001a0c:	2b00      	cmp	r3, #0
 8001a0e:	d011      	beq.n	8001a34 <cortexm_halt_request+0x4c>
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
 8001a10:	9801      	ldr	r0, [sp, #4]
 8001a12:	490a      	ldr	r1, [pc, #40]	; (8001a3c <cortexm_halt_request+0x54>)
 8001a14:	f006 fde9 	bl	80085ea <tc_printf>
 8001a18:	e00c      	b.n	8001a34 <cortexm_halt_request+0x4c>
}

static void cortexm_halt_request(target *t)
{
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8001a1a:	4d07      	ldr	r5, [pc, #28]	; (8001a38 <cortexm_halt_request+0x50>)
 8001a1c:	ab03      	add	r3, sp, #12
 8001a1e:	682c      	ldr	r4, [r5, #0]
 8001a20:	429c      	cmp	r4, r3
 8001a22:	d1f2      	bne.n	8001a0a <cortexm_halt_request+0x22>
		target_mem_write32(t, CORTEXM_DHCSR, CORTEXM_DHCSR_DBGKEY |
 8001a24:	9801      	ldr	r0, [sp, #4]
 8001a26:	4906      	ldr	r1, [pc, #24]	; (8001a40 <cortexm_halt_request+0x58>)
 8001a28:	4a06      	ldr	r2, [pc, #24]	; (8001a44 <cortexm_halt_request+0x5c>)
 8001a2a:	f006 fd87 	bl	800853c <target_mem_write32>
}

static void cortexm_halt_request(target *t)
{
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_TIMEOUT) {
 8001a2e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8001a30:	602b      	str	r3, [r5, #0]
 8001a32:	e7f2      	b.n	8001a1a <cortexm_halt_request+0x32>
		                                          CORTEXM_DHCSR_C_DEBUGEN);
	}
	if (e.type) {
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}
 8001a34:	b01f      	add	sp, #124	; 0x7c
 8001a36:	bd30      	pop	{r4, r5, pc}
 8001a38:	20001dc4 	.word	0x20001dc4
 8001a3c:	080105b2 	.word	0x080105b2
 8001a40:	e000edf0 	.word	0xe000edf0
 8001a44:	a05f0003 	.word	0xa05f0003

08001a48 <cortexm_halt_resume>:

	return TARGET_HALT_BREAKPOINT;
}

void cortexm_halt_resume(target *t, bool step)
{
 8001a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a4a:	1c04      	adds	r4, r0, #0
 8001a4c:	1e0f      	subs	r7, r1, #0
	struct cortexm_priv *priv = t->priv;
 8001a4e:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
	uint32_t dhcsr = CORTEXM_DHCSR_DBGKEY | CORTEXM_DHCSR_C_DEBUGEN;

	if (step)
 8001a50:	d001      	beq.n	8001a56 <cortexm_halt_resume+0xe>
		dhcsr |= CORTEXM_DHCSR_C_STEP | CORTEXM_DHCSR_C_MASKINTS;
 8001a52:	4e17      	ldr	r6, [pc, #92]	; (8001ab0 <cortexm_halt_resume+0x68>)
 8001a54:	e000      	b.n	8001a58 <cortexm_halt_resume+0x10>
}

void cortexm_halt_resume(target *t, bool step)
{
	struct cortexm_priv *priv = t->priv;
	uint32_t dhcsr = CORTEXM_DHCSR_DBGKEY | CORTEXM_DHCSR_C_DEBUGEN;
 8001a56:	4e17      	ldr	r6, [pc, #92]	; (8001ab4 <cortexm_halt_resume+0x6c>)

	if (step)
		dhcsr |= CORTEXM_DHCSR_C_STEP | CORTEXM_DHCSR_C_MASKINTS;

	/* Disable interrupts while single stepping... */
	if(step != priv->stepping) {
 8001a58:	792b      	ldrb	r3, [r5, #4]
 8001a5a:	42bb      	cmp	r3, r7
 8001a5c:	d006      	beq.n	8001a6c <cortexm_halt_resume+0x24>
		target_mem_write32(t, CORTEXM_DHCSR, dhcsr | CORTEXM_DHCSR_C_HALT);
 8001a5e:	2202      	movs	r2, #2
 8001a60:	1c20      	adds	r0, r4, #0
 8001a62:	4332      	orrs	r2, r6
 8001a64:	4914      	ldr	r1, [pc, #80]	; (8001ab8 <cortexm_halt_resume+0x70>)
 8001a66:	f006 fd69 	bl	800853c <target_mem_write32>
		priv->stepping = step;
 8001a6a:	712f      	strb	r7, [r5, #4]
	}

	if (priv->on_bkpt) {
 8001a6c:	796b      	ldrb	r3, [r5, #5]
 8001a6e:	2b00      	cmp	r3, #0
 8001a70:	d018      	beq.n	8001aa4 <cortexm_halt_resume+0x5c>
		uint32_t pc = cortexm_pc_read(t);
 8001a72:	1c20      	adds	r0, r4, #0
 8001a74:	f7ff ffa8 	bl	80019c8 <cortexm_pc_read>
 8001a78:	1c05      	adds	r5, r0, #0
		if ((target_mem_read16(t, pc) & 0xFF00) == 0xBE00)
 8001a7a:	1c20      	adds	r0, r4, #0
 8001a7c:	1c29      	adds	r1, r5, #0
 8001a7e:	f006 fd64 	bl	800854a <target_mem_read16>
 8001a82:	23ff      	movs	r3, #255	; 0xff
 8001a84:	021b      	lsls	r3, r3, #8
 8001a86:	4018      	ands	r0, r3
 8001a88:	23be      	movs	r3, #190	; 0xbe
 8001a8a:	021b      	lsls	r3, r3, #8
 8001a8c:	4298      	cmp	r0, r3
 8001a8e:	d109      	bne.n	8001aa4 <cortexm_halt_resume+0x5c>
			cortexm_pc_write(t, pc + 2);
 8001a90:	1caa      	adds	r2, r5, #2
	return target_mem_read32(t, CORTEXM_DCRDR);
}

static void cortexm_pc_write(target *t, const uint32_t val)
{
	target_mem_write32(t, CORTEXM_DCRDR, val);
 8001a92:	1c20      	adds	r0, r4, #0
 8001a94:	4909      	ldr	r1, [pc, #36]	; (8001abc <cortexm_halt_resume+0x74>)
 8001a96:	f006 fd51 	bl	800853c <target_mem_write32>
	target_mem_write32(t, CORTEXM_DCRSR, CORTEXM_DCRSR_REGWnR | 0x0F);
 8001a9a:	1c20      	adds	r0, r4, #0
 8001a9c:	4908      	ldr	r1, [pc, #32]	; (8001ac0 <cortexm_halt_resume+0x78>)
 8001a9e:	4a09      	ldr	r2, [pc, #36]	; (8001ac4 <cortexm_halt_resume+0x7c>)
 8001aa0:	f006 fd4c 	bl	800853c <target_mem_write32>
		uint32_t pc = cortexm_pc_read(t);
		if ((target_mem_read16(t, pc) & 0xFF00) == 0xBE00)
			cortexm_pc_write(t, pc + 2);
	}

	target_mem_write32(t, CORTEXM_DHCSR, dhcsr);
 8001aa4:	1c32      	adds	r2, r6, #0
 8001aa6:	1c20      	adds	r0, r4, #0
 8001aa8:	4903      	ldr	r1, [pc, #12]	; (8001ab8 <cortexm_halt_resume+0x70>)
 8001aaa:	f006 fd47 	bl	800853c <target_mem_write32>
}
 8001aae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001ab0:	a05f000d 	.word	0xa05f000d
 8001ab4:	a05f0001 	.word	0xa05f0001
 8001ab8:	e000edf0 	.word	0xe000edf0
 8001abc:	e000edf8 	.word	0xe000edf8
 8001ac0:	e000edf4 	.word	0xe000edf4
 8001ac4:	0001000f 	.word	0x0001000f

08001ac8 <cortexm_halt_poll>:
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}

static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
{
 8001ac8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001aca:	b0c7      	sub	sp, #284	; 0x11c
 8001acc:	af02      	add	r7, sp, #8
	struct cortexm_priv *priv = t->priv;
 8001ace:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}

static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
{
 8001ad0:	63f9      	str	r1, [r7, #60]	; 0x3c
	struct cortexm_priv *priv = t->priv;

	volatile uint32_t dhcsr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001ad2:	2150      	movs	r1, #80	; 0x50
	}
}

static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
{
	struct cortexm_priv *priv = t->priv;
 8001ad4:	647b      	str	r3, [r7, #68]	; 0x44

	volatile uint32_t dhcsr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001ad6:	2354      	movs	r3, #84	; 0x54
 8001ad8:	1879      	adds	r1, r7, r1
 8001ada:	18cb      	adds	r3, r1, r3
 8001adc:	21a4      	movs	r1, #164	; 0xa4

static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
{
	struct cortexm_priv *priv = t->priv;

	volatile uint32_t dhcsr = 0;
 8001ade:	2200      	movs	r2, #0
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001ae0:	1879      	adds	r1, r7, r1

static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
{
	struct cortexm_priv *priv = t->priv;

	volatile uint32_t dhcsr = 0;
 8001ae2:	657a      	str	r2, [r7, #84]	; 0x54
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001ae4:	600a      	str	r2, [r1, #0]
 8001ae6:	3a01      	subs	r2, #1
 8001ae8:	609a      	str	r2, [r3, #8]
 8001aea:	4ad0      	ldr	r2, [pc, #832]	; (8001e2c <cortexm_halt_poll+0x364>)
		tc_printf(t, "Timeout sending interrupt, is target in WFI?\n");
	}
}

static enum target_halt_reason cortexm_halt_poll(target *t, target_addr *watch)
{
 8001aec:	64f8      	str	r0, [r7, #76]	; 0x4c
	struct cortexm_priv *priv = t->priv;

	volatile uint32_t dhcsr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001aee:	6811      	ldr	r1, [r2, #0]
 8001af0:	6013      	str	r3, [r2, #0]
 8001af2:	2250      	movs	r2, #80	; 0x50
 8001af4:	6699      	str	r1, [r3, #104]	; 0x68
 8001af6:	2360      	movs	r3, #96	; 0x60
 8001af8:	18ba      	adds	r2, r7, r2
 8001afa:	18d0      	adds	r0, r2, r3
 8001afc:	f00b f85a 	bl	800cbb4 <setjmp>
 8001b00:	2800      	cmp	r0, #0
 8001b02:	d009      	beq.n	8001b18 <cortexm_halt_poll+0x50>
		/* If this times out because the target is in WFI then
		 * the target is still running. */
		dhcsr = target_mem_read32(t, CORTEXM_DHCSR);
	}
	switch (e.type) {
 8001b04:	23a4      	movs	r3, #164	; 0xa4
 8001b06:	18fb      	adds	r3, r7, r3
 8001b08:	681c      	ldr	r4, [r3, #0]
 8001b0a:	2c01      	cmp	r4, #1
 8001b0c:	d014      	beq.n	8001b38 <cortexm_halt_poll+0x70>
		/* Oh crap, there's no recovery from this... */
		target_list_free();
		return TARGET_HALT_ERROR;
	case EXCEPTION_TIMEOUT:
		/* Timeout isn't a problem, target could be in WFI */
		return TARGET_HALT_RUNNING;
 8001b0e:	2000      	movs	r0, #0
	TRY_CATCH (e, EXCEPTION_ALL) {
		/* If this times out because the target is in WFI then
		 * the target is still running. */
		dhcsr = target_mem_read32(t, CORTEXM_DHCSR);
	}
	switch (e.type) {
 8001b10:	2c02      	cmp	r4, #2
 8001b12:	d100      	bne.n	8001b16 <cortexm_halt_poll+0x4e>
 8001b14:	e1eb      	b.n	8001eee <cortexm_halt_poll+0x426>
 8001b16:	e013      	b.n	8001b40 <cortexm_halt_poll+0x78>
{
	struct cortexm_priv *priv = t->priv;

	volatile uint32_t dhcsr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001b18:	2250      	movs	r2, #80	; 0x50
 8001b1a:	2354      	movs	r3, #84	; 0x54
 8001b1c:	4dc3      	ldr	r5, [pc, #780]	; (8001e2c <cortexm_halt_poll+0x364>)
 8001b1e:	18ba      	adds	r2, r7, r2
 8001b20:	682c      	ldr	r4, [r5, #0]
 8001b22:	18d3      	adds	r3, r2, r3
 8001b24:	429c      	cmp	r4, r3
 8001b26:	d1ed      	bne.n	8001b04 <cortexm_halt_poll+0x3c>
		/* If this times out because the target is in WFI then
		 * the target is still running. */
		dhcsr = target_mem_read32(t, CORTEXM_DHCSR);
 8001b28:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b2a:	49c1      	ldr	r1, [pc, #772]	; (8001e30 <cortexm_halt_poll+0x368>)
 8001b2c:	f006 fcfe 	bl	800852c <target_mem_read32>
 8001b30:	6578      	str	r0, [r7, #84]	; 0x54
{
	struct cortexm_priv *priv = t->priv;

	volatile uint32_t dhcsr = 0;
	volatile struct exception e;
	TRY_CATCH (e, EXCEPTION_ALL) {
 8001b32:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8001b34:	602b      	str	r3, [r5, #0]
 8001b36:	e7ef      	b.n	8001b18 <cortexm_halt_poll+0x50>
		dhcsr = target_mem_read32(t, CORTEXM_DHCSR);
	}
	switch (e.type) {
	case EXCEPTION_ERROR:
		/* Oh crap, there's no recovery from this... */
		target_list_free();
 8001b38:	f006 fa6e 	bl	8008018 <target_list_free>
		return TARGET_HALT_ERROR;
 8001b3c:	1c20      	adds	r0, r4, #0
 8001b3e:	e1d6      	b.n	8001eee <cortexm_halt_poll+0x426>
	case EXCEPTION_TIMEOUT:
		/* Timeout isn't a problem, target could be in WFI */
		return TARGET_HALT_RUNNING;
	}

	if (!(dhcsr & CORTEXM_DHCSR_S_HALT))
 8001b40:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001b42:	039b      	lsls	r3, r3, #14
 8001b44:	d401      	bmi.n	8001b4a <cortexm_halt_poll+0x82>
		return TARGET_HALT_RUNNING;
 8001b46:	2000      	movs	r0, #0
 8001b48:	e1d1      	b.n	8001eee <cortexm_halt_poll+0x426>

	/* We've halted.  Let's find out why. */
	uint32_t dfsr = target_mem_read32(t, CORTEXM_DFSR);
 8001b4a:	4cba      	ldr	r4, [pc, #744]	; (8001e34 <cortexm_halt_poll+0x36c>)
 8001b4c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b4e:	1c21      	adds	r1, r4, #0
 8001b50:	f006 fcec 	bl	800852c <target_mem_read32>
 8001b54:	64b8      	str	r0, [r7, #72]	; 0x48
	target_mem_write32(t, CORTEXM_DFSR, dfsr); /* write back to reset */
 8001b56:	1c21      	adds	r1, r4, #0
 8001b58:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b5a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8001b5c:	f006 fcee 	bl	800853c <target_mem_write32>

	if ((dfsr & CORTEXM_DFSR_VCATCH) && cortexm_fault_unwind(t))
 8001b60:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001b62:	071b      	lsls	r3, r3, #28
 8001b64:	d407      	bmi.n	8001b76 <cortexm_halt_poll+0xae>
		return TARGET_HALT_FAULT;

	/* Remember if we stopped on a breakpoint */
	priv->on_bkpt = dfsr & (CORTEXM_DFSR_BKPT);
 8001b66:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001b68:	079c      	lsls	r4, r3, #30
 8001b6a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001b6c:	0fe4      	lsrs	r4, r4, #31
 8001b6e:	715c      	strb	r4, [r3, #5]
	if (priv->on_bkpt) {
 8001b70:	d100      	bne.n	8001b74 <cortexm_halt_poll+0xac>
 8001b72:	e187      	b.n	8001e84 <cortexm_halt_poll+0x3bc>
 8001b74:	e07f      	b.n	8001c76 <cortexm_halt_poll+0x1ae>
	target_mem_write32(t, CORTEXM_DHCSR, dhcsr);
}

static int cortexm_fault_unwind(target *t)
{
	uint32_t hfsr = target_mem_read32(t, CORTEXM_HFSR);
 8001b76:	4eb0      	ldr	r6, [pc, #704]	; (8001e38 <cortexm_halt_poll+0x370>)
 8001b78:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b7a:	1c31      	adds	r1, r6, #0
 8001b7c:	f006 fcd6 	bl	800852c <target_mem_read32>
	uint32_t cfsr = target_mem_read32(t, CORTEXM_CFSR);
 8001b80:	4dae      	ldr	r5, [pc, #696]	; (8001e3c <cortexm_halt_poll+0x374>)
	target_mem_write32(t, CORTEXM_DHCSR, dhcsr);
}

static int cortexm_fault_unwind(target *t)
{
	uint32_t hfsr = target_mem_read32(t, CORTEXM_HFSR);
 8001b82:	1c04      	adds	r4, r0, #0
	uint32_t cfsr = target_mem_read32(t, CORTEXM_CFSR);
 8001b84:	1c29      	adds	r1, r5, #0
 8001b86:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b88:	f006 fcd0 	bl	800852c <target_mem_read32>
	target_mem_write32(t, CORTEXM_HFSR, hfsr);/* write back to reset */
 8001b8c:	1c22      	adds	r2, r4, #0
}

static int cortexm_fault_unwind(target *t)
{
	uint32_t hfsr = target_mem_read32(t, CORTEXM_HFSR);
	uint32_t cfsr = target_mem_read32(t, CORTEXM_CFSR);
 8001b8e:	6438      	str	r0, [r7, #64]	; 0x40
	target_mem_write32(t, CORTEXM_HFSR, hfsr);/* write back to reset */
 8001b90:	1c31      	adds	r1, r6, #0
 8001b92:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b94:	f006 fcd2 	bl	800853c <target_mem_write32>
	target_mem_write32(t, CORTEXM_CFSR, cfsr);/* write back to reset */
 8001b98:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001b9a:	1c29      	adds	r1, r5, #0
 8001b9c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8001b9e:	f006 fccd 	bl	800853c <target_mem_write32>
	/* We check for FORCED in the HardFault Status Register or
	 * for a configurable fault to avoid catching core resets */
	if((hfsr & CORTEXM_HFSR_FORCED) || cfsr) {
 8001ba2:	2380      	movs	r3, #128	; 0x80
 8001ba4:	05db      	lsls	r3, r3, #23
 8001ba6:	401c      	ands	r4, r3
 8001ba8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8001baa:	4323      	orrs	r3, r4
 8001bac:	d0db      	beq.n	8001b66 <cortexm_halt_poll+0x9e>
 8001bae:	466b      	mov	r3, sp
		/* Unwind exception */
		uint32_t regs[t->regs_size / 4];
 8001bb0:	466a      	mov	r2, sp
 8001bb2:	637b      	str	r3, [r7, #52]	; 0x34
 8001bb4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
		uint32_t stack[8];
		uint32_t retcode, framesize;
		/* Read registers for post-exception stack pointer */
		target_regs_read(t, regs);
 8001bb6:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
	target_mem_write32(t, CORTEXM_CFSR, cfsr);/* write back to reset */
	/* We check for FORCED in the HardFault Status Register or
	 * for a configurable fault to avoid catching core resets */
	if((hfsr & CORTEXM_HFSR_FORCED) || cfsr) {
		/* Unwind exception */
		uint32_t regs[t->regs_size / 4];
 8001bb8:	69db      	ldr	r3, [r3, #28]
 8001bba:	633b      	str	r3, [r7, #48]	; 0x30
 8001bbc:	089b      	lsrs	r3, r3, #2
 8001bbe:	009b      	lsls	r3, r3, #2
 8001bc0:	330a      	adds	r3, #10
 8001bc2:	08db      	lsrs	r3, r3, #3
 8001bc4:	00db      	lsls	r3, r3, #3
 8001bc6:	1ad3      	subs	r3, r2, r3
 8001bc8:	469d      	mov	sp, r3
 8001bca:	ac02      	add	r4, sp, #8
		uint32_t stack[8];
		uint32_t retcode, framesize;
		/* Read registers for post-exception stack pointer */
		target_regs_read(t, regs);
 8001bcc:	1c21      	adds	r1, r4, #0
 8001bce:	f006 fc39 	bl	8008444 <target_regs_read>
		/* save retcode currently in lr */
		retcode = regs[REG_LR];
 8001bd2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		bool spsel = retcode & (1<<2);
 8001bd4:	076e      	lsls	r6, r5, #29
 8001bd6:	0ff6      	lsrs	r6, r6, #31
		bool fpca = !(retcode & (1<<4));
		/* Read stack for pre-exception registers */
		uint32_t sp = spsel ? regs[REG_PSP] : regs[REG_MSP];
 8001bd8:	d001      	beq.n	8001bde <cortexm_halt_poll+0x116>
 8001bda:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001bdc:	e000      	b.n	8001be0 <cortexm_halt_poll+0x118>
 8001bde:	6c62      	ldr	r2, [r4, #68]	; 0x44
		target_mem_read(t, stack, sp, sizeof(stack));
 8001be0:	2150      	movs	r1, #80	; 0x50
 8001be2:	2334      	movs	r3, #52	; 0x34
 8001be4:	1879      	adds	r1, r7, r1
 8001be6:	18c9      	adds	r1, r1, r3
 8001be8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001bea:	3b14      	subs	r3, #20
 8001bec:	f006 fc1a 	bl	8008424 <target_mem_read>
		if (target_check_error(t))
 8001bf0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001bf2:	f006 fc11 	bl	8008418 <target_check_error>
			return 0;
 8001bf6:	2300      	movs	r3, #0
		bool spsel = retcode & (1<<2);
		bool fpca = !(retcode & (1<<4));
		/* Read stack for pre-exception registers */
		uint32_t sp = spsel ? regs[REG_PSP] : regs[REG_MSP];
		target_mem_read(t, stack, sp, sizeof(stack));
		if (target_check_error(t))
 8001bf8:	4298      	cmp	r0, r3
 8001bfa:	d135      	bne.n	8001c68 <cortexm_halt_poll+0x1a0>
			return 0;
		regs[REG_LR] = stack[5];	/* restore LR to pre-exception state */
 8001bfc:	3398      	adds	r3, #152	; 0x98
 8001bfe:	18fb      	adds	r3, r7, r3
 8001c00:	681b      	ldr	r3, [r3, #0]
		/* Read registers for post-exception stack pointer */
		target_regs_read(t, regs);
		/* save retcode currently in lr */
		retcode = regs[REG_LR];
		bool spsel = retcode & (1<<2);
		bool fpca = !(retcode & (1<<4));
 8001c02:	2201      	movs	r2, #1
		/* Read stack for pre-exception registers */
		uint32_t sp = spsel ? regs[REG_PSP] : regs[REG_MSP];
		target_mem_read(t, stack, sp, sizeof(stack));
		if (target_check_error(t))
			return 0;
		regs[REG_LR] = stack[5];	/* restore LR to pre-exception state */
 8001c04:	62fb      	str	r3, [r7, #44]	; 0x2c
 8001c06:	63a3      	str	r3, [r4, #56]	; 0x38
		regs[REG_PC] = stack[6];	/* restore PC to pre-exception state */
 8001c08:	239c      	movs	r3, #156	; 0x9c
 8001c0a:	18fb      	adds	r3, r7, r3
 8001c0c:	681b      	ldr	r3, [r3, #0]
		/* Read registers for post-exception stack pointer */
		target_regs_read(t, regs);
		/* save retcode currently in lr */
		retcode = regs[REG_LR];
		bool spsel = retcode & (1<<2);
		bool fpca = !(retcode & (1<<4));
 8001c0e:	092d      	lsrs	r5, r5, #4
		uint32_t sp = spsel ? regs[REG_PSP] : regs[REG_MSP];
		target_mem_read(t, stack, sp, sizeof(stack));
		if (target_check_error(t))
			return 0;
		regs[REG_LR] = stack[5];	/* restore LR to pre-exception state */
		regs[REG_PC] = stack[6];	/* restore PC to pre-exception state */
 8001c10:	63e3      	str	r3, [r4, #60]	; 0x3c
		/* Read registers for post-exception stack pointer */
		target_regs_read(t, regs);
		/* save retcode currently in lr */
		retcode = regs[REG_LR];
		bool spsel = retcode & (1<<2);
		bool fpca = !(retcode & (1<<4));
 8001c12:	43aa      	bics	r2, r5
			return 0;
		regs[REG_LR] = stack[5];	/* restore LR to pre-exception state */
		regs[REG_PC] = stack[6];	/* restore PC to pre-exception state */

		/* adjust stack to pop exception state */
		framesize = fpca ? 0x68 : 0x20;	/* check for basic vs. extended frame */
 8001c14:	2368      	movs	r3, #104	; 0x68
 8001c16:	2a00      	cmp	r2, #0
 8001c18:	d100      	bne.n	8001c1c <cortexm_halt_poll+0x154>
 8001c1a:	3b48      	subs	r3, #72	; 0x48
		if (stack[7] & (1<<9))				/* check for stack alignment fixup */
 8001c1c:	21a0      	movs	r1, #160	; 0xa0
 8001c1e:	1879      	adds	r1, r7, r1
 8001c20:	6809      	ldr	r1, [r1, #0]
 8001c22:	0589      	lsls	r1, r1, #22
 8001c24:	d500      	bpl.n	8001c28 <cortexm_halt_poll+0x160>
			framesize += 4;
 8001c26:	3304      	adds	r3, #4

		if (spsel) {
 8001c28:	2e00      	cmp	r6, #0
 8001c2a:	d008      	beq.n	8001c3e <cortexm_halt_poll+0x176>
			regs[REG_SPECIAL] |= 0x4000000;
 8001c2c:	2180      	movs	r1, #128	; 0x80
 8001c2e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8001c30:	04c9      	lsls	r1, r1, #19
 8001c32:	4301      	orrs	r1, r0
 8001c34:	64e1      	str	r1, [r4, #76]	; 0x4c
			regs[REG_SP] = regs[REG_PSP] += framesize;
 8001c36:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8001c38:	185b      	adds	r3, r3, r1
 8001c3a:	64a3      	str	r3, [r4, #72]	; 0x48
 8001c3c:	e002      	b.n	8001c44 <cortexm_halt_poll+0x17c>
		} else {
			regs[REG_SP] = regs[REG_MSP] += framesize;
 8001c3e:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8001c40:	185b      	adds	r3, r3, r1
 8001c42:	6463      	str	r3, [r4, #68]	; 0x44
 8001c44:	6363      	str	r3, [r4, #52]	; 0x34
		}

		if (fpca)
 8001c46:	2a00      	cmp	r2, #0
 8001c48:	d004      	beq.n	8001c54 <cortexm_halt_poll+0x18c>
			regs[REG_SPECIAL] |= 0x2000000;
 8001c4a:	2380      	movs	r3, #128	; 0x80
 8001c4c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8001c4e:	049b      	lsls	r3, r3, #18
 8001c50:	4313      	orrs	r3, r2
 8001c52:	64e3      	str	r3, [r4, #76]	; 0x4c
		/* although, if we caught the exception it will be unchanged */

		/* Reset exception state to allow resuming from restored
		 * state.
		 */
		target_mem_write32(t, CORTEXM_AIRCR,
 8001c54:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001c56:	497a      	ldr	r1, [pc, #488]	; (8001e40 <cortexm_halt_poll+0x378>)
 8001c58:	4a7a      	ldr	r2, [pc, #488]	; (8001e44 <cortexm_halt_poll+0x37c>)
 8001c5a:	f006 fc6f 	bl	800853c <target_mem_write32>
				CORTEXM_AIRCR_VECTKEY | CORTEXM_AIRCR_VECTCLRACTIVE);

		/* Write pre-exception registers back to core */
		target_regs_write(t, regs);
 8001c5e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001c60:	1c21      	adds	r1, r4, #0
 8001c62:	f006 fbf3 	bl	800844c <target_regs_write>

		return 1;
 8001c66:	2301      	movs	r3, #1
 8001c68:	6b7a      	ldr	r2, [r7, #52]	; 0x34
	/* We've halted.  Let's find out why. */
	uint32_t dfsr = target_mem_read32(t, CORTEXM_DFSR);
	target_mem_write32(t, CORTEXM_DFSR, dfsr); /* write back to reset */

	if ((dfsr & CORTEXM_DFSR_VCATCH) && cortexm_fault_unwind(t))
		return TARGET_HALT_FAULT;
 8001c6a:	2006      	movs	r0, #6
 8001c6c:	4695      	mov	sp, r2

	/* We've halted.  Let's find out why. */
	uint32_t dfsr = target_mem_read32(t, CORTEXM_DFSR);
	target_mem_write32(t, CORTEXM_DFSR, dfsr); /* write back to reset */

	if ((dfsr & CORTEXM_DFSR_VCATCH) && cortexm_fault_unwind(t))
 8001c6e:	2b00      	cmp	r3, #0
 8001c70:	d000      	beq.n	8001c74 <cortexm_halt_poll+0x1ac>
 8001c72:	e13c      	b.n	8001eee <cortexm_halt_poll+0x426>
 8001c74:	e777      	b.n	8001b66 <cortexm_halt_poll+0x9e>
	/* Remember if we stopped on a breakpoint */
	priv->on_bkpt = dfsr & (CORTEXM_DFSR_BKPT);
	if (priv->on_bkpt) {
		/* If we've hit a programmed breakpoint, check for semihosting
		 * call. */
		uint32_t pc = cortexm_pc_read(t);
 8001c76:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001c78:	f7ff fea6 	bl	80019c8 <cortexm_pc_read>
 8001c7c:	1c01      	adds	r1, r0, #0
		uint16_t bkpt_instr;
		bkpt_instr = target_mem_read16(t, pc);
 8001c7e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001c80:	f006 fc63 	bl	800854a <target_mem_read16>
		if (bkpt_instr == 0xBEAB) {
 8001c84:	4b70      	ldr	r3, [pc, #448]	; (8001e48 <cortexm_halt_poll+0x380>)
 8001c86:	4298      	cmp	r0, r3
 8001c88:	d000      	beq.n	8001c8c <cortexm_halt_poll+0x1c4>
 8001c8a:	e0fb      	b.n	8001e84 <cortexm_halt_poll+0x3bc>
 8001c8c:	466b      	mov	r3, sp
#define SYS_WRITEC	0x03
#define SYS_WRITE0	0x04

static int cortexm_hostio_request(target *t)
{
	uint32_t arm_regs[t->regs_size];
 8001c8e:	466a      	mov	r2, sp
 8001c90:	63bb      	str	r3, [r7, #56]	; 0x38
 8001c92:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
	uint32_t params[4];

	t->tc->interrupted = false;
	target_regs_read(t, arm_regs);
 8001c94:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
#define SYS_WRITEC	0x03
#define SYS_WRITE0	0x04

static int cortexm_hostio_request(target *t)
{
	uint32_t arm_regs[t->regs_size];
 8001c96:	69db      	ldr	r3, [r3, #28]
 8001c98:	62bb      	str	r3, [r7, #40]	; 0x28
 8001c9a:	009b      	lsls	r3, r3, #2
 8001c9c:	330a      	adds	r3, #10
 8001c9e:	08db      	lsrs	r3, r3, #3
 8001ca0:	00db      	lsls	r3, r3, #3
 8001ca2:	1ad3      	subs	r3, r2, r3
 8001ca4:	469d      	mov	sp, r3
	uint32_t params[4];

	t->tc->interrupted = false;
 8001ca6:	2200      	movs	r2, #0
 8001ca8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
#define SYS_WRITEC	0x03
#define SYS_WRITE0	0x04

static int cortexm_hostio_request(target *t)
{
	uint32_t arm_regs[t->regs_size];
 8001caa:	ac02      	add	r4, sp, #8
	uint32_t params[4];

	t->tc->interrupted = false;
 8001cac:	685b      	ldr	r3, [r3, #4]
	target_regs_read(t, arm_regs);
 8001cae:	1c21      	adds	r1, r4, #0
static int cortexm_hostio_request(target *t)
{
	uint32_t arm_regs[t->regs_size];
	uint32_t params[4];

	t->tc->interrupted = false;
 8001cb0:	627b      	str	r3, [r7, #36]	; 0x24
 8001cb2:	3339      	adds	r3, #57	; 0x39
 8001cb4:	701a      	strb	r2, [r3, #0]
	target_regs_read(t, arm_regs);
 8001cb6:	f006 fbc5 	bl	8008444 <target_regs_read>
	target_mem_read(t, params, arm_regs[1], sizeof(params));
 8001cba:	2250      	movs	r2, #80	; 0x50
 8001cbc:	230c      	movs	r3, #12
 8001cbe:	18ba      	adds	r2, r7, r2
 8001cc0:	18d1      	adds	r1, r2, r3
 8001cc2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001cc4:	6862      	ldr	r2, [r4, #4]
 8001cc6:	3304      	adds	r3, #4
 8001cc8:	f006 fbac 	bl	8008424 <target_mem_read>
	uint32_t syscall = arm_regs[0];
	int32_t ret = 0;

	DEBUG("syscall 0"PRIx32"%"PRIx32" (%"PRIx32" %"PRIx32" %"PRIx32" %"PRIx32")\n",
 8001ccc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
	uint32_t params[4];

	t->tc->interrupted = false;
	target_regs_read(t, arm_regs);
	target_mem_read(t, params, arm_regs[1], sizeof(params));
	uint32_t syscall = arm_regs[0];
 8001cce:	6826      	ldr	r6, [r4, #0]
	int32_t ret = 0;

	DEBUG("syscall 0"PRIx32"%"PRIx32" (%"PRIx32" %"PRIx32" %"PRIx32" %"PRIx32")\n",
 8001cd0:	623b      	str	r3, [r7, #32]
 8001cd2:	9300      	str	r3, [sp, #0]
 8001cd4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001cd6:	485d      	ldr	r0, [pc, #372]	; (8001e4c <cortexm_halt_poll+0x384>)
 8001cd8:	61fb      	str	r3, [r7, #28]
 8001cda:	9301      	str	r3, [sp, #4]
 8001cdc:	1c31      	adds	r1, r6, #0
 8001cde:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001ce0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8001ce2:	f00a febb 	bl	800ca5c <iprintf>
              syscall, params[0], params[1], params[2], params[3]);
	switch (syscall) {
 8001ce6:	1e70      	subs	r0, r6, #1
 8001ce8:	2812      	cmp	r0, #18
 8001cea:	d900      	bls.n	8001cee <cortexm_halt_poll+0x226>
 8001cec:	e0b4      	b.n	8001e58 <cortexm_halt_poll+0x390>
 8001cee:	f00c fe45 	bl	800e97c <__gnu_thumb1_case_uqi>
 8001cf2:	430a      	.short	0x430a
 8001cf4:	4951b35d 	.word	0x4951b35d
 8001cf8:	6a64b3b3 	.word	0x6a64b3b3
 8001cfc:	80b390b3 	.word	0x80b390b3
 8001d00:	88b3b372 	.word	0x88b3b372
 8001d04:	97          	.byte	0x97
 8001d05:	00          	.byte	0x00
	case SYS_OPEN:{	/* open */
		/* Translate stupid fopen modes to open flags.
		 * See DUI0471C, Table 8-3 */
		const uint32_t flags[] = {
 8001d06:	2250      	movs	r2, #80	; 0x50
 8001d08:	231c      	movs	r3, #28
 8001d0a:	18ba      	adds	r2, r7, r2
 8001d0c:	18d2      	adds	r2, r2, r3
 8001d0e:	1c11      	adds	r1, r2, #0
 8001d10:	4b4f      	ldr	r3, [pc, #316]	; (8001e50 <cortexm_halt_poll+0x388>)
 8001d12:	332c      	adds	r3, #44	; 0x2c
 8001d14:	cb61      	ldmia	r3!, {r0, r5, r6}
 8001d16:	c161      	stmia	r1!, {r0, r5, r6}
 8001d18:	cb61      	ldmia	r3!, {r0, r5, r6}
 8001d1a:	c161      	stmia	r1!, {r0, r5, r6}
			TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_TRUNC,/*w*/
			TARGET_O_RDWR | TARGET_O_CREAT | TARGET_O_TRUNC,/*w+*/
			TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_APPEND,/*a*/
			TARGET_O_RDWR | TARGET_O_CREAT | TARGET_O_APPEND,/*a+*/
		};
		uint32_t pflag = flags[params[1] >> 1];
 8001d1c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
		char filename[4];

		target_mem_read(t, filename, params[0], sizeof(filename));
 8001d1e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
			TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_TRUNC,/*w*/
			TARGET_O_RDWR | TARGET_O_CREAT | TARGET_O_TRUNC,/*w+*/
			TARGET_O_WRONLY | TARGET_O_CREAT | TARGET_O_APPEND,/*a*/
			TARGET_O_RDWR | TARGET_O_CREAT | TARGET_O_APPEND,/*a+*/
		};
		uint32_t pflag = flags[params[1] >> 1];
 8001d20:	61bb      	str	r3, [r7, #24]
 8001d22:	085b      	lsrs	r3, r3, #1
 8001d24:	009b      	lsls	r3, r3, #2
 8001d26:	589e      	ldr	r6, [r3, r2]
		char filename[4];

		target_mem_read(t, filename, params[0], sizeof(filename));
 8001d28:	2250      	movs	r2, #80	; 0x50
 8001d2a:	2308      	movs	r3, #8
 8001d2c:	18ba      	adds	r2, r7, r2
 8001d2e:	18d1      	adds	r1, r2, r3
 8001d30:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001d32:	3b04      	subs	r3, #4
 8001d34:	f006 fb76 	bl	8008424 <target_mem_read>
		/* handle requests for console i/o */
		if (!strcmp(filename, ":tt")) {
 8001d38:	2250      	movs	r2, #80	; 0x50
 8001d3a:	2308      	movs	r3, #8
 8001d3c:	18ba      	adds	r2, r7, r2
 8001d3e:	18d0      	adds	r0, r2, r3
 8001d40:	4944      	ldr	r1, [pc, #272]	; (8001e54 <cortexm_halt_poll+0x38c>)
 8001d42:	f00b f867 	bl	800ce14 <strcmp>
 8001d46:	2800      	cmp	r0, #0
 8001d48:	d107      	bne.n	8001d5a <cortexm_halt_poll+0x292>
			if (pflag == TARGET_O_RDONLY)
				ret = STDIN_FILENO;
 8001d4a:	1e30      	subs	r0, r6, #0
		char filename[4];

		target_mem_read(t, filename, params[0], sizeof(filename));
		/* handle requests for console i/o */
		if (!strcmp(filename, ":tt")) {
			if (pflag == TARGET_O_RDONLY)
 8001d4c:	d003      	beq.n	8001d56 <cortexm_halt_poll+0x28e>
				ret = STDIN_FILENO;
			else if (pflag & TARGET_O_TRUNC)
				ret = STDOUT_FILENO;
			else
				ret = STDERR_FILENO;
 8001d4e:	2302      	movs	r3, #2
		target_mem_read(t, filename, params[0], sizeof(filename));
		/* handle requests for console i/o */
		if (!strcmp(filename, ":tt")) {
			if (pflag == TARGET_O_RDONLY)
				ret = STDIN_FILENO;
			else if (pflag & TARGET_O_TRUNC)
 8001d50:	0570      	lsls	r0, r6, #21
				ret = STDOUT_FILENO;
			else
				ret = STDERR_FILENO;
 8001d52:	0fc0      	lsrs	r0, r0, #31
 8001d54:	1a18      	subs	r0, r3, r0
			ret++;
 8001d56:	3001      	adds	r0, #1
 8001d58:	e07f      	b.n	8001e5a <cortexm_halt_poll+0x392>
			break;
		}

		ret = tc_open(t, params[0], params[2] + 1, pflag, 0644);
 8001d5a:	21d2      	movs	r1, #210	; 0xd2
 8001d5c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8001d5e:	0049      	lsls	r1, r1, #1
 8001d60:	9100      	str	r1, [sp, #0]
 8001d62:	3201      	adds	r2, #1
 8001d64:	b2b3      	uxth	r3, r6
 8001d66:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001d68:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8001d6a:	f006 fc69 	bl	8008640 <tc_open>
		if (ret != -1)
			ret++;
 8001d6e:	1c43      	adds	r3, r0, #1
 8001d70:	1e5a      	subs	r2, r3, #1
 8001d72:	4193      	sbcs	r3, r2
 8001d74:	18c0      	adds	r0, r0, r3
 8001d76:	e070      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
		}
	case SYS_CLOSE:	/* close */
		ret = tc_close(t, params[0] - 1);
 8001d78:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001d7a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001d7c:	1e59      	subs	r1, r3, #1
 8001d7e:	f006 fc6e 	bl	800865e <tc_close>
 8001d82:	e06a      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
	case SYS_READ:	/* read */
		ret = tc_read(t, params[0] - 1, params[1], params[2]);
 8001d84:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001d86:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001d88:	1e59      	subs	r1, r3, #1
 8001d8a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001d8c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d8e:	f006 fc73 	bl	8008678 <tc_read>
 8001d92:	e006      	b.n	8001da2 <cortexm_halt_poll+0x2da>
		if (ret > 0)
			ret = params[2] - ret;
		break;
	case SYS_WRITE:	/* write */
		ret = tc_write(t, params[0] - 1, params[1], params[2]);
 8001d94:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001d96:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001d98:	1e59      	subs	r1, r3, #1
 8001d9a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001d9c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001d9e:	f006 fc73 	bl	8008688 <tc_write>
		if (ret > 0)
 8001da2:	2800      	cmp	r0, #0
 8001da4:	dd59      	ble.n	8001e5a <cortexm_halt_poll+0x392>
			ret = params[2] - ret;
 8001da6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001da8:	1a18      	subs	r0, r3, r0
 8001daa:	e056      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
	case SYS_WRITEC: /* writec */
		ret = tc_write(t, 2, arm_regs[1], 1);
 8001dac:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001dae:	2102      	movs	r1, #2
 8001db0:	6862      	ldr	r2, [r4, #4]
 8001db2:	2301      	movs	r3, #1
 8001db4:	f006 fc68 	bl	8008688 <tc_write>
 8001db8:	e04f      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
	case SYS_ISTTY:	/* isatty */
		ret = tc_isatty(t, params[0] - 1);
 8001dba:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001dbc:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001dbe:	1e59      	subs	r1, r3, #1
 8001dc0:	f006 fcad 	bl	800871e <tc_isatty>
 8001dc4:	e049      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
	case SYS_SEEK:	/* lseek */
		ret = tc_lseek(t, params[0] - 1, params[1], TARGET_SEEK_SET);
 8001dc6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001dc8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001dca:	1e59      	subs	r1, r3, #1
 8001dcc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8001dce:	2300      	movs	r3, #0
 8001dd0:	f006 fc62 	bl	8008698 <tc_lseek>
 8001dd4:	e041      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
	case SYS_RENAME:/* rename */
		ret = tc_rename(t, params[0] - 1, params[1] + 1,
 8001dd6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001dd8:	1e59      	subs	r1, r3, #1
 8001dda:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8001ddc:	617b      	str	r3, [r7, #20]
 8001dde:	1c5a      	adds	r2, r3, #1
				params[2], params[3] + 1);
 8001de0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8001de2:	613b      	str	r3, [r7, #16]
 8001de4:	3301      	adds	r3, #1
		break;
	case SYS_SEEK:	/* lseek */
		ret = tc_lseek(t, params[0] - 1, params[1], TARGET_SEEK_SET);
		break;
	case SYS_RENAME:/* rename */
		ret = tc_rename(t, params[0] - 1, params[1] + 1,
 8001de6:	9300      	str	r3, [sp, #0]
 8001de8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001dea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8001dec:	f006 fc5c 	bl	80086a8 <tc_rename>
 8001df0:	e033      	b.n	8001e5a <cortexm_halt_poll+0x392>
				params[2], params[3] + 1);
		break;
	case SYS_REMOVE:/* unlink */
		ret = tc_unlink(t, params[0] - 1, params[1] + 1);
 8001df2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001df4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001df6:	1e59      	subs	r1, r3, #1
 8001df8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8001dfa:	1c5a      	adds	r2, r3, #1
 8001dfc:	f006 fc63 	bl	80086c6 <tc_unlink>
 8001e00:	e02b      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;
	case SYS_SYSTEM:/* system */
		ret = tc_system(t, params[0] - 1, params[1] + 1);
 8001e02:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001e04:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001e06:	1e59      	subs	r1, r3, #1
 8001e08:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8001e0a:	1c5a      	adds	r2, r3, #1
 8001e0c:	f006 fc90 	bl	8008730 <tc_system>
 8001e10:	e023      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;

	case SYS_FLEN:	/* Not supported, fake success */
		t->tc->errno_ = 0;
 8001e12:	2000      	movs	r0, #0
 8001e14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001e16:	685b      	ldr	r3, [r3, #4]
 8001e18:	60fb      	str	r3, [r7, #12]
 8001e1a:	3338      	adds	r3, #56	; 0x38
 8001e1c:	7018      	strb	r0, [r3, #0]
 8001e1e:	e01c      	b.n	8001e5a <cortexm_halt_poll+0x392>
		break;

	case SYS_ERRNO: /* Return last errno from GDB */
		ret = t->tc->errno_;
 8001e20:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001e22:	685b      	ldr	r3, [r3, #4]
 8001e24:	60bb      	str	r3, [r7, #8]
 8001e26:	3338      	adds	r3, #56	; 0x38
 8001e28:	7818      	ldrb	r0, [r3, #0]
 8001e2a:	e016      	b.n	8001e5a <cortexm_halt_poll+0x392>
 8001e2c:	20001dc4 	.word	0x20001dc4
 8001e30:	e000edf0 	.word	0xe000edf0
 8001e34:	e000ed30 	.word	0xe000ed30
 8001e38:	e000ed2c 	.word	0xe000ed2c
 8001e3c:	e000ed28 	.word	0xe000ed28
 8001e40:	e000ed0c 	.word	0xe000ed0c
 8001e44:	05fa0002 	.word	0x05fa0002
 8001e48:	0000beab 	.word	0x0000beab
 8001e4c:	080112c3 	.word	0x080112c3
 8001e50:	0801063c 	.word	0x0801063c
 8001e54:	080112e5 	.word	0x080112e5

	t->tc->interrupted = false;
	target_regs_read(t, arm_regs);
	target_mem_read(t, params, arm_regs[1], sizeof(params));
	uint32_t syscall = arm_regs[0];
	int32_t ret = 0;
 8001e58:	2000      	movs	r0, #0
	case SYS_TIME:	/* gettimeofday */
		/* FIXME How do we use gdb's gettimeofday? */
		break;
	}

	arm_regs[0] = ret;
 8001e5a:	6020      	str	r0, [r4, #0]
	target_regs_write(t, arm_regs);
 8001e5c:	1c21      	adds	r1, r4, #0
 8001e5e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001e60:	f006 faf4 	bl	800844c <target_regs_write>

	return t->tc->interrupted;
 8001e64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
		uint32_t pc = cortexm_pc_read(t);
		uint16_t bkpt_instr;
		bkpt_instr = target_mem_read16(t, pc);
		if (bkpt_instr == 0xBEAB) {
			if (cortexm_hostio_request(t)) {
				return TARGET_HALT_REQUEST;
 8001e66:	2002      	movs	r0, #2
	}

	arm_regs[0] = ret;
	target_regs_write(t, arm_regs);

	return t->tc->interrupted;
 8001e68:	685b      	ldr	r3, [r3, #4]
 8001e6a:	607b      	str	r3, [r7, #4]
 8001e6c:	3339      	adds	r3, #57	; 0x39
 8001e6e:	781b      	ldrb	r3, [r3, #0]
 8001e70:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8001e72:	4695      	mov	sp, r2
		 * call. */
		uint32_t pc = cortexm_pc_read(t);
		uint16_t bkpt_instr;
		bkpt_instr = target_mem_read16(t, pc);
		if (bkpt_instr == 0xBEAB) {
			if (cortexm_hostio_request(t)) {
 8001e74:	2b00      	cmp	r3, #0
 8001e76:	d13a      	bne.n	8001eee <cortexm_halt_poll+0x426>
				return TARGET_HALT_REQUEST;
			} else {
				target_halt_resume(t, priv->stepping);
 8001e78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001e7a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001e7c:	7919      	ldrb	r1, [r3, #4]
 8001e7e:	f006 faf5 	bl	800846c <target_halt_resume>
 8001e82:	e660      	b.n	8001b46 <cortexm_halt_poll+0x7e>
				return 0;
			}
		}
	}

	if (dfsr & CORTEXM_DFSR_DWTTRAP) {
 8001e84:	2004      	movs	r0, #4
 8001e86:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001e88:	4203      	tst	r3, r0
 8001e8a:	d026      	beq.n	8001eda <cortexm_halt_poll+0x412>
		if (watch != NULL)
 8001e8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
			*watch = cortexm_check_watch(t);
		return TARGET_HALT_WATCHPOINT;
 8001e8e:	3001      	adds	r0, #1
			}
		}
	}

	if (dfsr & CORTEXM_DFSR_DWTTRAP) {
		if (watch != NULL)
 8001e90:	2b00      	cmp	r3, #0
 8001e92:	d02c      	beq.n	8001eee <cortexm_halt_poll+0x426>
static target_addr cortexm_check_watch(target *t)
{
	struct cortexm_priv *priv = t->priv;
	unsigned i;

	for(i = 0; i < priv->hw_watchpoint_max; i++)
 8001e94:	2400      	movs	r4, #0
	}
}

static target_addr cortexm_check_watch(target *t)
{
	struct cortexm_priv *priv = t->priv;
 8001e96:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8001e98:	6edd      	ldr	r5, [r3, #108]	; 0x6c
	unsigned i;

	for(i = 0; i < priv->hw_watchpoint_max; i++)
 8001e9a:	692b      	ldr	r3, [r5, #16]
 8001e9c:	429c      	cmp	r4, r3
 8001e9e:	d20b      	bcs.n	8001eb8 <cortexm_halt_poll+0x3f0>
 8001ea0:	192b      	adds	r3, r5, r4
		/* if SET and MATCHED then break */
		if(priv->hw_watchpoint[i] &&
 8001ea2:	799b      	ldrb	r3, [r3, #6]
 8001ea4:	2b00      	cmp	r3, #0
 8001ea6:	d012      	beq.n	8001ece <cortexm_halt_poll+0x406>
 8001ea8:	4b12      	ldr	r3, [pc, #72]	; (8001ef4 <cortexm_halt_poll+0x42c>)
 8001eaa:	0121      	lsls	r1, r4, #4
 8001eac:	18c9      	adds	r1, r1, r3
		   (target_mem_read32(t, CORTEXM_DWT_FUNC(i)) &
 8001eae:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001eb0:	f006 fb3c 	bl	800852c <target_mem_read32>
	struct cortexm_priv *priv = t->priv;
	unsigned i;

	for(i = 0; i < priv->hw_watchpoint_max; i++)
		/* if SET and MATCHED then break */
		if(priv->hw_watchpoint[i] &&
 8001eb4:	01c3      	lsls	r3, r0, #7
 8001eb6:	d50a      	bpl.n	8001ece <cortexm_halt_poll+0x406>
		   (target_mem_read32(t, CORTEXM_DWT_FUNC(i)) &
					CORTEXM_DWT_FUNC_MATCHED))
			break;

	if (i == priv->hw_watchpoint_max)
 8001eb8:	692b      	ldr	r3, [r5, #16]
		return 0;
 8001eba:	2000      	movs	r0, #0
		if(priv->hw_watchpoint[i] &&
		   (target_mem_read32(t, CORTEXM_DWT_FUNC(i)) &
					CORTEXM_DWT_FUNC_MATCHED))
			break;

	if (i == priv->hw_watchpoint_max)
 8001ebc:	429c      	cmp	r4, r3
 8001ebe:	d008      	beq.n	8001ed2 <cortexm_halt_poll+0x40a>
		return 0;

	return target_mem_read32(t, CORTEXM_DWT_COMP(i));
 8001ec0:	4b0d      	ldr	r3, [pc, #52]	; (8001ef8 <cortexm_halt_poll+0x430>)
 8001ec2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8001ec4:	18e1      	adds	r1, r4, r3
 8001ec6:	0109      	lsls	r1, r1, #4
 8001ec8:	f006 fb30 	bl	800852c <target_mem_read32>
 8001ecc:	e001      	b.n	8001ed2 <cortexm_halt_poll+0x40a>
static target_addr cortexm_check_watch(target *t)
{
	struct cortexm_priv *priv = t->priv;
	unsigned i;

	for(i = 0; i < priv->hw_watchpoint_max; i++)
 8001ece:	3401      	adds	r4, #1
 8001ed0:	e7e3      	b.n	8001e9a <cortexm_halt_poll+0x3d2>
		}
	}

	if (dfsr & CORTEXM_DFSR_DWTTRAP) {
		if (watch != NULL)
			*watch = cortexm_check_watch(t);
 8001ed2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001ed4:	6018      	str	r0, [r3, #0]
		return TARGET_HALT_WATCHPOINT;
 8001ed6:	2005      	movs	r0, #5
 8001ed8:	e009      	b.n	8001eee <cortexm_halt_poll+0x426>
	}
	if (dfsr & CORTEXM_DFSR_BKPT)
 8001eda:	2c00      	cmp	r4, #0
 8001edc:	d107      	bne.n	8001eee <cortexm_halt_poll+0x426>
		return TARGET_HALT_BREAKPOINT;

	if (dfsr & CORTEXM_DFSR_HALTED)
 8001ede:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8001ee0:	07db      	lsls	r3, r3, #31
 8001ee2:	d504      	bpl.n	8001eee <cortexm_halt_poll+0x426>
		return priv->stepping ? TARGET_HALT_STEPPING : TARGET_HALT_REQUEST;
 8001ee4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001ee6:	7918      	ldrb	r0, [r3, #4]
 8001ee8:	1e43      	subs	r3, r0, #1
 8001eea:	4198      	sbcs	r0, r3
 8001eec:	3002      	adds	r0, #2

	return TARGET_HALT_BREAKPOINT;
}
 8001eee:	46bd      	mov	sp, r7
 8001ef0:	b045      	add	sp, #276	; 0x114
 8001ef2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001ef4:	e0001028 	.word	0xe0001028
 8001ef8:	0e000102 	.word	0x0e000102

08001efc <cortexm_reset>:
}

/* The following three routines implement target halt/resume
 * using the core debug registers in the NVIC. */
static void cortexm_reset(target *t)
{
 8001efc:	b538      	push	{r3, r4, r5, lr}
	if ((t->target_options & CORTEXM_TOPT_INHIBIT_SRST) == 0) {
 8001efe:	2504      	movs	r5, #4
 8001f00:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
}

/* The following three routines implement target halt/resume
 * using the core debug registers in the NVIC. */
static void cortexm_reset(target *t)
{
 8001f02:	1c04      	adds	r4, r0, #0
	if ((t->target_options & CORTEXM_TOPT_INHIBIT_SRST) == 0) {
 8001f04:	401d      	ands	r5, r3
 8001f06:	d105      	bne.n	8001f14 <cortexm_reset+0x18>
		platform_srst_set_val(true);
 8001f08:	2001      	movs	r0, #1
 8001f0a:	f003 fbc3 	bl	8005694 <platform_srst_set_val>
		platform_srst_set_val(false);
 8001f0e:	1c28      	adds	r0, r5, #0
 8001f10:	f003 fbc0 	bl	8005694 <platform_srst_set_val>
	}

	/* Read DHCSR here to clear S_RESET_ST bit before reset */
	target_mem_read32(t, CORTEXM_DHCSR);
 8001f14:	490c      	ldr	r1, [pc, #48]	; (8001f48 <cortexm_reset+0x4c>)
 8001f16:	1c20      	adds	r0, r4, #0
 8001f18:	f006 fb08 	bl	800852c <target_mem_read32>

	/* Request system reset from NVIC: SRST doesn't work correctly */
	/* This could be VECTRESET: 0x05FA0001 (reset only core)
	 *          or SYSRESETREQ: 0x05FA0004 (system reset)
	 */
	target_mem_write32(t, CORTEXM_AIRCR,
 8001f1c:	1c20      	adds	r0, r4, #0
 8001f1e:	490b      	ldr	r1, [pc, #44]	; (8001f4c <cortexm_reset+0x50>)
 8001f20:	4a0b      	ldr	r2, [pc, #44]	; (8001f50 <cortexm_reset+0x54>)
 8001f22:	f006 fb0b 	bl	800853c <target_mem_write32>
	                   CORTEXM_AIRCR_VECTKEY | CORTEXM_AIRCR_SYSRESETREQ);

	/* If target needs to do something extra (see Atmel SAM4L for example) */
	if (t->extended_reset != NULL) {
 8001f26:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001f28:	2b00      	cmp	r3, #0
 8001f2a:	d001      	beq.n	8001f30 <cortexm_reset+0x34>
		t->extended_reset(t);
 8001f2c:	1c20      	adds	r0, r4, #0
 8001f2e:	4798      	blx	r3
	}

	/* Poll for release from reset */
	while (target_mem_read32(t, CORTEXM_DHCSR) & CORTEXM_DHCSR_S_RESET_ST);
 8001f30:	1c20      	adds	r0, r4, #0
 8001f32:	4905      	ldr	r1, [pc, #20]	; (8001f48 <cortexm_reset+0x4c>)
 8001f34:	f006 fafa 	bl	800852c <target_mem_read32>
 8001f38:	0183      	lsls	r3, r0, #6
 8001f3a:	d4f9      	bmi.n	8001f30 <cortexm_reset+0x34>

	/* Reset DFSR flags */
	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
 8001f3c:	1c20      	adds	r0, r4, #0
 8001f3e:	4905      	ldr	r1, [pc, #20]	; (8001f54 <cortexm_reset+0x58>)
 8001f40:	221f      	movs	r2, #31
 8001f42:	f006 fafb 	bl	800853c <target_mem_write32>
}
 8001f46:	bd38      	pop	{r3, r4, r5, pc}
 8001f48:	e000edf0 	.word	0xe000edf0
 8001f4c:	e000ed0c 	.word	0xe000ed0c
 8001f50:	05fa0004 	.word	0x05fa0004
 8001f54:	e000ed30 	.word	0xe000ed30

08001f58 <cortexm_mem_write>:
{
	adiv5_mem_read(cortexm_ap(t), dest, src, len);
}

static void cortexm_mem_write(target *t, target_addr dest, const void *src, size_t len)
{
 8001f58:	b508      	push	{r3, lr}
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 8001f5a:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
	adiv5_mem_read(cortexm_ap(t), dest, src, len);
}

static void cortexm_mem_write(target *t, target_addr dest, const void *src, size_t len)
{
	adiv5_mem_write(cortexm_ap(t), dest, src, len);
 8001f5c:	6800      	ldr	r0, [r0, #0]
 8001f5e:	f7fe fab3 	bl	80004c8 <adiv5_mem_write>
}
 8001f62:	bd08      	pop	{r3, pc}

08001f64 <cortexm_mem_read>:
{
	return ((struct cortexm_priv *)t->priv)->ap;
}

static void cortexm_mem_read(target *t, void *dest, target_addr src, size_t len)
{
 8001f64:	b508      	push	{r3, lr}
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 8001f66:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
}

static void cortexm_mem_read(target *t, void *dest, target_addr src, size_t len)
{
	adiv5_mem_read(cortexm_ap(t), dest, src, len);
 8001f68:	6800      	ldr	r0, [r0, #0]
 8001f6a:	f7fe f91f 	bl	80001ac <adiv5_mem_read>
}
 8001f6e:	bd08      	pop	{r3, pc}

08001f70 <cortexm_priv_free>:
	ADIv5_AP_t *ap = cortexm_ap(t);
	return adiv5_dp_error(ap->dp) != 0;
}

static void cortexm_priv_free(void *priv)
{
 8001f70:	b510      	push	{r4, lr}
 8001f72:	1c04      	adds	r4, r0, #0
	adiv5_ap_unref(((struct cortexm_priv *)priv)->ap);
 8001f74:	6800      	ldr	r0, [r0, #0]
 8001f76:	f7fe f8d5 	bl	8000124 <adiv5_ap_unref>
	free(priv);
 8001f7a:	1c20      	adds	r0, r4, #0
 8001f7c:	f00a fc92 	bl	800c8a4 <free>
}
 8001f80:	bd10      	pop	{r4, pc}

08001f82 <cortexm_attach>:

	return true;
}

bool cortexm_attach(target *t)
{
 8001f82:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001f84:	1c05      	adds	r5, r0, #0
	struct cortexm_priv *priv = t->priv;
 8001f86:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
	unsigned i;
	uint32_t r;
	int tries;

	/* Clear any pending fault condition */
	target_check_error(t);
 8001f88:	f006 fa46 	bl	8008418 <target_check_error>

	target_halt_request(t);
 8001f8c:	1c28      	adds	r0, r5, #0
 8001f8e:	f006 fa65 	bl	800845c <target_halt_request>
	tries = 10;
	while(!platform_srst_get_val() && !target_halt_poll(t, NULL) && --tries)
 8001f92:	270a      	movs	r7, #10
 8001f94:	f003 fb8d 	bl	80056b2 <platform_srst_get_val>
 8001f98:	1e06      	subs	r6, r0, #0
 8001f9a:	d10c      	bne.n	8001fb6 <cortexm_attach+0x34>
 8001f9c:	1c28      	adds	r0, r5, #0
 8001f9e:	1c31      	adds	r1, r6, #0
 8001fa0:	f006 fa60 	bl	8008464 <target_halt_poll>
 8001fa4:	2800      	cmp	r0, #0
 8001fa6:	d106      	bne.n	8001fb6 <cortexm_attach+0x34>
 8001fa8:	3f01      	subs	r7, #1
 8001faa:	2f00      	cmp	r7, #0
 8001fac:	d04f      	beq.n	800204e <cortexm_attach+0xcc>
		platform_delay(200);
 8001fae:	20c8      	movs	r0, #200	; 0xc8
 8001fb0:	f009 fa9a 	bl	800b4e8 <platform_delay>
 8001fb4:	e7ee      	b.n	8001f94 <cortexm_attach+0x12>
	if(!tries)
		return false;

	/* Request halt on reset */
	target_mem_write32(t, CORTEXM_DEMCR, priv->demcr);
 8001fb6:	1c28      	adds	r0, r5, #0
 8001fb8:	4926      	ldr	r1, [pc, #152]	; (8002054 <cortexm_attach+0xd2>)
 8001fba:	6a22      	ldr	r2, [r4, #32]
 8001fbc:	f006 fabe 	bl	800853c <target_mem_write32>

	/* Reset DFSR flags */
	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
 8001fc0:	221f      	movs	r2, #31
 8001fc2:	1c28      	adds	r0, r5, #0
 8001fc4:	4924      	ldr	r1, [pc, #144]	; (8002058 <cortexm_attach+0xd6>)
 8001fc6:	f006 fab9 	bl	800853c <target_mem_write32>

	/* size the break/watchpoint units */
	priv->hw_breakpoint_max = CORTEXM_MAX_BREAKPOINTS;
 8001fca:	2306      	movs	r3, #6
	r = target_mem_read32(t, CORTEXM_FPB_CTRL);
 8001fcc:	1c28      	adds	r0, r5, #0

	/* Reset DFSR flags */
	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);

	/* size the break/watchpoint units */
	priv->hw_breakpoint_max = CORTEXM_MAX_BREAKPOINTS;
 8001fce:	61e3      	str	r3, [r4, #28]
	r = target_mem_read32(t, CORTEXM_FPB_CTRL);
 8001fd0:	4922      	ldr	r1, [pc, #136]	; (800205c <cortexm_attach+0xda>)
 8001fd2:	f006 faab 	bl	800852c <target_mem_read32>
	if (((r >> 4) & 0xf) < priv->hw_breakpoint_max)	/* only look at NUM_COMP1 */
 8001fd6:	69e2      	ldr	r2, [r4, #28]
 8001fd8:	0603      	lsls	r3, r0, #24
 8001fda:	0f1b      	lsrs	r3, r3, #28
 8001fdc:	4293      	cmp	r3, r2
 8001fde:	d200      	bcs.n	8001fe2 <cortexm_attach+0x60>
		priv->hw_breakpoint_max = (r >> 4) & 0xf;
 8001fe0:	61e3      	str	r3, [r4, #28]
	priv->flash_patch_revision = (r >> 28);
	priv->hw_watchpoint_max = CORTEXM_MAX_WATCHPOINTS;
 8001fe2:	2304      	movs	r3, #4
	/* size the break/watchpoint units */
	priv->hw_breakpoint_max = CORTEXM_MAX_BREAKPOINTS;
	r = target_mem_read32(t, CORTEXM_FPB_CTRL);
	if (((r >> 4) & 0xf) < priv->hw_breakpoint_max)	/* only look at NUM_COMP1 */
		priv->hw_breakpoint_max = (r >> 4) & 0xf;
	priv->flash_patch_revision = (r >> 28);
 8001fe4:	0f00      	lsrs	r0, r0, #28
 8001fe6:	60e0      	str	r0, [r4, #12]
	priv->hw_watchpoint_max = CORTEXM_MAX_WATCHPOINTS;
 8001fe8:	6123      	str	r3, [r4, #16]
	r = target_mem_read32(t, CORTEXM_DWT_CTRL);
 8001fea:	1c28      	adds	r0, r5, #0
 8001fec:	491c      	ldr	r1, [pc, #112]	; (8002060 <cortexm_attach+0xde>)
 8001fee:	f006 fa9d 	bl	800852c <target_mem_read32>
	if ((r >> 28) > priv->hw_watchpoint_max)
 8001ff2:	6923      	ldr	r3, [r4, #16]
 8001ff4:	0f00      	lsrs	r0, r0, #28
 8001ff6:	4298      	cmp	r0, r3
 8001ff8:	d900      	bls.n	8001ffc <cortexm_attach+0x7a>
		priv->hw_watchpoint_max = r >> 28;
 8001ffa:	6120      	str	r0, [r4, #16]
	/* Clear any pending fault condition */
	target_check_error(t);

	target_halt_request(t);
	tries = 10;
	while(!platform_srst_get_val() && !target_halt_poll(t, NULL) && --tries)
 8001ffc:	2600      	movs	r6, #0
	r = target_mem_read32(t, CORTEXM_DWT_CTRL);
	if ((r >> 28) > priv->hw_watchpoint_max)
		priv->hw_watchpoint_max = r >> 28;

	/* Clear any stale breakpoints */
	for(i = 0; i < priv->hw_breakpoint_max; i++) {
 8001ffe:	69e3      	ldr	r3, [r4, #28]
 8002000:	429e      	cmp	r6, r3
 8002002:	d20b      	bcs.n	800201c <cortexm_attach+0x9a>
 8002004:	4b17      	ldr	r3, [pc, #92]	; (8002064 <cortexm_attach+0xe2>)
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
 8002006:	2200      	movs	r2, #0
 8002008:	18f1      	adds	r1, r6, r3
 800200a:	0089      	lsls	r1, r1, #2
 800200c:	1c28      	adds	r0, r5, #0
 800200e:	f006 fa95 	bl	800853c <target_mem_write32>
		priv->hw_breakpoint[i] = 0;
 8002012:	2200      	movs	r2, #0
 8002014:	19a3      	adds	r3, r4, r6
 8002016:	751a      	strb	r2, [r3, #20]
	r = target_mem_read32(t, CORTEXM_DWT_CTRL);
	if ((r >> 28) > priv->hw_watchpoint_max)
		priv->hw_watchpoint_max = r >> 28;

	/* Clear any stale breakpoints */
	for(i = 0; i < priv->hw_breakpoint_max; i++) {
 8002018:	3601      	adds	r6, #1
 800201a:	e7f0      	b.n	8001ffe <cortexm_attach+0x7c>
 800201c:	2600      	movs	r6, #0
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
		priv->hw_breakpoint[i] = 0;
	}

	/* Clear any stale watchpoints */
	for(i = 0; i < priv->hw_watchpoint_max; i++) {
 800201e:	6923      	ldr	r3, [r4, #16]
 8002020:	429e      	cmp	r6, r3
 8002022:	d20b      	bcs.n	800203c <cortexm_attach+0xba>
 8002024:	4b10      	ldr	r3, [pc, #64]	; (8002068 <cortexm_attach+0xe6>)
 8002026:	0131      	lsls	r1, r6, #4
 8002028:	18c9      	adds	r1, r1, r3
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
 800202a:	2200      	movs	r2, #0
 800202c:	1c28      	adds	r0, r5, #0
 800202e:	f006 fa85 	bl	800853c <target_mem_write32>
		priv->hw_watchpoint[i] = 0;
 8002032:	2200      	movs	r2, #0
 8002034:	19a3      	adds	r3, r4, r6
 8002036:	719a      	strb	r2, [r3, #6]
		target_mem_write32(t, CORTEXM_FPB_COMP(i), 0);
		priv->hw_breakpoint[i] = 0;
	}

	/* Clear any stale watchpoints */
	for(i = 0; i < priv->hw_watchpoint_max; i++) {
 8002038:	3601      	adds	r6, #1
 800203a:	e7f0      	b.n	800201e <cortexm_attach+0x9c>
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), 0);
		priv->hw_watchpoint[i] = 0;
	}

	/* Flash Patch Control Register: set ENABLE */
	target_mem_write32(t, CORTEXM_FPB_CTRL,
 800203c:	1c28      	adds	r0, r5, #0
 800203e:	4907      	ldr	r1, [pc, #28]	; (800205c <cortexm_attach+0xda>)
 8002040:	2203      	movs	r2, #3
 8002042:	f006 fa7b 	bl	800853c <target_mem_write32>
			CORTEXM_FPB_CTRL_KEY | CORTEXM_FPB_CTRL_ENABLE);

	platform_srst_set_val(false);
 8002046:	2000      	movs	r0, #0
 8002048:	f003 fb24 	bl	8005694 <platform_srst_set_val>

	return true;
 800204c:	2601      	movs	r6, #1
}
 800204e:	1c30      	adds	r0, r6, #0
 8002050:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002052:	46c0      	nop			; (mov r8, r8)
 8002054:	e000edfc 	.word	0xe000edfc
 8002058:	e000ed30 	.word	0xe000ed30
 800205c:	e0002000 	.word	0xe0002000
 8002060:	e0001000 	.word	0xe0001000
 8002064:	38000802 	.word	0x38000802
 8002068:	e0001028 	.word	0xe0001028

0800206c <cortexm_breakwatch_set>:
		return -1;
	}
}

static int cortexm_breakwatch_set(target *t, struct breakwatch *bw)
{
 800206c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct cortexm_priv *priv = t->priv;
	unsigned i;
	uint32_t val = bw->addr;
 800206e:	688a      	ldr	r2, [r1, #8]
		return -1;
	}
}

static int cortexm_breakwatch_set(target *t, struct breakwatch *bw)
{
 8002070:	1c0e      	adds	r6, r1, #0
	struct cortexm_priv *priv = t->priv;
	unsigned i;
	uint32_t val = bw->addr;

	switch (bw->type) {
 8002072:	7909      	ldrb	r1, [r1, #4]
		return -1;
	}
}

static int cortexm_breakwatch_set(target *t, struct breakwatch *bw)
{
 8002074:	1c05      	adds	r5, r0, #0
	struct cortexm_priv *priv = t->priv;
 8002076:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
	unsigned i;
	uint32_t val = bw->addr;

	switch (bw->type) {
 8002078:	2901      	cmp	r1, #1
 800207a:	d006      	beq.n	800208a <cortexm_breakwatch_set+0x1e>
 800207c:	2900      	cmp	r1, #0
 800207e:	d027      	beq.n	80020d0 <cortexm_breakwatch_set+0x64>
 8002080:	2904      	cmp	r1, #4
 8002082:	d825      	bhi.n	80020d0 <cortexm_breakwatch_set+0x64>
		return 0;

	case TARGET_WATCH_WRITE:
	case TARGET_WATCH_READ:
	case TARGET_WATCH_ACCESS:
		for(i = 0; i < priv->hw_watchpoint_max; i++)
 8002084:	6918      	ldr	r0, [r3, #16]
 8002086:	2400      	movs	r4, #0
 8002088:	e01d      	b.n	80020c6 <cortexm_breakwatch_set+0x5a>
	unsigned i;
	uint32_t val = bw->addr;

	switch (bw->type) {
	case TARGET_BREAK_HARD:
		if (priv->flash_patch_revision == 0) {
 800208a:	68d9      	ldr	r1, [r3, #12]
 800208c:	2900      	cmp	r1, #0
 800208e:	d109      	bne.n	80020a4 <cortexm_breakwatch_set+0x38>
			val &= 0x1FFFFFFC;
 8002090:	4931      	ldr	r1, [pc, #196]	; (8002158 <cortexm_breakwatch_set+0xec>)
 8002092:	4011      	ands	r1, r2
			val |= (bw->addr & 2)?0x80000000:0x40000000;
 8002094:	0792      	lsls	r2, r2, #30
 8002096:	d402      	bmi.n	800209e <cortexm_breakwatch_set+0x32>
 8002098:	2280      	movs	r2, #128	; 0x80
 800209a:	05d2      	lsls	r2, r2, #23
 800209c:	e001      	b.n	80020a2 <cortexm_breakwatch_set+0x36>
 800209e:	2280      	movs	r2, #128	; 0x80
 80020a0:	0612      	lsls	r2, r2, #24
 80020a2:	430a      	orrs	r2, r1
		}
		val |= 1;
 80020a4:	2101      	movs	r1, #1

		for(i = 0; i < priv->hw_breakpoint_max; i++)
 80020a6:	2700      	movs	r7, #0
 80020a8:	69d8      	ldr	r0, [r3, #28]
	case TARGET_BREAK_HARD:
		if (priv->flash_patch_revision == 0) {
			val &= 0x1FFFFFFC;
			val |= (bw->addr & 2)?0x80000000:0x40000000;
		}
		val |= 1;
 80020aa:	430a      	orrs	r2, r1

		for(i = 0; i < priv->hw_breakpoint_max; i++)
 80020ac:	4287      	cmp	r7, r0
 80020ae:	d00c      	beq.n	80020ca <cortexm_breakwatch_set+0x5e>
 80020b0:	19d9      	adds	r1, r3, r7
			if (!priv->hw_breakpoint[i])
 80020b2:	7d0c      	ldrb	r4, [r1, #20]
 80020b4:	2c00      	cmp	r4, #0
 80020b6:	d00d      	beq.n	80020d4 <cortexm_breakwatch_set+0x68>
			val &= 0x1FFFFFFC;
			val |= (bw->addr & 2)?0x80000000:0x40000000;
		}
		val |= 1;

		for(i = 0; i < priv->hw_breakpoint_max; i++)
 80020b8:	3701      	adds	r7, #1
 80020ba:	e7f7      	b.n	80020ac <cortexm_breakwatch_set+0x40>
 80020bc:	1919      	adds	r1, r3, r4

	case TARGET_WATCH_WRITE:
	case TARGET_WATCH_READ:
	case TARGET_WATCH_ACCESS:
		for(i = 0; i < priv->hw_watchpoint_max; i++)
			if (!priv->hw_watchpoint[i])
 80020be:	798f      	ldrb	r7, [r1, #6]
 80020c0:	2f00      	cmp	r7, #0
 80020c2:	d012      	beq.n	80020ea <cortexm_breakwatch_set+0x7e>
		return 0;

	case TARGET_WATCH_WRITE:
	case TARGET_WATCH_READ:
	case TARGET_WATCH_ACCESS:
		for(i = 0; i < priv->hw_watchpoint_max; i++)
 80020c4:	3401      	adds	r4, #1
 80020c6:	4284      	cmp	r4, r0
 80020c8:	d1f8      	bne.n	80020bc <cortexm_breakwatch_set+0x50>
		for(i = 0; i < priv->hw_breakpoint_max; i++)
			if (!priv->hw_breakpoint[i])
				break;

		if (i == priv->hw_breakpoint_max)
			return -1;
 80020ca:	2001      	movs	r0, #1
 80020cc:	4240      	negs	r0, r0
 80020ce:	e041      	b.n	8002154 <cortexm_breakwatch_set+0xe8>
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), dwt_func(t, bw->type));

		bw->reserved[0] = i;
		return 0;
	default:
		return 1;
 80020d0:	2001      	movs	r0, #1
 80020d2:	e03f      	b.n	8002154 <cortexm_breakwatch_set+0xe8>
				break;

		if (i == priv->hw_breakpoint_max)
			return -1;

		priv->hw_breakpoint[i] = true;
 80020d4:	2301      	movs	r3, #1
 80020d6:	750b      	strb	r3, [r1, #20]
		target_mem_write32(t, CORTEXM_FPB_COMP(i), val);
 80020d8:	4b20      	ldr	r3, [pc, #128]	; (800215c <cortexm_breakwatch_set+0xf0>)
 80020da:	1c28      	adds	r0, r5, #0
 80020dc:	18f9      	adds	r1, r7, r3
 80020de:	0089      	lsls	r1, r1, #2
 80020e0:	f006 fa2c 	bl	800853c <target_mem_write32>
		bw->reserved[0] = i;
 80020e4:	6137      	str	r7, [r6, #16]
		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), dwt_func(t, bw->type));

		bw->reserved[0] = i;
		return 0;
 80020e6:	2000      	movs	r0, #0
 80020e8:	e034      	b.n	8002154 <cortexm_breakwatch_set+0xe8>
				break;

		if (i == priv->hw_watchpoint_max)
			return -1;

		priv->hw_watchpoint[i] = true;
 80020ea:	2301      	movs	r3, #1
 80020ec:	718b      	strb	r3, [r1, #6]

		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
 80020ee:	4b1c      	ldr	r3, [pc, #112]	; (8002160 <cortexm_breakwatch_set+0xf4>)
 80020f0:	1c28      	adds	r0, r5, #0
 80020f2:	18e1      	adds	r1, r4, r3
 80020f4:	010f      	lsls	r7, r1, #4
 80020f6:	1c39      	adds	r1, r7, #0
 80020f8:	f006 fa20 	bl	800853c <target_mem_write32>
 80020fc:	68f3      	ldr	r3, [r6, #12]
		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
 80020fe:	1d39      	adds	r1, r7, #4
 8002100:	3b01      	subs	r3, #1
 8002102:	2b03      	cmp	r3, #3
 8002104:	d823      	bhi.n	800214e <cortexm_breakwatch_set+0xe2>
 8002106:	4a17      	ldr	r2, [pc, #92]	; (8002164 <cortexm_breakwatch_set+0xf8>)
 8002108:	009b      	lsls	r3, r3, #2
 800210a:	18d3      	adds	r3, r2, r3
 800210c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800210e:	1c28      	adds	r0, r5, #0
 8002110:	f006 fa14 	bl	800853c <target_mem_write32>

static uint32_t dwt_func(target *t, enum target_breakwatch type)
{
	uint32_t x = 0;

	if ((t->target_options & TOPT_FLAVOUR_V6M) == 0)
 8002114:	2201      	movs	r2, #1
 8002116:	6ce8      	ldr	r0, [r5, #76]	; 0x4c

		priv->hw_watchpoint[i] = true;

		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), dwt_func(t, bw->type));
 8002118:	1c39      	adds	r1, r7, #0

static uint32_t dwt_func(target *t, enum target_breakwatch type)
{
	uint32_t x = 0;

	if ((t->target_options & TOPT_FLAVOUR_V6M) == 0)
 800211a:	4010      	ands	r0, r2
		x = CORTEXM_DWT_FUNC_DATAVSIZE_WORD;
 800211c:	4242      	negs	r2, r0
 800211e:	4142      	adcs	r2, r0

		priv->hw_watchpoint[i] = true;

		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), dwt_func(t, bw->type));
 8002120:	7933      	ldrb	r3, [r6, #4]
 8002122:	3108      	adds	r1, #8
static uint32_t dwt_func(target *t, enum target_breakwatch type)
{
	uint32_t x = 0;

	if ((t->target_options & TOPT_FLAVOUR_V6M) == 0)
		x = CORTEXM_DWT_FUNC_DATAVSIZE_WORD;
 8002124:	02d2      	lsls	r2, r2, #11

	switch (type) {
 8002126:	2b03      	cmp	r3, #3
 8002128:	d005      	beq.n	8002136 <cortexm_breakwatch_set+0xca>
 800212a:	2b04      	cmp	r3, #4
 800212c:	d005      	beq.n	800213a <cortexm_breakwatch_set+0xce>
 800212e:	2b02      	cmp	r3, #2
 8002130:	d106      	bne.n	8002140 <cortexm_breakwatch_set+0xd4>
	case TARGET_WATCH_WRITE:
		return CORTEXM_DWT_FUNC_FUNC_WRITE | x;
 8002132:	3304      	adds	r3, #4
 8002134:	e002      	b.n	800213c <cortexm_breakwatch_set+0xd0>
	case TARGET_WATCH_READ:
		return CORTEXM_DWT_FUNC_FUNC_READ | x;
 8002136:	2305      	movs	r3, #5
 8002138:	e000      	b.n	800213c <cortexm_breakwatch_set+0xd0>
	case TARGET_WATCH_ACCESS:
		return CORTEXM_DWT_FUNC_FUNC_ACCESS | x;
 800213a:	2307      	movs	r3, #7
 800213c:	431a      	orrs	r2, r3
 800213e:	e001      	b.n	8002144 <cortexm_breakwatch_set+0xd8>
	default:
		return -1;
 8002140:	2201      	movs	r2, #1
 8002142:	4252      	negs	r2, r2

		priv->hw_watchpoint[i] = true;

		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
		target_mem_write32(t, CORTEXM_DWT_FUNC(i), dwt_func(t, bw->type));
 8002144:	1c28      	adds	r0, r5, #0
 8002146:	f006 f9f9 	bl	800853c <target_mem_write32>

		bw->reserved[0] = i;
 800214a:	6134      	str	r4, [r6, #16]
 800214c:	e7cb      	b.n	80020e6 <cortexm_breakwatch_set+0x7a>
			return -1;

		priv->hw_watchpoint[i] = true;

		target_mem_write32(t, CORTEXM_DWT_COMP(i), val);
		target_mem_write32(t, CORTEXM_DWT_MASK(i), dwt_mask(bw->size));
 800214e:	2201      	movs	r2, #1
 8002150:	4252      	negs	r2, r2
 8002152:	e7dc      	b.n	800210e <cortexm_breakwatch_set+0xa2>
		bw->reserved[0] = i;
		return 0;
	default:
		return 1;
	}
}
 8002154:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002156:	46c0      	nop			; (mov r8, r8)
 8002158:	1ffffffc 	.word	0x1ffffffc
 800215c:	38000802 	.word	0x38000802
 8002160:	0e000102 	.word	0x0e000102
 8002164:	0801063c 	.word	0x0801063c

08002168 <adiv5_dp_low_access.constprop.1>:
}

static inline uint32_t adiv5_dp_low_access(struct ADIv5_DP_s *dp, uint8_t RnW,
 8002168:	b538      	push	{r3, r4, r5, lr}
 800216a:	1c0d      	adds	r5, r1, #0
 800216c:	1c13      	adds	r3, r2, #0
                                           uint16_t addr, uint32_t value)
{
	return dp->low_access(dp, RnW, addr, value);
 800216e:	6904      	ldr	r4, [r0, #16]
 8002170:	1c2a      	adds	r2, r5, #0
 8002172:	2100      	movs	r1, #0
 8002174:	47a0      	blx	r4
}
 8002176:	bd38      	pop	{r3, r4, r5, pc}

08002178 <cortexm_regs_write>:
			*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
		}
}

static void cortexm_regs_write(target *t, const void *data)
{
 8002178:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ADIv5_AP_t *ap = cortexm_ap(t);
	const uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 800217a:	2202      	movs	r2, #2
			*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
		}
}

static void cortexm_regs_write(target *t, const void *data)
{
 800217c:	1c0e      	adds	r6, r1, #0
	ADIv5_AP_t *ap = cortexm_ap(t);
	const uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 800217e:	2180      	movs	r1, #128	; 0x80
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 8002180:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
	ADIv5_AP_t *ap = cortexm_ap(t);
	const uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 8002182:	0049      	lsls	r1, r1, #1
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 8002184:	681c      	ldr	r4, [r3, #0]
			*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
		}
}

static void cortexm_regs_write(target *t, const void *data)
{
 8002186:	1c07      	adds	r7, r0, #0
	ADIv5_AP_t *ap = cortexm_ap(t);
	const uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 8002188:	69a3      	ldr	r3, [r4, #24]
 800218a:	1c20      	adds	r0, r4, #0
 800218c:	431a      	orrs	r2, r3
 800218e:	f7fd ffdf 	bl	8000150 <adiv5_ap_write>

	/* Map the banked data registers (0x10-0x1c) to the
	 * debug registers DHCSR, DCRSR, DCRDR and DEMCR respectively */
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, CORTEXM_DHCSR);
 8002192:	2182      	movs	r1, #130	; 0x82
 8002194:	4a20      	ldr	r2, [pc, #128]	; (8002218 <cortexm_regs_write+0xa0>)
 8002196:	0049      	lsls	r1, r1, #1
 8002198:	6860      	ldr	r0, [r4, #4]
 800219a:	f7ff ffe5 	bl	8002168 <adiv5_dp_low_access.constprop.1>

	/* Walk the regnum_cortex_m array, writing the registers it
	 * calls out. */
	adiv5_ap_write(ap, ADIV5_AP_DB(DB_DCRDR), *regs++); /* Required to switch banks */
 800219e:	218c      	movs	r1, #140	; 0x8c
 80021a0:	1c20      	adds	r0, r4, #0
 80021a2:	0049      	lsls	r1, r1, #1
 80021a4:	6832      	ldr	r2, [r6, #0]
 80021a6:	f7fd ffd3 	bl	8000150 <adiv5_ap_write>
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
 80021aa:	218a      	movs	r1, #138	; 0x8a
 80021ac:	2280      	movs	r2, #128	; 0x80
 80021ae:	6860      	ldr	r0, [r4, #4]
 80021b0:	0049      	lsls	r1, r1, #1
 80021b2:	0252      	lsls	r2, r2, #9
 80021b4:	f7ff ffd8 	bl	8002168 <adiv5_dp_low_access.constprop.1>
 80021b8:	2500      	movs	r5, #0
	                    0x10000 | regnum_cortex_m[0]);
	for(i = 1; i < sizeof(regnum_cortex_m) / 4; i++) {
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
 80021ba:	218c      	movs	r1, #140	; 0x8c
 80021bc:	1973      	adds	r3, r6, r5
 80021be:	685a      	ldr	r2, [r3, #4]
 80021c0:	0049      	lsls	r1, r1, #1
 80021c2:	6860      	ldr	r0, [r4, #4]
 80021c4:	f7ff ffd0 	bl	8002168 <adiv5_dp_low_access.constprop.1>
		                    ADIV5_AP_DB(DB_DCRDR), *regs++);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
 80021c8:	2280      	movs	r2, #128	; 0x80
 80021ca:	218a      	movs	r1, #138	; 0x8a
 80021cc:	4b13      	ldr	r3, [pc, #76]	; (800221c <cortexm_regs_write+0xa4>)
 80021ce:	0252      	lsls	r2, r2, #9
 80021d0:	195b      	adds	r3, r3, r5
 80021d2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80021d4:	6860      	ldr	r0, [r4, #4]
 80021d6:	431a      	orrs	r2, r3
 80021d8:	0049      	lsls	r1, r1, #1
 80021da:	3504      	adds	r5, #4
 80021dc:	f7ff ffc4 	bl	8002168 <adiv5_dp_low_access.constprop.1>
	/* Walk the regnum_cortex_m array, writing the registers it
	 * calls out. */
	adiv5_ap_write(ap, ADIV5_AP_DB(DB_DCRDR), *regs++); /* Required to switch banks */
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
	                    0x10000 | regnum_cortex_m[0]);
	for(i = 1; i < sizeof(regnum_cortex_m) / 4; i++) {
 80021e0:	2d4c      	cmp	r5, #76	; 0x4c
 80021e2:	d1ea      	bne.n	80021ba <cortexm_regs_write+0x42>
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
		                    ADIV5_AP_DB(DB_DCRDR), *regs++);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
		                    0x10000 | regnum_cortex_m[i]);
	}
	if (t->target_options & TOPT_FLAVOUR_V7MF)
 80021e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80021e6:	2500      	movs	r5, #0
 80021e8:	079b      	lsls	r3, r3, #30
 80021ea:	d514      	bpl.n	8002216 <cortexm_regs_write+0x9e>
		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
 80021ec:	218c      	movs	r1, #140	; 0x8c
 80021ee:	1973      	adds	r3, r6, r5
 80021f0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80021f2:	0049      	lsls	r1, r1, #1
 80021f4:	6860      	ldr	r0, [r4, #4]
 80021f6:	f7ff ffb7 	bl	8002168 <adiv5_dp_low_access.constprop.1>
			                    ADIV5_AP_DB(DB_DCRDR), *regs++);
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
 80021fa:	2280      	movs	r2, #128	; 0x80
 80021fc:	218a      	movs	r1, #138	; 0x8a
			                    ADIV5_AP_DB(DB_DCRSR),
			                    0x10000 | regnum_cortex_mf[i]);
 80021fe:	4b08      	ldr	r3, [pc, #32]	; (8002220 <cortexm_regs_write+0xa8>)
	}
	if (t->target_options & TOPT_FLAVOUR_V7MF)
		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
			                    ADIV5_AP_DB(DB_DCRDR), *regs++);
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
 8002200:	0252      	lsls	r2, r2, #9
			                    ADIV5_AP_DB(DB_DCRSR),
			                    0x10000 | regnum_cortex_mf[i]);
 8002202:	3324      	adds	r3, #36	; 0x24
	}
	if (t->target_options & TOPT_FLAVOUR_V7MF)
		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
			                    ADIV5_AP_DB(DB_DCRDR), *regs++);
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
 8002204:	58eb      	ldr	r3, [r5, r3]
 8002206:	6860      	ldr	r0, [r4, #4]
 8002208:	431a      	orrs	r2, r3
 800220a:	0049      	lsls	r1, r1, #1
 800220c:	3504      	adds	r5, #4
 800220e:	f7ff ffab 	bl	8002168 <adiv5_dp_low_access.constprop.1>
		                    ADIV5_AP_DB(DB_DCRDR), *regs++);
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
		                    0x10000 | regnum_cortex_m[i]);
	}
	if (t->target_options & TOPT_FLAVOUR_V7MF)
		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
 8002212:	2d84      	cmp	r5, #132	; 0x84
 8002214:	d1ea      	bne.n	80021ec <cortexm_regs_write+0x74>
			                    ADIV5_AP_DB(DB_DCRDR), *regs++);
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
			                    ADIV5_AP_DB(DB_DCRSR),
			                    0x10000 | regnum_cortex_mf[i]);
		}
}
 8002216:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002218:	e000edf0 	.word	0xe000edf0
 800221c:	0801063c 	.word	0x0801063c
 8002220:	080106bc 	.word	0x080106bc

08002224 <cortexm_regs_read>:
}

enum { DB_DHCSR, DB_DCRSR, DB_DCRDR, DB_DEMCR };

static void cortexm_regs_read(target *t, void *data)
{
 8002224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ADIv5_AP_t *ap = cortexm_ap(t);
	uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 8002226:	2202      	movs	r2, #2
}

enum { DB_DHCSR, DB_DCRSR, DB_DCRDR, DB_DEMCR };

static void cortexm_regs_read(target *t, void *data)
{
 8002228:	1c0e      	adds	r6, r1, #0
	ADIv5_AP_t *ap = cortexm_ap(t);
	uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 800222a:	2180      	movs	r1, #128	; 0x80
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 800222c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
	ADIv5_AP_t *ap = cortexm_ap(t);
	uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 800222e:	0049      	lsls	r1, r1, #1
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 8002230:	681c      	ldr	r4, [r3, #0]
}

enum { DB_DHCSR, DB_DCRSR, DB_DCRDR, DB_DEMCR };

static void cortexm_regs_read(target *t, void *data)
{
 8002232:	1c07      	adds	r7, r0, #0
	ADIv5_AP_t *ap = cortexm_ap(t);
	uint32_t *regs = data;
	unsigned i;

	/* FIXME: Describe what's really going on here */
	adiv5_ap_write(ap, ADIV5_AP_CSW, ap->csw | ADIV5_AP_CSW_SIZE_WORD);
 8002234:	69a3      	ldr	r3, [r4, #24]
 8002236:	1c20      	adds	r0, r4, #0
 8002238:	431a      	orrs	r2, r3
 800223a:	f7fd ff89 	bl	8000150 <adiv5_ap_write>

	/* Map the banked data registers (0x10-0x1c) to the
	 * debug registers DHCSR, DCRSR, DCRDR and DEMCR respectively */
	adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_TAR, CORTEXM_DHCSR);
 800223e:	2182      	movs	r1, #130	; 0x82
 8002240:	4a1d      	ldr	r2, [pc, #116]	; (80022b8 <cortexm_regs_read+0x94>)
 8002242:	0049      	lsls	r1, r1, #1
 8002244:	6860      	ldr	r0, [r4, #4]
 8002246:	f7ff ff8f 	bl	8002168 <adiv5_dp_low_access.constprop.1>

	/* Walk the regnum_cortex_m array, reading the registers it
	 * calls out. */
	adiv5_ap_write(ap, ADIV5_AP_DB(DB_DCRSR), regnum_cortex_m[0]); /* Required to switch banks */
 800224a:	218a      	movs	r1, #138	; 0x8a
 800224c:	1c20      	adds	r0, r4, #0
 800224e:	0049      	lsls	r1, r1, #1
 8002250:	2200      	movs	r2, #0
 8002252:	f7fd ff7d 	bl	8000150 <adiv5_ap_write>
	};
} ADIv5_DP_t;

static inline uint32_t adiv5_dp_read(ADIv5_DP_t *dp, uint16_t addr)
{
	return dp->dp_read(dp, addr);
 8002256:	218c      	movs	r1, #140	; 0x8c
	*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
 8002258:	6860      	ldr	r0, [r4, #4]
 800225a:	0049      	lsls	r1, r1, #1
 800225c:	6883      	ldr	r3, [r0, #8]
 800225e:	4798      	blx	r3
 8002260:	2500      	movs	r5, #0
 8002262:	6030      	str	r0, [r6, #0]
	for(i = 1; i < sizeof(regnum_cortex_m) / 4; i++) {
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
 8002264:	218a      	movs	r1, #138	; 0x8a
 8002266:	4b15      	ldr	r3, [pc, #84]	; (80022bc <cortexm_regs_read+0x98>)
 8002268:	0049      	lsls	r1, r1, #1
 800226a:	195b      	adds	r3, r3, r5
 800226c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800226e:	6860      	ldr	r0, [r4, #4]
 8002270:	f7ff ff7a 	bl	8002168 <adiv5_dp_low_access.constprop.1>
 8002274:	218c      	movs	r1, #140	; 0x8c
		                    regnum_cortex_m[i]);
		*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
 8002276:	6860      	ldr	r0, [r4, #4]
 8002278:	0049      	lsls	r1, r1, #1
 800227a:	6883      	ldr	r3, [r0, #8]
 800227c:	4798      	blx	r3
 800227e:	1973      	adds	r3, r6, r5
 8002280:	3504      	adds	r5, #4
 8002282:	6058      	str	r0, [r3, #4]

	/* Walk the regnum_cortex_m array, reading the registers it
	 * calls out. */
	adiv5_ap_write(ap, ADIV5_AP_DB(DB_DCRSR), regnum_cortex_m[0]); /* Required to switch banks */
	*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
	for(i = 1; i < sizeof(regnum_cortex_m) / 4; i++) {
 8002284:	2d4c      	cmp	r5, #76	; 0x4c
 8002286:	d1ed      	bne.n	8002264 <cortexm_regs_read+0x40>
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
		                    regnum_cortex_m[i]);
		*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
	}
	if (t->target_options & TOPT_FLAVOUR_V7MF)
 8002288:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800228a:	2500      	movs	r5, #0
 800228c:	079b      	lsls	r3, r3, #30
 800228e:	d511      	bpl.n	80022b4 <cortexm_regs_read+0x90>
		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
 8002290:	218a      	movs	r1, #138	; 0x8a
 8002292:	4b0b      	ldr	r3, [pc, #44]	; (80022c0 <cortexm_regs_read+0x9c>)
 8002294:	0049      	lsls	r1, r1, #1
 8002296:	3324      	adds	r3, #36	; 0x24
 8002298:	58ea      	ldr	r2, [r5, r3]
 800229a:	6860      	ldr	r0, [r4, #4]
 800229c:	f7ff ff64 	bl	8002168 <adiv5_dp_low_access.constprop.1>
 80022a0:	218c      	movs	r1, #140	; 0x8c
			                    ADIV5_AP_DB(DB_DCRSR),
			                    regnum_cortex_mf[i]);
			*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
 80022a2:	6860      	ldr	r0, [r4, #4]
 80022a4:	0049      	lsls	r1, r1, #1
 80022a6:	6883      	ldr	r3, [r0, #8]
 80022a8:	4798      	blx	r3
 80022aa:	1973      	adds	r3, r6, r5
 80022ac:	3504      	adds	r5, #4
 80022ae:	6518      	str	r0, [r3, #80]	; 0x50
		adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE, ADIV5_AP_DB(DB_DCRSR),
		                    regnum_cortex_m[i]);
		*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
	}
	if (t->target_options & TOPT_FLAVOUR_V7MF)
		for(i = 0; i < sizeof(regnum_cortex_mf) / 4; i++) {
 80022b0:	2d84      	cmp	r5, #132	; 0x84
 80022b2:	d1ed      	bne.n	8002290 <cortexm_regs_read+0x6c>
			adiv5_dp_low_access(ap->dp, ADIV5_LOW_WRITE,
			                    ADIV5_AP_DB(DB_DCRSR),
			                    regnum_cortex_mf[i]);
			*regs++ = adiv5_dp_read(ap->dp, ADIV5_AP_DB(DB_DCRDR));
		}
}
 80022b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80022b6:	46c0      	nop			; (mov r8, r8)
 80022b8:	e000edf0 	.word	0xe000edf0
 80022bc:	0801063c 	.word	0x0801063c
 80022c0:	080106bc 	.word	0x080106bc

080022c4 <cortexm_ap>:
	"  </feature>"
	"</target>";

ADIv5_AP_t *cortexm_ap(target *t)
{
	return ((struct cortexm_priv *)t->priv)->ap;
 80022c4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80022c6:	6818      	ldr	r0, [r3, #0]
}
 80022c8:	4770      	bx	lr

080022ca <cortexm_probe>:
	adiv5_ap_unref(((struct cortexm_priv *)priv)->ap);
	free(priv);
}

bool cortexm_probe(ADIv5_AP_t *ap)
{
 80022ca:	b570      	push	{r4, r5, r6, lr}
 80022cc:	1c05      	adds	r5, r0, #0
	target *t;

	t = target_new();
 80022ce:	f005 fe7f 	bl	8007fd0 <target_new>
 80022d2:	1c04      	adds	r4, r0, #0
	adiv5_ap_ref(ap);
 80022d4:	1c28      	adds	r0, r5, #0
 80022d6:	f7fd ff17 	bl	8000108 <adiv5_ap_ref>
	struct cortexm_priv *priv = calloc(1, sizeof(*priv));
 80022da:	2124      	movs	r1, #36	; 0x24
 80022dc:	2001      	movs	r0, #1
 80022de:	f00a facb 	bl	800c878 <calloc>
	t->priv = priv;
	t->priv_free = cortexm_priv_free;
 80022e2:	4b5d      	ldr	r3, [pc, #372]	; (8002458 <cortexm_probe+0x18e>)
	target *t;

	t = target_new();
	adiv5_ap_ref(ap);
	struct cortexm_priv *priv = calloc(1, sizeof(*priv));
	t->priv = priv;
 80022e4:	66e0      	str	r0, [r4, #108]	; 0x6c
	t->priv_free = cortexm_priv_free;
 80022e6:	6723      	str	r3, [r4, #112]	; 0x70
	priv->ap = ap;

	t->check_error = cortexm_check_error;
 80022e8:	4b5c      	ldr	r3, [pc, #368]	; (800245c <cortexm_probe+0x192>)
	t = target_new();
	adiv5_ap_ref(ap);
	struct cortexm_priv *priv = calloc(1, sizeof(*priv));
	t->priv = priv;
	t->priv_free = cortexm_priv_free;
	priv->ap = ap;
 80022ea:	6005      	str	r5, [r0, #0]

	t->check_error = cortexm_check_error;
 80022ec:	6123      	str	r3, [r4, #16]
	t->mem_read = cortexm_mem_read;
 80022ee:	4b5c      	ldr	r3, [pc, #368]	; (8002460 <cortexm_probe+0x196>)
	t->mem_write = cortexm_mem_write;

	t->driver = cortexm_driver_str;
 80022f0:	4a5c      	ldr	r2, [pc, #368]	; (8002464 <cortexm_probe+0x19a>)
	t->priv = priv;
	t->priv_free = cortexm_priv_free;
	priv->ap = ap;

	t->check_error = cortexm_check_error;
	t->mem_read = cortexm_mem_read;
 80022f2:	6163      	str	r3, [r4, #20]
	t->mem_write = cortexm_mem_write;
 80022f4:	4b5c      	ldr	r3, [pc, #368]	; (8002468 <cortexm_probe+0x19e>)

	t->driver = cortexm_driver_str;
 80022f6:	6622      	str	r2, [r4, #96]	; 0x60
	t->priv_free = cortexm_priv_free;
	priv->ap = ap;

	t->check_error = cortexm_check_error;
	t->mem_read = cortexm_mem_read;
	t->mem_write = cortexm_mem_write;
 80022f8:	61a3      	str	r3, [r4, #24]

	t->driver = cortexm_driver_str;

	t->attach = cortexm_attach;
 80022fa:	4b5c      	ldr	r3, [pc, #368]	; (800246c <cortexm_probe+0x1a2>)
{
	target *t;

	t = target_new();
	adiv5_ap_ref(ap);
	struct cortexm_priv *priv = calloc(1, sizeof(*priv));
 80022fc:	1c06      	adds	r6, r0, #0
	t->mem_read = cortexm_mem_read;
	t->mem_write = cortexm_mem_write;

	t->driver = cortexm_driver_str;

	t->attach = cortexm_attach;
 80022fe:	60a3      	str	r3, [r4, #8]
	t->detach = cortexm_detach;
 8002300:	4b5b      	ldr	r3, [pc, #364]	; (8002470 <cortexm_probe+0x1a6>)
	t->regs_size = sizeof(regnum_cortex_m);

	t->breakwatch_set = cortexm_breakwatch_set;
	t->breakwatch_clear = cortexm_breakwatch_clear;

	target_add_commands(t, cortexm_cmd_list, cortexm_driver_str);
 8002302:	1c20      	adds	r0, r4, #0
	t->mem_write = cortexm_mem_write;

	t->driver = cortexm_driver_str;

	t->attach = cortexm_attach;
	t->detach = cortexm_detach;
 8002304:	60e3      	str	r3, [r4, #12]

	/* Should probe here to make sure it's Cortex-M3 */
	t->tdesc = tdesc_cortex_m;
 8002306:	4b5b      	ldr	r3, [pc, #364]	; (8002474 <cortexm_probe+0x1aa>)

	target_add_commands(t, cortexm_cmd_list, cortexm_driver_str);

	/* Probe for FP extension */
	uint32_t cpacr = target_mem_read32(t, CORTEXM_CPACR);
	cpacr |= 0x00F00000; /* CP10 = 0b11, CP11 = 0b11 */
 8002308:	25f0      	movs	r5, #240	; 0xf0

	t->attach = cortexm_attach;
	t->detach = cortexm_detach;

	/* Should probe here to make sure it's Cortex-M3 */
	t->tdesc = tdesc_cortex_m;
 800230a:	3328      	adds	r3, #40	; 0x28
 800230c:	6223      	str	r3, [r4, #32]
	t->regs_read = cortexm_regs_read;
 800230e:	4b5a      	ldr	r3, [pc, #360]	; (8002478 <cortexm_probe+0x1ae>)

	target_add_commands(t, cortexm_cmd_list, cortexm_driver_str);

	/* Probe for FP extension */
	uint32_t cpacr = target_mem_read32(t, CORTEXM_CPACR);
	cpacr |= 0x00F00000; /* CP10 = 0b11, CP11 = 0b11 */
 8002310:	042d      	lsls	r5, r5, #16
	t->attach = cortexm_attach;
	t->detach = cortexm_detach;

	/* Should probe here to make sure it's Cortex-M3 */
	t->tdesc = tdesc_cortex_m;
	t->regs_read = cortexm_regs_read;
 8002312:	6263      	str	r3, [r4, #36]	; 0x24
	t->regs_write = cortexm_regs_write;
 8002314:	4b59      	ldr	r3, [pc, #356]	; (800247c <cortexm_probe+0x1b2>)
 8002316:	62a3      	str	r3, [r4, #40]	; 0x28

	t->reset = cortexm_reset;
 8002318:	4b59      	ldr	r3, [pc, #356]	; (8002480 <cortexm_probe+0x1b6>)
 800231a:	62e3      	str	r3, [r4, #44]	; 0x2c
	t->halt_request = cortexm_halt_request;
 800231c:	4b59      	ldr	r3, [pc, #356]	; (8002484 <cortexm_probe+0x1ba>)
 800231e:	6363      	str	r3, [r4, #52]	; 0x34
	t->halt_poll = cortexm_halt_poll;
 8002320:	4b59      	ldr	r3, [pc, #356]	; (8002488 <cortexm_probe+0x1be>)
 8002322:	63a3      	str	r3, [r4, #56]	; 0x38
	t->halt_resume = cortexm_halt_resume;
 8002324:	4b59      	ldr	r3, [pc, #356]	; (800248c <cortexm_probe+0x1c2>)
 8002326:	63e3      	str	r3, [r4, #60]	; 0x3c
	t->regs_size = sizeof(regnum_cortex_m);
 8002328:	2350      	movs	r3, #80	; 0x50
 800232a:	61e3      	str	r3, [r4, #28]

	t->breakwatch_set = cortexm_breakwatch_set;
 800232c:	4b58      	ldr	r3, [pc, #352]	; (8002490 <cortexm_probe+0x1c6>)
 800232e:	6423      	str	r3, [r4, #64]	; 0x40
	t->breakwatch_clear = cortexm_breakwatch_clear;
 8002330:	4b58      	ldr	r3, [pc, #352]	; (8002494 <cortexm_probe+0x1ca>)

	target_add_commands(t, cortexm_cmd_list, cortexm_driver_str);
 8002332:	4959      	ldr	r1, [pc, #356]	; (8002498 <cortexm_probe+0x1ce>)
	t->halt_poll = cortexm_halt_poll;
	t->halt_resume = cortexm_halt_resume;
	t->regs_size = sizeof(regnum_cortex_m);

	t->breakwatch_set = cortexm_breakwatch_set;
	t->breakwatch_clear = cortexm_breakwatch_clear;
 8002334:	6463      	str	r3, [r4, #68]	; 0x44

	target_add_commands(t, cortexm_cmd_list, cortexm_driver_str);
 8002336:	3178      	adds	r1, #120	; 0x78
 8002338:	f005 febc 	bl	80080b4 <target_add_commands>

	/* Probe for FP extension */
	uint32_t cpacr = target_mem_read32(t, CORTEXM_CPACR);
 800233c:	4957      	ldr	r1, [pc, #348]	; (800249c <cortexm_probe+0x1d2>)
 800233e:	1c20      	adds	r0, r4, #0
 8002340:	f006 f8f4 	bl	800852c <target_mem_read32>
	cpacr |= 0x00F00000; /* CP10 = 0b11, CP11 = 0b11 */
 8002344:	4305      	orrs	r5, r0
	target_mem_write32(t, CORTEXM_CPACR, cpacr);
 8002346:	4955      	ldr	r1, [pc, #340]	; (800249c <cortexm_probe+0x1d2>)
 8002348:	1c20      	adds	r0, r4, #0
 800234a:	1c2a      	adds	r2, r5, #0
 800234c:	f006 f8f6 	bl	800853c <target_mem_write32>
	if (target_mem_read32(t, CORTEXM_CPACR) == cpacr) {
 8002350:	1c20      	adds	r0, r4, #0
 8002352:	4952      	ldr	r1, [pc, #328]	; (800249c <cortexm_probe+0x1d2>)
 8002354:	f006 f8ea 	bl	800852c <target_mem_read32>
 8002358:	42a8      	cmp	r0, r5
 800235a:	d109      	bne.n	8002370 <cortexm_probe+0xa6>
		t->target_options |= TOPT_FLAVOUR_V7MF;
 800235c:	2302      	movs	r3, #2
 800235e:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8002360:	4313      	orrs	r3, r2
 8002362:	64e3      	str	r3, [r4, #76]	; 0x4c
		t->regs_size += sizeof(regnum_cortex_mf);
 8002364:	69e3      	ldr	r3, [r4, #28]
 8002366:	3384      	adds	r3, #132	; 0x84
 8002368:	61e3      	str	r3, [r4, #28]
		t->tdesc = tdesc_cortex_mf;
 800236a:	4b4d      	ldr	r3, [pc, #308]	; (80024a0 <cortexm_probe+0x1d6>)
 800236c:	3310      	adds	r3, #16
 800236e:	6223      	str	r3, [r4, #32]
	}

	/* Default vectors to catch */
	priv->demcr = CORTEXM_DEMCR_TRCENA | CORTEXM_DEMCR_VC_HARDERR |
 8002370:	4b4c      	ldr	r3, [pc, #304]	; (80024a4 <cortexm_probe+0x1da>)
			CORTEXM_DEMCR_VC_CORERESET;

#define PROBE(x) \
	do { if ((x)(t)) return true; else target_check_error(t); } while (0)

	PROBE(stm32f1_probe);
 8002372:	1c20      	adds	r0, r4, #0
		t->regs_size += sizeof(regnum_cortex_mf);
		t->tdesc = tdesc_cortex_mf;
	}

	/* Default vectors to catch */
	priv->demcr = CORTEXM_DEMCR_TRCENA | CORTEXM_DEMCR_VC_HARDERR |
 8002374:	6233      	str	r3, [r6, #32]
			CORTEXM_DEMCR_VC_CORERESET;

#define PROBE(x) \
	do { if ((x)(t)) return true; else target_check_error(t); } while (0)

	PROBE(stm32f1_probe);
 8002376:	f004 fbb3 	bl	8006ae0 <stm32f1_probe>
 800237a:	2800      	cmp	r0, #0
 800237c:	d16a      	bne.n	8002454 <cortexm_probe+0x18a>
 800237e:	1c20      	adds	r0, r4, #0
 8002380:	f006 f84a 	bl	8008418 <target_check_error>
	PROBE(stm32f4_probe);
 8002384:	1c20      	adds	r0, r4, #0
 8002386:	f004 fe19 	bl	8006fbc <stm32f4_probe>
 800238a:	2800      	cmp	r0, #0
 800238c:	d162      	bne.n	8002454 <cortexm_probe+0x18a>
 800238e:	1c20      	adds	r0, r4, #0
 8002390:	f006 f842 	bl	8008418 <target_check_error>
	PROBE(stm32l0_probe);   /* STM32L0xx & STM32L1xx */
 8002394:	1c20      	adds	r0, r4, #0
 8002396:	f005 fb8d 	bl	8007ab4 <stm32l0_probe>
 800239a:	2800      	cmp	r0, #0
 800239c:	d15a      	bne.n	8002454 <cortexm_probe+0x18a>
 800239e:	1c20      	adds	r0, r4, #0
 80023a0:	f006 f83a 	bl	8008418 <target_check_error>
	PROBE(stm32l4_probe);
 80023a4:	1c20      	adds	r0, r4, #0
 80023a6:	f005 fd23 	bl	8007df0 <stm32l4_probe>
 80023aa:	2800      	cmp	r0, #0
 80023ac:	d152      	bne.n	8002454 <cortexm_probe+0x18a>
 80023ae:	1c20      	adds	r0, r4, #0
 80023b0:	f006 f832 	bl	8008418 <target_check_error>
	PROBE(lpc11xx_probe);
 80023b4:	1c20      	adds	r0, r4, #0
 80023b6:	f001 ffcf 	bl	8004358 <lpc11xx_probe>
 80023ba:	2800      	cmp	r0, #0
 80023bc:	d14a      	bne.n	8002454 <cortexm_probe+0x18a>
 80023be:	1c20      	adds	r0, r4, #0
 80023c0:	f006 f82a 	bl	8008418 <target_check_error>
	PROBE(lpc15xx_probe);
 80023c4:	1c20      	adds	r0, r4, #0
 80023c6:	f002 f8e5 	bl	8004594 <lpc15xx_probe>
 80023ca:	2800      	cmp	r0, #0
 80023cc:	d142      	bne.n	8002454 <cortexm_probe+0x18a>
 80023ce:	1c20      	adds	r0, r4, #0
 80023d0:	f006 f822 	bl	8008418 <target_check_error>
	PROBE(lpc43xx_probe);
 80023d4:	1c20      	adds	r0, r4, #0
 80023d6:	f002 f9fb 	bl	80047d0 <lpc43xx_probe>
 80023da:	2800      	cmp	r0, #0
 80023dc:	d13a      	bne.n	8002454 <cortexm_probe+0x18a>
 80023de:	1c20      	adds	r0, r4, #0
 80023e0:	f006 f81a 	bl	8008418 <target_check_error>
	PROBE(sam3x_probe);
 80023e4:	1c20      	adds	r0, r4, #0
 80023e6:	f003 fc1b 	bl	8005c20 <sam3x_probe>
 80023ea:	2800      	cmp	r0, #0
 80023ec:	d132      	bne.n	8002454 <cortexm_probe+0x18a>
 80023ee:	1c20      	adds	r0, r4, #0
 80023f0:	f006 f812 	bl	8008418 <target_check_error>
	PROBE(sam4l_probe);
 80023f4:	1c20      	adds	r0, r4, #0
 80023f6:	f003 fde5 	bl	8005fc4 <sam4l_probe>
 80023fa:	2800      	cmp	r0, #0
 80023fc:	d12a      	bne.n	8002454 <cortexm_probe+0x18a>
 80023fe:	1c20      	adds	r0, r4, #0
 8002400:	f006 f80a 	bl	8008418 <target_check_error>
	PROBE(nrf51_probe);
 8002404:	1c20      	adds	r0, r4, #0
 8002406:	f002 fdc9 	bl	8004f9c <nrf51_probe>
 800240a:	2800      	cmp	r0, #0
 800240c:	d122      	bne.n	8002454 <cortexm_probe+0x18a>
 800240e:	1c20      	adds	r0, r4, #0
 8002410:	f006 f802 	bl	8008418 <target_check_error>
	PROBE(samd_probe);
 8002414:	1c20      	adds	r0, r4, #0
 8002416:	f004 f8dd 	bl	80065d4 <samd_probe>
 800241a:	2800      	cmp	r0, #0
 800241c:	d11a      	bne.n	8002454 <cortexm_probe+0x18a>
 800241e:	1c20      	adds	r0, r4, #0
 8002420:	f005 fffa 	bl	8008418 <target_check_error>
	PROBE(lmi_probe);
 8002424:	1c20      	adds	r0, r4, #0
 8002426:	f001 fe33 	bl	8004090 <lmi_probe>
 800242a:	2800      	cmp	r0, #0
 800242c:	d112      	bne.n	8002454 <cortexm_probe+0x18a>
 800242e:	1c20      	adds	r0, r4, #0
 8002430:	f005 fff2 	bl	8008418 <target_check_error>
	PROBE(kinetis_probe);
 8002434:	1c20      	adds	r0, r4, #0
 8002436:	f002 fb13 	bl	8004a60 <kinetis_probe>
 800243a:	2800      	cmp	r0, #0
 800243c:	d10a      	bne.n	8002454 <cortexm_probe+0x18a>
 800243e:	1c20      	adds	r0, r4, #0
 8002440:	f005 ffea 	bl	8008418 <target_check_error>
	PROBE(efm32_probe);
 8002444:	1c20      	adds	r0, r4, #0
 8002446:	f000 f975 	bl	8002734 <efm32_probe>
 800244a:	2800      	cmp	r0, #0
 800244c:	d102      	bne.n	8002454 <cortexm_probe+0x18a>
 800244e:	1c20      	adds	r0, r4, #0
 8002450:	f005 ffe2 	bl	8008418 <target_check_error>
#undef PROBE

	return true;
}
 8002454:	2001      	movs	r0, #1
 8002456:	bd70      	pop	{r4, r5, r6, pc}
 8002458:	08001f71 	.word	0x08001f71
 800245c:	0800182d 	.word	0x0800182d
 8002460:	08001f65 	.word	0x08001f65
 8002464:	2000000d 	.word	0x2000000d
 8002468:	08001f59 	.word	0x08001f59
 800246c:	08001f83 	.word	0x08001f83
 8002470:	08001971 	.word	0x08001971
 8002474:	0801073c 	.word	0x0801073c
 8002478:	08002225 	.word	0x08002225
 800247c:	08002179 	.word	0x08002179
 8002480:	08001efd 	.word	0x08001efd
 8002484:	080019e9 	.word	0x080019e9
 8002488:	08001ac9 	.word	0x08001ac9
 800248c:	08001a49 	.word	0x08001a49
 8002490:	0800206d 	.word	0x0800206d
 8002494:	0800192d 	.word	0x0800192d
 8002498:	08010abc 	.word	0x08010abc
 800249c:	e000ed88 	.word	0xe000ed88
 80024a0:	08010b3c 	.word	0x08010b3c
 80024a4:	01000401 	.word	0x01000401

080024a8 <cortexm_run_stub>:
	return 0;
}

int cortexm_run_stub(target *t, uint32_t loadaddr,
                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
{
 80024a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80024aa:	af00      	add	r7, sp, #0
 80024ac:	603b      	str	r3, [r7, #0]
	uint32_t regs[t->regs_size / 4];
 80024ae:	69c3      	ldr	r3, [r0, #28]
	return 0;
}

int cortexm_run_stub(target *t, uint32_t loadaddr,
                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
{
 80024b0:	1c16      	adds	r6, r2, #0
	uint32_t regs[t->regs_size / 4];
 80024b2:	089a      	lsrs	r2, r3, #2
 80024b4:	0092      	lsls	r2, r2, #2
 80024b6:	1c13      	adds	r3, r2, #0
	return 0;
}

int cortexm_run_stub(target *t, uint32_t loadaddr,
                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
{
 80024b8:	6079      	str	r1, [r7, #4]
	uint32_t regs[t->regs_size / 4];
 80024ba:	4669      	mov	r1, sp
 80024bc:	330a      	adds	r3, #10
 80024be:	08db      	lsrs	r3, r3, #3
 80024c0:	00db      	lsls	r3, r3, #3
 80024c2:	1acb      	subs	r3, r1, r3
 80024c4:	469d      	mov	sp, r3
	return 0;
}

int cortexm_run_stub(target *t, uint32_t loadaddr,
                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
{
 80024c6:	1c05      	adds	r5, r0, #0
	uint32_t regs[t->regs_size / 4];

	memset(regs, 0, sizeof(regs));
 80024c8:	2100      	movs	r1, #0
 80024ca:	4668      	mov	r0, sp
 80024cc:	f00a fa11 	bl	800c8f2 <memset>
	regs[0] = r0;
	regs[1] = r1;
 80024d0:	683b      	ldr	r3, [r7, #0]
	regs[3] = r3;
	regs[15] = loadaddr;
	regs[16] = 0x1000000;
	regs[19] = 0;

	cortexm_regs_write(t, regs);
 80024d2:	4669      	mov	r1, sp
{
	uint32_t regs[t->regs_size / 4];

	memset(regs, 0, sizeof(regs));
	regs[0] = r0;
	regs[1] = r1;
 80024d4:	9301      	str	r3, [sp, #4]
	regs[2] = r2;
 80024d6:	6a3b      	ldr	r3, [r7, #32]
	regs[3] = r3;
	regs[15] = loadaddr;
	regs[16] = 0x1000000;
	regs[19] = 0;

	cortexm_regs_write(t, regs);
 80024d8:	1c28      	adds	r0, r5, #0
	uint32_t regs[t->regs_size / 4];

	memset(regs, 0, sizeof(regs));
	regs[0] = r0;
	regs[1] = r1;
	regs[2] = r2;
 80024da:	9302      	str	r3, [sp, #8]
	regs[3] = r3;
 80024dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
                     uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
{
	uint32_t regs[t->regs_size / 4];

	memset(regs, 0, sizeof(regs));
	regs[0] = r0;
 80024de:	9600      	str	r6, [sp, #0]
	regs[1] = r1;
	regs[2] = r2;
	regs[3] = r3;
 80024e0:	9303      	str	r3, [sp, #12]
	regs[15] = loadaddr;
 80024e2:	687b      	ldr	r3, [r7, #4]
 80024e4:	930f      	str	r3, [sp, #60]	; 0x3c
	regs[16] = 0x1000000;
 80024e6:	2380      	movs	r3, #128	; 0x80
 80024e8:	045b      	lsls	r3, r3, #17
 80024ea:	9310      	str	r3, [sp, #64]	; 0x40
	regs[19] = 0;
 80024ec:	2300      	movs	r3, #0
 80024ee:	9313      	str	r3, [sp, #76]	; 0x4c

	cortexm_regs_write(t, regs);
 80024f0:	f7ff fe42 	bl	8002178 <cortexm_regs_write>

	if (target_check_error(t))
 80024f4:	1c28      	adds	r0, r5, #0
 80024f6:	f005 ff8f 	bl	8008418 <target_check_error>
 80024fa:	1e01      	subs	r1, r0, #0
 80024fc:	d116      	bne.n	800252c <cortexm_run_stub+0x84>
		return -1;

	/* Execute the stub */
	cortexm_halt_resume(t, 0);
 80024fe:	1c28      	adds	r0, r5, #0
 8002500:	f7ff faa2 	bl	8001a48 <cortexm_halt_resume>
	while (!cortexm_halt_poll(t, NULL))
 8002504:	1c28      	adds	r0, r5, #0
 8002506:	2100      	movs	r1, #0
 8002508:	f7ff fade 	bl	8001ac8 <cortexm_halt_poll>
 800250c:	2800      	cmp	r0, #0
 800250e:	d0f9      	beq.n	8002504 <cortexm_run_stub+0x5c>
		;

	uint32_t pc = cortexm_pc_read(t);
 8002510:	1c28      	adds	r0, r5, #0
 8002512:	f7ff fa59 	bl	80019c8 <cortexm_pc_read>
 8002516:	1c01      	adds	r1, r0, #0
	uint16_t bkpt_instr = target_mem_read16(t, pc);
 8002518:	1c28      	adds	r0, r5, #0
 800251a:	f006 f816 	bl	800854a <target_mem_read16>
	if (bkpt_instr >> 8 != 0xbe)
 800251e:	0a03      	lsrs	r3, r0, #8
 8002520:	b29b      	uxth	r3, r3
		return -2;

	return bkpt_instr & 0xff;
 8002522:	b2c0      	uxtb	r0, r0
	while (!cortexm_halt_poll(t, NULL))
		;

	uint32_t pc = cortexm_pc_read(t);
	uint16_t bkpt_instr = target_mem_read16(t, pc);
	if (bkpt_instr >> 8 != 0xbe)
 8002524:	2bbe      	cmp	r3, #190	; 0xbe
 8002526:	d003      	beq.n	8002530 <cortexm_run_stub+0x88>
		return -2;
 8002528:	2002      	movs	r0, #2
 800252a:	e000      	b.n	800252e <cortexm_run_stub+0x86>
	regs[19] = 0;

	cortexm_regs_write(t, regs);

	if (target_check_error(t))
		return -1;
 800252c:	2001      	movs	r0, #1
		;

	uint32_t pc = cortexm_pc_read(t);
	uint16_t bkpt_instr = target_mem_read16(t, pc);
	if (bkpt_instr >> 8 != 0xbe)
		return -2;
 800252e:	4240      	negs	r0, r0

	return bkpt_instr & 0xff;
}
 8002530:	46bd      	mov	sp, r7
 8002532:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08002534 <generic_crc32>:
{
	return (crc << 8) ^ crc32_table[((crc >> 24) ^ data) & 255];
}

uint32_t generic_crc32(target *t, uint32_t base, size_t len)
{
 8002534:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t crc = -1;
 8002536:	2401      	movs	r4, #1
{
	return (crc << 8) ^ crc32_table[((crc >> 24) ^ data) & 255];
}

uint32_t generic_crc32(target *t, uint32_t base, size_t len)
{
 8002538:	1c0e      	adds	r6, r1, #0
 800253a:	1c15      	adds	r5, r2, #0
 800253c:	b0a3      	sub	sp, #140	; 0x8c
 800253e:	9001      	str	r0, [sp, #4]
	uint32_t crc = -1;
 8002540:	4264      	negs	r4, r4
	uint8_t bytes[128];

	while (len) {
 8002542:	2d00      	cmp	r5, #0
 8002544:	d019      	beq.n	800257a <generic_crc32+0x46>
		size_t read_len = MIN(sizeof(bytes), len);
 8002546:	1e2f      	subs	r7, r5, #0
 8002548:	2f80      	cmp	r7, #128	; 0x80
 800254a:	d900      	bls.n	800254e <generic_crc32+0x1a>
 800254c:	2780      	movs	r7, #128	; 0x80
		target_mem_read(t, bytes, base, read_len);
 800254e:	1c3b      	adds	r3, r7, #0
 8002550:	9801      	ldr	r0, [sp, #4]
 8002552:	a902      	add	r1, sp, #8
 8002554:	1c32      	adds	r2, r6, #0
 8002556:	f005 ff65 	bl	8008424 <target_mem_read>

		for (unsigned i = 0; i < read_len; i++)
 800255a:	2300      	movs	r3, #0
	0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4,
};

static uint32_t crc32_calc(uint32_t crc, uint8_t data)
{
	return (crc << 8) ^ crc32_table[((crc >> 24) ^ data) & 255];
 800255c:	a902      	add	r1, sp, #8
 800255e:	5c59      	ldrb	r1, [r3, r1]
 8002560:	0222      	lsls	r2, r4, #8
 8002562:	0e24      	lsrs	r4, r4, #24
 8002564:	404c      	eors	r4, r1
 8002566:	4906      	ldr	r1, [pc, #24]	; (8002580 <generic_crc32+0x4c>)
 8002568:	00a4      	lsls	r4, r4, #2
 800256a:	5864      	ldr	r4, [r4, r1]

	while (len) {
		size_t read_len = MIN(sizeof(bytes), len);
		target_mem_read(t, bytes, base, read_len);

		for (unsigned i = 0; i < read_len; i++)
 800256c:	3301      	adds	r3, #1
	0xBCB4666D, 0xB8757BDA, 0xB5365D03, 0xB1F740B4,
};

static uint32_t crc32_calc(uint32_t crc, uint8_t data)
{
	return (crc << 8) ^ crc32_table[((crc >> 24) ^ data) & 255];
 800256e:	4054      	eors	r4, r2

	while (len) {
		size_t read_len = MIN(sizeof(bytes), len);
		target_mem_read(t, bytes, base, read_len);

		for (unsigned i = 0; i < read_len; i++)
 8002570:	42bb      	cmp	r3, r7
 8002572:	d1f3      	bne.n	800255c <generic_crc32+0x28>
			crc = crc32_calc(crc, bytes[i]);

		base += read_len;
 8002574:	18f6      	adds	r6, r6, r3
		len -= read_len;
 8002576:	1aed      	subs	r5, r5, r3
 8002578:	e7e3      	b.n	8002542 <generic_crc32+0xe>
	}
	return crc;
}
 800257a:	1c20      	adds	r0, r4, #0
 800257c:	b023      	add	sp, #140	; 0x8c
 800257e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002580:	08011334 	.word	0x08011334

08002584 <efm32_flash_erase>:

/**
 * Erase flash row by row
 */
static int efm32_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8002584:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	target *t = f->t;
 8002586:	6985      	ldr	r5, [r0, #24]

/**
 * Erase flash row by row
 */
static int efm32_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8002588:	1c07      	adds	r7, r0, #0
 800258a:	1c0e      	adds	r6, r1, #0
 800258c:	1c14      	adds	r4, r2, #0
	target *t = f->t;

	/* Set WREN bit to enabel MSC write and erase functionality */
	target_mem_write32(t, EFM32_MSC_WRITECTRL, 1);
 800258e:	1c28      	adds	r0, r5, #0
 8002590:	4914      	ldr	r1, [pc, #80]	; (80025e4 <efm32_flash_erase+0x60>)
 8002592:	2201      	movs	r2, #1
 8002594:	f005 ffd2 	bl	800853c <target_mem_write32>

	while (len) {
 8002598:	2c00      	cmp	r4, #0
 800259a:	d020      	beq.n	80025de <efm32_flash_erase+0x5a>
		/* Write address of first word in row to erase it */
		target_mem_write32(t, EFM32_MSC_ADDRB, addr);
 800259c:	1c28      	adds	r0, r5, #0
 800259e:	4912      	ldr	r1, [pc, #72]	; (80025e8 <efm32_flash_erase+0x64>)
 80025a0:	1c32      	adds	r2, r6, #0
 80025a2:	f005 ffcb 	bl	800853c <target_mem_write32>
		target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_LADDRIM);
 80025a6:	1c28      	adds	r0, r5, #0
 80025a8:	4910      	ldr	r1, [pc, #64]	; (80025ec <efm32_flash_erase+0x68>)
 80025aa:	2201      	movs	r2, #1
 80025ac:	f005 ffc6 	bl	800853c <target_mem_write32>

		/* Issue the erase command */
		target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_ERASEPAGE );
 80025b0:	1c28      	adds	r0, r5, #0
 80025b2:	490e      	ldr	r1, [pc, #56]	; (80025ec <efm32_flash_erase+0x68>)
 80025b4:	2202      	movs	r2, #2
 80025b6:	f005 ffc1 	bl	800853c <target_mem_write32>

		/* Poll MSC Busy */
		while ((target_mem_read32(t, EFM32_MSC_STATUS) & EFM32_MSC_STATUS_BUSY)) {
 80025ba:	1c28      	adds	r0, r5, #0
 80025bc:	490c      	ldr	r1, [pc, #48]	; (80025f0 <efm32_flash_erase+0x6c>)
 80025be:	f005 ffb5 	bl	800852c <target_mem_read32>
 80025c2:	07c3      	lsls	r3, r0, #31
 80025c4:	d507      	bpl.n	80025d6 <efm32_flash_erase+0x52>
			if (target_check_error(t))
 80025c6:	1c28      	adds	r0, r5, #0
 80025c8:	f005 ff26 	bl	8008418 <target_check_error>
 80025cc:	2800      	cmp	r0, #0
 80025ce:	d0f4      	beq.n	80025ba <efm32_flash_erase+0x36>
				return -1;
 80025d0:	2001      	movs	r0, #1
 80025d2:	4240      	negs	r0, r0
 80025d4:	e004      	b.n	80025e0 <efm32_flash_erase+0x5c>
		}

		addr += f->blocksize;
 80025d6:	68bb      	ldr	r3, [r7, #8]
 80025d8:	18f6      	adds	r6, r6, r3
		len -= f->blocksize;
 80025da:	1ae4      	subs	r4, r4, r3
 80025dc:	e7dc      	b.n	8002598 <efm32_flash_erase+0x14>
	}

	return 0;
 80025de:	1c20      	adds	r0, r4, #0
}
 80025e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80025e2:	46c0      	nop			; (mov r8, r8)
 80025e4:	400c0008 	.word	0x400c0008
 80025e8:	400c0010 	.word	0x400c0010
 80025ec:	400c000c 	.word	0x400c000c
 80025f0:	400c001c 	.word	0x400c001c

080025f4 <efm32_flash_write>:
/**
 * Write flash page by page
 */
static int efm32_flash_write(struct target_flash *f,
			     target_addr dest, const void *src, size_t len)
{
 80025f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	(void)len;
	target *t = f->t;

	/* Write flashloader */
	target_mem_write(t, SRAM_BASE, efm32_flash_write_stub,
 80025f6:	2580      	movs	r5, #128	; 0x80
/**
 * Write flash page by page
 */
static int efm32_flash_write(struct target_flash *f,
			     target_addr dest, const void *src, size_t len)
{
 80025f8:	1c1e      	adds	r6, r3, #0
	(void)len;
	target *t = f->t;
 80025fa:	6984      	ldr	r4, [r0, #24]
/**
 * Write flash page by page
 */
static int efm32_flash_write(struct target_flash *f,
			     target_addr dest, const void *src, size_t len)
{
 80025fc:	b085      	sub	sp, #20
	(void)len;
	target *t = f->t;

	/* Write flashloader */
	target_mem_write(t, SRAM_BASE, efm32_flash_write_stub,
 80025fe:	05ad      	lsls	r5, r5, #22
			 sizeof(efm32_flash_write_stub));
	/* Write Buffer */
	target_mem_write(t, STUB_BUFFER_BASE, src, len);
 8002600:	4f0c      	ldr	r7, [pc, #48]	; (8002634 <efm32_flash_write+0x40>)
/**
 * Write flash page by page
 */
static int efm32_flash_write(struct target_flash *f,
			     target_addr dest, const void *src, size_t len)
{
 8002602:	9102      	str	r1, [sp, #8]
 8002604:	9203      	str	r2, [sp, #12]
	(void)len;
	target *t = f->t;

	/* Write flashloader */
	target_mem_write(t, SRAM_BASE, efm32_flash_write_stub,
 8002606:	1c29      	adds	r1, r5, #0
 8002608:	1c20      	adds	r0, r4, #0
 800260a:	4a0b      	ldr	r2, [pc, #44]	; (8002638 <efm32_flash_write+0x44>)
 800260c:	2360      	movs	r3, #96	; 0x60
 800260e:	f005 ff11 	bl	8008434 <target_mem_write>
			 sizeof(efm32_flash_write_stub));
	/* Write Buffer */
	target_mem_write(t, STUB_BUFFER_BASE, src, len);
 8002612:	1c39      	adds	r1, r7, #0
 8002614:	9a03      	ldr	r2, [sp, #12]
 8002616:	1c33      	adds	r3, r6, #0
 8002618:	1c20      	adds	r0, r4, #0
 800261a:	f005 ff0b 	bl	8008434 <target_mem_write>
	/* Run flashloader */
	return cortexm_run_stub(t, SRAM_BASE, dest, STUB_BUFFER_BASE, len, 0);
 800261e:	2300      	movs	r3, #0
 8002620:	9600      	str	r6, [sp, #0]
 8002622:	9301      	str	r3, [sp, #4]
 8002624:	1c20      	adds	r0, r4, #0
 8002626:	1c29      	adds	r1, r5, #0
 8002628:	9a02      	ldr	r2, [sp, #8]
 800262a:	1c3b      	adds	r3, r7, #0
 800262c:	f7ff ff3c 	bl	80024a8 <cortexm_run_stub>

	return 0;
}
 8002630:	b005      	add	sp, #20
 8002632:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002634:	20000060 	.word	0x20000060
 8002638:	08011734 	.word	0x08011734

0800263c <efm32_cmd_erase_all>:

/**
 * Uses the MSC ERASEMAIN0 command to erase the entire flash
 */
static bool efm32_cmd_erase_all(target *t)
{
 800263c:	b538      	push	{r3, r4, r5, lr}
 800263e:	1c04      	adds	r4, r0, #0
	/* Set WREN bit to enabel MSC write and erase functionality */
	target_mem_write32(t, EFM32_MSC_WRITECTRL, 1);
 8002640:	4913      	ldr	r1, [pc, #76]	; (8002690 <efm32_cmd_erase_all+0x54>)
 8002642:	2201      	movs	r2, #1
 8002644:	f005 ff7a 	bl	800853c <target_mem_write32>

	/* Unlock mass erase */
	target_mem_write32(t, EFM32_MSC_MASSLOCK, EFM32_MSC_MASSLOCK_LOCKKEY);
 8002648:	1c20      	adds	r0, r4, #0
 800264a:	4912      	ldr	r1, [pc, #72]	; (8002694 <efm32_cmd_erase_all+0x58>)
 800264c:	4a12      	ldr	r2, [pc, #72]	; (8002698 <efm32_cmd_erase_all+0x5c>)
 800264e:	f005 ff75 	bl	800853c <target_mem_write32>

	/* Erase operation */
	target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_ERASEMAIN0);
 8002652:	2280      	movs	r2, #128	; 0x80
 8002654:	1c20      	adds	r0, r4, #0
 8002656:	4911      	ldr	r1, [pc, #68]	; (800269c <efm32_cmd_erase_all+0x60>)
 8002658:	0052      	lsls	r2, r2, #1
 800265a:	f005 ff6f 	bl	800853c <target_mem_write32>

	/* Poll MSC Busy */
	while ((target_mem_read32(t, EFM32_MSC_STATUS) & EFM32_MSC_STATUS_BUSY)) {
 800265e:	1c20      	adds	r0, r4, #0
 8002660:	490f      	ldr	r1, [pc, #60]	; (80026a0 <efm32_cmd_erase_all+0x64>)
 8002662:	f005 ff63 	bl	800852c <target_mem_read32>
 8002666:	2501      	movs	r5, #1
 8002668:	1c02      	adds	r2, r0, #0
		if (target_check_error(t))
 800266a:	1c20      	adds	r0, r4, #0

	/* Erase operation */
	target_mem_write32(t, EFM32_MSC_WRITECMD, EFM32_MSC_WRITECMD_ERASEMAIN0);

	/* Poll MSC Busy */
	while ((target_mem_read32(t, EFM32_MSC_STATUS) & EFM32_MSC_STATUS_BUSY)) {
 800266c:	402a      	ands	r2, r5
 800266e:	d005      	beq.n	800267c <efm32_cmd_erase_all+0x40>
		if (target_check_error(t))
 8002670:	f005 fed2 	bl	8008418 <target_check_error>
 8002674:	2800      	cmp	r0, #0
 8002676:	d0f2      	beq.n	800265e <efm32_cmd_erase_all+0x22>
			return false;
 8002678:	2000      	movs	r0, #0
 800267a:	e007      	b.n	800268c <efm32_cmd_erase_all+0x50>
	}

	/* Relock mass erase */
	target_mem_write32(t, EFM32_MSC_MASSLOCK, 0);
 800267c:	4905      	ldr	r1, [pc, #20]	; (8002694 <efm32_cmd_erase_all+0x58>)
 800267e:	f005 ff5d 	bl	800853c <target_mem_write32>

	tc_printf(t, "Erase successful!\n");
 8002682:	1c20      	adds	r0, r4, #0
 8002684:	4907      	ldr	r1, [pc, #28]	; (80026a4 <efm32_cmd_erase_all+0x68>)
 8002686:	f005 ffb0 	bl	80085ea <tc_printf>
 800268a:	1c28      	adds	r0, r5, #0

	return true;
}
 800268c:	bd38      	pop	{r3, r4, r5, pc}
 800268e:	46c0      	nop			; (mov r8, r8)
 8002690:	400c0008 	.word	0x400c0008
 8002694:	400c0054 	.word	0x400c0054
 8002698:	0000631a 	.word	0x0000631a
 800269c:	400c000c 	.word	0x400c000c
 80026a0:	400c001c 	.word	0x400c001c
 80026a4:	080117b8 	.word	0x080117b8

080026a8 <efm32_read_eui>:

/**
 * Reads the EFM32 Extended Unique Identifier
 */
	uint64_t efm32_read_eui(target *t)
	{
 80026a8:	b538      	push	{r3, r4, r5, lr}
		uint64_t eui;

		eui  = (uint64_t)target_mem_read32(t, EFM32_DI_EUI64_1) << 32;
 80026aa:	4905      	ldr	r1, [pc, #20]	; (80026c0 <efm32_read_eui+0x18>)

/**
 * Reads the EFM32 Extended Unique Identifier
 */
	uint64_t efm32_read_eui(target *t)
	{
 80026ac:	1c04      	adds	r4, r0, #0
		uint64_t eui;

		eui  = (uint64_t)target_mem_read32(t, EFM32_DI_EUI64_1) << 32;
 80026ae:	f005 ff3d 	bl	800852c <target_mem_read32>
 80026b2:	1c05      	adds	r5, r0, #0
		eui |= (uint64_t)target_mem_read32(t, EFM32_DI_EUI64_0) <<  0;
 80026b4:	4903      	ldr	r1, [pc, #12]	; (80026c4 <efm32_read_eui+0x1c>)
 80026b6:	1c20      	adds	r0, r4, #0
 80026b8:	f005 ff38 	bl	800852c <target_mem_read32>

		return eui;
	}
 80026bc:	1c29      	adds	r1, r5, #0
 80026be:	bd38      	pop	{r3, r4, r5, pc}
 80026c0:	0fe081f4 	.word	0x0fe081f4
 80026c4:	0fe081f0 	.word	0x0fe081f0

080026c8 <efm32_cmd_serial>:

/**
 * Reads the 40-bit unique number
 */
static bool efm32_cmd_serial(target *t)
{
 80026c8:	b510      	push	{r4, lr}
 80026ca:	1c04      	adds	r4, r0, #0
	/* Read the extended unique identifier */
	uint64_t eui = efm32_read_eui(t);
 80026cc:	f7ff ffec 	bl	80026a8 <efm32_read_eui>
 80026d0:	1c02      	adds	r2, r0, #0
 80026d2:	1c0b      	adds	r3, r1, #0

	/* 64 bits of unique number */
	tc_printf(t, "Unique Number: 0x%016llx\n", eui);
 80026d4:	1c20      	adds	r0, r4, #0
 80026d6:	4902      	ldr	r1, [pc, #8]	; (80026e0 <efm32_cmd_serial+0x18>)
 80026d8:	f005 ff87 	bl	80085ea <tc_printf>

	return true;
}
 80026dc:	2001      	movs	r0, #1
 80026de:	bd10      	pop	{r4, pc}
 80026e0:	080117cb 	.word	0x080117cb

080026e4 <efm32_read_flash_size>:
	}
/**
 * Reads the EFM32 flash size in kiB
 */
uint16_t efm32_read_flash_size(target *t)
{
 80026e4:	b508      	push	{r3, lr}
	return target_mem_read16(t, EFM32_DI_MEM_INFO_FLASH);
 80026e6:	4902      	ldr	r1, [pc, #8]	; (80026f0 <efm32_read_flash_size+0xc>)
 80026e8:	f005 ff2f 	bl	800854a <target_mem_read16>
}
 80026ec:	bd08      	pop	{r3, pc}
 80026ee:	46c0      	nop			; (mov r8, r8)
 80026f0:	0fe081f8 	.word	0x0fe081f8

080026f4 <efm32_read_ram_size>:
/**
 * Reads the EFM32 RAM size in kiB
 */
uint16_t efm32_read_ram_size(target *t)
{
 80026f4:	b508      	push	{r3, lr}
	return target_mem_read16(t, EFM32_DI_MEM_INFO_RAM);
 80026f6:	4902      	ldr	r1, [pc, #8]	; (8002700 <efm32_read_ram_size+0xc>)
 80026f8:	f005 ff27 	bl	800854a <target_mem_read16>
}
 80026fc:	bd08      	pop	{r3, pc}
 80026fe:	46c0      	nop			; (mov r8, r8)
 8002700:	0fe081fa 	.word	0x0fe081fa

08002704 <efm32_read_part_number>:
/**
 * Reads the EFM32 Part Number
 */
uint16_t efm32_read_part_number(target *t)
{
 8002704:	b508      	push	{r3, lr}
	return target_mem_read16(t, EFM32_DI_PART_NUMBER);
 8002706:	4902      	ldr	r1, [pc, #8]	; (8002710 <efm32_read_part_number+0xc>)
 8002708:	f005 ff1f 	bl	800854a <target_mem_read16>
}
 800270c:	bd08      	pop	{r3, pc}
 800270e:	46c0      	nop			; (mov r8, r8)
 8002710:	0fe081fc 	.word	0x0fe081fc

08002714 <efm32_read_part_family>:
/**
 * Reads the EFM32 Part Family
 */
uint8_t efm32_read_part_family(target *t)
{
 8002714:	b508      	push	{r3, lr}
	return target_mem_read8(t, EFM32_DI_PART_FAMILY);
 8002716:	4902      	ldr	r1, [pc, #8]	; (8002720 <efm32_read_part_family+0xc>)
 8002718:	f005 ff2a 	bl	8008570 <target_mem_read8>
}
 800271c:	bd08      	pop	{r3, pc}
 800271e:	46c0      	nop			; (mov r8, r8)
 8002720:	0fe081fe 	.word	0x0fe081fe

08002724 <efm32_read_radio_part_number>:
/**
 * Reads the EFM32 Radio part number (EZR parts only)
 */
uint16_t efm32_read_radio_part_number(target *t)
{
 8002724:	b508      	push	{r3, lr}
	return target_mem_read16(t, EFM32_DI_RADIO_OPN);
 8002726:	4902      	ldr	r1, [pc, #8]	; (8002730 <efm32_read_radio_part_number+0xc>)
 8002728:	f005 ff0f 	bl	800854a <target_mem_read16>
}
 800272c:	bd08      	pop	{r3, pc}
 800272e:	46c0      	nop			; (mov r8, r8)
 8002730:	0fe081ae 	.word	0x0fe081ae

08002734 <efm32_probe>:
	target_add_flash(t, f);
}

char variant_string[40];
bool efm32_probe(target *t)
{
 8002734:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8002736:	1c04      	adds	r4, r0, #0
	/* Read the IDCODE register from the SW-DP */
	ADIv5_AP_t *ap = cortexm_ap(t);
 8002738:	f7ff fdc4 	bl	80022c4 <cortexm_ap>
	uint32_t ap_idcode = ap->dp->idcode;
 800273c:	6843      	ldr	r3, [r0, #4]

	/* Check the idcode is silabs. See AN0062 Section 2.2 */
	if (ap_idcode == 0x2BA01477) {
 800273e:	4a53      	ldr	r2, [pc, #332]	; (800288c <efm32_probe+0x158>)
char variant_string[40];
bool efm32_probe(target *t)
{
	/* Read the IDCODE register from the SW-DP */
	ADIv5_AP_t *ap = cortexm_ap(t);
	uint32_t ap_idcode = ap->dp->idcode;
 8002740:	685b      	ldr	r3, [r3, #4]

	/* Check the idcode is silabs. See AN0062 Section 2.2 */
	if (ap_idcode == 0x2BA01477) {
 8002742:	4293      	cmp	r3, r2
 8002744:	d004      	beq.n	8002750 <efm32_probe+0x1c>
		/* Cortex M3, Cortex M4 */
	} else if (ap_idcode == 0x0BC11477) {
 8002746:	4a52      	ldr	r2, [pc, #328]	; (8002890 <efm32_probe+0x15c>)
		/* Cortex M0+ */
	} else {
		return false;
 8002748:	2000      	movs	r0, #0
	uint32_t ap_idcode = ap->dp->idcode;

	/* Check the idcode is silabs. See AN0062 Section 2.2 */
	if (ap_idcode == 0x2BA01477) {
		/* Cortex M3, Cortex M4 */
	} else if (ap_idcode == 0x0BC11477) {
 800274a:	4293      	cmp	r3, r2
 800274c:	d000      	beq.n	8002750 <efm32_probe+0x1c>
 800274e:	e09b      	b.n	8002888 <efm32_probe+0x154>
	} else {
		return false;
	}

	/* Read the part number and family */
	uint16_t part_number = efm32_read_part_number(t);
 8002750:	1c20      	adds	r0, r4, #0
 8002752:	f7ff ffd7 	bl	8002704 <efm32_read_part_number>
 8002756:	1c05      	adds	r5, r0, #0
	uint8_t part_family = efm32_read_part_family(t);
 8002758:	1c20      	adds	r0, r4, #0
 800275a:	f7ff ffdb 	bl	8002714 <efm32_read_part_family>
	uint16_t radio_number, radio_number_short;  /* optional, for ezr parts */
	uint32_t flash_page_size; uint16_t flash_kb;

	switch(part_family) {
 800275e:	284b      	cmp	r0, #75	; 0x4b
 8002760:	d034      	beq.n	80027cc <efm32_probe+0x98>
 8002762:	d810      	bhi.n	8002786 <efm32_probe+0x52>
 8002764:	2848      	cmp	r0, #72	; 0x48
 8002766:	d027      	beq.n	80027b8 <efm32_probe+0x84>
 8002768:	d805      	bhi.n	8002776 <efm32_probe+0x42>
 800276a:	2847      	cmp	r0, #71	; 0x47
 800276c:	d000      	beq.n	8002770 <efm32_probe+0x3c>
 800276e:	e08a      	b.n	8002886 <efm32_probe+0x152>
		case EFM32_DI_PART_FAMILY_GECKO:
			sprintf(variant_string,
 8002770:	4848      	ldr	r0, [pc, #288]	; (8002894 <efm32_probe+0x160>)
 8002772:	4949      	ldr	r1, [pc, #292]	; (8002898 <efm32_probe+0x164>)
 8002774:	e025      	b.n	80027c2 <efm32_probe+0x8e>
	uint16_t part_number = efm32_read_part_number(t);
	uint8_t part_family = efm32_read_part_family(t);
	uint16_t radio_number, radio_number_short;  /* optional, for ezr parts */
	uint32_t flash_page_size; uint16_t flash_kb;

	switch(part_family) {
 8002776:	2849      	cmp	r0, #73	; 0x49
 8002778:	d021      	beq.n	80027be <efm32_probe+0x8a>
 800277a:	284a      	cmp	r0, #74	; 0x4a
 800277c:	d000      	beq.n	8002780 <efm32_probe+0x4c>
 800277e:	e082      	b.n	8002886 <efm32_probe+0x152>
			sprintf(variant_string,
				"EFM32 Tiny Gecko");
			flash_page_size = 512;
			break;
		case EFM32_DI_PART_FAMILY_LEOPARD_GECKO:
			sprintf(variant_string,
 8002780:	4844      	ldr	r0, [pc, #272]	; (8002894 <efm32_probe+0x160>)
 8002782:	4946      	ldr	r1, [pc, #280]	; (800289c <efm32_probe+0x168>)
 8002784:	e024      	b.n	80027d0 <efm32_probe+0x9c>
	uint16_t part_number = efm32_read_part_number(t);
	uint8_t part_family = efm32_read_part_family(t);
	uint16_t radio_number, radio_number_short;  /* optional, for ezr parts */
	uint32_t flash_page_size; uint16_t flash_kb;

	switch(part_family) {
 8002786:	284d      	cmp	r0, #77	; 0x4d
 8002788:	d028      	beq.n	80027dc <efm32_probe+0xa8>
 800278a:	d324      	bcc.n	80027d6 <efm32_probe+0xa2>
 800278c:	2878      	cmp	r0, #120	; 0x78
 800278e:	d02c      	beq.n	80027ea <efm32_probe+0xb6>
 8002790:	2879      	cmp	r0, #121	; 0x79
 8002792:	d178      	bne.n	8002886 <efm32_probe+0x152>
				radio_number_short, radio_number);

			flash_page_size = 2048;
			break;
		case EFM32_DI_PART_FAMILY_EZR_LEOPARD_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
 8002794:	1c20      	adds	r0, r4, #0
 8002796:	f7ff ffc5 	bl	8002724 <efm32_read_radio_part_number>
 800279a:	1c06      	adds	r6, r0, #0
			radio_number_short = radio_number % 100;
			flash_kb = efm32_read_flash_size(t);
 800279c:	1c20      	adds	r0, r4, #0
 800279e:	f7ff ffa1 	bl	80026e4 <efm32_read_flash_size>

			flash_page_size = 2048;
			break;
		case EFM32_DI_PART_FAMILY_EZR_LEOPARD_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
			radio_number_short = radio_number % 100;
 80027a2:	2164      	movs	r1, #100	; 0x64
			flash_kb = efm32_read_flash_size(t);
 80027a4:	1c07      	adds	r7, r0, #0

			flash_page_size = 2048;
			break;
		case EFM32_DI_PART_FAMILY_EZR_LEOPARD_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
			radio_number_short = radio_number % 100;
 80027a6:	1c30      	adds	r0, r6, #0
 80027a8:	f00c f978 	bl	800ea9c <__aeabi_uidivmod>
			flash_kb = efm32_read_flash_size(t);

			sprintf(variant_string,
 80027ac:	b289      	uxth	r1, r1
 80027ae:	9100      	str	r1, [sp, #0]
 80027b0:	9601      	str	r6, [sp, #4]
 80027b2:	4838      	ldr	r0, [pc, #224]	; (8002894 <efm32_probe+0x160>)
 80027b4:	493a      	ldr	r1, [pc, #232]	; (80028a0 <efm32_probe+0x16c>)
 80027b6:	e029      	b.n	800280c <efm32_probe+0xd8>
			sprintf(variant_string,
				"EFM32 Gecko");
			flash_page_size = 512;
			break;
		case EFM32_DI_PART_FAMILY_GIANT_GECKO:
			sprintf(variant_string,
 80027b8:	4836      	ldr	r0, [pc, #216]	; (8002894 <efm32_probe+0x160>)
 80027ba:	493a      	ldr	r1, [pc, #232]	; (80028a4 <efm32_probe+0x170>)
 80027bc:	e008      	b.n	80027d0 <efm32_probe+0x9c>
				"EFM32 Giant Gecko");
			flash_page_size = 2048; /* Could be 2048 or 4096, assume 2048 */
			break;
		case EFM32_DI_PART_FAMILY_TINY_GECKO:
			sprintf(variant_string,
 80027be:	4835      	ldr	r0, [pc, #212]	; (8002894 <efm32_probe+0x160>)
 80027c0:	4939      	ldr	r1, [pc, #228]	; (80028a8 <efm32_probe+0x174>)
				"EFM32 Tiny Gecko");
			flash_page_size = 512;
 80027c2:	2580      	movs	r5, #128	; 0x80
			sprintf(variant_string,
				"EFM32 Giant Gecko");
			flash_page_size = 2048; /* Could be 2048 or 4096, assume 2048 */
			break;
		case EFM32_DI_PART_FAMILY_TINY_GECKO:
			sprintf(variant_string,
 80027c4:	f00a fa8e 	bl	800cce4 <siprintf>
				"EFM32 Tiny Gecko");
			flash_page_size = 512;
 80027c8:	00ad      	lsls	r5, r5, #2
			break;
 80027ca:	e025      	b.n	8002818 <efm32_probe+0xe4>
			sprintf(variant_string,
				"EFM32 Leopard Gecko");
			flash_page_size = 2048; /* Could be 2048 or 4096, assume 2048 */
			break;
		case EFM32_DI_PART_FAMILY_WONDER_GECKO:
			sprintf(variant_string,
 80027cc:	4831      	ldr	r0, [pc, #196]	; (8002894 <efm32_probe+0x160>)
 80027ce:	4937      	ldr	r1, [pc, #220]	; (80028ac <efm32_probe+0x178>)
 80027d0:	f00a fa88 	bl	800cce4 <siprintf>
 80027d4:	e01e      	b.n	8002814 <efm32_probe+0xe0>
				"EFM32 Wonder Gecko");
			flash_page_size = 2048;
			break;
		case EFM32_DI_PART_FAMILY_ZERO_GECKO:
			sprintf(variant_string,
 80027d6:	482f      	ldr	r0, [pc, #188]	; (8002894 <efm32_probe+0x160>)
 80027d8:	4935      	ldr	r1, [pc, #212]	; (80028b0 <efm32_probe+0x17c>)
 80027da:	e001      	b.n	80027e0 <efm32_probe+0xac>
				"EFM32 Zero Gecko");
			flash_page_size = 1024;
			break;
		case EFM32_DI_PART_FAMILY_HAPPY_GECKO:
			sprintf(variant_string,
 80027dc:	482d      	ldr	r0, [pc, #180]	; (8002894 <efm32_probe+0x160>)
 80027de:	4935      	ldr	r1, [pc, #212]	; (80028b4 <efm32_probe+0x180>)
				"EFM32 Happy Gecko");
			flash_page_size = 1024;
 80027e0:	2580      	movs	r5, #128	; 0x80
			sprintf(variant_string,
				"EFM32 Zero Gecko");
			flash_page_size = 1024;
			break;
		case EFM32_DI_PART_FAMILY_HAPPY_GECKO:
			sprintf(variant_string,
 80027e2:	f00a fa7f 	bl	800cce4 <siprintf>
				"EFM32 Happy Gecko");
			flash_page_size = 1024;
 80027e6:	00ed      	lsls	r5, r5, #3
			break;
 80027e8:	e016      	b.n	8002818 <efm32_probe+0xe4>
		case EFM32_DI_PART_FAMILY_EZR_WONDER_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
 80027ea:	1c20      	adds	r0, r4, #0
 80027ec:	f7ff ff9a 	bl	8002724 <efm32_read_radio_part_number>
 80027f0:	1c06      	adds	r6, r0, #0
			radio_number_short = radio_number % 100;
			flash_kb = efm32_read_flash_size(t);
 80027f2:	1c20      	adds	r0, r4, #0
 80027f4:	f7ff ff76 	bl	80026e4 <efm32_read_flash_size>
				"EFM32 Happy Gecko");
			flash_page_size = 1024;
			break;
		case EFM32_DI_PART_FAMILY_EZR_WONDER_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
			radio_number_short = radio_number % 100;
 80027f8:	2164      	movs	r1, #100	; 0x64
			flash_kb = efm32_read_flash_size(t);
 80027fa:	1c07      	adds	r7, r0, #0
				"EFM32 Happy Gecko");
			flash_page_size = 1024;
			break;
		case EFM32_DI_PART_FAMILY_EZR_WONDER_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
			radio_number_short = radio_number % 100;
 80027fc:	1c30      	adds	r0, r6, #0
 80027fe:	f00c f94d 	bl	800ea9c <__aeabi_uidivmod>
			flash_kb = efm32_read_flash_size(t);

			sprintf(variant_string,
 8002802:	b289      	uxth	r1, r1
 8002804:	9100      	str	r1, [sp, #0]
 8002806:	4823      	ldr	r0, [pc, #140]	; (8002894 <efm32_probe+0x160>)
 8002808:	492b      	ldr	r1, [pc, #172]	; (80028b8 <efm32_probe+0x184>)
 800280a:	9601      	str	r6, [sp, #4]
		case EFM32_DI_PART_FAMILY_EZR_LEOPARD_GECKO:
			radio_number = efm32_read_radio_part_number(t); /* on-chip radio */
			radio_number_short = radio_number % 100;
			flash_kb = efm32_read_flash_size(t);

			sprintf(variant_string,
 800280c:	1c2a      	adds	r2, r5, #0
 800280e:	1c3b      	adds	r3, r7, #0
 8002810:	f00a fa68 	bl	800cce4 <siprintf>
				"EZR32LG%dF%dR%d (radio si%d)",
				part_number, flash_kb,
				radio_number_short, radio_number);

			flash_page_size = 2048;
 8002814:	2580      	movs	r5, #128	; 0x80
 8002816:	012d      	lsls	r5, r5, #4
		default:	/* Unknown family */
			return false;
	}

	/* Read memory sizes, convert to bytes */
	uint32_t flash_size = efm32_read_flash_size(t) * 0x400;
 8002818:	1c20      	adds	r0, r4, #0
 800281a:	f7ff ff63 	bl	80026e4 <efm32_read_flash_size>
 800281e:	0286      	lsls	r6, r0, #10
	uint32_t ram_size   = efm32_read_ram_size(t)   * 0x400;
 8002820:	1c20      	adds	r0, r4, #0
 8002822:	f7ff ff67 	bl	80026f4 <efm32_read_ram_size>

	/* Setup Target */
	t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
 8002826:	2304      	movs	r3, #4
 8002828:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
			return false;
	}

	/* Read memory sizes, convert to bytes */
	uint32_t flash_size = efm32_read_flash_size(t) * 0x400;
	uint32_t ram_size   = efm32_read_ram_size(t)   * 0x400;
 800282a:	1c07      	adds	r7, r0, #0

	/* Setup Target */
	t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
 800282c:	4313      	orrs	r3, r2
 800282e:	64e3      	str	r3, [r4, #76]	; 0x4c
	t->driver = variant_string;
 8002830:	4b18      	ldr	r3, [pc, #96]	; (8002894 <efm32_probe+0x160>)
	tc_printf(t, "flash size %d page size %d\n", flash_size, flash_page_size);
 8002832:	1c20      	adds	r0, r4, #0
	uint32_t flash_size = efm32_read_flash_size(t) * 0x400;
	uint32_t ram_size   = efm32_read_ram_size(t)   * 0x400;

	/* Setup Target */
	t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
	t->driver = variant_string;
 8002834:	6623      	str	r3, [r4, #96]	; 0x60
	tc_printf(t, "flash size %d page size %d\n", flash_size, flash_page_size);
 8002836:	4921      	ldr	r1, [pc, #132]	; (80028bc <efm32_probe+0x188>)
 8002838:	1c2b      	adds	r3, r5, #0
 800283a:	1c32      	adds	r2, r6, #0
 800283c:	f005 fed5 	bl	80085ea <tc_printf>
	target_add_ram (t, SRAM_BASE, ram_size);
 8002840:	2180      	movs	r1, #128	; 0x80
			return false;
	}

	/* Read memory sizes, convert to bytes */
	uint32_t flash_size = efm32_read_flash_size(t) * 0x400;
	uint32_t ram_size   = efm32_read_ram_size(t)   * 0x400;
 8002842:	02ba      	lsls	r2, r7, #10

	/* Setup Target */
	t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
	t->driver = variant_string;
	tc_printf(t, "flash size %d page size %d\n", flash_size, flash_page_size);
	target_add_ram (t, SRAM_BASE, ram_size);
 8002844:	1c20      	adds	r0, r4, #0
 8002846:	0589      	lsls	r1, r1, #22
 8002848:	f005 fc74 	bl	8008134 <target_add_ram>


static void efm32_add_flash(target *t, target_addr addr, size_t length,
			    size_t page_size)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 800284c:	2138      	movs	r1, #56	; 0x38
 800284e:	2001      	movs	r0, #1
 8002850:	f00a f812 	bl	800c878 <calloc>
	f->start = addr;
 8002854:	2300      	movs	r3, #0
 8002856:	6003      	str	r3, [r0, #0]
	f->length = length;
	f->blocksize = page_size;
	f->erase = efm32_flash_erase;
 8002858:	4b19      	ldr	r3, [pc, #100]	; (80028c0 <efm32_probe+0x18c>)


static void efm32_add_flash(target *t, target_addr addr, size_t length,
			    size_t page_size)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 800285a:	1c01      	adds	r1, r0, #0
	f->start = addr;
	f->length = length;
	f->blocksize = page_size;
	f->erase = efm32_flash_erase;
 800285c:	60c3      	str	r3, [r0, #12]
	f->write = target_flash_write_buffered;
 800285e:	4b19      	ldr	r3, [pc, #100]	; (80028c4 <efm32_probe+0x190>)
static void efm32_add_flash(target *t, target_addr addr, size_t length,
			    size_t page_size)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
 8002860:	6046      	str	r6, [r0, #4]
	f->blocksize = page_size;
	f->erase = efm32_flash_erase;
	f->write = target_flash_write_buffered;
 8002862:	6103      	str	r3, [r0, #16]
	f->done = target_flash_done_buffered;
 8002864:	4b18      	ldr	r3, [pc, #96]	; (80028c8 <efm32_probe+0x194>)
			    size_t page_size)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = page_size;
 8002866:	6085      	str	r5, [r0, #8]
	f->erase = efm32_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 8002868:	6143      	str	r3, [r0, #20]
	f->write_buf = efm32_flash_write;
 800286a:	4b18      	ldr	r3, [pc, #96]	; (80028cc <efm32_probe+0x198>)
	f->buf_size = page_size;
 800286c:	6285      	str	r5, [r0, #40]	; 0x28
	f->length = length;
	f->blocksize = page_size;
	f->erase = efm32_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = efm32_flash_write;
 800286e:	62c3      	str	r3, [r0, #44]	; 0x2c
	f->buf_size = page_size;
	target_add_flash(t, f);
 8002870:	1c20      	adds	r0, r4, #0
 8002872:	f005 fc6c 	bl	800814e <target_add_flash>
	t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
	t->driver = variant_string;
	tc_printf(t, "flash size %d page size %d\n", flash_size, flash_page_size);
	target_add_ram (t, SRAM_BASE, ram_size);
	efm32_add_flash(t, 0x00000000, flash_size, flash_page_size);
	target_add_commands(t, efm32_cmd_list, "EFM32");
 8002876:	4916      	ldr	r1, [pc, #88]	; (80028d0 <efm32_probe+0x19c>)
 8002878:	1c20      	adds	r0, r4, #0
 800287a:	3160      	adds	r1, #96	; 0x60
 800287c:	4a15      	ldr	r2, [pc, #84]	; (80028d4 <efm32_probe+0x1a0>)
 800287e:	f005 fc19 	bl	80080b4 <target_add_commands>

	return true;
 8002882:	2001      	movs	r0, #1
 8002884:	e000      	b.n	8002888 <efm32_probe+0x154>
				radio_number_short, radio_number);

			flash_page_size = 2048;
			break;
		default:	/* Unknown family */
			return false;
 8002886:	2000      	movs	r0, #0
	target_add_ram (t, SRAM_BASE, ram_size);
	efm32_add_flash(t, 0x00000000, flash_size, flash_page_size);
	target_add_commands(t, efm32_cmd_list, "EFM32");

	return true;
}
 8002888:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800288a:	46c0      	nop			; (mov r8, r8)
 800288c:	2ba01477 	.word	0x2ba01477
 8002890:	0bc11477 	.word	0x0bc11477
 8002894:	20001d99 	.word	0x20001d99
 8002898:	080117e5 	.word	0x080117e5
 800289c:	08011814 	.word	0x08011814
 80028a0:	0801187b 	.word	0x0801187b
 80028a4:	080117f1 	.word	0x080117f1
 80028a8:	08011803 	.word	0x08011803
 80028ac:	08011828 	.word	0x08011828
 80028b0:	0801183b 	.word	0x0801183b
 80028b4:	0801184c 	.word	0x0801184c
 80028b8:	0801185e 	.word	0x0801185e
 80028bc:	08011898 	.word	0x08011898
 80028c0:	08002585 	.word	0x08002585
 80028c4:	0800834b 	.word	0x0800834b
 80028c8:	080083dd 	.word	0x080083dd
 80028cc:	080025f5 	.word	0x080025f5
 80028d0:	08011734 	.word	0x08011734
 80028d4:	080118b4 	.word	0x080118b4

080028d8 <raise_exception>:
#include "exception.h"

struct exception *innermost_exception;

void raise_exception(uint32_t type, const char *msg)
{
 80028d8:	b538      	push	{r3, r4, r5, lr}
 80028da:	1c04      	adds	r4, r0, #0
	struct exception *e;
	DEBUG("Exception: %s\n", msg);
 80028dc:	480b      	ldr	r0, [pc, #44]	; (800290c <raise_exception+0x34>)
#include "exception.h"

struct exception *innermost_exception;

void raise_exception(uint32_t type, const char *msg)
{
 80028de:	1c0d      	adds	r5, r1, #0
	struct exception *e;
	DEBUG("Exception: %s\n", msg);
 80028e0:	f00a f8bc 	bl	800ca5c <iprintf>
	for (e = innermost_exception; e; e = e->outer) {
 80028e4:	4b0a      	ldr	r3, [pc, #40]	; (8002910 <raise_exception+0x38>)
 80028e6:	6818      	ldr	r0, [r3, #0]
 80028e8:	2800      	cmp	r0, #0
 80028ea:	d00c      	beq.n	8002906 <raise_exception+0x2e>
		if (e->mask & type) {
 80028ec:	6882      	ldr	r2, [r0, #8]
 80028ee:	4222      	tst	r2, r4
 80028f0:	d007      	beq.n	8002902 <raise_exception+0x2a>
			e->type = type;
			e->msg = msg;
			innermost_exception = e->outer;
 80028f2:	6e82      	ldr	r2, [r0, #104]	; 0x68
{
	struct exception *e;
	DEBUG("Exception: %s\n", msg);
	for (e = innermost_exception; e; e = e->outer) {
		if (e->mask & type) {
			e->type = type;
 80028f4:	6004      	str	r4, [r0, #0]
			e->msg = msg;
 80028f6:	6045      	str	r5, [r0, #4]
			innermost_exception = e->outer;
			longjmp(e->jmpbuf, type);
 80028f8:	1c21      	adds	r1, r4, #0
 80028fa:	300c      	adds	r0, #12
	DEBUG("Exception: %s\n", msg);
	for (e = innermost_exception; e; e = e->outer) {
		if (e->mask & type) {
			e->type = type;
			e->msg = msg;
			innermost_exception = e->outer;
 80028fc:	601a      	str	r2, [r3, #0]
			longjmp(e->jmpbuf, type);
 80028fe:	f00a f965 	bl	800cbcc <longjmp>

void raise_exception(uint32_t type, const char *msg)
{
	struct exception *e;
	DEBUG("Exception: %s\n", msg);
	for (e = innermost_exception; e; e = e->outer) {
 8002902:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8002904:	e7f0      	b.n	80028e8 <raise_exception+0x10>
			e->msg = msg;
			innermost_exception = e->outer;
			longjmp(e->jmpbuf, type);
		}
	}
	abort();
 8002906:	f009 ffa3 	bl	800c850 <abort>
 800290a:	46c0      	nop			; (mov r8, r8)
 800290c:	0800fd1c 	.word	0x0800fd1c
 8002910:	20001dc4 	.word	0x20001dc4

08002914 <gdb_if_update_buf>:
	}
}
#endif

static void gdb_if_update_buf(void)
{
 8002914:	b510      	push	{r4, lr}
	while (cdcacm_get_config() != 1);
 8002916:	f008 fd03 	bl	800b320 <cdcacm_get_config>
 800291a:	1e01      	subs	r1, r0, #0
 800291c:	2901      	cmp	r1, #1
 800291e:	d1fa      	bne.n	8002916 <gdb_if_update_buf+0x2>
		out_ptr = 0;
		usbd_ep_nak_set(usbdev, CDCACM_GDB_ENDPOINT, 0);
	}
	asm volatile ("cpsie i; isb");
#else
	count_out = usbd_ep_read_packet(usbdev, CDCACM_GDB_ENDPOINT,
 8002920:	4c05      	ldr	r4, [pc, #20]	; (8002938 <gdb_if_update_buf+0x24>)
 8002922:	4b06      	ldr	r3, [pc, #24]	; (800293c <gdb_if_update_buf+0x28>)
 8002924:	1c22      	adds	r2, r4, #0
 8002926:	6818      	ldr	r0, [r3, #0]
 8002928:	2340      	movs	r3, #64	; 0x40
 800292a:	f008 ff86 	bl	800b83a <usbd_ep_read_packet>
	                                buffer_out, CDCACM_PACKET_SIZE);
	out_ptr = 0;
 800292e:	2300      	movs	r3, #0
		out_ptr = 0;
		usbd_ep_nak_set(usbdev, CDCACM_GDB_ENDPOINT, 0);
	}
	asm volatile ("cpsie i; isb");
#else
	count_out = usbd_ep_read_packet(usbdev, CDCACM_GDB_ENDPOINT,
 8002930:	6420      	str	r0, [r4, #64]	; 0x40
	                                buffer_out, CDCACM_PACKET_SIZE);
	out_ptr = 0;
 8002932:	6463      	str	r3, [r4, #68]	; 0x44
#endif
}
 8002934:	bd10      	pop	{r4, pc}
 8002936:	46c0      	nop			; (mov r8, r8)
 8002938:	2000013c 	.word	0x2000013c
 800293c:	20002080 	.word	0x20002080

08002940 <gdb_if_putchar>:
static volatile uint32_t count_new;
static uint8_t double_buffer_out[CDCACM_PACKET_SIZE];
#endif

void gdb_if_putchar(unsigned char c, int flush)
{
 8002940:	b570      	push	{r4, r5, r6, lr}
	buffer_in[count_in++] = c;
 8002942:	4c18      	ldr	r4, [pc, #96]	; (80029a4 <gdb_if_putchar+0x64>)
static volatile uint32_t count_new;
static uint8_t double_buffer_out[CDCACM_PACKET_SIZE];
#endif

void gdb_if_putchar(unsigned char c, int flush)
{
 8002944:	1c0e      	adds	r6, r1, #0
	buffer_in[count_in++] = c;
 8002946:	1c21      	adds	r1, r4, #0
 8002948:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800294a:	314c      	adds	r1, #76	; 0x4c
 800294c:	1c53      	adds	r3, r2, #1
 800294e:	64a3      	str	r3, [r4, #72]	; 0x48
 8002950:	5488      	strb	r0, [r1, r2]
	if(flush || (count_in == sizeof buffer_in)) {
 8002952:	2e00      	cmp	r6, #0
 8002954:	d101      	bne.n	800295a <gdb_if_putchar+0x1a>
 8002956:	2b3f      	cmp	r3, #63	; 0x3f
 8002958:	d123      	bne.n	80029a2 <gdb_if_putchar+0x62>
		/* Refuse to send if USB isn't configured, and
		 * don't bother if nobody's listening */
		if((cdcacm_get_config() != 1) || !cdcacm_get_dtr()) {
 800295a:	f008 fce1 	bl	800b320 <cdcacm_get_config>
 800295e:	2801      	cmp	r0, #1
 8002960:	d002      	beq.n	8002968 <gdb_if_putchar+0x28>
			count_in = 0;
 8002962:	2300      	movs	r3, #0
 8002964:	64a3      	str	r3, [r4, #72]	; 0x48
			return;
 8002966:	e01c      	b.n	80029a2 <gdb_if_putchar+0x62>
{
	buffer_in[count_in++] = c;
	if(flush || (count_in == sizeof buffer_in)) {
		/* Refuse to send if USB isn't configured, and
		 * don't bother if nobody's listening */
		if((cdcacm_get_config() != 1) || !cdcacm_get_dtr()) {
 8002968:	f008 fce0 	bl	800b32c <cdcacm_get_dtr>
 800296c:	2800      	cmp	r0, #0
 800296e:	d0f8      	beq.n	8002962 <gdb_if_putchar+0x22>
			count_in = 0;
			return;
		}
		while(usbd_ep_write_packet(usbdev, CDCACM_GDB_ENDPOINT,
 8002970:	1c22      	adds	r2, r4, #0
 8002972:	4d0d      	ldr	r5, [pc, #52]	; (80029a8 <gdb_if_putchar+0x68>)
 8002974:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002976:	324c      	adds	r2, #76	; 0x4c
 8002978:	b29b      	uxth	r3, r3
 800297a:	6828      	ldr	r0, [r5, #0]
 800297c:	2101      	movs	r1, #1
 800297e:	f008 ff55 	bl	800b82c <usbd_ep_write_packet>
 8002982:	2800      	cmp	r0, #0
 8002984:	d0f4      	beq.n	8002970 <gdb_if_putchar+0x30>
			buffer_in, count_in) <= 0);

		if (flush && (count_in == CDCACM_PACKET_SIZE)) {
 8002986:	2e00      	cmp	r6, #0
 8002988:	d0eb      	beq.n	8002962 <gdb_if_putchar+0x22>
 800298a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800298c:	2b40      	cmp	r3, #64	; 0x40
 800298e:	d1e8      	bne.n	8002962 <gdb_if_putchar+0x22>
			 * to accept this as a complete transfer. */
			/* libopencm3 needs a change for us to confirm when
			 * that transfer is complete, so we just send a packet
			 * containing a null byte for now.
			 */
			while (usbd_ep_write_packet(usbdev, CDCACM_GDB_ENDPOINT,
 8002990:	2101      	movs	r1, #1
 8002992:	6828      	ldr	r0, [r5, #0]
 8002994:	4a05      	ldr	r2, [pc, #20]	; (80029ac <gdb_if_putchar+0x6c>)
 8002996:	1c0b      	adds	r3, r1, #0
 8002998:	f008 ff48 	bl	800b82c <usbd_ep_write_packet>
 800299c:	2800      	cmp	r0, #0
 800299e:	d0f7      	beq.n	8002990 <gdb_if_putchar+0x50>
 80029a0:	e7df      	b.n	8002962 <gdb_if_putchar+0x22>
				"\0", 1) <= 0);
		}

		count_in = 0;
	}
}
 80029a2:	bd70      	pop	{r4, r5, r6, pc}
 80029a4:	2000013c 	.word	0x2000013c
 80029a8:	20002080 	.word	0x20002080
 80029ac:	080118fb 	.word	0x080118fb

080029b0 <gdb_if_flush>:

void gdb_if_flush(void)
{
 80029b0:	b538      	push	{r3, r4, r5, lr}
	/* Refuse to send if USB isn't configured, and
	 * don't bother if nobody's listening */
	if((cdcacm_get_config() != 1) || !count_in /*|| !cdcacm_get_dtr()*/) {
 80029b2:	f008 fcb5 	bl	800b320 <cdcacm_get_config>
 80029b6:	4c10      	ldr	r4, [pc, #64]	; (80029f8 <gdb_if_flush+0x48>)
 80029b8:	2801      	cmp	r0, #1
 80029ba:	d002      	beq.n	80029c2 <gdb_if_flush+0x12>
		count_in = 0;
 80029bc:	2300      	movs	r3, #0
 80029be:	64a3      	str	r3, [r4, #72]	; 0x48
		while (usbd_ep_write_packet(usbdev, CDCACM_GDB_ENDPOINT,
					"\0", 1) <= 0);
	}

	count_in = 0;
}
 80029c0:	bd38      	pop	{r3, r4, r5, pc}

void gdb_if_flush(void)
{
	/* Refuse to send if USB isn't configured, and
	 * don't bother if nobody's listening */
	if((cdcacm_get_config() != 1) || !count_in /*|| !cdcacm_get_dtr()*/) {
 80029c2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80029c4:	2b00      	cmp	r3, #0
 80029c6:	d0f9      	beq.n	80029bc <gdb_if_flush+0xc>
		count_in = 0;
		return;
	}
	while(usbd_ep_write_packet(usbdev, CDCACM_GDB_ENDPOINT,
 80029c8:	1c22      	adds	r2, r4, #0
 80029ca:	4d0c      	ldr	r5, [pc, #48]	; (80029fc <gdb_if_flush+0x4c>)
 80029cc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80029ce:	324c      	adds	r2, #76	; 0x4c
 80029d0:	b29b      	uxth	r3, r3
 80029d2:	6828      	ldr	r0, [r5, #0]
 80029d4:	2101      	movs	r1, #1
 80029d6:	f008 ff29 	bl	800b82c <usbd_ep_write_packet>
 80029da:	2800      	cmp	r0, #0
 80029dc:	d0f4      	beq.n	80029c8 <gdb_if_flush+0x18>
				buffer_in, count_in) <= 0);

	if (count_in == CDCACM_PACKET_SIZE) {
 80029de:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80029e0:	2b40      	cmp	r3, #64	; 0x40
 80029e2:	d1eb      	bne.n	80029bc <gdb_if_flush+0xc>
		 * to accept this as a complete transfer. */
		/* libopencm3 needs a change for us to confirm when
		 * that transfer is complete, so we just send a packet
		 * containing a null byte for now.
		 */
		while (usbd_ep_write_packet(usbdev, CDCACM_GDB_ENDPOINT,
 80029e4:	2101      	movs	r1, #1
 80029e6:	6828      	ldr	r0, [r5, #0]
 80029e8:	4a05      	ldr	r2, [pc, #20]	; (8002a00 <gdb_if_flush+0x50>)
 80029ea:	1c0b      	adds	r3, r1, #0
 80029ec:	f008 ff1e 	bl	800b82c <usbd_ep_write_packet>
 80029f0:	2800      	cmp	r0, #0
 80029f2:	d0f7      	beq.n	80029e4 <gdb_if_flush+0x34>
 80029f4:	e7e2      	b.n	80029bc <gdb_if_flush+0xc>
 80029f6:	46c0      	nop			; (mov r8, r8)
 80029f8:	2000013c 	.word	0x2000013c
 80029fc:	20002080 	.word	0x20002080
 8002a00:	080118fb 	.word	0x080118fb

08002a04 <gdb_if_putchar_single>:

	count_in = 0;
}

void gdb_if_putchar_single(unsigned char c)
{
 8002a04:	b508      	push	{r3, lr}
	buffer_in[count_in++] = c;
 8002a06:	4b05      	ldr	r3, [pc, #20]	; (8002a1c <gdb_if_putchar_single+0x18>)
 8002a08:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8002a0a:	1c4a      	adds	r2, r1, #1
 8002a0c:	649a      	str	r2, [r3, #72]	; 0x48
 8002a0e:	334c      	adds	r3, #76	; 0x4c
 8002a10:	5458      	strb	r0, [r3, r1]
	if(count_in == sizeof buffer_in)
 8002a12:	2a3f      	cmp	r2, #63	; 0x3f
 8002a14:	d101      	bne.n	8002a1a <gdb_if_putchar_single+0x16>
		gdb_if_flush();
 8002a16:	f7ff ffcb 	bl	80029b0 <gdb_if_flush>
}
 8002a1a:	bd08      	pop	{r3, pc}
 8002a1c:	2000013c 	.word	0x2000013c

08002a20 <gdb_if_getchar>:
	out_ptr = 0;
#endif
}

unsigned char gdb_if_getchar(void)
{
 8002a20:	b508      	push	{r3, lr}

	while (!(out_ptr < count_out)) {
 8002a22:	4b09      	ldr	r3, [pc, #36]	; (8002a48 <gdb_if_getchar+0x28>)
 8002a24:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002a26:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002a28:	428a      	cmp	r2, r1
 8002a2a:	d306      	bcc.n	8002a3a <gdb_if_getchar+0x1a>
		/* detach if port closed */
		if (!cdcacm_get_dtr())
 8002a2c:	f008 fc7e 	bl	800b32c <cdcacm_get_dtr>
 8002a30:	2800      	cmp	r0, #0
 8002a32:	d006      	beq.n	8002a42 <gdb_if_getchar+0x22>
			return 0x04;

		gdb_if_update_buf();
 8002a34:	f7ff ff6e 	bl	8002914 <gdb_if_update_buf>
 8002a38:	e7f3      	b.n	8002a22 <gdb_if_getchar+0x2>
	}

	return buffer_out[out_ptr++];
 8002a3a:	1c51      	adds	r1, r2, #1
 8002a3c:	6459      	str	r1, [r3, #68]	; 0x44
 8002a3e:	5c98      	ldrb	r0, [r3, r2]
 8002a40:	e000      	b.n	8002a44 <gdb_if_getchar+0x24>
{

	while (!(out_ptr < count_out)) {
		/* detach if port closed */
		if (!cdcacm_get_dtr())
			return 0x04;
 8002a42:	2004      	movs	r0, #4

		gdb_if_update_buf();
	}

	return buffer_out[out_ptr++];
}
 8002a44:	bd08      	pop	{r3, pc}
 8002a46:	46c0      	nop			; (mov r8, r8)
 8002a48:	2000013c 	.word	0x2000013c

08002a4c <gdb_if_getchar_single>:

unsigned char gdb_if_getchar_single(void)
{
 8002a4c:	b508      	push	{r3, lr}

	while (!(out_ptr < count_out)) {
 8002a4e:	4b06      	ldr	r3, [pc, #24]	; (8002a68 <gdb_if_getchar_single+0x1c>)
 8002a50:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002a52:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002a54:	428a      	cmp	r2, r1
 8002a56:	d302      	bcc.n	8002a5e <gdb_if_getchar_single+0x12>
		gdb_if_update_buf();
 8002a58:	f7ff ff5c 	bl	8002914 <gdb_if_update_buf>
 8002a5c:	e7f7      	b.n	8002a4e <gdb_if_getchar_single+0x2>
	}

	return buffer_out[out_ptr++];
 8002a5e:	1c51      	adds	r1, r2, #1
 8002a60:	5c98      	ldrb	r0, [r3, r2]
 8002a62:	6459      	str	r1, [r3, #68]	; 0x44
}
 8002a64:	bd08      	pop	{r3, pc}
 8002a66:	46c0      	nop			; (mov r8, r8)
 8002a68:	2000013c 	.word	0x2000013c

08002a6c <gdb_if_poll_char>:

unsigned char gdb_if_poll_char(void)
{
 8002a6c:	b508      	push	{r3, lr}
	if (!(out_ptr < count_out)) {
 8002a6e:	4b06      	ldr	r3, [pc, #24]	; (8002a88 <gdb_if_poll_char+0x1c>)
 8002a70:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002a72:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002a74:	428a      	cmp	r2, r1
 8002a76:	d303      	bcc.n	8002a80 <gdb_if_poll_char+0x14>
		gdb_if_update_buf();
 8002a78:	f7ff ff4c 	bl	8002914 <gdb_if_update_buf>
		return -1;
 8002a7c:	20ff      	movs	r0, #255	; 0xff
 8002a7e:	e002      	b.n	8002a86 <gdb_if_poll_char+0x1a>
	}

	return buffer_out[out_ptr++];
 8002a80:	1c51      	adds	r1, r2, #1
 8002a82:	5c98      	ldrb	r0, [r3, r2]
 8002a84:	6459      	str	r1, [r3, #68]	; 0x44
}
 8002a86:	bd08      	pop	{r3, pc}
 8002a88:	2000013c 	.word	0x2000013c

08002a8c <gdb_if_getchar_to>:

unsigned char gdb_if_getchar_to(int timeout)
{
 8002a8c:	b513      	push	{r0, r1, r4, lr}
 8002a8e:	1c01      	adds	r1, r0, #0
	platform_timeout t;
	platform_timeout_set(&t, timeout);
 8002a90:	a801      	add	r0, sp, #4
 8002a92:	f008 fcfd 	bl	800b490 <platform_timeout_set>

	if (!(out_ptr < count_out)) do {
 8002a96:	4c0f      	ldr	r4, [pc, #60]	; (8002ad4 <gdb_if_getchar_to+0x48>)
 8002a98:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8002a9a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002a9c:	429a      	cmp	r2, r3
 8002a9e:	d212      	bcs.n	8002ac6 <gdb_if_getchar_to+0x3a>
			return 0x04;

		gdb_if_update_buf();
	} while (!platform_timeout_is_expired(&t) && !(out_ptr < count_out));

	if(out_ptr < count_out)
 8002aa0:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8002aa2:	6c23      	ldr	r3, [r4, #64]	; 0x40
		return gdb_if_getchar();

	return -1;
 8002aa4:	20ff      	movs	r0, #255	; 0xff
			return 0x04;

		gdb_if_update_buf();
	} while (!platform_timeout_is_expired(&t) && !(out_ptr < count_out));

	if(out_ptr < count_out)
 8002aa6:	429a      	cmp	r2, r3
 8002aa8:	d212      	bcs.n	8002ad0 <gdb_if_getchar_to+0x44>
		return gdb_if_getchar();
 8002aaa:	f7ff ffb9 	bl	8002a20 <gdb_if_getchar>
 8002aae:	e00f      	b.n	8002ad0 <gdb_if_getchar_to+0x44>
	if (!(out_ptr < count_out)) do {
		/* Detach if port closed */
		if (!cdcacm_get_dtr())
			return 0x04;

		gdb_if_update_buf();
 8002ab0:	f7ff ff30 	bl	8002914 <gdb_if_update_buf>
	} while (!platform_timeout_is_expired(&t) && !(out_ptr < count_out));
 8002ab4:	a801      	add	r0, sp, #4
 8002ab6:	f008 fcf3 	bl	800b4a0 <platform_timeout_is_expired>
 8002aba:	2800      	cmp	r0, #0
 8002abc:	d1f0      	bne.n	8002aa0 <gdb_if_getchar_to+0x14>
 8002abe:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002ac0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002ac2:	4293      	cmp	r3, r2
 8002ac4:	d3ec      	bcc.n	8002aa0 <gdb_if_getchar_to+0x14>
	platform_timeout t;
	platform_timeout_set(&t, timeout);

	if (!(out_ptr < count_out)) do {
		/* Detach if port closed */
		if (!cdcacm_get_dtr())
 8002ac6:	f008 fc31 	bl	800b32c <cdcacm_get_dtr>
 8002aca:	2800      	cmp	r0, #0
 8002acc:	d1f0      	bne.n	8002ab0 <gdb_if_getchar_to+0x24>
			return 0x04;
 8002ace:	2004      	movs	r0, #4

	if(out_ptr < count_out)
		return gdb_if_getchar();

	return -1;
}
 8002ad0:	bd16      	pop	{r1, r2, r4, pc}
 8002ad2:	46c0      	nop			; (mov r8, r8)
 8002ad4:	2000013c 	.word	0x2000013c

08002ad8 <gdb_target_destroy_callback>:
static void handle_z_packet(char *packet, int len);

static void gdb_target_destroy_callback(struct target_controller *tc, target *t)
{
	(void)tc;
	if (cur_target == t)
 8002ad8:	4b05      	ldr	r3, [pc, #20]	; (8002af0 <gdb_target_destroy_callback+0x18>)
 8002ada:	681a      	ldr	r2, [r3, #0]
 8002adc:	428a      	cmp	r2, r1
 8002ade:	d101      	bne.n	8002ae4 <gdb_target_destroy_callback+0xc>
		cur_target = NULL;
 8002ae0:	2200      	movs	r2, #0
 8002ae2:	601a      	str	r2, [r3, #0]

	if (last_target == t)
 8002ae4:	685a      	ldr	r2, [r3, #4]
 8002ae6:	428a      	cmp	r2, r1
 8002ae8:	d101      	bne.n	8002aee <gdb_target_destroy_callback+0x16>
		last_target = NULL;
 8002aea:	2200      	movs	r2, #0
 8002aec:	605a      	str	r2, [r3, #4]
}
 8002aee:	4770      	bx	lr
 8002af0:	200001c8 	.word	0x200001c8

08002af4 <gdb_target_printf>:

static void gdb_target_printf(struct target_controller *tc,
                              const char *fmt, va_list ap)
{
 8002af4:	b508      	push	{r3, lr}
	(void)tc;
	gdb_voutf(fmt, ap);
 8002af6:	1c08      	adds	r0, r1, #0
 8002af8:	1c11      	adds	r1, r2, #0
 8002afa:	f000 ffaf 	bl	8003a5c <gdb_voutf>
}
 8002afe:	bd08      	pop	{r3, pc}

08002b00 <do_breakpoint_clear>:
	/* ( address length --) */
	result = target_breakwatch_set(cur_target, TARGET_BREAK_HARD, sf_pop(), length);
	print_str(result ? "breakpoint-error\n" : "breakpoint-ok\n");
}
static void do_breakpoint_clear(void)
{
 8002b00:	b538      	push	{r3, r4, r5, lr}
int result, length = sf_pop();
 8002b02:	f008 f93b 	bl	800ad7c <sf_pop>
	/* ( address length --) */
	result = target_breakwatch_clear(cur_target, TARGET_BREAK_HARD, sf_pop(), length);
 8002b06:	4b09      	ldr	r3, [pc, #36]	; (8002b2c <do_breakpoint_clear+0x2c>)
	result = target_breakwatch_set(cur_target, TARGET_BREAK_HARD, sf_pop(), length);
	print_str(result ? "breakpoint-error\n" : "breakpoint-ok\n");
}
static void do_breakpoint_clear(void)
{
int result, length = sf_pop();
 8002b08:	1c04      	adds	r4, r0, #0
	/* ( address length --) */
	result = target_breakwatch_clear(cur_target, TARGET_BREAK_HARD, sf_pop(), length);
 8002b0a:	681d      	ldr	r5, [r3, #0]
 8002b0c:	f008 f936 	bl	800ad7c <sf_pop>
 8002b10:	1c23      	adds	r3, r4, #0
 8002b12:	1c02      	adds	r2, r0, #0
 8002b14:	2101      	movs	r1, #1
 8002b16:	1c28      	adds	r0, r5, #0
 8002b18:	f005 fcd2 	bl	80084c0 <target_breakwatch_clear>
	print_str(result ? "breakpoint-error\n" : "breakpoint-ok\n");
 8002b1c:	4b04      	ldr	r3, [pc, #16]	; (8002b30 <do_breakpoint_clear+0x30>)
 8002b1e:	2800      	cmp	r0, #0
 8002b20:	d100      	bne.n	8002b24 <do_breakpoint_clear+0x24>
 8002b22:	4b04      	ldr	r3, [pc, #16]	; (8002b34 <do_breakpoint_clear+0x34>)
 8002b24:	1c18      	adds	r0, r3, #0
 8002b26:	f005 ff66 	bl	80089f6 <print_str>
}
 8002b2a:	bd38      	pop	{r3, r4, r5, pc}
 8002b2c:	200001c8 	.word	0x200001c8
 8002b30:	08011ac0 	.word	0x08011ac0
 8002b34:	08011ad2 	.word	0x08011ad2

08002b38 <do_breakpoint_set>:
		target_reset(cur_target);
	}
}

static void do_breakpoint_set(void)
{
 8002b38:	b538      	push	{r3, r4, r5, lr}
int result, length = sf_pop();
 8002b3a:	f008 f91f 	bl	800ad7c <sf_pop>
	/* ( address length --) */
	result = target_breakwatch_set(cur_target, TARGET_BREAK_HARD, sf_pop(), length);
 8002b3e:	4b09      	ldr	r3, [pc, #36]	; (8002b64 <do_breakpoint_set+0x2c>)
	}
}

static void do_breakpoint_set(void)
{
int result, length = sf_pop();
 8002b40:	1c04      	adds	r4, r0, #0
	/* ( address length --) */
	result = target_breakwatch_set(cur_target, TARGET_BREAK_HARD, sf_pop(), length);
 8002b42:	681d      	ldr	r5, [r3, #0]
 8002b44:	f008 f91a 	bl	800ad7c <sf_pop>
 8002b48:	1c23      	adds	r3, r4, #0
 8002b4a:	1c02      	adds	r2, r0, #0
 8002b4c:	2101      	movs	r1, #1
 8002b4e:	1c28      	adds	r0, r5, #0
 8002b50:	f005 fc90 	bl	8008474 <target_breakwatch_set>
	print_str(result ? "breakpoint-error\n" : "breakpoint-ok\n");
 8002b54:	4b04      	ldr	r3, [pc, #16]	; (8002b68 <do_breakpoint_set+0x30>)
 8002b56:	2800      	cmp	r0, #0
 8002b58:	d100      	bne.n	8002b5c <do_breakpoint_set+0x24>
 8002b5a:	4b04      	ldr	r3, [pc, #16]	; (8002b6c <do_breakpoint_set+0x34>)
 8002b5c:	1c18      	adds	r0, r3, #0
 8002b5e:	f005 ff4a 	bl	80089f6 <print_str>
}
 8002b62:	bd38      	pop	{r3, r4, r5, pc}
 8002b64:	200001c8 	.word	0x200001c8
 8002b68:	08011ac0 	.word	0x08011ac0
 8002b6c:	08011ad2 	.word	0x08011ad2

08002b70 <do_flash_write>:
		print_str("flash erased successfully");
	else
		print_str("error erasing flash");
}
static void do_flash_write(void)
{
 8002b70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002b72:	b0c3      	sub	sp, #268	; 0x10c
uint32_t len = sf_pop(), addr = sf_pop(), x;
 8002b74:	f008 f902 	bl	800ad7c <sf_pop>
 8002b78:	1c05      	adds	r5, r0, #0
 8002b7a:	f008 f8ff 	bl	800ad7c <sf_pop>
uint8_t buf[256];
int result = 0, i;
	if(!cur_target)
 8002b7e:	4b18      	ldr	r3, [pc, #96]	; (8002be0 <do_flash_write+0x70>)
	else
		print_str("error erasing flash");
}
static void do_flash_write(void)
{
uint32_t len = sf_pop(), addr = sf_pop(), x;
 8002b80:	9000      	str	r0, [sp, #0]
uint8_t buf[256];
int result = 0, i;
	if(!cur_target)
 8002b82:	681a      	ldr	r2, [r3, #0]
 8002b84:	1c1e      	adds	r6, r3, #0
 8002b86:	2700      	movs	r7, #0
	{
		print_str("target not connected\n");
 8002b88:	4816      	ldr	r0, [pc, #88]	; (8002be4 <do_flash_write+0x74>)
static void do_flash_write(void)
{
uint32_t len = sf_pop(), addr = sf_pop(), x;
uint8_t buf[256];
int result = 0, i;
	if(!cur_target)
 8002b8a:	2a00      	cmp	r2, #0
 8002b8c:	d024      	beq.n	8002bd8 <do_flash_write+0x68>
	{
		print_str("target not connected\n");
		return;
	}
	while (len)
 8002b8e:	2d00      	cmp	r5, #0
 8002b90:	d01a      	beq.n	8002bc8 <do_flash_write+0x58>
	{
		x = (len > sizeof buf) ? sizeof buf : len;
 8002b92:	2380      	movs	r3, #128	; 0x80
 8002b94:	9501      	str	r5, [sp, #4]
 8002b96:	005b      	lsls	r3, r3, #1
 8002b98:	429d      	cmp	r5, r3
 8002b9a:	d900      	bls.n	8002b9e <do_flash_write+0x2e>
 8002b9c:	9301      	str	r3, [sp, #4]
 8002b9e:	2400      	movs	r4, #0
		for (i = 0; i < x; buf[i ++] = gdb_if_getchar_single());
 8002ba0:	f7ff ff54 	bl	8002a4c <gdb_if_getchar_single>
 8002ba4:	ab02      	add	r3, sp, #8
 8002ba6:	54e0      	strb	r0, [r4, r3]
 8002ba8:	9b01      	ldr	r3, [sp, #4]
 8002baa:	3401      	adds	r4, #1
 8002bac:	429c      	cmp	r4, r3
 8002bae:	d1f7      	bne.n	8002ba0 <do_flash_write+0x30>
		result |= target_flash_write(cur_target, addr, buf, x);
 8002bb0:	1c23      	adds	r3, r4, #0
 8002bb2:	6830      	ldr	r0, [r6, #0]
 8002bb4:	9900      	ldr	r1, [sp, #0]
 8002bb6:	aa02      	add	r2, sp, #8
 8002bb8:	f005 fb4f 	bl	800825a <target_flash_write>
		addr += x;
 8002bbc:	9b00      	ldr	r3, [sp, #0]
	}
	while (len)
	{
		x = (len > sizeof buf) ? sizeof buf : len;
		for (i = 0; i < x; buf[i ++] = gdb_if_getchar_single());
		result |= target_flash_write(cur_target, addr, buf, x);
 8002bbe:	4307      	orrs	r7, r0
		addr += x;
 8002bc0:	191b      	adds	r3, r3, r4
 8002bc2:	9300      	str	r3, [sp, #0]
		len -= x;
 8002bc4:	1b2d      	subs	r5, r5, r4
 8002bc6:	e7e2      	b.n	8002b8e <do_flash_write+0x1e>
	}
	result |= target_flash_done(cur_target);
 8002bc8:	6830      	ldr	r0, [r6, #0]
 8002bca:	f005 fbaf 	bl	800832c <target_flash_done>
 8002bce:	4338      	orrs	r0, r7
	if (!result)
 8002bd0:	d101      	bne.n	8002bd6 <do_flash_write+0x66>
		print_str("flash written successfully");
 8002bd2:	4805      	ldr	r0, [pc, #20]	; (8002be8 <do_flash_write+0x78>)
 8002bd4:	e000      	b.n	8002bd8 <do_flash_write+0x68>
	else
		print_str("error writing flash");
 8002bd6:	4805      	ldr	r0, [pc, #20]	; (8002bec <do_flash_write+0x7c>)
 8002bd8:	f005 ff0d 	bl	80089f6 <print_str>
}
 8002bdc:	b043      	add	sp, #268	; 0x10c
 8002bde:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002be0:	200001c8 	.word	0x200001c8
 8002be4:	08011ae1 	.word	0x08011ae1
 8002be8:	08011af7 	.word	0x08011af7
 8002bec:	08011b12 	.word	0x08011b12

08002bf0 <do_flash_erase>:
			address += x;
		}
	}
}
static void do_flash_erase(void)
{
 8002bf0:	b570      	push	{r4, r5, r6, lr}
uint32_t len = sf_pop(), addr = sf_pop();
 8002bf2:	f008 f8c3 	bl	800ad7c <sf_pop>
 8002bf6:	1c05      	adds	r5, r0, #0
 8002bf8:	f008 f8c0 	bl	800ad7c <sf_pop>
	if(!cur_target)
 8002bfc:	4c0d      	ldr	r4, [pc, #52]	; (8002c34 <do_flash_erase+0x44>)
		}
	}
}
static void do_flash_erase(void)
{
uint32_t len = sf_pop(), addr = sf_pop();
 8002bfe:	1c06      	adds	r6, r0, #0
	if(!cur_target)
 8002c00:	6820      	ldr	r0, [r4, #0]
 8002c02:	2800      	cmp	r0, #0
 8002c04:	d101      	bne.n	8002c0a <do_flash_erase+0x1a>
	{
		print_str("target not connected\n");
 8002c06:	480c      	ldr	r0, [pc, #48]	; (8002c38 <do_flash_erase+0x48>)
 8002c08:	e010      	b.n	8002c2c <do_flash_erase+0x3c>
		return;
	}

	/* Reset target if first flash command! */
	/* This saves us if we're interrupted in IRQ context */
	target_reset(cur_target);
 8002c0a:	f005 fc23 	bl	8008454 <target_reset>

	if(target_flash_erase(cur_target, addr, len) == 0 && target_flash_done(cur_target) == 0)
 8002c0e:	6820      	ldr	r0, [r4, #0]
 8002c10:	1c31      	adds	r1, r6, #0
 8002c12:	1c2a      	adds	r2, r5, #0
 8002c14:	f005 faf6 	bl	8008204 <target_flash_erase>
 8002c18:	2800      	cmp	r0, #0
 8002c1a:	d106      	bne.n	8002c2a <do_flash_erase+0x3a>
 8002c1c:	6820      	ldr	r0, [r4, #0]
 8002c1e:	f005 fb85 	bl	800832c <target_flash_done>
 8002c22:	2800      	cmp	r0, #0
 8002c24:	d101      	bne.n	8002c2a <do_flash_erase+0x3a>
		print_str("flash erased successfully");
 8002c26:	4805      	ldr	r0, [pc, #20]	; (8002c3c <do_flash_erase+0x4c>)
 8002c28:	e000      	b.n	8002c2c <do_flash_erase+0x3c>
	else
		print_str("error erasing flash");
 8002c2a:	4805      	ldr	r0, [pc, #20]	; (8002c40 <do_flash_erase+0x50>)
 8002c2c:	f005 fee3 	bl	80089f6 <print_str>
}
 8002c30:	bd70      	pop	{r4, r5, r6, pc}
 8002c32:	46c0      	nop			; (mov r8, r8)
 8002c34:	200001c8 	.word	0x200001c8
 8002c38:	08011ae1 	.word	0x08011ae1
 8002c3c:	08011b26 	.word	0x08011b26
 8002c40:	08011b40 	.word	0x08011b40

08002c44 <do_target_memory_dump>:
	}
	else
		print_str("target not connected\n");
}
static void do_target_memory_dump(void)
{
 8002c44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002c46:	b093      	sub	sp, #76	; 0x4c
uint32_t len = sf_pop(), address = sf_pop();
 8002c48:	f008 f898 	bl	800ad7c <sf_pop>
 8002c4c:	1c04      	adds	r4, r0, #0
 8002c4e:	f008 f895 	bl	800ad7c <sf_pop>
	if (!cur_target)
 8002c52:	4b11      	ldr	r3, [pc, #68]	; (8002c98 <do_target_memory_dump+0x54>)
	else
		print_str("target not connected\n");
}
static void do_target_memory_dump(void)
{
uint32_t len = sf_pop(), address = sf_pop();
 8002c54:	1c07      	adds	r7, r0, #0
	if (!cur_target)
 8002c56:	681a      	ldr	r2, [r3, #0]
 8002c58:	9301      	str	r3, [sp, #4]
 8002c5a:	2a00      	cmp	r2, #0
 8002c5c:	d118      	bne.n	8002c90 <do_target_memory_dump+0x4c>
	{
		print_str("target not connected\n");
 8002c5e:	480f      	ldr	r0, [pc, #60]	; (8002c9c <do_target_memory_dump+0x58>)
 8002c60:	f005 fec9 	bl	80089f6 <print_str>
		return;
 8002c64:	e016      	b.n	8002c94 <do_target_memory_dump+0x50>
			uint8_t		data[0];
		} buf;
		int i, x;
		while (len)
		{
			x = ((len > sizeof buf) ? sizeof buf : len);
 8002c66:	1e25      	subs	r5, r4, #0
 8002c68:	2d3c      	cmp	r5, #60	; 0x3c
 8002c6a:	d900      	bls.n	8002c6e <do_target_memory_dump+0x2a>
 8002c6c:	253c      	movs	r5, #60	; 0x3c
			/*! \todo	handle errors here */
			target_mem_read(cur_target, buf.idata, address, x);
 8002c6e:	9b01      	ldr	r3, [sp, #4]
 8002c70:	a903      	add	r1, sp, #12
 8002c72:	6818      	ldr	r0, [r3, #0]
 8002c74:	1c3a      	adds	r2, r7, #0
 8002c76:	1c2b      	adds	r3, r5, #0
 8002c78:	f005 fbd4 	bl	8008424 <target_mem_read>
 8002c7c:	2600      	movs	r6, #0
			for (i = 0; i < x; gdb_if_putchar_single(buf.data[i ++]));
 8002c7e:	ab03      	add	r3, sp, #12
 8002c80:	5d98      	ldrb	r0, [r3, r6]
 8002c82:	3601      	adds	r6, #1
 8002c84:	f7ff febe 	bl	8002a04 <gdb_if_putchar_single>
 8002c88:	42ae      	cmp	r6, r5
 8002c8a:	dbf8      	blt.n	8002c7e <do_target_memory_dump+0x3a>
			len -= x;
 8002c8c:	1b64      	subs	r4, r4, r5
			address += x;
 8002c8e:	197f      	adds	r7, r7, r5
		{
			uint32_t	idata[15];
			uint8_t		data[0];
		} buf;
		int i, x;
		while (len)
 8002c90:	2c00      	cmp	r4, #0
 8002c92:	d1e8      	bne.n	8002c66 <do_target_memory_dump+0x22>
			for (i = 0; i < x; gdb_if_putchar_single(buf.data[i ++]));
			len -= x;
			address += x;
		}
	}
}
 8002c94:	b013      	add	sp, #76	; 0x4c
 8002c96:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002c98:	200001c8 	.word	0x200001c8
 8002c9c:	08011ae1 	.word	0x08011ae1

08002ca0 <do_question_target_mem_map>:
	else
		print_str("error writing flash");
}

static void do_question_target_mem_map(void)
{
 8002ca0:	b508      	push	{r3, lr}
	if(!cur_target)
 8002ca2:	4b07      	ldr	r3, [pc, #28]	; (8002cc0 <do_question_target_mem_map+0x20>)
 8002ca4:	6818      	ldr	r0, [r3, #0]
 8002ca6:	2800      	cmp	r0, #0
 8002ca8:	d101      	bne.n	8002cae <do_question_target_mem_map+0xe>
	{
		print_str("target not connected\n");
 8002caa:	4806      	ldr	r0, [pc, #24]	; (8002cc4 <do_question_target_mem_map+0x24>)
 8002cac:	e004      	b.n	8002cb8 <do_question_target_mem_map+0x18>
		return;
	}
	print_str(target_mem_map(cur_target));
 8002cae:	f005 fa53 	bl	8008158 <target_mem_map>
 8002cb2:	f005 fea0 	bl	80089f6 <print_str>
	print_str("\n");
 8002cb6:	4804      	ldr	r0, [pc, #16]	; (8002cc8 <do_question_target_mem_map+0x28>)
 8002cb8:	f005 fe9d 	bl	80089f6 <print_str>
}
 8002cbc:	bd08      	pop	{r3, pc}
 8002cbe:	46c0      	nop			; (mov r8, r8)
 8002cc0:	200001c8 	.word	0x200001c8
 8002cc4:	08011ae1 	.word	0x08011ae1
 8002cc8:	0800fc8c 	.word	0x0800fc8c

08002ccc <do_gdb_attach>:
	}
}


static void do_swdp_scan(void) { sf_push(command_process(cur_target, "swdp_scan")); }
static void do_gdb_attach(void) { sf_push((cur_target = target_attach_n(1, &gdb_controller)) != 0); }
 8002ccc:	b508      	push	{r3, lr}
 8002cce:	4905      	ldr	r1, [pc, #20]	; (8002ce4 <do_gdb_attach+0x18>)
 8002cd0:	2001      	movs	r0, #1
 8002cd2:	f005 fa1d 	bl	8008110 <target_attach_n>
 8002cd6:	4b04      	ldr	r3, [pc, #16]	; (8002ce8 <do_gdb_attach+0x1c>)
 8002cd8:	6018      	str	r0, [r3, #0]
 8002cda:	1e43      	subs	r3, r0, #1
 8002cdc:	4198      	sbcs	r0, r3
 8002cde:	f008 f855 	bl	800ad8c <sf_push>
 8002ce2:	bd08      	pop	{r3, pc}
 8002ce4:	2000001c 	.word	0x2000001c
 8002ce8:	200001c8 	.word	0x200001c8

08002cec <do_swdp_scan>:
		print_str("target-halted-breakpoint\n");
	}
}


static void do_swdp_scan(void) { sf_push(command_process(cur_target, "swdp_scan")); }
 8002cec:	b508      	push	{r3, lr}
 8002cee:	4b04      	ldr	r3, [pc, #16]	; (8002d00 <do_swdp_scan+0x14>)
 8002cf0:	4904      	ldr	r1, [pc, #16]	; (8002d04 <do_swdp_scan+0x18>)
 8002cf2:	6818      	ldr	r0, [r3, #0]
 8002cf4:	f7fe f83a 	bl	8000d6c <command_process>
 8002cf8:	f008 f848 	bl	800ad8c <sf_push>
 8002cfc:	bd08      	pop	{r3, pc}
 8002cfe:	46c0      	nop			; (mov r8, r8)
 8002d00:	200001c8 	.word	0x200001c8
 8002d04:	0800fe0d 	.word	0x0800fe0d

08002d08 <do_quesstion_target_run_state>:
		print_str("target not connected\n");
}
static void do_quesstion_target_run_state(void)
{
target_addr watch;
	if (cur_target)
 8002d08:	4b0a      	ldr	r3, [pc, #40]	; (8002d34 <do_quesstion_target_run_state+0x2c>)
	}
	else
		print_str("target not connected\n");
}
static void do_quesstion_target_run_state(void)
{
 8002d0a:	b507      	push	{r0, r1, r2, lr}
target_addr watch;
	if (cur_target)
 8002d0c:	6818      	ldr	r0, [r3, #0]
 8002d0e:	2800      	cmp	r0, #0
 8002d10:	d00b      	beq.n	8002d2a <do_quesstion_target_run_state+0x22>
	{
		sf_push(target_halt_poll(cur_target, &watch));
 8002d12:	a901      	add	r1, sp, #4
 8002d14:	f005 fba6 	bl	8008464 <target_halt_poll>
 8002d18:	f008 f838 	bl	800ad8c <sf_push>
		if (!sf_top())
 8002d1c:	f008 f832 	bl	800ad84 <sf_top>
 8002d20:	2800      	cmp	r0, #0
 8002d22:	d105      	bne.n	8002d30 <do_quesstion_target_run_state+0x28>
			SET_RUN_STATE(0);
 8002d24:	4b04      	ldr	r3, [pc, #16]	; (8002d38 <do_quesstion_target_run_state+0x30>)
 8002d26:	7018      	strb	r0, [r3, #0]
 8002d28:	e002      	b.n	8002d30 <do_quesstion_target_run_state+0x28>
	}
	else
		print_str("target not connected\n");
 8002d2a:	4804      	ldr	r0, [pc, #16]	; (8002d3c <do_quesstion_target_run_state+0x34>)
 8002d2c:	f005 fe63 	bl	80089f6 <print_str>
}
 8002d30:	bd07      	pop	{r0, r1, r2, pc}
 8002d32:	46c0      	nop			; (mov r8, r8)
 8002d34:	200001c8 	.word	0x200001c8
 8002d38:	2000207c 	.word	0x2000207c
 8002d3c:	08011ae1 	.word	0x08011ae1

08002d40 <do_target_fetch>:
	{
		print_str("target not connected\n");
	}
}
static void do_target_fetch(void)
{
 8002d40:	b513      	push	{r0, r1, r4, lr}
uint32_t address, x;
	address = sf_pop();
 8002d42:	f008 f81b 	bl	800ad7c <sf_pop>
	if (!cur_target)
 8002d46:	4b0e      	ldr	r3, [pc, #56]	; (8002d80 <do_target_fetch+0x40>)
	}
}
static void do_target_fetch(void)
{
uint32_t address, x;
	address = sf_pop();
 8002d48:	1c04      	adds	r4, r0, #0
	if (!cur_target)
 8002d4a:	6818      	ldr	r0, [r3, #0]
 8002d4c:	2800      	cmp	r0, #0
 8002d4e:	d103      	bne.n	8002d58 <do_target_fetch+0x18>
	{
		print_str("target not connected\n");
 8002d50:	480c      	ldr	r0, [pc, #48]	; (8002d84 <do_target_fetch+0x44>)
 8002d52:	f005 fe50 	bl	80089f6 <print_str>
 8002d56:	e012      	b.n	8002d7e <do_target_fetch+0x3e>
		return;
	}
	if (!target_mem_read(cur_target, &x, address, sizeof x))
 8002d58:	a901      	add	r1, sp, #4
 8002d5a:	1c22      	adds	r2, r4, #0
 8002d5c:	2304      	movs	r3, #4
 8002d5e:	f005 fb61 	bl	8008424 <target_mem_read>
 8002d62:	2800      	cmp	r0, #0
 8002d64:	d101      	bne.n	8002d6a <do_target_fetch+0x2a>
		sf_push(x);
 8002d66:	9801      	ldr	r0, [sp, #4]
 8002d68:	e007      	b.n	8002d7a <do_target_fetch+0x3a>
	else
		sf_push(address), sf_eval(".( failed to read memory at address ) base @ swap hex . cr base !"), sf_push(-1);
 8002d6a:	1c20      	adds	r0, r4, #0
 8002d6c:	f008 f80e 	bl	800ad8c <sf_push>
 8002d70:	4805      	ldr	r0, [pc, #20]	; (8002d88 <do_target_fetch+0x48>)
 8002d72:	f008 f80f 	bl	800ad94 <sf_eval>
 8002d76:	2001      	movs	r0, #1
 8002d78:	4240      	negs	r0, r0
 8002d7a:	f008 f807 	bl	800ad8c <sf_push>
}
 8002d7e:	bd13      	pop	{r0, r1, r4, pc}
 8002d80:	200001c8 	.word	0x200001c8
 8002d84:	08011ae1 	.word	0x08011ae1
 8002d88:	08011b54 	.word	0x08011b54

08002d8c <do_read_registers>:


static void do_swdp_scan(void) { sf_push(command_process(cur_target, "swdp_scan")); }
static void do_gdb_attach(void) { sf_push((cur_target = target_attach_n(1, &gdb_controller)) != 0); }
static void do_read_registers(void)
{
 8002d8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (cur_target)
 8002d8e:	4d17      	ldr	r5, [pc, #92]	; (8002dec <do_read_registers+0x60>)


static void do_swdp_scan(void) { sf_push(command_process(cur_target, "swdp_scan")); }
static void do_gdb_attach(void) { sf_push((cur_target = target_attach_n(1, &gdb_controller)) != 0); }
static void do_read_registers(void)
{
 8002d90:	af00      	add	r7, sp, #0
	if (cur_target)
 8002d92:	6828      	ldr	r0, [r5, #0]
 8002d94:	2800      	cmp	r0, #0
 8002d96:	d024      	beq.n	8002de2 <do_read_registers+0x56>
 8002d98:	466b      	mov	r3, sp
 8002d9a:	607b      	str	r3, [r7, #4]
	{
		int i, n;
		uint32_t arm_regs[n = (target_regs_size(cur_target) / sizeof(uint32_t))];
 8002d9c:	f005 fbba 	bl	8008514 <target_regs_size>
 8002da0:	466a      	mov	r2, sp
 8002da2:	0884      	lsrs	r4, r0, #2
 8002da4:	00a3      	lsls	r3, r4, #2
 8002da6:	330a      	adds	r3, #10
 8002da8:	08db      	lsrs	r3, r3, #3
 8002daa:	00db      	lsls	r3, r3, #3
 8002dac:	1ad3      	subs	r3, r2, r3
 8002dae:	469d      	mov	sp, r3
		target_regs_read(cur_target, arm_regs);
 8002db0:	6828      	ldr	r0, [r5, #0]
 8002db2:	4669      	mov	r1, sp
 8002db4:	f005 fb46 	bl	8008444 <target_regs_read>
		sf_eval("base @ hex");
 8002db8:	480d      	ldr	r0, [pc, #52]	; (8002df0 <do_read_registers+0x64>)
static void do_read_registers(void)
{
	if (cur_target)
	{
		int i, n;
		uint32_t arm_regs[n = (target_regs_size(cur_target) / sizeof(uint32_t))];
 8002dba:	466e      	mov	r6, sp
		target_regs_read(cur_target, arm_regs);
		sf_eval("base @ hex");
 8002dbc:	f007 ffea 	bl	800ad94 <sf_eval>
		for (i = 0; i < n; sf_push(arm_regs[i ++]), do_u_dot());
 8002dc0:	2500      	movs	r5, #0
 8002dc2:	42a5      	cmp	r5, r4
 8002dc4:	da07      	bge.n	8002dd6 <do_read_registers+0x4a>
 8002dc6:	00ab      	lsls	r3, r5, #2
 8002dc8:	58f0      	ldr	r0, [r6, r3]
 8002dca:	f007 ffdf 	bl	800ad8c <sf_push>
 8002dce:	3501      	adds	r5, #1
 8002dd0:	f006 fcce 	bl	8009770 <do_u_dot>
 8002dd4:	e7f5      	b.n	8002dc2 <do_read_registers+0x36>
		sf_eval("cr base !");
 8002dd6:	4807      	ldr	r0, [pc, #28]	; (8002df4 <do_read_registers+0x68>)
 8002dd8:	f007 ffdc 	bl	800ad94 <sf_eval>
 8002ddc:	687b      	ldr	r3, [r7, #4]
 8002dde:	469d      	mov	sp, r3
 8002de0:	e002      	b.n	8002de8 <do_read_registers+0x5c>
	}
	else
	{
		print_str("target not connected\n");
 8002de2:	4805      	ldr	r0, [pc, #20]	; (8002df8 <do_read_registers+0x6c>)
 8002de4:	f005 fe07 	bl	80089f6 <print_str>
	}
}
 8002de8:	46bd      	mov	sp, r7
 8002dea:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8002dec:	200001c8 	.word	0x200001c8
 8002df0:	08011b96 	.word	0x08011b96
 8002df4:	08011b8c 	.word	0x08011b8c
 8002df8:	08011ae1 	.word	0x08011ae1

08002dfc <do_target_reset>:
	}
	print_str(target_mem_map(cur_target));
	print_str("\n");
}
static void do_target_reset(void)
{
 8002dfc:	b510      	push	{r4, lr}
	if(cur_target)
 8002dfe:	4c07      	ldr	r4, [pc, #28]	; (8002e1c <do_target_reset+0x20>)
 8002e00:	6820      	ldr	r0, [r4, #0]
 8002e02:	2800      	cmp	r0, #0
 8002e04:	d106      	bne.n	8002e14 <do_target_reset+0x18>
		target_reset(cur_target);
	else if(last_target) {
 8002e06:	6860      	ldr	r0, [r4, #4]
 8002e08:	2800      	cmp	r0, #0
 8002e0a:	d005      	beq.n	8002e18 <do_target_reset+0x1c>
		cur_target = target_attach(last_target,
 8002e0c:	4904      	ldr	r1, [pc, #16]	; (8002e20 <do_target_reset+0x24>)
 8002e0e:	f005 f96b 	bl	80080e8 <target_attach>
 8002e12:	6020      	str	r0, [r4, #0]
		                           &gdb_controller);
		target_reset(cur_target);
 8002e14:	f005 fb1e 	bl	8008454 <target_reset>
	}
}
 8002e18:	bd10      	pop	{r4, pc}
 8002e1a:	46c0      	nop			; (mov r8, r8)
 8002e1c:	200001c8 	.word	0x200001c8
 8002e20:	2000001c 	.word	0x2000001c

08002e24 <wait_target_halted>:
/* sforth extension words */
#include "engine.h"
#include "sf-word-wizard.h"

static void wait_target_halted(void)
{
 8002e24:	b513      	push	{r0, r1, r4, lr}

	target_addr watch;
	enum target_halt_reason reason;

	if(!cur_target) {
 8002e26:	4c16      	ldr	r4, [pc, #88]	; (8002e80 <wait_target_halted+0x5c>)
 8002e28:	6823      	ldr	r3, [r4, #0]
 8002e2a:	2b00      	cmp	r3, #0
 8002e2c:	d024      	beq.n	8002e78 <wait_target_halted+0x54>
		print_str("target not connected");
		return;
	}

	/* Wait for target halt */
	while(!(reason = target_halt_poll(cur_target, &watch))) {
 8002e2e:	6820      	ldr	r0, [r4, #0]
 8002e30:	a901      	add	r1, sp, #4
 8002e32:	f005 fb17 	bl	8008464 <target_halt_poll>
 8002e36:	2800      	cmp	r0, #0
 8002e38:	d109      	bne.n	8002e4e <wait_target_halted+0x2a>
		unsigned char c = gdb_if_poll_char();
 8002e3a:	f7ff fe17 	bl	8002a6c <gdb_if_poll_char>
		if((c == '\x03') || (c == '\x04')) {
 8002e3e:	3803      	subs	r0, #3
 8002e40:	b2c0      	uxtb	r0, r0
 8002e42:	2801      	cmp	r0, #1
 8002e44:	d8f3      	bhi.n	8002e2e <wait_target_halted+0xa>
			target_halt_request(cur_target);
 8002e46:	6820      	ldr	r0, [r4, #0]
 8002e48:	f005 fb08 	bl	800845c <target_halt_request>
 8002e4c:	e7ef      	b.n	8002e2e <wait_target_halted+0xa>
		}
	}
	SET_RUN_STATE(0);
 8002e4e:	2200      	movs	r2, #0
 8002e50:	4b0c      	ldr	r3, [pc, #48]	; (8002e84 <wait_target_halted+0x60>)

	/* Translate reason to GDB signal */
	switch (reason) {
 8002e52:	3801      	subs	r0, #1
		unsigned char c = gdb_if_poll_char();
		if((c == '\x03') || (c == '\x04')) {
			target_halt_request(cur_target);
		}
	}
	SET_RUN_STATE(0);
 8002e54:	701a      	strb	r2, [r3, #0]

	/* Translate reason to GDB signal */
	switch (reason) {
 8002e56:	2805      	cmp	r0, #5
 8002e58:	d80c      	bhi.n	8002e74 <wait_target_halted+0x50>
 8002e5a:	f00b fd8f 	bl	800e97c <__gnu_thumb1_case_uqi>
 8002e5e:	0503      	.short	0x0503
 8002e60:	09070b0b 	.word	0x09070b0b
	case TARGET_HALT_ERROR:
		print_str("target-lost\n");
 8002e64:	4808      	ldr	r0, [pc, #32]	; (8002e88 <wait_target_halted+0x64>)
 8002e66:	e008      	b.n	8002e7a <wait_target_halted+0x56>
		break;
	case TARGET_HALT_REQUEST:
		print_str("target-halted\n");
 8002e68:	4808      	ldr	r0, [pc, #32]	; (8002e8c <wait_target_halted+0x68>)
 8002e6a:	e006      	b.n	8002e7a <wait_target_halted+0x56>
		break;
	case TARGET_HALT_WATCHPOINT:
		print_str("target-halted-watchpoint\n");
 8002e6c:	4808      	ldr	r0, [pc, #32]	; (8002e90 <wait_target_halted+0x6c>)
 8002e6e:	e004      	b.n	8002e7a <wait_target_halted+0x56>
		break;
	case TARGET_HALT_FAULT:
		print_str("target-halted-fault\n");
 8002e70:	4808      	ldr	r0, [pc, #32]	; (8002e94 <wait_target_halted+0x70>)
 8002e72:	e002      	b.n	8002e7a <wait_target_halted+0x56>
		break;
	default:
		print_str("target-halted-breakpoint\n");
 8002e74:	4808      	ldr	r0, [pc, #32]	; (8002e98 <wait_target_halted+0x74>)
 8002e76:	e000      	b.n	8002e7a <wait_target_halted+0x56>
	target_addr watch;
	enum target_halt_reason reason;

	if(!cur_target) {
		/* Report "target exited" if no target */
		print_str("target not connected");
 8002e78:	4808      	ldr	r0, [pc, #32]	; (8002e9c <wait_target_halted+0x78>)
 8002e7a:	f005 fdbc 	bl	80089f6 <print_str>
		print_str("target-halted-fault\n");
		break;
	default:
		print_str("target-halted-breakpoint\n");
	}
}
 8002e7e:	bd13      	pop	{r0, r1, r4, pc}
 8002e80:	200001c8 	.word	0x200001c8
 8002e84:	2000207c 	.word	0x2000207c
 8002e88:	08011ba1 	.word	0x08011ba1
 8002e8c:	08011bae 	.word	0x08011bae
 8002e90:	08011bbd 	.word	0x08011bbd
 8002e94:	08011bd7 	.word	0x08011bd7
 8002e98:	08011bec 	.word	0x08011bec
 8002e9c:	08011c06 	.word	0x08011c06

08002ea0 <do_target_request_halt>:
	}
	else
		print_str("target not connected\n");
}
static void do_target_request_halt(void)
{
 8002ea0:	b508      	push	{r3, lr}
	if (cur_target)
 8002ea2:	4b06      	ldr	r3, [pc, #24]	; (8002ebc <do_target_request_halt+0x1c>)
 8002ea4:	6818      	ldr	r0, [r3, #0]
 8002ea6:	2800      	cmp	r0, #0
 8002ea8:	d004      	beq.n	8002eb4 <do_target_request_halt+0x14>
	{
		target_halt_request(cur_target);
 8002eaa:	f005 fad7 	bl	800845c <target_halt_request>
		//print_str("requested target halt\n");
		wait_target_halted();
 8002eae:	f7ff ffb9 	bl	8002e24 <wait_target_halted>
 8002eb2:	e002      	b.n	8002eba <do_target_request_halt+0x1a>
	}
	else
		print_str("target not connected\n");
 8002eb4:	4802      	ldr	r0, [pc, #8]	; (8002ec0 <do_target_request_halt+0x20>)
 8002eb6:	f005 fd9e 	bl	80089f6 <print_str>
}
 8002eba:	bd08      	pop	{r3, pc}
 8002ebc:	200001c8 	.word	0x200001c8
 8002ec0:	08011ae1 	.word	0x08011ae1

08002ec4 <do_target_resume>:
	}
	else
		print_str("target not connected\n");
}
static void do_target_resume(void)
{
 8002ec4:	b508      	push	{r3, lr}
	if (cur_target)
 8002ec6:	4b08      	ldr	r3, [pc, #32]	; (8002ee8 <do_target_resume+0x24>)
 8002ec8:	6818      	ldr	r0, [r3, #0]
 8002eca:	2800      	cmp	r0, #0
 8002ecc:	d008      	beq.n	8002ee0 <do_target_resume+0x1c>
	{
		target_halt_resume(cur_target, false);
 8002ece:	2100      	movs	r1, #0
 8002ed0:	f005 facc 	bl	800846c <target_halt_resume>
		SET_RUN_STATE(1);
 8002ed4:	2201      	movs	r2, #1
 8002ed6:	4b05      	ldr	r3, [pc, #20]	; (8002eec <do_target_resume+0x28>)
 8002ed8:	701a      	strb	r2, [r3, #0]
		wait_target_halted();
 8002eda:	f7ff ffa3 	bl	8002e24 <wait_target_halted>
 8002ede:	e002      	b.n	8002ee6 <do_target_resume+0x22>
	}
	else
		print_str("target not connected\n");
 8002ee0:	4803      	ldr	r0, [pc, #12]	; (8002ef0 <do_target_resume+0x2c>)
 8002ee2:	f005 fd88 	bl	80089f6 <print_str>
}
 8002ee6:	bd08      	pop	{r3, pc}
 8002ee8:	200001c8 	.word	0x200001c8
 8002eec:	2000207c 	.word	0x2000207c
 8002ef0:	08011ae1 	.word	0x08011ae1

08002ef4 <do_target_single_step>:
		sf_push(x);
	else
		sf_push(address), sf_eval(".( failed to read memory at address ) base @ swap hex . cr base !"), sf_push(-1);
}
static void do_target_single_step(void)
{
 8002ef4:	b508      	push	{r3, lr}
target_addr watch;
enum target_halt_reason reason;

	if (cur_target)
 8002ef6:	4b08      	ldr	r3, [pc, #32]	; (8002f18 <do_target_single_step+0x24>)
 8002ef8:	6818      	ldr	r0, [r3, #0]
 8002efa:	2800      	cmp	r0, #0
 8002efc:	d008      	beq.n	8002f10 <do_target_single_step+0x1c>
	{
		target_halt_resume(cur_target, true);
 8002efe:	2101      	movs	r1, #1
 8002f00:	f005 fab4 	bl	800846c <target_halt_resume>
		SET_RUN_STATE(1);
 8002f04:	2201      	movs	r2, #1
 8002f06:	4b05      	ldr	r3, [pc, #20]	; (8002f1c <do_target_single_step+0x28>)
 8002f08:	701a      	strb	r2, [r3, #0]
		wait_target_halted();
 8002f0a:	f7ff ff8b 	bl	8002e24 <wait_target_halted>
 8002f0e:	e002      	b.n	8002f16 <do_target_single_step+0x22>
	}
	else
		print_str("target not connected\n");
 8002f10:	4803      	ldr	r0, [pc, #12]	; (8002f20 <do_target_single_step+0x2c>)
 8002f12:	f005 fd70 	bl	80089f6 <print_str>
}
 8002f16:	bd08      	pop	{r3, pc}
 8002f18:	200001c8 	.word	0x200001c8
 8002f1c:	2000207c 	.word	0x2000207c
 8002f20:	08011ae1 	.word	0x08011ae1

08002f24 <sfgetc>:
	.isatty = hostio_isatty,
	.system = hostio_system,
};

int sfgetc(void)
{
 8002f24:	b508      	push	{r3, lr}
	return gdb_if_getchar_single();
 8002f26:	f7ff fd91 	bl	8002a4c <gdb_if_getchar_single>
}
 8002f2a:	bd08      	pop	{r3, pc}

08002f2c <sfputc>:

int sfputc(int c)
{
 8002f2c:	b508      	push	{r3, lr}
	gdb_if_putchar_single(c);
 8002f2e:	b2c0      	uxtb	r0, r0
 8002f30:	f7ff fd68 	bl	8002a04 <gdb_if_putchar_single>
	return 0;
}
 8002f34:	2000      	movs	r0, #0
 8002f36:	bd08      	pop	{r3, pc}

08002f38 <sfsync>:

int sfsync(void)
{
 8002f38:	b508      	push	{r3, lr}
	gdb_if_flush();
 8002f3a:	f7ff fd39 	bl	80029b0 <gdb_if_flush>
	return 0;
}
 8002f3e:	2000      	movs	r0, #0
 8002f40:	bd08      	pop	{r3, pc}

08002f42 <gdb_main_loop>:

int gdb_main_loop(struct target_controller *tc, bool in_syscall)
{
 8002f42:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002f44:	b08d      	sub	sp, #52	; 0x34
 8002f46:	af02      	add	r7, sp, #8
 8002f48:	6078      	str	r0, [r7, #4]
 8002f4a:	60f9      	str	r1, [r7, #12]
	int size;
	bool single_step = false;

	if(is_sforth_mode_active())while(1)sf_reset(),do_quit();
 8002f4c:	f002 faca 	bl	80054e4 <is_sforth_mode_active>
 8002f50:	1e04      	subs	r4, r0, #0
 8002f52:	d004      	beq.n	8002f5e <gdb_main_loop+0x1c>
 8002f54:	f005 fc88 	bl	8008868 <sf_reset>
 8002f58:	f007 fe92 	bl	800ac80 <do_quit>
 8002f5c:	e7fa      	b.n	8002f54 <gdb_main_loop+0x12>

	DEBUG("Entering GDB protocol main loop\n");
 8002f5e:	48c2      	ldr	r0, [pc, #776]	; (8003268 <gdb_main_loop+0x326>)
 8002f60:	f009 fe0c 	bl	800cb7c <puts>
}

int gdb_main_loop(struct target_controller *tc, bool in_syscall)
{
	int size;
	bool single_step = false;
 8002f64:	617c      	str	r4, [r7, #20]
	if(is_sforth_mode_active())while(1)sf_reset(),do_quit();

	DEBUG("Entering GDB protocol main loop\n");
	/* GDB protocol main loop */
	while(1) {
		SET_IDLE_STATE(1);
 8002f66:	2090      	movs	r0, #144	; 0x90
 8002f68:	4dc0      	ldr	r5, [pc, #768]	; (800326c <gdb_main_loop+0x32a>)
 8002f6a:	05c0      	lsls	r0, r0, #23
 8002f6c:	8829      	ldrh	r1, [r5, #0]
 8002f6e:	f008 fba1 	bl	800b6b4 <gpio_set>
		size = gdb_getpacket(pbuf, BUF_SIZE);
 8002f72:	4cbf      	ldr	r4, [pc, #764]	; (8003270 <gdb_main_loop+0x32e>)
 8002f74:	2180      	movs	r1, #128	; 0x80
 8002f76:	1c26      	adds	r6, r4, #0
 8002f78:	3608      	adds	r6, #8
 8002f7a:	0149      	lsls	r1, r1, #5
 8002f7c:	1c30      	adds	r0, r6, #0
 8002f7e:	f000 fc8b 	bl	8003898 <gdb_getpacket>
 8002f82:	6138      	str	r0, [r7, #16]
		SET_IDLE_STATE(0);
 8002f84:	2090      	movs	r0, #144	; 0x90
 8002f86:	8829      	ldrh	r1, [r5, #0]
 8002f88:	05c0      	lsls	r0, r0, #23
 8002f8a:	f008 fb95 	bl	800b6b8 <gpio_clear>
		switch(pbuf[0]) {
 8002f8e:	7a25      	ldrb	r5, [r4, #8]
 8002f90:	2d5a      	cmp	r5, #90	; 0x5a
 8002f92:	d100      	bne.n	8002f96 <gdb_main_loop+0x54>
 8002f94:	e24c      	b.n	8003430 <gdb_main_loop+0x4ee>
 8002f96:	d820      	bhi.n	8002fda <gdb_main_loop+0x98>
 8002f98:	2d46      	cmp	r5, #70	; 0x46
 8002f9a:	d100      	bne.n	8002f9e <gdb_main_loop+0x5c>
 8002f9c:	e132      	b.n	8003204 <gdb_main_loop+0x2c2>
 8002f9e:	d80e      	bhi.n	8002fbe <gdb_main_loop+0x7c>
 8002fa0:	2d21      	cmp	r5, #33	; 0x21
 8002fa2:	d100      	bne.n	8002fa6 <gdb_main_loop+0x64>
 8002fa4:	e26c      	b.n	8003480 <gdb_main_loop+0x53e>
 8002fa6:	d803      	bhi.n	8002fb0 <gdb_main_loop+0x6e>
 8002fa8:	2d04      	cmp	r5, #4
 8002faa:	d100      	bne.n	8002fae <gdb_main_loop+0x6c>
 8002fac:	e135      	b.n	800321a <gdb_main_loop+0x2d8>
 8002fae:	e26a      	b.n	8003486 <gdb_main_loop+0x544>
 8002fb0:	2d3f      	cmp	r5, #63	; 0x3f
 8002fb2:	d100      	bne.n	8002fb6 <gdb_main_loop+0x74>
 8002fb4:	e0e7      	b.n	8003186 <gdb_main_loop+0x244>
 8002fb6:	2d44      	cmp	r5, #68	; 0x44
 8002fb8:	d100      	bne.n	8002fbc <gdb_main_loop+0x7a>
 8002fba:	e12e      	b.n	800321a <gdb_main_loop+0x2d8>
 8002fbc:	e263      	b.n	8003486 <gdb_main_loop+0x544>
 8002fbe:	2d4d      	cmp	r5, #77	; 0x4d
 8002fc0:	d100      	bne.n	8002fc4 <gdb_main_loop+0x82>
 8002fc2:	e09d      	b.n	8003100 <gdb_main_loop+0x1be>
 8002fc4:	d802      	bhi.n	8002fcc <gdb_main_loop+0x8a>
 8002fc6:	2d47      	cmp	r5, #71	; 0x47
 8002fc8:	d07b      	beq.n	80030c2 <gdb_main_loop+0x180>
 8002fca:	e25c      	b.n	8003486 <gdb_main_loop+0x544>
 8002fcc:	2d52      	cmp	r5, #82	; 0x52
 8002fce:	d100      	bne.n	8002fd2 <gdb_main_loop+0x90>
 8002fd0:	e13b      	b.n	800324a <gdb_main_loop+0x308>
 8002fd2:	2d58      	cmp	r5, #88	; 0x58
 8002fd4:	d100      	bne.n	8002fd8 <gdb_main_loop+0x96>
 8002fd6:	e16f      	b.n	80032b8 <gdb_main_loop+0x376>
 8002fd8:	e255      	b.n	8003486 <gdb_main_loop+0x544>
 8002fda:	2d71      	cmp	r5, #113	; 0x71
 8002fdc:	d100      	bne.n	8002fe0 <gdb_main_loop+0x9e>
 8002fde:	e194      	b.n	800330a <gdb_main_loop+0x3c8>
 8002fe0:	d80c      	bhi.n	8002ffc <gdb_main_loop+0xba>
 8002fe2:	2d67      	cmp	r5, #103	; 0x67
 8002fe4:	d016      	beq.n	8003014 <gdb_main_loop+0xd2>
 8002fe6:	d803      	bhi.n	8002ff0 <gdb_main_loop+0xae>
 8002fe8:	2d63      	cmp	r5, #99	; 0x63
 8002fea:	d100      	bne.n	8002fee <gdb_main_loop+0xac>
 8002fec:	e0be      	b.n	800316c <gdb_main_loop+0x22a>
 8002fee:	e24a      	b.n	8003486 <gdb_main_loop+0x544>
 8002ff0:	2d6b      	cmp	r5, #107	; 0x6b
 8002ff2:	d100      	bne.n	8002ff6 <gdb_main_loop+0xb4>
 8002ff4:	e11b      	b.n	800322e <gdb_main_loop+0x2ec>
 8002ff6:	2d6d      	cmp	r5, #109	; 0x6d
 8002ff8:	d02d      	beq.n	8003056 <gdb_main_loop+0x114>
 8002ffa:	e244      	b.n	8003486 <gdb_main_loop+0x544>
 8002ffc:	2d73      	cmp	r5, #115	; 0x73
 8002ffe:	d100      	bne.n	8003002 <gdb_main_loop+0xc0>
 8003000:	e0b2      	b.n	8003168 <gdb_main_loop+0x226>
 8003002:	d200      	bcs.n	8003006 <gdb_main_loop+0xc4>
 8003004:	e121      	b.n	800324a <gdb_main_loop+0x308>
 8003006:	2d76      	cmp	r5, #118	; 0x76
 8003008:	d100      	bne.n	800300c <gdb_main_loop+0xca>
 800300a:	e182      	b.n	8003312 <gdb_main_loop+0x3d0>
 800300c:	2d7a      	cmp	r5, #122	; 0x7a
 800300e:	d100      	bne.n	8003012 <gdb_main_loop+0xd0>
 8003010:	e20e      	b.n	8003430 <gdb_main_loop+0x4ee>
 8003012:	e238      	b.n	8003486 <gdb_main_loop+0x544>
 8003014:	466b      	mov	r3, sp
		/* Implementation of these is mandatory! */
		case 'g': { /* 'g': Read general registers */
			ERROR_IF_NO_TARGET();
 8003016:	6820      	ldr	r0, [r4, #0]
 8003018:	60bb      	str	r3, [r7, #8]
 800301a:	2800      	cmp	r0, #0
 800301c:	d102      	bne.n	8003024 <gdb_main_loop+0xe2>
 800301e:	4895      	ldr	r0, [pc, #596]	; (8003274 <gdb_main_loop+0x332>)
 8003020:	2103      	movs	r1, #3
 8003022:	e014      	b.n	800304e <gdb_main_loop+0x10c>
			uint8_t arm_regs[target_regs_size(cur_target)];
 8003024:	f005 fa76 	bl	8008514 <target_regs_size>
 8003028:	466a      	mov	r2, sp
 800302a:	1dc3      	adds	r3, r0, #7
 800302c:	08db      	lsrs	r3, r3, #3
 800302e:	00db      	lsls	r3, r3, #3
 8003030:	1ad3      	subs	r3, r2, r3
 8003032:	469d      	mov	sp, r3
 8003034:	1c05      	adds	r5, r0, #0
 8003036:	ab02      	add	r3, sp, #8
			target_regs_read(cur_target, arm_regs);
 8003038:	1c19      	adds	r1, r3, #0
 800303a:	6820      	ldr	r0, [r4, #0]
		SET_IDLE_STATE(0);
		switch(pbuf[0]) {
		/* Implementation of these is mandatory! */
		case 'g': { /* 'g': Read general registers */
			ERROR_IF_NO_TARGET();
			uint8_t arm_regs[target_regs_size(cur_target)];
 800303c:	613b      	str	r3, [r7, #16]
			target_regs_read(cur_target, arm_regs);
 800303e:	f005 fa01 	bl	8008444 <target_regs_read>
			gdb_putpacket(hexify(pbuf, arm_regs, sizeof(arm_regs)),
 8003042:	6939      	ldr	r1, [r7, #16]
 8003044:	1c30      	adds	r0, r6, #0
 8003046:	1c2a      	adds	r2, r5, #0
 8003048:	f000 fd24 	bl	8003a94 <hexify>
			              sizeof(arm_regs) * 2);
 800304c:	0069      	lsls	r1, r5, #1
		/* Implementation of these is mandatory! */
		case 'g': { /* 'g': Read general registers */
			ERROR_IF_NO_TARGET();
			uint8_t arm_regs[target_regs_size(cur_target)];
			target_regs_read(cur_target, arm_regs);
			gdb_putpacket(hexify(pbuf, arm_regs, sizeof(arm_regs)),
 800304e:	f000 fc69 	bl	8003924 <gdb_putpacket>
 8003052:	68bb      	ldr	r3, [r7, #8]
 8003054:	e033      	b.n	80030be <gdb_main_loop+0x17c>
 8003056:	466b      	mov	r3, sp
 8003058:	613b      	str	r3, [r7, #16]
			              sizeof(arm_regs) * 2);
			break;
			}
		case 'm': {	/* 'm addr,len': Read len bytes from addr */
			uint32_t addr, len;
			ERROR_IF_NO_TARGET();
 800305a:	6823      	ldr	r3, [r4, #0]
 800305c:	2b00      	cmp	r3, #0
 800305e:	d054      	beq.n	800310a <gdb_main_loop+0x1c8>
			sscanf(pbuf, "m%" SCNx32 ",%" SCNx32, &addr, &len);
 8003060:	2218      	movs	r2, #24
 8003062:	2308      	movs	r3, #8
 8003064:	2518      	movs	r5, #24
 8003066:	18ba      	adds	r2, r7, r2
 8003068:	18d2      	adds	r2, r2, r3
 800306a:	197d      	adds	r5, r7, r5
 800306c:	3304      	adds	r3, #4
 800306e:	18eb      	adds	r3, r5, r3
 8003070:	4981      	ldr	r1, [pc, #516]	; (8003278 <gdb_main_loop+0x336>)
 8003072:	1c30      	adds	r0, r6, #0
 8003074:	f009 fe58 	bl	800cd28 <siscanf>
			DEBUG("m packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
 8003078:	6a39      	ldr	r1, [r7, #32]
 800307a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800307c:	487f      	ldr	r0, [pc, #508]	; (800327c <gdb_main_loop+0x33a>)
 800307e:	f009 fced 	bl	800ca5c <iprintf>
			uint8_t mem[len];
 8003082:	466a      	mov	r2, sp
 8003084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
			if (target_mem_read(cur_target, mem, addr, len))
 8003086:	6820      	ldr	r0, [r4, #0]
		case 'm': {	/* 'm addr,len': Read len bytes from addr */
			uint32_t addr, len;
			ERROR_IF_NO_TARGET();
			sscanf(pbuf, "m%" SCNx32 ",%" SCNx32, &addr, &len);
			DEBUG("m packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
			uint8_t mem[len];
 8003088:	3307      	adds	r3, #7
 800308a:	08db      	lsrs	r3, r3, #3
 800308c:	00db      	lsls	r3, r3, #3
 800308e:	1ad3      	subs	r3, r2, r3
 8003090:	469d      	mov	sp, r3
 8003092:	ad02      	add	r5, sp, #8
			if (target_mem_read(cur_target, mem, addr, len))
 8003094:	1c29      	adds	r1, r5, #0
 8003096:	6a3a      	ldr	r2, [r7, #32]
 8003098:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800309a:	f005 f9c3 	bl	8008424 <target_mem_read>
 800309e:	2800      	cmp	r0, #0
 80030a0:	d002      	beq.n	80030a8 <gdb_main_loop+0x166>
				gdb_putpacketz("E01");
 80030a2:	4877      	ldr	r0, [pc, #476]	; (8003280 <gdb_main_loop+0x33e>)
 80030a4:	2103      	movs	r1, #3
 80030a6:	e007      	b.n	80030b8 <gdb_main_loop+0x176>
			else
				gdb_putpacket(hexify(pbuf, mem, len), len*2);
 80030a8:	4871      	ldr	r0, [pc, #452]	; (8003270 <gdb_main_loop+0x32e>)
 80030aa:	1c29      	adds	r1, r5, #0
 80030ac:	3008      	adds	r0, #8
 80030ae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80030b0:	f000 fcf0 	bl	8003a94 <hexify>
 80030b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80030b6:	0059      	lsls	r1, r3, #1
 80030b8:	f000 fc34 	bl	8003924 <gdb_putpacket>
 80030bc:	693b      	ldr	r3, [r7, #16]
 80030be:	469d      	mov	sp, r3
 80030c0:	e751      	b.n	8002f66 <gdb_main_loop+0x24>
			break;
			}
		case 'G': {	/* 'G XX': Write general registers */
			ERROR_IF_NO_TARGET();
 80030c2:	6820      	ldr	r0, [r4, #0]
 80030c4:	466e      	mov	r6, sp
 80030c6:	2800      	cmp	r0, #0
 80030c8:	d102      	bne.n	80030d0 <gdb_main_loop+0x18e>
 80030ca:	486a      	ldr	r0, [pc, #424]	; (8003274 <gdb_main_loop+0x332>)
 80030cc:	2103      	movs	r1, #3
 80030ce:	e013      	b.n	80030f8 <gdb_main_loop+0x1b6>
			uint8_t arm_regs[target_regs_size(cur_target)];
 80030d0:	f005 fa20 	bl	8008514 <target_regs_size>
 80030d4:	1dc3      	adds	r3, r0, #7
 80030d6:	08db      	lsrs	r3, r3, #3
 80030d8:	00db      	lsls	r3, r3, #3
 80030da:	1af3      	subs	r3, r6, r3
 80030dc:	469d      	mov	sp, r3
			unhexify(arm_regs, &pbuf[1], sizeof(arm_regs));
 80030de:	1c21      	adds	r1, r4, #0
				gdb_putpacket(hexify(pbuf, mem, len), len*2);
			break;
			}
		case 'G': {	/* 'G XX': Write general registers */
			ERROR_IF_NO_TARGET();
			uint8_t arm_regs[target_regs_size(cur_target)];
 80030e0:	ad02      	add	r5, sp, #8
 80030e2:	1c02      	adds	r2, r0, #0
			unhexify(arm_regs, &pbuf[1], sizeof(arm_regs));
 80030e4:	3109      	adds	r1, #9
 80030e6:	1c28      	adds	r0, r5, #0
 80030e8:	f000 fcec 	bl	8003ac4 <unhexify>
			target_regs_write(cur_target, arm_regs);
 80030ec:	6820      	ldr	r0, [r4, #0]
 80030ee:	1c29      	adds	r1, r5, #0
 80030f0:	f005 f9ac 	bl	800844c <target_regs_write>
			gdb_putpacketz("OK");
 80030f4:	2102      	movs	r1, #2
 80030f6:	4863      	ldr	r0, [pc, #396]	; (8003284 <gdb_main_loop+0x342>)
 80030f8:	f000 fc14 	bl	8003924 <gdb_putpacket>
 80030fc:	46b5      	mov	sp, r6
 80030fe:	e732      	b.n	8002f66 <gdb_main_loop+0x24>
 8003100:	466b      	mov	r3, sp
 8003102:	613b      	str	r3, [r7, #16]
			break;
			}
		case 'M': { /* 'M addr,len:XX': Write len bytes to addr */
			uint32_t addr, len;
			int hex;
			ERROR_IF_NO_TARGET();
 8003104:	6823      	ldr	r3, [r4, #0]
 8003106:	2b00      	cmp	r3, #0
 8003108:	d101      	bne.n	800310e <gdb_main_loop+0x1cc>
 800310a:	485a      	ldr	r0, [pc, #360]	; (8003274 <gdb_main_loop+0x332>)
 800310c:	e7ca      	b.n	80030a4 <gdb_main_loop+0x162>
			sscanf(pbuf, "M%" SCNx32 ",%" SCNx32 ":%n", &addr, &len, &hex);
 800310e:	2218      	movs	r2, #24
 8003110:	230c      	movs	r3, #12
 8003112:	18ba      	adds	r2, r7, r2
 8003114:	18d3      	adds	r3, r2, r3
 8003116:	9300      	str	r3, [sp, #0]
 8003118:	2518      	movs	r5, #24
 800311a:	231c      	movs	r3, #28
 800311c:	197d      	adds	r5, r7, r5
 800311e:	18fa      	adds	r2, r7, r3
 8003120:	3b14      	subs	r3, #20
 8003122:	18eb      	adds	r3, r5, r3
 8003124:	4958      	ldr	r1, [pc, #352]	; (8003288 <gdb_main_loop+0x346>)
 8003126:	1c30      	adds	r0, r6, #0
 8003128:	f009 fdfe 	bl	800cd28 <siscanf>
			DEBUG("M packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
 800312c:	69f9      	ldr	r1, [r7, #28]
 800312e:	6a3a      	ldr	r2, [r7, #32]
 8003130:	4856      	ldr	r0, [pc, #344]	; (800328c <gdb_main_loop+0x34a>)
 8003132:	f009 fc93 	bl	800ca5c <iprintf>
			uint8_t mem[len];
 8003136:	466a      	mov	r2, sp
 8003138:	6a3b      	ldr	r3, [r7, #32]
 800313a:	3307      	adds	r3, #7
 800313c:	08db      	lsrs	r3, r3, #3
 800313e:	00db      	lsls	r3, r3, #3
 8003140:	1ad3      	subs	r3, r2, r3
 8003142:	469d      	mov	sp, r3
			unhexify(mem, pbuf + hex, len);
 8003144:	6a7b      	ldr	r3, [r7, #36]	; 0x24
			uint32_t addr, len;
			int hex;
			ERROR_IF_NO_TARGET();
			sscanf(pbuf, "M%" SCNx32 ",%" SCNx32 ":%n", &addr, &len, &hex);
			DEBUG("M packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
			uint8_t mem[len];
 8003146:	ad02      	add	r5, sp, #8
			unhexify(mem, pbuf + hex, len);
 8003148:	18f1      	adds	r1, r6, r3
 800314a:	6a3a      	ldr	r2, [r7, #32]
 800314c:	1c28      	adds	r0, r5, #0
 800314e:	f000 fcb9 	bl	8003ac4 <unhexify>
			if (target_mem_write(cur_target, addr, mem, len))
 8003152:	6820      	ldr	r0, [r4, #0]
 8003154:	69f9      	ldr	r1, [r7, #28]
 8003156:	1c2a      	adds	r2, r5, #0
 8003158:	6a3b      	ldr	r3, [r7, #32]
 800315a:	f005 f96b 	bl	8008434 <target_mem_write>
 800315e:	2800      	cmp	r0, #0
 8003160:	d19f      	bne.n	80030a2 <gdb_main_loop+0x160>
				gdb_putpacketz("E01");
			else
				gdb_putpacketz("OK");
 8003162:	4848      	ldr	r0, [pc, #288]	; (8003284 <gdb_main_loop+0x342>)
 8003164:	2102      	movs	r1, #2
 8003166:	e7a7      	b.n	80030b8 <gdb_main_loop+0x176>
			break;
			}
		case 's':	/* 's [addr]': Single step [start at addr] */
			single_step = true;
 8003168:	2301      	movs	r3, #1
 800316a:	617b      	str	r3, [r7, #20]
			// Fall through to resume target
		case 'c':	/* 'c [addr]': Continue [at addr] */
			if(!cur_target) {
 800316c:	6820      	ldr	r0, [r4, #0]
 800316e:	2800      	cmp	r0, #0
 8003170:	d101      	bne.n	8003176 <gdb_main_loop+0x234>
				gdb_putpacketz("X1D");
 8003172:	4847      	ldr	r0, [pc, #284]	; (8003290 <gdb_main_loop+0x34e>)
 8003174:	e180      	b.n	8003478 <gdb_main_loop+0x536>
				break;
			}

			target_halt_resume(cur_target, single_step);
 8003176:	6979      	ldr	r1, [r7, #20]
 8003178:	f005 f978 	bl	800846c <target_halt_resume>
			SET_RUN_STATE(1);
 800317c:	2201      	movs	r2, #1
 800317e:	4b45      	ldr	r3, [pc, #276]	; (8003294 <gdb_main_loop+0x352>)
 8003180:	701a      	strb	r2, [r3, #0]
			single_step = false;
 8003182:	2300      	movs	r3, #0
 8003184:	617b      	str	r3, [r7, #20]
			/* This packet isn't documented as being mandatory,
			 * but GDB doesn't work without it. */
			target_addr watch;
			enum target_halt_reason reason;

			if(!cur_target) {
 8003186:	6823      	ldr	r3, [r4, #0]
				/* Report "target exited" if no target */
				gdb_putpacketz("W00");
 8003188:	4843      	ldr	r0, [pc, #268]	; (8003298 <gdb_main_loop+0x356>)
			/* This packet isn't documented as being mandatory,
			 * but GDB doesn't work without it. */
			target_addr watch;
			enum target_halt_reason reason;

			if(!cur_target) {
 800318a:	2b00      	cmp	r3, #0
 800318c:	d100      	bne.n	8003190 <gdb_main_loop+0x24e>
 800318e:	e173      	b.n	8003478 <gdb_main_loop+0x536>
				gdb_putpacketz("W00");
				break;
			}

			/* Wait for target halt */
			while(!(reason = target_halt_poll(cur_target, &watch))) {
 8003190:	4b37      	ldr	r3, [pc, #220]	; (8003270 <gdb_main_loop+0x32e>)
 8003192:	2218      	movs	r2, #24
 8003194:	6818      	ldr	r0, [r3, #0]
 8003196:	230c      	movs	r3, #12
 8003198:	18ba      	adds	r2, r7, r2
 800319a:	18d1      	adds	r1, r2, r3
 800319c:	f005 f962 	bl	8008464 <target_halt_poll>
 80031a0:	2800      	cmp	r0, #0
 80031a2:	d10a      	bne.n	80031ba <gdb_main_loop+0x278>
				unsigned char c = gdb_if_getchar_to(0);
 80031a4:	f7ff fc72 	bl	8002a8c <gdb_if_getchar_to>
				if((c == '\x03') || (c == '\x04')) {
 80031a8:	3803      	subs	r0, #3
 80031aa:	b2c0      	uxtb	r0, r0
 80031ac:	2801      	cmp	r0, #1
 80031ae:	d8ef      	bhi.n	8003190 <gdb_main_loop+0x24e>
					target_halt_request(cur_target);
 80031b0:	4b2f      	ldr	r3, [pc, #188]	; (8003270 <gdb_main_loop+0x32e>)
 80031b2:	6818      	ldr	r0, [r3, #0]
 80031b4:	f005 f952 	bl	800845c <target_halt_request>
 80031b8:	e7ea      	b.n	8003190 <gdb_main_loop+0x24e>
				}
			}
			SET_RUN_STATE(0);
 80031ba:	2200      	movs	r2, #0
 80031bc:	4b35      	ldr	r3, [pc, #212]	; (8003294 <gdb_main_loop+0x352>)

			/* Translate reason to GDB signal */
			switch (reason) {
 80031be:	3801      	subs	r0, #1
				unsigned char c = gdb_if_getchar_to(0);
				if((c == '\x03') || (c == '\x04')) {
					target_halt_request(cur_target);
				}
			}
			SET_RUN_STATE(0);
 80031c0:	701a      	strb	r2, [r3, #0]

			/* Translate reason to GDB signal */
			switch (reason) {
 80031c2:	2805      	cmp	r0, #5
 80031c4:	d81b      	bhi.n	80031fe <gdb_main_loop+0x2bc>
 80031c6:	f00b fbd9 	bl	800e97c <__gnu_thumb1_case_uqi>
 80031ca:	0c03      	.short	0x0c03
 80031cc:	150f1a1a 	.word	0x150f1a1a
			case TARGET_HALT_ERROR:
				gdb_putpacket_f("X%02X", GDB_SIGLOST);
 80031d0:	4832      	ldr	r0, [pc, #200]	; (800329c <gdb_main_loop+0x35a>)
 80031d2:	211d      	movs	r1, #29
 80031d4:	f000 fc06 	bl	80039e4 <gdb_putpacket_f>
				morse("TARGET LOST.", true);
 80031d8:	4831      	ldr	r0, [pc, #196]	; (80032a0 <gdb_main_loop+0x35e>)
 80031da:	2101      	movs	r1, #1
 80031dc:	f001 fd08 	bl	8004bf0 <morse>
 80031e0:	e6c1      	b.n	8002f66 <gdb_main_loop+0x24>
				break;
			case TARGET_HALT_REQUEST:
				gdb_putpacket_f("T%02X", GDB_SIGINT);
 80031e2:	4830      	ldr	r0, [pc, #192]	; (80032a4 <gdb_main_loop+0x362>)
 80031e4:	2102      	movs	r1, #2
 80031e6:	e007      	b.n	80031f8 <gdb_main_loop+0x2b6>
				break;
			case TARGET_HALT_WATCHPOINT:
				gdb_putpacket_f("T%02Xwatch:%08X;", GDB_SIGTRAP, watch);
 80031e8:	482f      	ldr	r0, [pc, #188]	; (80032a8 <gdb_main_loop+0x366>)
 80031ea:	2105      	movs	r1, #5
 80031ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80031ee:	f000 fbf9 	bl	80039e4 <gdb_putpacket_f>
 80031f2:	e6b8      	b.n	8002f66 <gdb_main_loop+0x24>
				break;
			case TARGET_HALT_FAULT:
				gdb_putpacket_f("T%02X", GDB_SIGSEGV);
 80031f4:	210b      	movs	r1, #11
 80031f6:	482b      	ldr	r0, [pc, #172]	; (80032a4 <gdb_main_loop+0x362>)
 80031f8:	f000 fbf4 	bl	80039e4 <gdb_putpacket_f>
 80031fc:	e6b3      	b.n	8002f66 <gdb_main_loop+0x24>
				break;
			default:
				gdb_putpacket_f("T%02X", GDB_SIGTRAP);
 80031fe:	4829      	ldr	r0, [pc, #164]	; (80032a4 <gdb_main_loop+0x362>)
 8003200:	2105      	movs	r1, #5
 8003202:	e7f9      	b.n	80031f8 <gdb_main_loop+0x2b6>
			}
			break;
			}
		case 'F':	/* Semihosting call finished */
			if (in_syscall) {
 8003204:	68fb      	ldr	r3, [r7, #12]
 8003206:	2b00      	cmp	r3, #0
 8003208:	d000      	beq.n	800320c <gdb_main_loop+0x2ca>
 800320a:	e146      	b.n	800349a <gdb_main_loop+0x558>
				return hostio_reply(tc, pbuf, size);
			} else {
				DEBUG("*** F packet when not in syscall! '%s'\n", pbuf);
 800320c:	1c31      	adds	r1, r6, #0
 800320e:	4827      	ldr	r0, [pc, #156]	; (80032ac <gdb_main_loop+0x36a>)
 8003210:	f009 fc24 	bl	800ca5c <iprintf>
				gdb_putpacketz("");
 8003214:	4826      	ldr	r0, [pc, #152]	; (80032b0 <gdb_main_loop+0x36e>)
 8003216:	68f9      	ldr	r1, [r7, #12]
 8003218:	e13c      	b.n	8003494 <gdb_main_loop+0x552>
			gdb_putpacketz("OK");
			break;

		case 0x04:
		case 'D':	/* GDB 'detach' command. */
			if(cur_target)
 800321a:	6820      	ldr	r0, [r4, #0]
 800321c:	2800      	cmp	r0, #0
 800321e:	d001      	beq.n	8003224 <gdb_main_loop+0x2e2>
				target_detach(cur_target);
 8003220:	f005 f8f3 	bl	800840a <target_detach>
			last_target = cur_target;
 8003224:	6823      	ldr	r3, [r4, #0]
 8003226:	6063      	str	r3, [r4, #4]
			cur_target = NULL;
 8003228:	2300      	movs	r3, #0
 800322a:	6023      	str	r3, [r4, #0]
 800322c:	e128      	b.n	8003480 <gdb_main_loop+0x53e>
			gdb_putpacketz("OK");
			break;

		case 'k':	/* Kill the target */
			if(cur_target) {
 800322e:	6820      	ldr	r0, [r4, #0]
 8003230:	2800      	cmp	r0, #0
 8003232:	d100      	bne.n	8003236 <gdb_main_loop+0x2f4>
 8003234:	e697      	b.n	8002f66 <gdb_main_loop+0x24>
				target_reset(cur_target);
 8003236:	f005 f90d 	bl	8008454 <target_reset>
				target_detach(cur_target);
 800323a:	6820      	ldr	r0, [r4, #0]
 800323c:	f005 f8e5 	bl	800840a <target_detach>
				last_target = cur_target;
 8003240:	6823      	ldr	r3, [r4, #0]
 8003242:	6063      	str	r3, [r4, #4]
				cur_target = NULL;
 8003244:	2300      	movs	r3, #0
 8003246:	6023      	str	r3, [r4, #0]
 8003248:	e68d      	b.n	8002f66 <gdb_main_loop+0x24>
			}
			break;

		case 'r':	/* Reset the target system */
		case 'R':	/* Restart the target program */
			if(cur_target)
 800324a:	6820      	ldr	r0, [r4, #0]
 800324c:	2800      	cmp	r0, #0
 800324e:	d107      	bne.n	8003260 <gdb_main_loop+0x31e>
				target_reset(cur_target);
			else if(last_target) {
 8003250:	6860      	ldr	r0, [r4, #4]
 8003252:	2800      	cmp	r0, #0
 8003254:	d100      	bne.n	8003258 <gdb_main_loop+0x316>
 8003256:	e686      	b.n	8002f66 <gdb_main_loop+0x24>
				cur_target = target_attach(last_target,
 8003258:	4916      	ldr	r1, [pc, #88]	; (80032b4 <gdb_main_loop+0x372>)
 800325a:	f004 ff45 	bl	80080e8 <target_attach>
 800325e:	6020      	str	r0, [r4, #0]
						           &gdb_controller);
				target_reset(cur_target);
 8003260:	f005 f8f8 	bl	8008454 <target_reset>
 8003264:	e67f      	b.n	8002f66 <gdb_main_loop+0x24>
 8003266:	46c0      	nop			; (mov r8, r8)
 8003268:	08011cd6 	.word	0x08011cd6
 800326c:	20002064 	.word	0x20002064
 8003270:	200001c8 	.word	0x200001c8
 8003274:	08011cd2 	.word	0x08011cd2
 8003278:	08011cf6 	.word	0x08011cf6
 800327c:	08011cff 	.word	0x08011cff
 8003280:	08011abc 	.word	0x08011abc
 8003284:	08011c22 	.word	0x08011c22
 8003288:	08011d20 	.word	0x08011d20
 800328c:	08011d2c 	.word	0x08011d2c
 8003290:	08011d4d 	.word	0x08011d4d
 8003294:	2000207c 	.word	0x2000207c
 8003298:	08011d51 	.word	0x08011d51
 800329c:	08011d55 	.word	0x08011d55
 80032a0:	08011d5b 	.word	0x08011d5b
 80032a4:	08011d68 	.word	0x08011d68
 80032a8:	08011d6e 	.word	0x08011d6e
 80032ac:	08011d7f 	.word	0x08011d7f
 80032b0:	0800fd99 	.word	0x0800fd99
 80032b4:	2000001c 	.word	0x2000001c
			break;

		case 'X': { /* 'X addr,len:XX': Write binary data to addr */
			uint32_t addr, len;
			int bin;
			ERROR_IF_NO_TARGET();
 80032b8:	6823      	ldr	r3, [r4, #0]
 80032ba:	2b00      	cmp	r3, #0
 80032bc:	d100      	bne.n	80032c0 <gdb_main_loop+0x37e>
 80032be:	e0ba      	b.n	8003436 <gdb_main_loop+0x4f4>
			sscanf(pbuf, "X%" SCNx32 ",%" SCNx32 ":%n", &addr, &len, &bin);
 80032c0:	2218      	movs	r2, #24
 80032c2:	230c      	movs	r3, #12
 80032c4:	18ba      	adds	r2, r7, r2
 80032c6:	18d3      	adds	r3, r2, r3
 80032c8:	9300      	str	r3, [sp, #0]
 80032ca:	2518      	movs	r5, #24
 80032cc:	231c      	movs	r3, #28
 80032ce:	197d      	adds	r5, r7, r5
 80032d0:	18fa      	adds	r2, r7, r3
 80032d2:	3b14      	subs	r3, #20
 80032d4:	18eb      	adds	r3, r5, r3
 80032d6:	4975      	ldr	r1, [pc, #468]	; (80034ac <gdb_main_loop+0x56a>)
 80032d8:	1c30      	adds	r0, r6, #0
 80032da:	f009 fd25 	bl	800cd28 <siscanf>
			DEBUG("X packet: addr = %" PRIx32 ", len = %" PRIx32 "\n", addr, len);
 80032de:	69f9      	ldr	r1, [r7, #28]
 80032e0:	6a3a      	ldr	r2, [r7, #32]
 80032e2:	4873      	ldr	r0, [pc, #460]	; (80034b0 <gdb_main_loop+0x56e>)
 80032e4:	f009 fbba 	bl	800ca5c <iprintf>
			memmove(pbuf, pbuf + bin, len);
 80032e8:	6a3d      	ldr	r5, [r7, #32]
 80032ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80032ec:	1c2a      	adds	r2, r5, #0
 80032ee:	18f1      	adds	r1, r6, r3
 80032f0:	1c30      	adds	r0, r6, #0
 80032f2:	f009 faea 	bl	800c8ca <memmove>
			if (target_mem_write(cur_target, addr, pbuf, len))
 80032f6:	6820      	ldr	r0, [r4, #0]
 80032f8:	69f9      	ldr	r1, [r7, #28]
 80032fa:	1c32      	adds	r2, r6, #0
 80032fc:	1c2b      	adds	r3, r5, #0
 80032fe:	f005 f899 	bl	8008434 <target_mem_write>
 8003302:	2800      	cmp	r0, #0
 8003304:	d100      	bne.n	8003308 <gdb_main_loop+0x3c6>
 8003306:	e0bb      	b.n	8003480 <gdb_main_loop+0x53e>
 8003308:	e0b5      	b.n	8003476 <gdb_main_loop+0x534>
				gdb_putpacketz("OK");
			break;
			}

		case 'q':	/* General query packet */
			handle_q_packet(pbuf, size);
 800330a:	6938      	ldr	r0, [r7, #16]
 800330c:	f000 f944 	bl	8003598 <handle_q_packet.constprop.6>
 8003310:	e629      	b.n	8002f66 <gdb_main_loop+0x24>
{
static uint8_t flash_mode = 0;
	unsigned long addr, len;
	int bin;

	if (sscanf(packet, "vAttach;%08lx", &addr) == 1) {
 8003312:	231c      	movs	r3, #28
 8003314:	1c30      	adds	r0, r6, #0
 8003316:	4967      	ldr	r1, [pc, #412]	; (80034b4 <gdb_main_loop+0x572>)
 8003318:	18fa      	adds	r2, r7, r3
 800331a:	f009 fd05 	bl	800cd28 <siscanf>
 800331e:	2801      	cmp	r0, #1
 8003320:	d107      	bne.n	8003332 <gdb_main_loop+0x3f0>
		/* Attach to remote target processor */
		cur_target = target_attach_n(addr, &gdb_controller);
 8003322:	69f8      	ldr	r0, [r7, #28]
 8003324:	4964      	ldr	r1, [pc, #400]	; (80034b8 <gdb_main_loop+0x576>)
 8003326:	f004 fef3 	bl	8008110 <target_attach_n>
 800332a:	6020      	str	r0, [r4, #0]
		if(cur_target)
 800332c:	2800      	cmp	r0, #0
 800332e:	d117      	bne.n	8003360 <gdb_main_loop+0x41e>
 8003330:	e0a1      	b.n	8003476 <gdb_main_loop+0x534>
			gdb_putpacketz("T05");
		else
			gdb_putpacketz("E01");

	} else if (!strcmp(packet, "vRun;")) {
 8003332:	1c30      	adds	r0, r6, #0
 8003334:	4961      	ldr	r1, [pc, #388]	; (80034bc <gdb_main_loop+0x57a>)
 8003336:	f009 fd6d 	bl	800ce14 <strcmp>
 800333a:	1c25      	adds	r5, r4, #0
 800333c:	2800      	cmp	r0, #0
 800333e:	d111      	bne.n	8003364 <gdb_main_loop+0x422>
		/* Run target program. For us (embedded) this means reset. */
		if(cur_target) {
 8003340:	6820      	ldr	r0, [r4, #0]
 8003342:	2800      	cmp	r0, #0
 8003344:	d10a      	bne.n	800335c <gdb_main_loop+0x41a>
			target_reset(cur_target);
			gdb_putpacketz("T05");
		} else if(last_target) {
 8003346:	6860      	ldr	r0, [r4, #4]
 8003348:	2800      	cmp	r0, #0
 800334a:	d100      	bne.n	800334e <gdb_main_loop+0x40c>
 800334c:	e093      	b.n	8003476 <gdb_main_loop+0x534>
			cur_target = target_attach(last_target,
 800334e:	495a      	ldr	r1, [pc, #360]	; (80034b8 <gdb_main_loop+0x576>)
 8003350:	f004 feca 	bl	80080e8 <target_attach>
 8003354:	6020      	str	r0, [r4, #0]
						   &gdb_controller);

                        /* If we were able to attach to the target again */
                        if (cur_target) {
 8003356:	2800      	cmp	r0, #0
 8003358:	d100      	bne.n	800335c <gdb_main_loop+0x41a>
 800335a:	e08c      	b.n	8003476 <gdb_main_loop+0x534>
                        	target_reset(cur_target);
 800335c:	f005 f87a 	bl	8008454 <target_reset>
                        	gdb_putpacketz("T05");
 8003360:	4857      	ldr	r0, [pc, #348]	; (80034c0 <gdb_main_loop+0x57e>)
 8003362:	e089      	b.n	8003478 <gdb_main_loop+0x536>
                        } else	gdb_putpacketz("E01");

		} else	gdb_putpacketz("E01");

	} else if (sscanf(packet, "vFlashErase:%08lx,%08lx", &addr, &len) == 2) {
 8003364:	231c      	movs	r3, #28
 8003366:	1c30      	adds	r0, r6, #0
 8003368:	2618      	movs	r6, #24
 800336a:	18fa      	adds	r2, r7, r3
 800336c:	19be      	adds	r6, r7, r6
 800336e:	3b14      	subs	r3, #20
 8003370:	4954      	ldr	r1, [pc, #336]	; (80034c4 <gdb_main_loop+0x582>)
 8003372:	18f3      	adds	r3, r6, r3
 8003374:	f009 fcd8 	bl	800cd28 <siscanf>
 8003378:	2802      	cmp	r0, #2
 800337a:	d117      	bne.n	80033ac <gdb_main_loop+0x46a>
		/* Erase Flash Memory */
		DEBUG("Flash Erase %08lX %08lX\n", addr, len);
 800337c:	4852      	ldr	r0, [pc, #328]	; (80034c8 <gdb_main_loop+0x586>)
 800337e:	69f9      	ldr	r1, [r7, #28]
 8003380:	6a3a      	ldr	r2, [r7, #32]
 8003382:	f009 fb6b 	bl	800ca5c <iprintf>
		if(!cur_target) { gdb_putpacketz("EFF"); return; }
 8003386:	6820      	ldr	r0, [r4, #0]
 8003388:	2800      	cmp	r0, #0
 800338a:	d054      	beq.n	8003436 <gdb_main_loop+0x4f4>

		if(!flash_mode) {
 800338c:	4d4f      	ldr	r5, [pc, #316]	; (80034cc <gdb_main_loop+0x58a>)
 800338e:	7a6b      	ldrb	r3, [r5, #9]
 8003390:	2b00      	cmp	r3, #0
 8003392:	d103      	bne.n	800339c <gdb_main_loop+0x45a>
			/* Reset target if first flash command! */
			/* This saves us if we're interrupted in IRQ context */
			target_reset(cur_target);
 8003394:	f005 f85e 	bl	8008454 <target_reset>
			flash_mode = 1;
 8003398:	2301      	movs	r3, #1
 800339a:	726b      	strb	r3, [r5, #9]
		}
		if(target_flash_erase(cur_target, addr, len) == 0)
 800339c:	6820      	ldr	r0, [r4, #0]
 800339e:	69f9      	ldr	r1, [r7, #28]
 80033a0:	6a3a      	ldr	r2, [r7, #32]
 80033a2:	f004 ff2f 	bl	8008204 <target_flash_erase>
 80033a6:	2800      	cmp	r0, #0
 80033a8:	d145      	bne.n	8003436 <gdb_main_loop+0x4f4>
 80033aa:	e069      	b.n	8003480 <gdb_main_loop+0x53e>
			gdb_putpacketz("OK");
		else
			gdb_putpacketz("EFF");

	} else if (sscanf(packet, "vFlashWrite:%08lx:%n", &addr, &bin) == 1) {
 80033ac:	231c      	movs	r3, #28
 80033ae:	2618      	movs	r6, #24
 80033b0:	3508      	adds	r5, #8
 80033b2:	18fa      	adds	r2, r7, r3
 80033b4:	19be      	adds	r6, r7, r6
 80033b6:	3b10      	subs	r3, #16
 80033b8:	1c28      	adds	r0, r5, #0
 80033ba:	4945      	ldr	r1, [pc, #276]	; (80034d0 <gdb_main_loop+0x58e>)
 80033bc:	18f3      	adds	r3, r6, r3
 80033be:	f009 fcb3 	bl	800cd28 <siscanf>
 80033c2:	2801      	cmp	r0, #1
 80033c4:	d111      	bne.n	80033ea <gdb_main_loop+0x4a8>
		/* Write Flash Memory */
		len = plen - bin;
 80033c6:	693b      	ldr	r3, [r7, #16]
 80033c8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
		DEBUG("Flash Write %08lX %08lX\n", addr, len);
 80033ca:	4842      	ldr	r0, [pc, #264]	; (80034d4 <gdb_main_loop+0x592>)
		else
			gdb_putpacketz("EFF");

	} else if (sscanf(packet, "vFlashWrite:%08lx:%n", &addr, &bin) == 1) {
		/* Write Flash Memory */
		len = plen - bin;
 80033cc:	1a9a      	subs	r2, r3, r2
		DEBUG("Flash Write %08lX %08lX\n", addr, len);
 80033ce:	69f9      	ldr	r1, [r7, #28]
		else
			gdb_putpacketz("EFF");

	} else if (sscanf(packet, "vFlashWrite:%08lx:%n", &addr, &bin) == 1) {
		/* Write Flash Memory */
		len = plen - bin;
 80033d0:	623a      	str	r2, [r7, #32]
		DEBUG("Flash Write %08lX %08lX\n", addr, len);
 80033d2:	f009 fb43 	bl	800ca5c <iprintf>
		if(cur_target && target_flash_write(cur_target, addr, (void*)packet + bin, len) == 0)
 80033d6:	6820      	ldr	r0, [r4, #0]
 80033d8:	2800      	cmp	r0, #0
 80033da:	d02c      	beq.n	8003436 <gdb_main_loop+0x4f4>
 80033dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033de:	69f9      	ldr	r1, [r7, #28]
 80033e0:	18ea      	adds	r2, r5, r3
 80033e2:	6a3b      	ldr	r3, [r7, #32]
 80033e4:	f004 ff39 	bl	800825a <target_flash_write>
 80033e8:	e7dd      	b.n	80033a6 <gdb_main_loop+0x464>
			gdb_putpacketz("OK");
		else
			gdb_putpacketz("EFF");

	} else if (!strcmp(packet, "vFlashDone")) {
 80033ea:	1c28      	adds	r0, r5, #0
 80033ec:	493a      	ldr	r1, [pc, #232]	; (80034d8 <gdb_main_loop+0x596>)
 80033ee:	f009 fd11 	bl	800ce14 <strcmp>
 80033f2:	2800      	cmp	r0, #0
 80033f4:	d119      	bne.n	800342a <gdb_main_loop+0x4e8>
		/* Commit flash operations. */
		gdb_putpacketz(target_flash_done(cur_target) ? "EFF" : "OK");
 80033f6:	6820      	ldr	r0, [r4, #0]
 80033f8:	f004 ff98 	bl	800832c <target_flash_done>
 80033fc:	4c37      	ldr	r4, [pc, #220]	; (80034dc <gdb_main_loop+0x59a>)
 80033fe:	2800      	cmp	r0, #0
 8003400:	d100      	bne.n	8003404 <gdb_main_loop+0x4c2>
 8003402:	4c37      	ldr	r4, [pc, #220]	; (80034e0 <gdb_main_loop+0x59e>)
 8003404:	4b37      	ldr	r3, [pc, #220]	; (80034e4 <gdb_main_loop+0x5a2>)
 8003406:	6818      	ldr	r0, [r3, #0]
 8003408:	f004 ff90 	bl	800832c <target_flash_done>
 800340c:	4b33      	ldr	r3, [pc, #204]	; (80034dc <gdb_main_loop+0x59a>)
 800340e:	2800      	cmp	r0, #0
 8003410:	d100      	bne.n	8003414 <gdb_main_loop+0x4d2>
 8003412:	4b33      	ldr	r3, [pc, #204]	; (80034e0 <gdb_main_loop+0x59e>)
 8003414:	1c18      	adds	r0, r3, #0
 8003416:	f009 fd07 	bl	800ce28 <strlen>
 800341a:	1c01      	adds	r1, r0, #0
 800341c:	1c20      	adds	r0, r4, #0
 800341e:	f000 fa81 	bl	8003924 <gdb_putpacket>
		flash_mode = 0;
 8003422:	2200      	movs	r2, #0
 8003424:	4b29      	ldr	r3, [pc, #164]	; (80034cc <gdb_main_loop+0x58a>)
 8003426:	725a      	strb	r2, [r3, #9]
 8003428:	e59d      	b.n	8002f66 <gdb_main_loop+0x24>

	} else {
		DEBUG("*** Unsupported packet: %s\n", packet);
 800342a:	482f      	ldr	r0, [pc, #188]	; (80034e8 <gdb_main_loop+0x5a6>)
 800342c:	1c29      	adds	r1, r5, #0
 800342e:	e02d      	b.n	800348c <gdb_main_loop+0x54a>
			break;

		/* These packet implement hardware break-/watchpoints */
		case 'Z':	/* Z type,addr,len: Set breakpoint packet */
		case 'z':	/* z type,addr,len: Clear breakpoint packet */
			ERROR_IF_NO_TARGET();
 8003430:	6823      	ldr	r3, [r4, #0]
 8003432:	2b00      	cmp	r3, #0
 8003434:	d101      	bne.n	800343a <gdb_main_loop+0x4f8>
 8003436:	4829      	ldr	r0, [pc, #164]	; (80034dc <gdb_main_loop+0x59a>)
 8003438:	e01e      	b.n	8003478 <gdb_main_loop+0x536>
	int ret;

	/* I have no idea why this doesn't work. Seems to work
	 * with real sscanf() though... */
	//sscanf(packet, "%*[zZ]%hhd,%08lX,%hhd", &type, &addr, &len);
	type = packet[1] - '0';
 800343a:	7a66      	ldrb	r6, [r4, #9]
	sscanf(packet + 2, ",%" PRIx32 ",%d", &addr, &len);
 800343c:	2218      	movs	r2, #24
	int ret;

	/* I have no idea why this doesn't work. Seems to work
	 * with real sscanf() though... */
	//sscanf(packet, "%*[zZ]%hhd,%08lX,%hhd", &type, &addr, &len);
	type = packet[1] - '0';
 800343e:	3e30      	subs	r6, #48	; 0x30
 8003440:	603e      	str	r6, [r7, #0]
	sscanf(packet + 2, ",%" PRIx32 ",%d", &addr, &len);
 8003442:	230c      	movs	r3, #12
 8003444:	2618      	movs	r6, #24
 8003446:	4827      	ldr	r0, [pc, #156]	; (80034e4 <gdb_main_loop+0x5a2>)
 8003448:	18ba      	adds	r2, r7, r2
 800344a:	18d2      	adds	r2, r2, r3
 800344c:	19be      	adds	r6, r7, r6
 800344e:	3b04      	subs	r3, #4
 8003450:	4926      	ldr	r1, [pc, #152]	; (80034ec <gdb_main_loop+0x5aa>)
 8003452:	18f3      	adds	r3, r6, r3
 8003454:	300a      	adds	r0, #10
 8003456:	f009 fc67 	bl	800cd28 <siscanf>
 800345a:	683b      	ldr	r3, [r7, #0]
	if(set)
		ret = target_breakwatch_set(cur_target, type, addr, len);
 800345c:	6820      	ldr	r0, [r4, #0]
 800345e:	b2d9      	uxtb	r1, r3
 8003460:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003462:	6a3b      	ldr	r3, [r7, #32]
	/* I have no idea why this doesn't work. Seems to work
	 * with real sscanf() though... */
	//sscanf(packet, "%*[zZ]%hhd,%08lX,%hhd", &type, &addr, &len);
	type = packet[1] - '0';
	sscanf(packet + 2, ",%" PRIx32 ",%d", &addr, &len);
	if(set)
 8003464:	2d5a      	cmp	r5, #90	; 0x5a
 8003466:	d102      	bne.n	800346e <gdb_main_loop+0x52c>
		ret = target_breakwatch_set(cur_target, type, addr, len);
 8003468:	f005 f804 	bl	8008474 <target_breakwatch_set>
 800346c:	e001      	b.n	8003472 <gdb_main_loop+0x530>
	else
		ret = target_breakwatch_clear(cur_target, type, addr, len);
 800346e:	f005 f827 	bl	80084c0 <target_breakwatch_clear>

	if (ret < 0) {
 8003472:	2800      	cmp	r0, #0
 8003474:	da02      	bge.n	800347c <gdb_main_loop+0x53a>
		gdb_putpacketz("E01");
 8003476:	481e      	ldr	r0, [pc, #120]	; (80034f0 <gdb_main_loop+0x5ae>)
 8003478:	2103      	movs	r1, #3
 800347a:	e00b      	b.n	8003494 <gdb_main_loop+0x552>
	} else if (ret > 0) {
 800347c:	2800      	cmp	r0, #0
 800347e:	d107      	bne.n	8003490 <gdb_main_loop+0x54e>
		gdb_putpacketz("");
	} else {
		gdb_putpacketz("OK");
 8003480:	4817      	ldr	r0, [pc, #92]	; (80034e0 <gdb_main_loop+0x59e>)
 8003482:	2102      	movs	r1, #2
 8003484:	e006      	b.n	8003494 <gdb_main_loop+0x552>
			ERROR_IF_NO_TARGET();
			handle_z_packet(pbuf, size);
			break;

		default: 	/* Packet not implemented */
			DEBUG("*** Unsupported packet: %s\n", pbuf);
 8003486:	4917      	ldr	r1, [pc, #92]	; (80034e4 <gdb_main_loop+0x5a2>)
 8003488:	4817      	ldr	r0, [pc, #92]	; (80034e8 <gdb_main_loop+0x5a6>)
 800348a:	3108      	adds	r1, #8
 800348c:	f009 fae6 	bl	800ca5c <iprintf>
			gdb_putpacketz("");
 8003490:	2100      	movs	r1, #0
 8003492:	4818      	ldr	r0, [pc, #96]	; (80034f4 <gdb_main_loop+0x5b2>)
 8003494:	f000 fa46 	bl	8003924 <gdb_putpacket>
 8003498:	e565      	b.n	8002f66 <gdb_main_loop+0x24>
			}
			break;
			}
		case 'F':	/* Semihosting call finished */
			if (in_syscall) {
				return hostio_reply(tc, pbuf, size);
 800349a:	6878      	ldr	r0, [r7, #4]
 800349c:	1c31      	adds	r1, r6, #0
 800349e:	693a      	ldr	r2, [r7, #16]
 80034a0:	f000 f93c 	bl	800371c <hostio_reply>
		default: 	/* Packet not implemented */
			DEBUG("*** Unsupported packet: %s\n", pbuf);
			gdb_putpacketz("");
		}
	}
}
 80034a4:	46bd      	mov	sp, r7
 80034a6:	b00b      	add	sp, #44	; 0x2c
 80034a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80034aa:	46c0      	nop			; (mov r8, r8)
 80034ac:	08011da7 	.word	0x08011da7
 80034b0:	08011db3 	.word	0x08011db3
 80034b4:	08011dd4 	.word	0x08011dd4
 80034b8:	2000001c 	.word	0x2000001c
 80034bc:	08011de6 	.word	0x08011de6
 80034c0:	08011de2 	.word	0x08011de2
 80034c4:	08011dec 	.word	0x08011dec
 80034c8:	08011e04 	.word	0x08011e04
 80034cc:	200011c8 	.word	0x200011c8
 80034d0:	08011e1d 	.word	0x08011e1d
 80034d4:	08011e32 	.word	0x08011e32
 80034d8:	08011e4b 	.word	0x08011e4b
 80034dc:	08011cd2 	.word	0x08011cd2
 80034e0:	08011c22 	.word	0x08011c22
 80034e4:	200001c8 	.word	0x200001c8
 80034e8:	08011cb6 	.word	0x08011cb6
 80034ec:	08011e56 	.word	0x08011e56
 80034f0:	08011abc 	.word	0x08011abc
 80034f4:	0800fd99 	.word	0x0800fd99

080034f8 <gdb_main>:
		gdb_putpacketz("OK");
	}
}

void gdb_main(void)
{
 80034f8:	b508      	push	{r3, lr}
	gdb_main_loop(&gdb_controller, false);
 80034fa:	4802      	ldr	r0, [pc, #8]	; (8003504 <gdb_main+0xc>)
 80034fc:	2100      	movs	r1, #0
 80034fe:	f7ff fd20 	bl	8002f42 <gdb_main_loop>
}
 8003502:	bd08      	pop	{r3, pc}
 8003504:	2000001c 	.word	0x2000001c

08003508 <handle_q_string_reply>:
static void
handle_q_string_reply(const char *str, const char *param)
{
	unsigned long addr, len;

	if (sscanf(param, "%08lx,%08lx", &addr, &len) != 2) {
 8003508:	2308      	movs	r3, #8
	}
}

static void
handle_q_string_reply(const char *str, const char *param)
{
 800350a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800350c:	b085      	sub	sp, #20
 800350e:	af00      	add	r7, sp, #0
	unsigned long addr, len;

	if (sscanf(param, "%08lx,%08lx", &addr, &len) != 2) {
 8003510:	18fa      	adds	r2, r7, r3
 8003512:	3304      	adds	r3, #4
	}
}

static void
handle_q_string_reply(const char *str, const char *param)
{
 8003514:	1c04      	adds	r4, r0, #0
	unsigned long addr, len;

	if (sscanf(param, "%08lx,%08lx", &addr, &len) != 2) {
 8003516:	18fb      	adds	r3, r7, r3
 8003518:	1c08      	adds	r0, r1, #0
 800351a:	491c      	ldr	r1, [pc, #112]	; (800358c <handle_q_string_reply+0x84>)
 800351c:	f009 fc04 	bl	800cd28 <siscanf>
 8003520:	2802      	cmp	r0, #2
 8003522:	d12c      	bne.n	800357e <handle_q_string_reply+0x76>
		gdb_putpacketz("E01");
		return;
	}
	if (addr < strlen (str)) {
 8003524:	1c20      	adds	r0, r4, #0
 8003526:	68bd      	ldr	r5, [r7, #8]
 8003528:	f009 fc7e 	bl	800ce28 <strlen>
 800352c:	4285      	cmp	r5, r0
 800352e:	d221      	bcs.n	8003574 <handle_q_string_reply+0x6c>
 8003530:	466b      	mov	r3, sp
		char reply[len+2];
 8003532:	68fe      	ldr	r6, [r7, #12]
 8003534:	603b      	str	r3, [r7, #0]
 8003536:	1c33      	adds	r3, r6, #0
 8003538:	466a      	mov	r2, sp
 800353a:	3309      	adds	r3, #9
 800353c:	08db      	lsrs	r3, r3, #3
 800353e:	00db      	lsls	r3, r3, #3
 8003540:	1ad3      	subs	r3, r2, r3
 8003542:	469d      	mov	sp, r3
 8003544:	607b      	str	r3, [r7, #4]
		reply[0] = 'm';
 8003546:	466a      	mov	r2, sp
 8003548:	236d      	movs	r3, #109	; 0x6d
		strncpy (reply + 1, &str[addr], len);
 800354a:	1964      	adds	r4, r4, r5
		gdb_putpacketz("E01");
		return;
	}
	if (addr < strlen (str)) {
		char reply[len+2];
		reply[0] = 'm';
 800354c:	7013      	strb	r3, [r2, #0]
		strncpy (reply + 1, &str[addr], len);
 800354e:	1c50      	adds	r0, r2, #1
 8003550:	1c21      	adds	r1, r4, #0
 8003552:	1c32      	adds	r2, r6, #0
 8003554:	f009 fcaa 	bl	800ceac <strncpy>
		if(len > strlen(&str[addr]))
 8003558:	1c20      	adds	r0, r4, #0
 800355a:	f009 fc65 	bl	800ce28 <strlen>
 800355e:	4286      	cmp	r6, r0
 8003560:	d900      	bls.n	8003564 <handle_q_string_reply+0x5c>
			len = strlen(&str[addr]);
 8003562:	60f8      	str	r0, [r7, #12]
		gdb_putpacket(reply, len + 1);
 8003564:	68fb      	ldr	r3, [r7, #12]
 8003566:	6878      	ldr	r0, [r7, #4]
 8003568:	1c59      	adds	r1, r3, #1
 800356a:	f000 f9db 	bl	8003924 <gdb_putpacket>
 800356e:	683b      	ldr	r3, [r7, #0]
 8003570:	469d      	mov	sp, r3
 8003572:	e008      	b.n	8003586 <handle_q_string_reply+0x7e>
	} else if (addr == strlen (str)) {
 8003574:	4285      	cmp	r5, r0
 8003576:	d102      	bne.n	800357e <handle_q_string_reply+0x76>
		gdb_putpacketz("l");
 8003578:	4805      	ldr	r0, [pc, #20]	; (8003590 <handle_q_string_reply+0x88>)
 800357a:	2101      	movs	r1, #1
 800357c:	e001      	b.n	8003582 <handle_q_string_reply+0x7a>
	} else
		gdb_putpacketz("E01");
 800357e:	2103      	movs	r1, #3
 8003580:	4804      	ldr	r0, [pc, #16]	; (8003594 <handle_q_string_reply+0x8c>)
 8003582:	f000 f9cf 	bl	8003924 <gdb_putpacket>
}
 8003586:	46bd      	mov	sp, r7
 8003588:	b005      	add	sp, #20
 800358a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800358c:	08011df8 	.word	0x08011df8
 8003590:	080118e4 	.word	0x080118e4
 8003594:	08011abc 	.word	0x08011abc

08003598 <handle_q_packet.constprop.6>:

static void
handle_q_packet(char *packet, int len)
 8003598:	b5f0      	push	{r4, r5, r6, r7, lr}
{
	uint32_t addr, alen;

	if(!strncmp(packet, "qRcmd,", 6)) {
 800359a:	4e4c      	ldr	r6, [pc, #304]	; (80036cc <handle_q_packet.constprop.6+0x134>)
	} else
		gdb_putpacketz("E01");
}

static void
handle_q_packet(char *packet, int len)
 800359c:	b085      	sub	sp, #20
{
	uint32_t addr, alen;

	if(!strncmp(packet, "qRcmd,", 6)) {
 800359e:	1c35      	adds	r5, r6, #0
	} else
		gdb_putpacketz("E01");
}

static void
handle_q_packet(char *packet, int len)
 80035a0:	af00      	add	r7, sp, #0
{
	uint32_t addr, alen;

	if(!strncmp(packet, "qRcmd,", 6)) {
 80035a2:	3508      	adds	r5, #8
	} else
		gdb_putpacketz("E01");
}

static void
handle_q_packet(char *packet, int len)
 80035a4:	6038      	str	r0, [r7, #0]
{
	uint32_t addr, alen;

	if(!strncmp(packet, "qRcmd,", 6)) {
 80035a6:	494a      	ldr	r1, [pc, #296]	; (80036d0 <handle_q_packet.constprop.6+0x138>)
 80035a8:	1c28      	adds	r0, r5, #0
 80035aa:	2206      	movs	r2, #6
 80035ac:	f009 fc6a 	bl	800ce84 <strncmp>
 80035b0:	1c34      	adds	r4, r6, #0
 80035b2:	6078      	str	r0, [r7, #4]
 80035b4:	2800      	cmp	r0, #0
 80035b6:	d125      	bne.n	8003604 <handle_q_packet.constprop.6+0x6c>
		char *data;
		int datalen;

		/* calculate size and allocate buffer for command */
		datalen = (len - 6) / 2;
 80035b8:	683d      	ldr	r5, [r7, #0]
		data = alloca(datalen+1);
 80035ba:	466a      	mov	r2, sp
	if(!strncmp(packet, "qRcmd,", 6)) {
		char *data;
		int datalen;

		/* calculate size and allocate buffer for command */
		datalen = (len - 6) / 2;
 80035bc:	3d06      	subs	r5, #6
 80035be:	0feb      	lsrs	r3, r5, #31
 80035c0:	195d      	adds	r5, r3, r5
 80035c2:	106d      	asrs	r5, r5, #1
		data = alloca(datalen+1);
 80035c4:	1c2b      	adds	r3, r5, #0
 80035c6:	330f      	adds	r3, #15
 80035c8:	08db      	lsrs	r3, r3, #3
 80035ca:	00db      	lsls	r3, r3, #3
 80035cc:	1ad3      	subs	r3, r2, r3
 80035ce:	469d      	mov	sp, r3
		/* dehexify command */
		unhexify(data, packet+6, datalen);
 80035d0:	1c31      	adds	r1, r6, #0
		char *data;
		int datalen;

		/* calculate size and allocate buffer for command */
		datalen = (len - 6) / 2;
		data = alloca(datalen+1);
 80035d2:	466c      	mov	r4, sp
		/* dehexify command */
		unhexify(data, packet+6, datalen);
 80035d4:	310e      	adds	r1, #14
 80035d6:	4668      	mov	r0, sp
 80035d8:	1c2a      	adds	r2, r5, #0
 80035da:	f000 fa73 	bl	8003ac4 <unhexify>
		data[datalen] = 0;	/* add terminating null */
 80035de:	793b      	ldrb	r3, [r7, #4]

		int c = command_process(cur_target, data);
 80035e0:	6830      	ldr	r0, [r6, #0]
		/* calculate size and allocate buffer for command */
		datalen = (len - 6) / 2;
		data = alloca(datalen+1);
		/* dehexify command */
		unhexify(data, packet+6, datalen);
		data[datalen] = 0;	/* add terminating null */
 80035e2:	5563      	strb	r3, [r4, r5]

		int c = command_process(cur_target, data);
 80035e4:	4669      	mov	r1, sp
 80035e6:	f7fd fbc1 	bl	8000d6c <command_process>
		if(c < 0)
 80035ea:	2800      	cmp	r0, #0
 80035ec:	da02      	bge.n	80035f4 <handle_q_packet.constprop.6+0x5c>
			gdb_putpacketz("");
 80035ee:	4839      	ldr	r0, [pc, #228]	; (80036d4 <handle_q_packet.constprop.6+0x13c>)
 80035f0:	6879      	ldr	r1, [r7, #4]
 80035f2:	e065      	b.n	80036c0 <handle_q_packet.constprop.6+0x128>
		else if(c == 0)
 80035f4:	2800      	cmp	r0, #0
 80035f6:	d102      	bne.n	80035fe <handle_q_packet.constprop.6+0x66>
			gdb_putpacketz("OK");
 80035f8:	4837      	ldr	r0, [pc, #220]	; (80036d8 <handle_q_packet.constprop.6+0x140>)
 80035fa:	2102      	movs	r1, #2
 80035fc:	e060      	b.n	80036c0 <handle_q_packet.constprop.6+0x128>
		else
			gdb_putpacketz("E");
 80035fe:	4837      	ldr	r0, [pc, #220]	; (80036dc <handle_q_packet.constprop.6+0x144>)
 8003600:	2101      	movs	r1, #1
 8003602:	e05d      	b.n	80036c0 <handle_q_packet.constprop.6+0x128>

	} else if (!strncmp (packet, "qSupported", 10)) {
 8003604:	1c28      	adds	r0, r5, #0
 8003606:	4936      	ldr	r1, [pc, #216]	; (80036e0 <handle_q_packet.constprop.6+0x148>)
 8003608:	220a      	movs	r2, #10
 800360a:	f009 fc3b 	bl	800ce84 <strncmp>
 800360e:	2800      	cmp	r0, #0
 8003610:	d103      	bne.n	800361a <handle_q_packet.constprop.6+0x82>
		/* Query supported protocol features */
		gdb_putpacket_f("PacketSize=%X;qXfer:memory-map:read+;qXfer:features:read+", BUF_SIZE);
 8003612:	2180      	movs	r1, #128	; 0x80
 8003614:	4833      	ldr	r0, [pc, #204]	; (80036e4 <handle_q_packet.constprop.6+0x14c>)
 8003616:	0149      	lsls	r1, r1, #5
 8003618:	e049      	b.n	80036ae <handle_q_packet.constprop.6+0x116>

	} else if (strncmp (packet, "qXfer:memory-map:read::", 23) == 0) {
 800361a:	1c28      	adds	r0, r5, #0
 800361c:	4932      	ldr	r1, [pc, #200]	; (80036e8 <handle_q_packet.constprop.6+0x150>)
 800361e:	2217      	movs	r2, #23
 8003620:	f009 fc30 	bl	800ce84 <strncmp>
 8003624:	2800      	cmp	r0, #0
 8003626:	d114      	bne.n	8003652 <handle_q_packet.constprop.6+0xba>
		/* Read target XML memory map */
		if((!cur_target) && last_target) {
 8003628:	6833      	ldr	r3, [r6, #0]
 800362a:	2b00      	cmp	r3, #0
 800362c:	d106      	bne.n	800363c <handle_q_packet.constprop.6+0xa4>
 800362e:	6870      	ldr	r0, [r6, #4]
 8003630:	2800      	cmp	r0, #0
 8003632:	d003      	beq.n	800363c <handle_q_packet.constprop.6+0xa4>
			/* Attach to last target if detached. */
			cur_target = target_attach(last_target,
 8003634:	492d      	ldr	r1, [pc, #180]	; (80036ec <handle_q_packet.constprop.6+0x154>)
 8003636:	f004 fd57 	bl	80080e8 <target_attach>
 800363a:	6030      	str	r0, [r6, #0]
						   &gdb_controller);
		}
		if (!cur_target) {
 800363c:	6820      	ldr	r0, [r4, #0]
 800363e:	2800      	cmp	r0, #0
 8003640:	d102      	bne.n	8003648 <handle_q_packet.constprop.6+0xb0>
			gdb_putpacketz("E01");
 8003642:	482b      	ldr	r0, [pc, #172]	; (80036f0 <handle_q_packet.constprop.6+0x158>)
 8003644:	2103      	movs	r1, #3
 8003646:	e03b      	b.n	80036c0 <handle_q_packet.constprop.6+0x128>
			return;
		}
		handle_q_string_reply(target_mem_map(cur_target), packet + 23);
 8003648:	f004 fd86 	bl	8008158 <target_mem_map>
 800364c:	1c21      	adds	r1, r4, #0
 800364e:	311f      	adds	r1, #31
 8003650:	e017      	b.n	8003682 <handle_q_packet.constprop.6+0xea>

	} else if (strncmp (packet, "qXfer:features:read:target.xml:", 31) == 0) {
 8003652:	1c28      	adds	r0, r5, #0
 8003654:	4927      	ldr	r1, [pc, #156]	; (80036f4 <handle_q_packet.constprop.6+0x15c>)
 8003656:	221f      	movs	r2, #31
 8003658:	f009 fc14 	bl	800ce84 <strncmp>
 800365c:	2800      	cmp	r0, #0
 800365e:	d113      	bne.n	8003688 <handle_q_packet.constprop.6+0xf0>
		/* Read target description */
		if((!cur_target) && last_target) {
 8003660:	6833      	ldr	r3, [r6, #0]
 8003662:	2b00      	cmp	r3, #0
 8003664:	d106      	bne.n	8003674 <handle_q_packet.constprop.6+0xdc>
 8003666:	6870      	ldr	r0, [r6, #4]
 8003668:	2800      	cmp	r0, #0
 800366a:	d003      	beq.n	8003674 <handle_q_packet.constprop.6+0xdc>
			/* Attach to last target if detached. */
			cur_target = target_attach(last_target,
 800366c:	491f      	ldr	r1, [pc, #124]	; (80036ec <handle_q_packet.constprop.6+0x154>)
 800366e:	f004 fd3b 	bl	80080e8 <target_attach>
 8003672:	6030      	str	r0, [r6, #0]
						   &gdb_controller);
		}
		if (!cur_target) {
 8003674:	6820      	ldr	r0, [r4, #0]
 8003676:	2800      	cmp	r0, #0
 8003678:	d0e3      	beq.n	8003642 <handle_q_packet.constprop.6+0xaa>
			gdb_putpacketz("E01");
			return;
		}
		handle_q_string_reply(target_tdesc(cur_target), packet + 31);
 800367a:	f004 ff4d 	bl	8008518 <target_tdesc>
 800367e:	1c21      	adds	r1, r4, #0
 8003680:	3127      	adds	r1, #39	; 0x27
 8003682:	f7ff ff41 	bl	8003508 <handle_q_string_reply>
 8003686:	e01d      	b.n	80036c4 <handle_q_packet.constprop.6+0x12c>
	} else if (sscanf(packet, "qCRC:%" PRIx32 ",%" PRIx32, &addr, &alen) == 2) {
 8003688:	2308      	movs	r3, #8
 800368a:	18fa      	adds	r2, r7, r3
 800368c:	3304      	adds	r3, #4
 800368e:	1c28      	adds	r0, r5, #0
 8003690:	4919      	ldr	r1, [pc, #100]	; (80036f8 <handle_q_packet.constprop.6+0x160>)
 8003692:	18fb      	adds	r3, r7, r3
 8003694:	f009 fb48 	bl	800cd28 <siscanf>
 8003698:	2802      	cmp	r0, #2
 800369a:	d10b      	bne.n	80036b4 <handle_q_packet.constprop.6+0x11c>
		if(!cur_target) {
 800369c:	6830      	ldr	r0, [r6, #0]
 800369e:	2800      	cmp	r0, #0
 80036a0:	d0cf      	beq.n	8003642 <handle_q_packet.constprop.6+0xaa>
			gdb_putpacketz("E01");
			return;
		}
		gdb_putpacket_f("C%lx", generic_crc32(cur_target, addr, alen));
 80036a2:	68b9      	ldr	r1, [r7, #8]
 80036a4:	68fa      	ldr	r2, [r7, #12]
 80036a6:	f7fe ff45 	bl	8002534 <generic_crc32>
 80036aa:	1c01      	adds	r1, r0, #0
 80036ac:	4813      	ldr	r0, [pc, #76]	; (80036fc <handle_q_packet.constprop.6+0x164>)
 80036ae:	f000 f999 	bl	80039e4 <gdb_putpacket_f>
 80036b2:	e007      	b.n	80036c4 <handle_q_packet.constprop.6+0x12c>

	} else {
		DEBUG("*** Unsupported packet: %s\n", packet);
 80036b4:	1c29      	adds	r1, r5, #0
 80036b6:	4812      	ldr	r0, [pc, #72]	; (8003700 <handle_q_packet.constprop.6+0x168>)
 80036b8:	f009 f9d0 	bl	800ca5c <iprintf>
		gdb_putpacket("", 0);
 80036bc:	2100      	movs	r1, #0
 80036be:	4805      	ldr	r0, [pc, #20]	; (80036d4 <handle_q_packet.constprop.6+0x13c>)
 80036c0:	f000 f930 	bl	8003924 <gdb_putpacket>
	}
}
 80036c4:	46bd      	mov	sp, r7
 80036c6:	b005      	add	sp, #20
 80036c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036ca:	46c0      	nop			; (mov r8, r8)
 80036cc:	200001c8 	.word	0x200001c8
 80036d0:	08011c1b 	.word	0x08011c1b
 80036d4:	0800fd99 	.word	0x0800fd99
 80036d8:	08011c22 	.word	0x08011c22
 80036dc:	08011c25 	.word	0x08011c25
 80036e0:	08011c27 	.word	0x08011c27
 80036e4:	08011c32 	.word	0x08011c32
 80036e8:	08011c6c 	.word	0x08011c6c
 80036ec:	2000001c 	.word	0x2000001c
 80036f0:	08011abc 	.word	0x08011abc
 80036f4:	08011c84 	.word	0x08011c84
 80036f8:	08011ca4 	.word	0x08011ca4
 80036fc:	08011cb1 	.word	0x08011cb1
 8003700:	08011cb6 	.word	0x08011cb6

08003704 <sf_gdb_main_init>:

}, * custom_dict_start = custom_dict + __COUNTER__;

static void sf_gdb_main_init(void) __attribute__((constructor));
static void sf_gdb_main_init(void)
{
 8003704:	b508      	push	{r3, lr}
	sf_merge_custom_dictionary(dict_base_dummy_word, custom_dict_start);
 8003706:	4803      	ldr	r0, [pc, #12]	; (8003714 <sf_gdb_main_init+0x10>)
 8003708:	4903      	ldr	r1, [pc, #12]	; (8003718 <sf_gdb_main_init+0x14>)
 800370a:	303c      	adds	r0, #60	; 0x3c
 800370c:	31e0      	adds	r1, #224	; 0xe0
 800370e:	f007 fb4f 	bl	800adb0 <sf_merge_custom_dictionary>
}
 8003712:	bd08      	pop	{r3, pc}
 8003714:	2000001c 	.word	0x2000001c
 8003718:	08011900 	.word	0x08011900

0800371c <hostio_reply>:
#include "gdb_packet.h"

int gdb_main_loop(struct target_controller *, bool in_syscall);

int hostio_reply(struct target_controller *tc, char *pbuf, int len)
{
 800371c:	b570      	push	{r4, r5, r6, lr}
	(void)len;
	int retcode, items, errno_;
	char c, *p;
	if (pbuf[1] == '-')
 800371e:	784b      	ldrb	r3, [r1, #1]
#include "gdb_packet.h"

int gdb_main_loop(struct target_controller *, bool in_syscall);

int hostio_reply(struct target_controller *tc, char *pbuf, int len)
{
 8003720:	1c04      	adds	r4, r0, #0
 8003722:	b086      	sub	sp, #24
 8003724:	1c0d      	adds	r5, r1, #0
	int retcode, items, errno_;
	char c, *p;
	if (pbuf[1] == '-')
		p = &pbuf[2];
	else
		p = &pbuf[1];
 8003726:	1c48      	adds	r0, r1, #1
int hostio_reply(struct target_controller *tc, char *pbuf, int len)
{
	(void)len;
	int retcode, items, errno_;
	char c, *p;
	if (pbuf[1] == '-')
 8003728:	2b2d      	cmp	r3, #45	; 0x2d
 800372a:	d100      	bne.n	800372e <hostio_reply+0x12>
		p = &pbuf[2];
 800372c:	1c88      	adds	r0, r1, #2
	else
		p = &pbuf[1];
	items = sscanf(p, "%x,%x,%c", &retcode, &errno_, &c);
 800372e:	260f      	movs	r6, #15
 8003730:	446e      	add	r6, sp
 8003732:	ab05      	add	r3, sp, #20
 8003734:	9600      	str	r6, [sp, #0]
 8003736:	490d      	ldr	r1, [pc, #52]	; (800376c <hostio_reply+0x50>)
 8003738:	aa04      	add	r2, sp, #16
 800373a:	f009 faf5 	bl	800cd28 <siscanf>
	if (pbuf[1] == '-')
 800373e:	786b      	ldrb	r3, [r5, #1]
 8003740:	2b2d      	cmp	r3, #45	; 0x2d
 8003742:	d102      	bne.n	800374a <hostio_reply+0x2e>
		retcode = -retcode;
 8003744:	9b04      	ldr	r3, [sp, #16]
 8003746:	425b      	negs	r3, r3
 8003748:	9304      	str	r3, [sp, #16]

	/* if break is requested */
	tc->interrupted = items == 3 && c == 'C';
 800374a:	2300      	movs	r3, #0
 800374c:	2803      	cmp	r0, #3
 800374e:	d103      	bne.n	8003758 <hostio_reply+0x3c>
 8003750:	7833      	ldrb	r3, [r6, #0]
 8003752:	3b43      	subs	r3, #67	; 0x43
 8003754:	425a      	negs	r2, r3
 8003756:	4153      	adcs	r3, r2
 8003758:	1c22      	adds	r2, r4, #0
 800375a:	3239      	adds	r2, #57	; 0x39
 800375c:	7013      	strb	r3, [r2, #0]
	tc->errno_ = errno_;

	return retcode;
}
 800375e:	9804      	ldr	r0, [sp, #16]
	if (pbuf[1] == '-')
		retcode = -retcode;

	/* if break is requested */
	tc->interrupted = items == 3 && c == 'C';
	tc->errno_ = errno_;
 8003760:	9b05      	ldr	r3, [sp, #20]
 8003762:	3438      	adds	r4, #56	; 0x38
 8003764:	7023      	strb	r3, [r4, #0]

	return retcode;
}
 8003766:	b006      	add	sp, #24
 8003768:	bd70      	pop	{r4, r5, r6, pc}
 800376a:	46c0      	nop			; (mov r8, r8)
 800376c:	08011e5e 	.word	0x08011e5e

08003770 <hostio_open>:

/* Interface to host system calls */
int hostio_open(struct target_controller *tc,
	        target_addr path, size_t path_len,
                enum target_open_flags flags, mode_t mode)
{
 8003770:	b513      	push	{r0, r1, r4, lr}
 8003772:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fopen,%08X/%X,%08X,%08X", path, path_len, flags, mode);;;;
 8003774:	9804      	ldr	r0, [sp, #16]
 8003776:	9000      	str	r0, [sp, #0]
 8003778:	4803      	ldr	r0, [pc, #12]	; (8003788 <hostio_open+0x18>)
 800377a:	f000 f933 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 800377e:	1c20      	adds	r0, r4, #0
 8003780:	2101      	movs	r1, #1
 8003782:	f7ff fbde 	bl	8002f42 <gdb_main_loop>
}
 8003786:	bd16      	pop	{r1, r2, r4, pc}
 8003788:	08011e67 	.word	0x08011e67

0800378c <hostio_close>:

int hostio_close(struct target_controller *tc, int fd)
{
 800378c:	b510      	push	{r4, lr}
 800378e:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fclose,%08X", fd);
 8003790:	4803      	ldr	r0, [pc, #12]	; (80037a0 <hostio_close+0x14>)
 8003792:	f000 f927 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 8003796:	1c20      	adds	r0, r4, #0
 8003798:	2101      	movs	r1, #1
 800379a:	f7ff fbd2 	bl	8002f42 <gdb_main_loop>
}
 800379e:	bd10      	pop	{r4, pc}
 80037a0:	08011e7f 	.word	0x08011e7f

080037a4 <hostio_read>:

int hostio_read(struct target_controller *tc,
	         int fd, target_addr buf, unsigned int count)
{
 80037a4:	b510      	push	{r4, lr}
 80037a6:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fread,%08X,%08X,%08X", fd, buf, count);
 80037a8:	4803      	ldr	r0, [pc, #12]	; (80037b8 <hostio_read+0x14>)
 80037aa:	f000 f91b 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 80037ae:	1c20      	adds	r0, r4, #0
 80037b0:	2101      	movs	r1, #1
 80037b2:	f7ff fbc6 	bl	8002f42 <gdb_main_loop>
}
 80037b6:	bd10      	pop	{r4, pc}
 80037b8:	08011e8b 	.word	0x08011e8b

080037bc <hostio_write>:

int hostio_write(struct target_controller *tc,
	          int fd, target_addr buf, unsigned int count)
{
 80037bc:	b510      	push	{r4, lr}
 80037be:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fwrite,%08X,%08X,%08X", fd, buf, count);
 80037c0:	4803      	ldr	r0, [pc, #12]	; (80037d0 <hostio_write+0x14>)
 80037c2:	f000 f90f 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 80037c6:	1c20      	adds	r0, r4, #0
 80037c8:	2101      	movs	r1, #1
 80037ca:	f7ff fbba 	bl	8002f42 <gdb_main_loop>
}
 80037ce:	bd10      	pop	{r4, pc}
 80037d0:	08011ea0 	.word	0x08011ea0

080037d4 <hostio_lseek>:

long hostio_lseek(struct target_controller *tc,
	           int fd, long offset, enum target_seek_flag flag)
{
 80037d4:	b510      	push	{r4, lr}
 80037d6:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Flseek,%08X,%08X,%08X", fd, offset, flag);
 80037d8:	4803      	ldr	r0, [pc, #12]	; (80037e8 <hostio_lseek+0x14>)
 80037da:	f000 f903 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 80037de:	1c20      	adds	r0, r4, #0
 80037e0:	2101      	movs	r1, #1
 80037e2:	f7ff fbae 	bl	8002f42 <gdb_main_loop>
}
 80037e6:	bd10      	pop	{r4, pc}
 80037e8:	08011eb6 	.word	0x08011eb6

080037ec <hostio_rename>:

int hostio_rename(struct target_controller *tc,
	           target_addr oldpath, size_t old_len,
	           target_addr newpath, size_t new_len)
{
 80037ec:	b513      	push	{r0, r1, r4, lr}
 80037ee:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Frename,%08X/%X,%08X/%X",
 80037f0:	9804      	ldr	r0, [sp, #16]
 80037f2:	9000      	str	r0, [sp, #0]
 80037f4:	4803      	ldr	r0, [pc, #12]	; (8003804 <hostio_rename+0x18>)
 80037f6:	f000 f8f5 	bl	80039e4 <gdb_putpacket_f>
	                oldpath, old_len, newpath, new_len);
	return gdb_main_loop(tc, true);
 80037fa:	1c20      	adds	r0, r4, #0
 80037fc:	2101      	movs	r1, #1
 80037fe:	f7ff fba0 	bl	8002f42 <gdb_main_loop>
}
 8003802:	bd16      	pop	{r1, r2, r4, pc}
 8003804:	08011ecc 	.word	0x08011ecc

08003808 <hostio_unlink>:

int hostio_unlink(struct target_controller *tc,
	           target_addr path, size_t path_len)
{
 8003808:	b510      	push	{r4, lr}
 800380a:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Funlink,%08X/%X", path, path_len);
 800380c:	4803      	ldr	r0, [pc, #12]	; (800381c <hostio_unlink+0x14>)
 800380e:	f000 f8e9 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 8003812:	1c20      	adds	r0, r4, #0
 8003814:	2101      	movs	r1, #1
 8003816:	f7ff fb94 	bl	8002f42 <gdb_main_loop>
}
 800381a:	bd10      	pop	{r4, pc}
 800381c:	08011ee4 	.word	0x08011ee4

08003820 <hostio_stat>:

int hostio_stat(struct target_controller *tc,
	         target_addr path, size_t path_len, target_addr buf)
{
 8003820:	b510      	push	{r4, lr}
 8003822:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fstat,%08X/%X,%08X", path, path_len, buf);
 8003824:	4803      	ldr	r0, [pc, #12]	; (8003834 <hostio_stat+0x14>)
 8003826:	f000 f8dd 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 800382a:	1c20      	adds	r0, r4, #0
 800382c:	2101      	movs	r1, #1
 800382e:	f7ff fb88 	bl	8002f42 <gdb_main_loop>
}
 8003832:	bd10      	pop	{r4, pc}
 8003834:	08011ef4 	.word	0x08011ef4

08003838 <hostio_fstat>:

int hostio_fstat(struct target_controller *tc, int fd, target_addr buf)
{
 8003838:	b510      	push	{r4, lr}
 800383a:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Ffstat,%X,%08X", fd, buf);
 800383c:	4803      	ldr	r0, [pc, #12]	; (800384c <hostio_fstat+0x14>)
 800383e:	f000 f8d1 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 8003842:	1c20      	adds	r0, r4, #0
 8003844:	2101      	movs	r1, #1
 8003846:	f7ff fb7c 	bl	8002f42 <gdb_main_loop>
}
 800384a:	bd10      	pop	{r4, pc}
 800384c:	08011f07 	.word	0x08011f07

08003850 <hostio_gettimeofday>:

int hostio_gettimeofday(struct target_controller *tc,
		         target_addr tv, target_addr tz)
{
 8003850:	b510      	push	{r4, lr}
 8003852:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fgettimeofday,%08X,%08X", tv, tz);
 8003854:	4803      	ldr	r0, [pc, #12]	; (8003864 <hostio_gettimeofday+0x14>)
 8003856:	f000 f8c5 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 800385a:	1c20      	adds	r0, r4, #0
 800385c:	2101      	movs	r1, #1
 800385e:	f7ff fb70 	bl	8002f42 <gdb_main_loop>
}
 8003862:	bd10      	pop	{r4, pc}
 8003864:	08011f16 	.word	0x08011f16

08003868 <hostio_isatty>:

int hostio_isatty(struct target_controller *tc, int fd)
{
 8003868:	b510      	push	{r4, lr}
 800386a:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fisatty,%08X", fd);
 800386c:	4803      	ldr	r0, [pc, #12]	; (800387c <hostio_isatty+0x14>)
 800386e:	f000 f8b9 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 8003872:	1c20      	adds	r0, r4, #0
 8003874:	2101      	movs	r1, #1
 8003876:	f7ff fb64 	bl	8002f42 <gdb_main_loop>
}
 800387a:	bd10      	pop	{r4, pc}
 800387c:	08011f2e 	.word	0x08011f2e

08003880 <hostio_system>:

int hostio_system(struct target_controller *tc,
	          target_addr cmd, size_t cmd_len)
{
 8003880:	b510      	push	{r4, lr}
 8003882:	1c04      	adds	r4, r0, #0
	gdb_putpacket_f("Fsystem,%08X/%X", cmd, cmd_len);
 8003884:	4803      	ldr	r0, [pc, #12]	; (8003894 <hostio_system+0x14>)
 8003886:	f000 f8ad 	bl	80039e4 <gdb_putpacket_f>
	return gdb_main_loop(tc, true);
 800388a:	1c20      	adds	r0, r4, #0
 800388c:	2101      	movs	r1, #1
 800388e:	f7ff fb58 	bl	8002f42 <gdb_main_loop>
}
 8003892:	bd10      	pop	{r4, pc}
 8003894:	08011f3b 	.word	0x08011f3b

08003898 <gdb_getpacket>:
#include "hex_utils.h"

#include <stdarg.h>

int gdb_getpacket(char *packet, int size)
{
 8003898:	b5f0      	push	{r4, r5, r6, r7, lr}
 800389a:	1c06      	adds	r6, r0, #0
 800389c:	b085      	sub	sp, #20
 800389e:	9101      	str	r1, [sp, #4]
	char recv_csum[3];
	int i;

	while(1) {
		/* Wait for packet start */
		while((packet[0] = gdb_if_getchar()) != '$')
 80038a0:	f7ff f8be 	bl	8002a20 <gdb_if_getchar>
 80038a4:	7030      	strb	r0, [r6, #0]
 80038a6:	2824      	cmp	r0, #36	; 0x24
 80038a8:	d018      	beq.n	80038dc <gdb_getpacket+0x44>
			if(packet[0] == 0x04) return 1;
 80038aa:	2804      	cmp	r0, #4
 80038ac:	d1f8      	bne.n	80038a0 <gdb_getpacket+0x8>
 80038ae:	2001      	movs	r0, #1
 80038b0:	e036      	b.n	8003920 <gdb_getpacket+0x88>
 80038b2:	1c67      	adds	r7, r4, #1
			if(c == '$') { /* Restart capture */
				i = 0;
				csum = 0;
				continue;
			}
			if(c == '}') { /* escaped char */
 80038b4:	287d      	cmp	r0, #125	; 0x7d
 80038b6:	d114      	bne.n	80038e2 <gdb_getpacket+0x4a>
				c = gdb_if_getchar();
 80038b8:	f7ff f8b2 	bl	8002a20 <gdb_if_getchar>
				csum += c + '}';
				packet[i++] = c ^ 0x20;
 80038bc:	2320      	movs	r3, #32
 80038be:	357d      	adds	r5, #125	; 0x7d
				csum = 0;
				continue;
			}
			if(c == '}') { /* escaped char */
				c = gdb_if_getchar();
				csum += c + '}';
 80038c0:	182d      	adds	r5, r5, r0
 80038c2:	b2ed      	uxtb	r5, r5
				packet[i++] = c ^ 0x20;
 80038c4:	4058      	eors	r0, r3
				continue;
			}
			csum += c;
			packet[i++] = c;
 80038c6:	5530      	strb	r0, [r6, r4]
 80038c8:	1c3c      	adds	r4, r7, #0
		while((packet[0] = gdb_if_getchar()) != '$')
			if(packet[0] == 0x04) return 1;

		i = 0; csum = 0;
		/* Capture packet data into buffer */
		while((c = gdb_if_getchar()) != '#') {
 80038ca:	f7ff f8a9 	bl	8002a20 <gdb_if_getchar>
 80038ce:	2823      	cmp	r0, #35	; 0x23
 80038d0:	d00a      	beq.n	80038e8 <gdb_getpacket+0x50>

			if(i == size) break; /* Oh shit */
 80038d2:	9b01      	ldr	r3, [sp, #4]
 80038d4:	429c      	cmp	r4, r3
 80038d6:	d007      	beq.n	80038e8 <gdb_getpacket+0x50>

			if(c == '$') { /* Restart capture */
 80038d8:	2824      	cmp	r0, #36	; 0x24
 80038da:	d1ea      	bne.n	80038b2 <gdb_getpacket+0x1a>
				i = 0;
 80038dc:	2400      	movs	r4, #0
				csum = 0;
 80038de:	1c25      	adds	r5, r4, #0
 80038e0:	e7f3      	b.n	80038ca <gdb_getpacket+0x32>
				c = gdb_if_getchar();
				csum += c + '}';
				packet[i++] = c ^ 0x20;
				continue;
			}
			csum += c;
 80038e2:	1945      	adds	r5, r0, r5
 80038e4:	b2ed      	uxtb	r5, r5
 80038e6:	e7ee      	b.n	80038c6 <gdb_getpacket+0x2e>
			packet[i++] = c;
		}
		recv_csum[0] = gdb_if_getchar();
 80038e8:	f7ff f89a 	bl	8002a20 <gdb_if_getchar>
 80038ec:	af03      	add	r7, sp, #12
 80038ee:	7038      	strb	r0, [r7, #0]
		recv_csum[1] = gdb_if_getchar();
 80038f0:	f7ff f896 	bl	8002a20 <gdb_if_getchar>
		recv_csum[2] = 0;
 80038f4:	2300      	movs	r3, #0
			}
			csum += c;
			packet[i++] = c;
		}
		recv_csum[0] = gdb_if_getchar();
		recv_csum[1] = gdb_if_getchar();
 80038f6:	7078      	strb	r0, [r7, #1]
		recv_csum[2] = 0;

		/* return packet if checksum matches */
		if(csum == strtol(recv_csum, NULL, 16)) break;
 80038f8:	1c19      	adds	r1, r3, #0
 80038fa:	1c38      	adds	r0, r7, #0
 80038fc:	2210      	movs	r2, #16
			csum += c;
			packet[i++] = c;
		}
		recv_csum[0] = gdb_if_getchar();
		recv_csum[1] = gdb_if_getchar();
		recv_csum[2] = 0;
 80038fe:	70bb      	strb	r3, [r7, #2]

		/* return packet if checksum matches */
		if(csum == strtol(recv_csum, NULL, 16)) break;
 8003900:	f009 fbda 	bl	800d0b8 <strtol>
 8003904:	4285      	cmp	r5, r0
 8003906:	d004      	beq.n	8003912 <gdb_getpacket+0x7a>

		/* get here if checksum fails */
		gdb_if_putchar('-', 1); /* send nack */
 8003908:	202d      	movs	r0, #45	; 0x2d
 800390a:	2101      	movs	r1, #1
 800390c:	f7ff f818 	bl	8002940 <gdb_if_putchar>
	char recv_csum[3];
	int i;

	while(1) {
		/* Wait for packet start */
		while((packet[0] = gdb_if_getchar()) != '$')
 8003910:	e7c6      	b.n	80038a0 <gdb_getpacket+0x8>
		if(csum == strtol(recv_csum, NULL, 16)) break;

		/* get here if checksum fails */
		gdb_if_putchar('-', 1); /* send nack */
	}
	gdb_if_putchar('+', 1); /* send ack */
 8003912:	202b      	movs	r0, #43	; 0x2b
 8003914:	2101      	movs	r1, #1
 8003916:	f7ff f813 	bl	8002940 <gdb_if_putchar>
	packet[i] = 0;
 800391a:	2300      	movs	r3, #0
		else
			DEBUG("\\x%02X", c);
	}
	DEBUG("\n");
#endif
	return i;
 800391c:	1c20      	adds	r0, r4, #0

		/* get here if checksum fails */
		gdb_if_putchar('-', 1); /* send nack */
	}
	gdb_if_putchar('+', 1); /* send ack */
	packet[i] = 0;
 800391e:	5533      	strb	r3, [r6, r4]
			DEBUG("\\x%02X", c);
	}
	DEBUG("\n");
#endif
	return i;
}
 8003920:	b005      	add	sp, #20
 8003922:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003924 <gdb_putpacket>:

void gdb_putpacket(const char *packet, int size)
{
 8003924:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003926:	b085      	sub	sp, #20
 8003928:	1c05      	adds	r5, r0, #0
 800392a:	9101      	str	r1, [sp, #4]
	if (!is_sforth_mode_active())
 800392c:	f001 fdda 	bl	80054e4 <is_sforth_mode_active>
 8003930:	2800      	cmp	r0, #0
 8003932:	d002      	beq.n	800393a <gdb_putpacket+0x16>
 8003934:	9b01      	ldr	r3, [sp, #4]
 8003936:	18ec      	adds	r4, r5, r3
 8003938:	e046      	b.n	80039c8 <gdb_putpacket+0xa4>
 800393a:	2304      	movs	r3, #4
 800393c:	9300      	str	r3, [sp, #0]
		do {
#ifdef DEBUG_GDBPACKET
			DEBUG("%s : ", __func__);
#endif
			csum = 0;
			gdb_if_putchar('$', 0);
 800393e:	2024      	movs	r0, #36	; 0x24
 8003940:	2100      	movs	r1, #0
 8003942:	f7fe fffd 	bl	8002940 <gdb_if_putchar>
 8003946:	1c2f      	adds	r7, r5, #0

		do {
#ifdef DEBUG_GDBPACKET
			DEBUG("%s : ", __func__);
#endif
			csum = 0;
 8003948:	2600      	movs	r6, #0
			gdb_if_putchar('$', 0);
			for(i = 0; i < size; i++) {
 800394a:	9a01      	ldr	r2, [sp, #4]
 800394c:	1b7b      	subs	r3, r7, r5
 800394e:	4293      	cmp	r3, r2
 8003950:	da1c      	bge.n	800398c <gdb_putpacket+0x68>
				c = packet[i];
 8003952:	783c      	ldrb	r4, [r7, #0]
				if ((c >= 32) && (c < 127))
					DEBUG("%c", c);
				else
					DEBUG("\\x%02X", c);
#endif
				if((c == '$') || (c == '#') || (c == '}')) {
 8003954:	1c23      	adds	r3, r4, #0
 8003956:	3b23      	subs	r3, #35	; 0x23
 8003958:	2b01      	cmp	r3, #1
 800395a:	d901      	bls.n	8003960 <gdb_putpacket+0x3c>
 800395c:	2c7d      	cmp	r4, #125	; 0x7d
 800395e:	d10d      	bne.n	800397c <gdb_putpacket+0x58>
					gdb_if_putchar('}', 0);
 8003960:	207d      	movs	r0, #125	; 0x7d
 8003962:	2100      	movs	r1, #0
 8003964:	f7fe ffec 	bl	8002940 <gdb_if_putchar>
					gdb_if_putchar(c ^ 0x20, 0);
 8003968:	2320      	movs	r3, #32
 800396a:	367d      	adds	r6, #125	; 0x7d
 800396c:	405c      	eors	r4, r3
 800396e:	1c20      	adds	r0, r4, #0
 8003970:	2100      	movs	r1, #0
					csum += '}' + (c ^ 0x20);
 8003972:	1934      	adds	r4, r6, r4
				else
					DEBUG("\\x%02X", c);
#endif
				if((c == '$') || (c == '#') || (c == '}')) {
					gdb_if_putchar('}', 0);
					gdb_if_putchar(c ^ 0x20, 0);
 8003974:	f7fe ffe4 	bl	8002940 <gdb_if_putchar>
					csum += '}' + (c ^ 0x20);
 8003978:	b2e6      	uxtb	r6, r4
 800397a:	e005      	b.n	8003988 <gdb_putpacket+0x64>
				} else {
					gdb_if_putchar(c, 0);
 800397c:	1c20      	adds	r0, r4, #0
 800397e:	2100      	movs	r1, #0
 8003980:	f7fe ffde 	bl	8002940 <gdb_if_putchar>
					csum += c;
 8003984:	19a6      	adds	r6, r4, r6
 8003986:	b2f6      	uxtb	r6, r6
 8003988:	3701      	adds	r7, #1
 800398a:	e7de      	b.n	800394a <gdb_putpacket+0x26>
				}
			}
			gdb_if_putchar('#', 0);
			sprintf(xmit_csum, "%02X", csum);
 800398c:	ac03      	add	r4, sp, #12
				} else {
					gdb_if_putchar(c, 0);
					csum += c;
				}
			}
			gdb_if_putchar('#', 0);
 800398e:	2023      	movs	r0, #35	; 0x23
 8003990:	2100      	movs	r1, #0
 8003992:	f7fe ffd5 	bl	8002940 <gdb_if_putchar>
			sprintf(xmit_csum, "%02X", csum);
 8003996:	1c32      	adds	r2, r6, #0
 8003998:	4911      	ldr	r1, [pc, #68]	; (80039e0 <gdb_putpacket+0xbc>)
 800399a:	1c20      	adds	r0, r4, #0
 800399c:	f009 f9a2 	bl	800cce4 <siprintf>
			gdb_if_putchar(xmit_csum[0], 0);
 80039a0:	7820      	ldrb	r0, [r4, #0]
 80039a2:	2100      	movs	r1, #0
 80039a4:	f7fe ffcc 	bl	8002940 <gdb_if_putchar>
			gdb_if_putchar(xmit_csum[1], 1);
 80039a8:	7860      	ldrb	r0, [r4, #1]
 80039aa:	2101      	movs	r1, #1
 80039ac:	f7fe ffc8 	bl	8002940 <gdb_if_putchar>
#ifdef DEBUG_GDBPACKET
			DEBUG("\n");
#endif
		} while((gdb_if_getchar_to(2000) != '+') && (tries++ < 3));
 80039b0:	20fa      	movs	r0, #250	; 0xfa
 80039b2:	00c0      	lsls	r0, r0, #3
 80039b4:	f7ff f86a 	bl	8002a8c <gdb_if_getchar_to>
 80039b8:	282b      	cmp	r0, #43	; 0x2b
 80039ba:	d00e      	beq.n	80039da <gdb_putpacket+0xb6>
 80039bc:	9b00      	ldr	r3, [sp, #0]
 80039be:	3b01      	subs	r3, #1
 80039c0:	9300      	str	r3, [sp, #0]
 80039c2:	2b00      	cmp	r3, #0
 80039c4:	d1bb      	bne.n	800393e <gdb_putpacket+0x1a>
 80039c6:	e008      	b.n	80039da <gdb_putpacket+0xb6>
	}
	else
	{
		while (size --)
 80039c8:	42a5      	cmp	r5, r4
 80039ca:	d004      	beq.n	80039d6 <gdb_putpacket+0xb2>
			gdb_if_putchar_single(* packet ++);
 80039cc:	7828      	ldrb	r0, [r5, #0]
 80039ce:	f7ff f819 	bl	8002a04 <gdb_if_putchar_single>
 80039d2:	3501      	adds	r5, #1
 80039d4:	e7f8      	b.n	80039c8 <gdb_putpacket+0xa4>
		gdb_if_flush();
 80039d6:	f7fe ffeb 	bl	80029b0 <gdb_if_flush>
	}
}
 80039da:	b005      	add	sp, #20
 80039dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80039de:	46c0      	nop			; (mov r8, r8)
 80039e0:	08011d69 	.word	0x08011d69

080039e4 <gdb_putpacket_f>:

void gdb_putpacket_f(const char *fmt, ...)
{
 80039e4:	b40f      	push	{r0, r1, r2, r3}
 80039e6:	b507      	push	{r0, r1, r2, lr}
 80039e8:	aa04      	add	r2, sp, #16
 80039ea:	ca02      	ldmia	r2!, {r1}
	va_list ap;
	char *buf;
	int size;

	va_start(ap, fmt);
	size = vasprintf(&buf, fmt, ap);
 80039ec:	a801      	add	r0, sp, #4
{
	va_list ap;
	char *buf;
	int size;

	va_start(ap, fmt);
 80039ee:	9200      	str	r2, [sp, #0]
	size = vasprintf(&buf, fmt, ap);
 80039f0:	f009 fc1c 	bl	800d22c <vasiprintf>
 80039f4:	1c01      	adds	r1, r0, #0
	gdb_putpacket(buf, size);
 80039f6:	9801      	ldr	r0, [sp, #4]
 80039f8:	f7ff ff94 	bl	8003924 <gdb_putpacket>
	free(buf);
 80039fc:	9801      	ldr	r0, [sp, #4]
 80039fe:	f008 ff51 	bl	800c8a4 <free>
	va_end(ap);
}
 8003a02:	b003      	add	sp, #12
 8003a04:	bc08      	pop	{r3}
 8003a06:	b004      	add	sp, #16
 8003a08:	4718      	bx	r3

08003a0a <gdb_out>:

void gdb_out(const char *buf)
{
 8003a0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003a0c:	af00      	add	r7, sp, #0
 8003a0e:	1c04      	adds	r4, r0, #0
	if (!is_sforth_mode_active())
 8003a10:	f001 fd68 	bl	80054e4 <is_sforth_mode_active>
 8003a14:	2800      	cmp	r0, #0
 8003a16:	d118      	bne.n	8003a4a <gdb_out+0x40>
	{
		char *hexdata;
		int i;

		hexdata = alloca((i = strlen(buf)*2 + 1) + 1);
 8003a18:	1c20      	adds	r0, r4, #0
 8003a1a:	f009 fa05 	bl	800ce28 <strlen>
 8003a1e:	466b      	mov	r3, sp
 8003a20:	0040      	lsls	r0, r0, #1
 8003a22:	1c45      	adds	r5, r0, #1
 8003a24:	3010      	adds	r0, #16
 8003a26:	08c0      	lsrs	r0, r0, #3
 8003a28:	00c0      	lsls	r0, r0, #3
 8003a2a:	1a1b      	subs	r3, r3, r0
 8003a2c:	469d      	mov	sp, r3
		hexdata[0] = 'O';
 8003a2e:	234f      	movs	r3, #79	; 0x4f
	if (!is_sforth_mode_active())
	{
		char *hexdata;
		int i;

		hexdata = alloca((i = strlen(buf)*2 + 1) + 1);
 8003a30:	466e      	mov	r6, sp
		hexdata[0] = 'O';
		hexify(hexdata+1, buf, strlen(buf));
 8003a32:	1c20      	adds	r0, r4, #0
	{
		char *hexdata;
		int i;

		hexdata = alloca((i = strlen(buf)*2 + 1) + 1);
		hexdata[0] = 'O';
 8003a34:	7033      	strb	r3, [r6, #0]
		hexify(hexdata+1, buf, strlen(buf));
 8003a36:	f009 f9f7 	bl	800ce28 <strlen>
 8003a3a:	1c21      	adds	r1, r4, #0
 8003a3c:	1c02      	adds	r2, r0, #0
 8003a3e:	1c70      	adds	r0, r6, #1
 8003a40:	f000 f828 	bl	8003a94 <hexify>
		gdb_putpacket(hexdata, i);
 8003a44:	4668      	mov	r0, sp
 8003a46:	1c29      	adds	r1, r5, #0
 8003a48:	e004      	b.n	8003a54 <gdb_out+0x4a>
	}
	else
		gdb_putpacket(buf, strlen(buf));
 8003a4a:	1c20      	adds	r0, r4, #0
 8003a4c:	f009 f9ec 	bl	800ce28 <strlen>
 8003a50:	1c01      	adds	r1, r0, #0
 8003a52:	1c20      	adds	r0, r4, #0
 8003a54:	f7ff ff66 	bl	8003924 <gdb_putpacket>
}
 8003a58:	46bd      	mov	sp, r7
 8003a5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003a5c <gdb_voutf>:

void gdb_voutf(const char *fmt, va_list ap)
{
 8003a5c:	1c03      	adds	r3, r0, #0
 8003a5e:	b507      	push	{r0, r1, r2, lr}
 8003a60:	1c0a      	adds	r2, r1, #0
	char *buf;

	if (vasprintf(&buf, fmt, ap) < 0)
 8003a62:	a801      	add	r0, sp, #4
 8003a64:	1c19      	adds	r1, r3, #0
 8003a66:	f009 fbe1 	bl	800d22c <vasiprintf>
 8003a6a:	2800      	cmp	r0, #0
 8003a6c:	db05      	blt.n	8003a7a <gdb_voutf+0x1e>
		return;
	gdb_out(buf);
 8003a6e:	9801      	ldr	r0, [sp, #4]
 8003a70:	f7ff ffcb 	bl	8003a0a <gdb_out>
	free(buf);
 8003a74:	9801      	ldr	r0, [sp, #4]
 8003a76:	f008 ff15 	bl	800c8a4 <free>
}
 8003a7a:	bd07      	pop	{r0, r1, r2, pc}

08003a7c <gdb_outf>:

void gdb_outf(const char *fmt, ...)
{
 8003a7c:	b40f      	push	{r0, r1, r2, r3}
 8003a7e:	b507      	push	{r0, r1, r2, lr}
 8003a80:	a904      	add	r1, sp, #16
 8003a82:	c901      	ldmia	r1!, {r0}
	va_list ap;

	va_start(ap, fmt);
 8003a84:	9101      	str	r1, [sp, #4]
	gdb_voutf(fmt, ap);
 8003a86:	f7ff ffe9 	bl	8003a5c <gdb_voutf>
	va_end(ap);
}
 8003a8a:	b003      	add	sp, #12
 8003a8c:	bc08      	pop	{r3}
 8003a8e:	b004      	add	sp, #16
 8003a90:	4718      	bx	r3
 8003a92:	46c0      	nop			; (mov r8, r8)

08003a94 <hexify>:
#include "hex_utils.h"

static const char hexdigits[] = "0123456789abcdef";

char * hexify(char *hex, const void *buf, size_t size)
{
 8003a94:	1c03      	adds	r3, r0, #0
 8003a96:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003a98:	188e      	adds	r6, r1, r2
	char *tmp = hex;
	const uint8_t *b = buf;

	while (size--) {
 8003a9a:	42b1      	cmp	r1, r6
 8003a9c:	d00c      	beq.n	8003ab8 <hexify+0x24>
		*tmp++ = hexdigits[*b >> 4];
 8003a9e:	780c      	ldrb	r4, [r1, #0]
 8003aa0:	4d07      	ldr	r5, [pc, #28]	; (8003ac0 <hexify+0x2c>)
 8003aa2:	0924      	lsrs	r4, r4, #4
 8003aa4:	5d2c      	ldrb	r4, [r5, r4]
 8003aa6:	701c      	strb	r4, [r3, #0]
		*tmp++ = hexdigits[*b++ & 0xF];
 8003aa8:	240f      	movs	r4, #15
 8003aaa:	780f      	ldrb	r7, [r1, #0]
 8003aac:	3101      	adds	r1, #1
 8003aae:	403c      	ands	r4, r7
 8003ab0:	5d2c      	ldrb	r4, [r5, r4]
 8003ab2:	705c      	strb	r4, [r3, #1]
 8003ab4:	3302      	adds	r3, #2
 8003ab6:	e7f0      	b.n	8003a9a <hexify+0x6>
	}
	*tmp++ = 0;
 8003ab8:	2300      	movs	r3, #0
 8003aba:	0052      	lsls	r2, r2, #1
 8003abc:	5413      	strb	r3, [r2, r0]

	return hex;
}
 8003abe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003ac0:	08011f4b 	.word	0x08011f4b

08003ac4 <unhexify>:
		tmp -= 'a' - 'A';
	return tmp;
}

char * unhexify(void *buf, const char *hex, size_t size)
{
 8003ac4:	b570      	push	{r4, r5, r6, lr}
 8003ac6:	1c04      	adds	r4, r0, #0
 8003ac8:	1882      	adds	r2, r0, r2
	uint8_t *b = buf;
	while (size--) {
 8003aca:	4294      	cmp	r4, r2
 8003acc:	d023      	beq.n	8003b16 <unhexify+0x52>
		*b = unhex_digit(*hex++) << 4;
 8003ace:	780d      	ldrb	r5, [r1, #0]
	return hex;
}

static uint8_t unhex_digit(char hex)
{
	uint8_t tmp = hex - '0';
 8003ad0:	1c2b      	adds	r3, r5, #0
 8003ad2:	3b30      	subs	r3, #48	; 0x30
 8003ad4:	b2db      	uxtb	r3, r3
	if(tmp > 9)
 8003ad6:	2b09      	cmp	r3, #9
 8003ad8:	d907      	bls.n	8003aea <unhexify+0x26>
		tmp -= 'A' - '0' - 10;
 8003ada:	1c2b      	adds	r3, r5, #0
 8003adc:	3b37      	subs	r3, #55	; 0x37
 8003ade:	b2db      	uxtb	r3, r3
	if(tmp > 16)
 8003ae0:	2b10      	cmp	r3, #16
 8003ae2:	d902      	bls.n	8003aea <unhexify+0x26>
		tmp -= 'a' - 'A';
 8003ae4:	1c2b      	adds	r3, r5, #0
 8003ae6:	3b57      	subs	r3, #87	; 0x57
 8003ae8:	b2db      	uxtb	r3, r3

char * unhexify(void *buf, const char *hex, size_t size)
{
	uint8_t *b = buf;
	while (size--) {
		*b = unhex_digit(*hex++) << 4;
 8003aea:	011b      	lsls	r3, r3, #4
 8003aec:	b2db      	uxtb	r3, r3
 8003aee:	7023      	strb	r3, [r4, #0]
		*b++ |= unhex_digit(*hex++);
 8003af0:	784e      	ldrb	r6, [r1, #1]
	return hex;
}

static uint8_t unhex_digit(char hex)
{
	uint8_t tmp = hex - '0';
 8003af2:	1c35      	adds	r5, r6, #0
 8003af4:	3d30      	subs	r5, #48	; 0x30
 8003af6:	b2ed      	uxtb	r5, r5
	if(tmp > 9)
 8003af8:	2d09      	cmp	r5, #9
 8003afa:	d907      	bls.n	8003b0c <unhexify+0x48>
		tmp -= 'A' - '0' - 10;
 8003afc:	1c35      	adds	r5, r6, #0
 8003afe:	3d37      	subs	r5, #55	; 0x37
 8003b00:	b2ed      	uxtb	r5, r5
	if(tmp > 16)
 8003b02:	2d10      	cmp	r5, #16
 8003b04:	d902      	bls.n	8003b0c <unhexify+0x48>
		tmp -= 'a' - 'A';
 8003b06:	1c35      	adds	r5, r6, #0
 8003b08:	3d57      	subs	r5, #87	; 0x57
 8003b0a:	b2ed      	uxtb	r5, r5
char * unhexify(void *buf, const char *hex, size_t size)
{
	uint8_t *b = buf;
	while (size--) {
		*b = unhex_digit(*hex++) << 4;
		*b++ |= unhex_digit(*hex++);
 8003b0c:	432b      	orrs	r3, r5
 8003b0e:	7023      	strb	r3, [r4, #0]
 8003b10:	3102      	adds	r1, #2
 8003b12:	3401      	adds	r4, #1
 8003b14:	e7d9      	b.n	8003aca <unhexify+0x6>
	}
	return buf;
}
 8003b16:	bd70      	pop	{r4, r5, r6, pc}

08003b18 <jtag_scan>:
 * For each device, shift out one bit. If this is zero IDCODE isn't present,
 *	continue to next device. If this is one shift out the remaining 31 bits
 *	of the IDCODE register.
 */
int jtag_scan(const uint8_t *irlens)
{
 8003b18:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003b1a:	b087      	sub	sp, #28
 8003b1c:	1c06      	adds	r6, r0, #0
	int i;
	uint32_t j;

	target_list_free();
 8003b1e:	f004 fa7b 	bl	8008018 <target_list_free>

	jtag_dev_count = 0;
 8003b22:	2300      	movs	r3, #0
	memset(&jtag_devs, 0, sizeof(jtag_devs));
 8003b24:	22a5      	movs	r2, #165	; 0xa5
 8003b26:	4ca3      	ldr	r4, [pc, #652]	; (8003db4 <jtag_scan+0x29c>)
	int i;
	uint32_t j;

	target_list_free();

	jtag_dev_count = 0;
 8003b28:	4fa3      	ldr	r7, [pc, #652]	; (8003db8 <jtag_scan+0x2a0>)
	memset(&jtag_devs, 0, sizeof(jtag_devs));
 8003b2a:	1c19      	adds	r1, r3, #0
 8003b2c:	0092      	lsls	r2, r2, #2
 8003b2e:	1c20      	adds	r0, r4, #0
	int i;
	uint32_t j;

	target_list_free();

	jtag_dev_count = 0;
 8003b30:	603b      	str	r3, [r7, #0]
	memset(&jtag_devs, 0, sizeof(jtag_devs));
 8003b32:	f008 fede 	bl	800c8f2 <memset>

	/* Run throught the SWD to JTAG sequence for the case where an attached SWJ-DP is
	 * in SW-DP mode.
	 */
	DEBUG("Resetting TAP\n");
 8003b36:	48a1      	ldr	r0, [pc, #644]	; (8003dbc <jtag_scan+0x2a4>)
 8003b38:	f009 f820 	bl	800cb7c <puts>
 8003b3c:	1c3d      	adds	r5, r7, #0
	jtagtap_init();
 8003b3e:	f000 f9bf 	bl	8003ec0 <jtagtap_init>
	jtagtap_reset();
 8003b42:	f000 f9be 	bl	8003ec2 <jtagtap_reset>

	if (irlens) {
 8003b46:	2e00      	cmp	r6, #0
 8003b48:	d034      	beq.n	8003bb4 <jtag_scan+0x9c>
		DEBUG("Given list of IR lengths, skipping probe\n");
 8003b4a:	489d      	ldr	r0, [pc, #628]	; (8003dc0 <jtag_scan+0x2a8>)
 8003b4c:	f009 f816 	bl	800cb7c <puts>
		DEBUG("Change state to Shift-IR\n");
 8003b50:	489c      	ldr	r0, [pc, #624]	; (8003dc4 <jtag_scan+0x2ac>)
 8003b52:	f009 f813 	bl	800cb7c <puts>
		jtagtap_shift_ir();
 8003b56:	2003      	movs	r0, #3
 8003b58:	2104      	movs	r1, #4
 8003b5a:	f000 f9e5 	bl	8003f28 <jtagtap_tms_seq>
		j = 0;
 8003b5e:	2400      	movs	r4, #0
		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
 8003b60:	4f95      	ldr	r7, [pc, #596]	; (8003db8 <jtag_scan+0x2a0>)
 8003b62:	683b      	ldr	r3, [r7, #0]
 8003b64:	2b20      	cmp	r3, #32
 8003b66:	dc76      	bgt.n	8003c56 <jtag_scan+0x13e>
		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
 8003b68:	2214      	movs	r2, #20
 8003b6a:	4353      	muls	r3, r2
 8003b6c:	4d91      	ldr	r5, [pc, #580]	; (8003db4 <jtag_scan+0x29c>)
 8003b6e:	18eb      	adds	r3, r5, r3
	if (irlens) {
		DEBUG("Given list of IR lengths, skipping probe\n");
		DEBUG("Change state to Shift-IR\n");
		jtagtap_shift_ir();
		j = 0;
		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
 8003b70:	789b      	ldrb	r3, [r3, #2]
 8003b72:	2b10      	cmp	r3, #16
 8003b74:	d86f      	bhi.n	8003c56 <jtag_scan+0x13e>
		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
			uint32_t irout;
			if(*irlens == 0)
 8003b76:	7833      	ldrb	r3, [r6, #0]
 8003b78:	2b00      	cmp	r3, #0
 8003b7a:	d06c      	beq.n	8003c56 <jtag_scan+0x13e>
				break;
			jtagtap_tdi_tdo_seq((uint8_t*)&irout, 0, ones, *irlens);
 8003b7c:	a805      	add	r0, sp, #20
 8003b7e:	2100      	movs	r1, #0
 8003b80:	4a91      	ldr	r2, [pc, #580]	; (8003dc8 <jtag_scan+0x2b0>)
 8003b82:	f000 f9df 	bl	8003f44 <jtagtap_tdi_tdo_seq>
			if (!(irout & 1)) {
 8003b86:	9b05      	ldr	r3, [sp, #20]
 8003b88:	07db      	lsls	r3, r3, #31
 8003b8a:	d405      	bmi.n	8003b98 <jtag_scan+0x80>
				DEBUG("check failed: IR[0] != 1\n");
 8003b8c:	488f      	ldr	r0, [pc, #572]	; (8003dcc <jtag_scan+0x2b4>)
 8003b8e:	f008 fff5 	bl	800cb7c <puts>
				return -1;
 8003b92:	2001      	movs	r0, #1
 8003b94:	4240      	negs	r0, r0
 8003b96:	e10b      	b.n	8003db0 <jtag_scan+0x298>
			}
			jtag_devs[jtag_dev_count].ir_len = *irlens;
 8003b98:	2214      	movs	r2, #20
 8003b9a:	683b      	ldr	r3, [r7, #0]
 8003b9c:	7830      	ldrb	r0, [r6, #0]
 8003b9e:	435a      	muls	r2, r3
 8003ba0:	18a9      	adds	r1, r5, r2
			jtag_devs[jtag_dev_count].ir_prescan = j;
 8003ba2:	70cc      	strb	r4, [r1, #3]
			jtag_devs[jtag_dev_count].dev = jtag_dev_count;
 8003ba4:	5553      	strb	r3, [r2, r5]
			jtagtap_tdi_tdo_seq((uint8_t*)&irout, 0, ones, *irlens);
			if (!(irout & 1)) {
				DEBUG("check failed: IR[0] != 1\n");
				return -1;
			}
			jtag_devs[jtag_dev_count].ir_len = *irlens;
 8003ba6:	7088      	strb	r0, [r1, #2]
			jtag_devs[jtag_dev_count].ir_prescan = j;
			jtag_devs[jtag_dev_count].dev = jtag_dev_count;
			j += *irlens;
 8003ba8:	7832      	ldrb	r2, [r6, #0]
			irlens++;
			jtag_dev_count++;
 8003baa:	3301      	adds	r3, #1
				return -1;
			}
			jtag_devs[jtag_dev_count].ir_len = *irlens;
			jtag_devs[jtag_dev_count].ir_prescan = j;
			jtag_devs[jtag_dev_count].dev = jtag_dev_count;
			j += *irlens;
 8003bac:	18a4      	adds	r4, r4, r2
			irlens++;
 8003bae:	3601      	adds	r6, #1
			jtag_dev_count++;
 8003bb0:	603b      	str	r3, [r7, #0]
 8003bb2:	e7d5      	b.n	8003b60 <jtag_scan+0x48>
		}
	} else {
		DEBUG("Change state to Shift-IR\n");
 8003bb4:	4883      	ldr	r0, [pc, #524]	; (8003dc4 <jtag_scan+0x2ac>)
 8003bb6:	f008 ffe1 	bl	800cb7c <puts>
		jtagtap_shift_ir();
 8003bba:	2104      	movs	r1, #4
 8003bbc:	2003      	movs	r0, #3
 8003bbe:	f000 f9b3 	bl	8003f28 <jtagtap_tms_seq>

		DEBUG("Scanning out IRs\n");
 8003bc2:	4883      	ldr	r0, [pc, #524]	; (8003dd0 <jtag_scan+0x2b8>)
 8003bc4:	f008 ffda 	bl	800cb7c <puts>
		if(!jtagtap_next(0, 1)) {
 8003bc8:	1c30      	adds	r0, r6, #0
 8003bca:	2101      	movs	r1, #1
 8003bcc:	f000 f97f 	bl	8003ece <jtagtap_next>
 8003bd0:	2800      	cmp	r0, #0
 8003bd2:	d106      	bne.n	8003be2 <jtag_scan+0xca>
			DEBUG("jtag_scan: Sanity check failed: IR[0] shifted out as 0\n");
 8003bd4:	487f      	ldr	r0, [pc, #508]	; (8003dd4 <jtag_scan+0x2bc>)
 8003bd6:	f008 ffd1 	bl	800cb7c <puts>
			jtag_dev_count = -1;
 8003bda:	2001      	movs	r0, #1
 8003bdc:	4240      	negs	r0, r0
 8003bde:	6038      	str	r0, [r7, #0]
			return -1; /* must be 1 */
 8003be0:	e0e6      	b.n	8003db0 <jtag_scan+0x298>
		}
		jtag_devs[0].ir_len = 1; j = 1;
 8003be2:	2701      	movs	r7, #1
 8003be4:	70a7      	strb	r7, [r4, #2]
		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
 8003be6:	682b      	ldr	r3, [r5, #0]
 8003be8:	2b20      	cmp	r3, #32
 8003bea:	dd04      	ble.n	8003bf6 <jtag_scan+0xde>
				jtag_devs[jtag_dev_count].ir_prescan = j;
				jtag_devs[jtag_dev_count].dev = jtag_dev_count;
			} else jtag_devs[jtag_dev_count].ir_len++;
			j++;
		}
		if(jtag_dev_count > JTAG_MAX_DEVS) {
 8003bec:	682a      	ldr	r2, [r5, #0]
 8003bee:	2a20      	cmp	r2, #32
 8003bf0:	dd24      	ble.n	8003c3c <jtag_scan+0x124>
			DEBUG("jtag_scan: Maximum device count exceeded\n");
 8003bf2:	4879      	ldr	r0, [pc, #484]	; (8003dd8 <jtag_scan+0x2c0>)
 8003bf4:	e029      	b.n	8003c4a <jtag_scan+0x132>
			jtag_dev_count = -1;
			return -1; /* must be 1 */
		}
		jtag_devs[0].ir_len = 1; j = 1;
		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
 8003bf6:	2614      	movs	r6, #20
 8003bf8:	4373      	muls	r3, r6
 8003bfa:	18e3      	adds	r3, r4, r3
			DEBUG("jtag_scan: Sanity check failed: IR[0] shifted out as 0\n");
			jtag_dev_count = -1;
			return -1; /* must be 1 */
		}
		jtag_devs[0].ir_len = 1; j = 1;
		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
 8003bfc:	789b      	ldrb	r3, [r3, #2]
 8003bfe:	2b10      	cmp	r3, #16
 8003c00:	d8f4      	bhi.n	8003bec <jtag_scan+0xd4>
		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
			if(jtagtap_next(0, 1)) {
 8003c02:	2000      	movs	r0, #0
 8003c04:	2101      	movs	r1, #1
 8003c06:	f000 f962 	bl	8003ece <jtagtap_next>
				if(jtag_devs[jtag_dev_count].ir_len == 1) break;
 8003c0a:	682b      	ldr	r3, [r5, #0]
			return -1; /* must be 1 */
		}
		jtag_devs[0].ir_len = 1; j = 1;
		while((jtag_dev_count <= JTAG_MAX_DEVS) &&
		      (jtag_devs[jtag_dev_count].ir_len <= JTAG_MAX_IR_LEN)) {
			if(jtagtap_next(0, 1)) {
 8003c0c:	2800      	cmp	r0, #0
 8003c0e:	d00e      	beq.n	8003c2e <jtag_scan+0x116>
				if(jtag_devs[jtag_dev_count].ir_len == 1) break;
 8003c10:	1c32      	adds	r2, r6, #0
 8003c12:	435a      	muls	r2, r3
 8003c14:	18a2      	adds	r2, r4, r2
 8003c16:	7892      	ldrb	r2, [r2, #2]
 8003c18:	2a01      	cmp	r2, #1
 8003c1a:	d0e7      	beq.n	8003bec <jtag_scan+0xd4>
				jtag_devs[++jtag_dev_count].ir_len = 1;
 8003c1c:	2101      	movs	r1, #1
 8003c1e:	3301      	adds	r3, #1
 8003c20:	435e      	muls	r6, r3
 8003c22:	19a2      	adds	r2, r4, r6
 8003c24:	602b      	str	r3, [r5, #0]
 8003c26:	7091      	strb	r1, [r2, #2]
				jtag_devs[jtag_dev_count].ir_prescan = j;
 8003c28:	70d7      	strb	r7, [r2, #3]
				jtag_devs[jtag_dev_count].dev = jtag_dev_count;
 8003c2a:	55a3      	strb	r3, [r4, r6]
 8003c2c:	e004      	b.n	8003c38 <jtag_scan+0x120>
			} else jtag_devs[jtag_dev_count].ir_len++;
 8003c2e:	435e      	muls	r6, r3
 8003c30:	19a6      	adds	r6, r4, r6
 8003c32:	78b3      	ldrb	r3, [r6, #2]
 8003c34:	3301      	adds	r3, #1
 8003c36:	70b3      	strb	r3, [r6, #2]
			j++;
 8003c38:	3701      	adds	r7, #1
 8003c3a:	e7d4      	b.n	8003be6 <jtag_scan+0xce>
		if(jtag_dev_count > JTAG_MAX_DEVS) {
			DEBUG("jtag_scan: Maximum device count exceeded\n");
			jtag_dev_count = -1;
			return -1;
		}
		if(jtag_devs[jtag_dev_count].ir_len > JTAG_MAX_IR_LEN) {
 8003c3c:	2314      	movs	r3, #20
 8003c3e:	4353      	muls	r3, r2
 8003c40:	18e4      	adds	r4, r4, r3
 8003c42:	78a3      	ldrb	r3, [r4, #2]
 8003c44:	2b10      	cmp	r3, #16
 8003c46:	d906      	bls.n	8003c56 <jtag_scan+0x13e>
			DEBUG("jtag_scan: Maximum IR length exceeded\n");
 8003c48:	4864      	ldr	r0, [pc, #400]	; (8003ddc <jtag_scan+0x2c4>)
 8003c4a:	f008 ff97 	bl	800cb7c <puts>
			jtag_dev_count = -1;
 8003c4e:	2001      	movs	r0, #1
 8003c50:	4240      	negs	r0, r0
 8003c52:	6028      	str	r0, [r5, #0]
			return -1;
 8003c54:	e0ac      	b.n	8003db0 <jtag_scan+0x298>
		}
	}

	DEBUG("Return to Run-Test/Idle\n");
 8003c56:	4d62      	ldr	r5, [pc, #392]	; (8003de0 <jtag_scan+0x2c8>)
	/* All devices should be in BYPASS now */

	/* Count device on chain */
	DEBUG("Change state to Shift-DR\n");
	jtagtap_shift_dr();
	for(i = 0; (jtagtap_next(0, 1) == 0) && (i <= jtag_dev_count); i++)
 8003c58:	2400      	movs	r4, #0
			jtag_dev_count = -1;
			return -1;
		}
	}

	DEBUG("Return to Run-Test/Idle\n");
 8003c5a:	1c28      	adds	r0, r5, #0
 8003c5c:	f008 ff8e 	bl	800cb7c <puts>
	jtagtap_next(1, 1);
 8003c60:	2001      	movs	r0, #1
 8003c62:	1c01      	adds	r1, r0, #0
 8003c64:	f000 f933 	bl	8003ece <jtagtap_next>
	jtagtap_return_idle();
 8003c68:	2102      	movs	r1, #2
 8003c6a:	2001      	movs	r0, #1
 8003c6c:	f000 f95c 	bl	8003f28 <jtagtap_tms_seq>

	/* All devices should be in BYPASS now */

	/* Count device on chain */
	DEBUG("Change state to Shift-DR\n");
 8003c70:	485c      	ldr	r0, [pc, #368]	; (8003de4 <jtag_scan+0x2cc>)
 8003c72:	f008 ff83 	bl	800cb7c <puts>
	jtagtap_shift_dr();
 8003c76:	2001      	movs	r0, #1
 8003c78:	2103      	movs	r1, #3
 8003c7a:	f000 f955 	bl	8003f28 <jtagtap_tms_seq>
 8003c7e:	9503      	str	r5, [sp, #12]
	for(i = 0; (jtagtap_next(0, 1) == 0) && (i <= jtag_dev_count); i++)
 8003c80:	2000      	movs	r0, #0
 8003c82:	2101      	movs	r1, #1
 8003c84:	f000 f923 	bl	8003ece <jtagtap_next>
 8003c88:	4e4b      	ldr	r6, [pc, #300]	; (8003db8 <jtag_scan+0x2a0>)
 8003c8a:	2800      	cmp	r0, #0
 8003c8c:	d009      	beq.n	8003ca2 <jtag_scan+0x18a>
		jtag_devs[i].dr_postscan = jtag_dev_count - i - 1;

	if(i != jtag_dev_count) {
 8003c8e:	6833      	ldr	r3, [r6, #0]
 8003c90:	429c      	cmp	r4, r3
 8003c92:	d012      	beq.n	8003cba <jtag_scan+0x1a2>
		DEBUG("jtag_scan: Sanity check failed: "
 8003c94:	4854      	ldr	r0, [pc, #336]	; (8003de8 <jtag_scan+0x2d0>)
 8003c96:	f008 ff71 	bl	800cb7c <puts>
			"BYPASS dev count doesn't match IR scan\n");
		jtag_dev_count = -1;
 8003c9a:	2001      	movs	r0, #1
 8003c9c:	4240      	negs	r0, r0
 8003c9e:	6030      	str	r0, [r6, #0]
		return -1;
 8003ca0:	e086      	b.n	8003db0 <jtag_scan+0x298>
	/* All devices should be in BYPASS now */

	/* Count device on chain */
	DEBUG("Change state to Shift-DR\n");
	jtagtap_shift_dr();
	for(i = 0; (jtagtap_next(0, 1) == 0) && (i <= jtag_dev_count); i++)
 8003ca2:	6833      	ldr	r3, [r6, #0]
 8003ca4:	429c      	cmp	r4, r3
 8003ca6:	dcf2      	bgt.n	8003c8e <jtag_scan+0x176>
 8003ca8:	2214      	movs	r2, #20
 8003caa:	4362      	muls	r2, r4
 8003cac:	4941      	ldr	r1, [pc, #260]	; (8003db4 <jtag_scan+0x29c>)
 8003cae:	3b01      	subs	r3, #1
		jtag_devs[i].dr_postscan = jtag_dev_count - i - 1;
 8003cb0:	1b1b      	subs	r3, r3, r4
 8003cb2:	1852      	adds	r2, r2, r1
 8003cb4:	7053      	strb	r3, [r2, #1]
	/* All devices should be in BYPASS now */

	/* Count device on chain */
	DEBUG("Change state to Shift-DR\n");
	jtagtap_shift_dr();
	for(i = 0; (jtagtap_next(0, 1) == 0) && (i <= jtag_dev_count); i++)
 8003cb6:	3401      	adds	r4, #1
 8003cb8:	e7e2      	b.n	8003c80 <jtag_scan+0x168>
			"BYPASS dev count doesn't match IR scan\n");
		jtag_dev_count = -1;
		return -1;
	}

	DEBUG("Return to Run-Test/Idle\n");
 8003cba:	9803      	ldr	r0, [sp, #12]
 8003cbc:	f008 ff5e 	bl	800cb7c <puts>
	jtagtap_next(1, 1);
 8003cc0:	2001      	movs	r0, #1
 8003cc2:	1c01      	adds	r1, r0, #0
 8003cc4:	f000 f903 	bl	8003ece <jtagtap_next>
	jtagtap_return_idle();
 8003cc8:	2001      	movs	r0, #1
 8003cca:	2102      	movs	r1, #2
 8003ccc:	f000 f92c 	bl	8003f28 <jtagtap_tms_seq>
	if(!jtag_dev_count) {
 8003cd0:	6830      	ldr	r0, [r6, #0]
 8003cd2:	2800      	cmp	r0, #0
 8003cd4:	d06c      	beq.n	8003db0 <jtag_scan+0x298>
 8003cd6:	2314      	movs	r3, #20
		return 0;
	}

	/* Fill in the ir_postscan fields */
	for(i = jtag_dev_count - 1; i; i--)
 8003cd8:	1e44      	subs	r4, r0, #1
 8003cda:	4358      	muls	r0, r3
 8003cdc:	4b35      	ldr	r3, [pc, #212]	; (8003db4 <jtag_scan+0x29c>)
 8003cde:	3810      	subs	r0, #16
 8003ce0:	18c0      	adds	r0, r0, r3
 8003ce2:	3814      	subs	r0, #20
 8003ce4:	2c00      	cmp	r4, #0
 8003ce6:	d005      	beq.n	8003cf4 <jtag_scan+0x1dc>
		jtag_devs[i-1].ir_postscan = jtag_devs[i].ir_postscan +
 8003ce8:	7c82      	ldrb	r2, [r0, #18]
 8003cea:	7d03      	ldrb	r3, [r0, #20]
 8003cec:	3c01      	subs	r4, #1
 8003cee:	18d3      	adds	r3, r2, r3
 8003cf0:	7003      	strb	r3, [r0, #0]
 8003cf2:	e7f6      	b.n	8003ce2 <jtag_scan+0x1ca>
					jtag_devs[i].ir_len;

	/* Reset jtagtap: should take all devs to IDCODE */
	jtagtap_reset();
 8003cf4:	f000 f8e5 	bl	8003ec2 <jtagtap_reset>
	jtagtap_shift_dr();
 8003cf8:	2001      	movs	r0, #1
 8003cfa:	2103      	movs	r1, #3
 8003cfc:	f000 f914 	bl	8003f28 <jtagtap_tms_seq>
 8003d00:	4d3a      	ldr	r5, [pc, #232]	; (8003dec <jtag_scan+0x2d4>)
	for(i = 0; i < jtag_dev_count; i++) {
 8003d02:	9400      	str	r4, [sp, #0]
 8003d04:	1c2f      	adds	r7, r5, #0
 8003d06:	9b00      	ldr	r3, [sp, #0]
 8003d08:	6832      	ldr	r2, [r6, #0]
 8003d0a:	4293      	cmp	r3, r2
 8003d0c:	da22      	bge.n	8003d54 <jtag_scan+0x23c>
		if(!jtagtap_next(0, 1)) continue;
 8003d0e:	2000      	movs	r0, #0
 8003d10:	2101      	movs	r1, #1
 8003d12:	f000 f8dc 	bl	8003ece <jtagtap_next>
 8003d16:	2800      	cmp	r0, #0
 8003d18:	d017      	beq.n	8003d4a <jtag_scan+0x232>
		jtag_devs[i].idcode = 1;
 8003d1a:	2301      	movs	r3, #1
 8003d1c:	603b      	str	r3, [r7, #0]
 8003d1e:	331e      	adds	r3, #30
 8003d20:	9301      	str	r3, [sp, #4]
		for(j = 2; j; j <<= 1)
 8003d22:	3b1d      	subs	r3, #29
 8003d24:	9302      	str	r3, [sp, #8]
			if(jtagtap_next(0, 1)) jtag_devs[i].idcode |= j;
 8003d26:	2000      	movs	r0, #0
 8003d28:	2101      	movs	r1, #1
 8003d2a:	f000 f8d0 	bl	8003ece <jtagtap_next>
 8003d2e:	2800      	cmp	r0, #0
 8003d30:	d003      	beq.n	8003d3a <jtag_scan+0x222>
 8003d32:	683b      	ldr	r3, [r7, #0]
 8003d34:	9a02      	ldr	r2, [sp, #8]
 8003d36:	4313      	orrs	r3, r2
 8003d38:	603b      	str	r3, [r7, #0]
	jtagtap_reset();
	jtagtap_shift_dr();
	for(i = 0; i < jtag_dev_count; i++) {
		if(!jtagtap_next(0, 1)) continue;
		jtag_devs[i].idcode = 1;
		for(j = 2; j; j <<= 1)
 8003d3a:	9b02      	ldr	r3, [sp, #8]
 8003d3c:	005b      	lsls	r3, r3, #1
 8003d3e:	9302      	str	r3, [sp, #8]
 8003d40:	9b01      	ldr	r3, [sp, #4]
 8003d42:	3b01      	subs	r3, #1
 8003d44:	9301      	str	r3, [sp, #4]
 8003d46:	2b00      	cmp	r3, #0
 8003d48:	d1ed      	bne.n	8003d26 <jtag_scan+0x20e>
					jtag_devs[i].ir_len;

	/* Reset jtagtap: should take all devs to IDCODE */
	jtagtap_reset();
	jtagtap_shift_dr();
	for(i = 0; i < jtag_dev_count; i++) {
 8003d4a:	9b00      	ldr	r3, [sp, #0]
 8003d4c:	3714      	adds	r7, #20
 8003d4e:	3301      	adds	r3, #1
 8003d50:	9300      	str	r3, [sp, #0]
 8003d52:	e7d8      	b.n	8003d06 <jtag_scan+0x1ee>
		jtag_devs[i].idcode = 1;
		for(j = 2; j; j <<= 1)
			if(jtagtap_next(0, 1)) jtag_devs[i].idcode |= j;

	}
	DEBUG("Return to Run-Test/Idle\n");
 8003d54:	9803      	ldr	r0, [sp, #12]
 8003d56:	f008 ff11 	bl	800cb7c <puts>
	jtagtap_next(1, 1);
 8003d5a:	2001      	movs	r0, #1
 8003d5c:	1c01      	adds	r1, r0, #0
 8003d5e:	f000 f8b6 	bl	8003ece <jtagtap_next>
	jtagtap_return_idle();
 8003d62:	2001      	movs	r0, #1
 8003d64:	2102      	movs	r1, #2
 8003d66:	f000 f8df 	bl	8003f28 <jtagtap_tms_seq>

	/* Check for known devices and handle accordingly */
	for(i = 0; i < jtag_dev_count; i++)
 8003d6a:	6830      	ldr	r0, [r6, #0]
 8003d6c:	4284      	cmp	r4, r0
 8003d6e:	da1f      	bge.n	8003db0 <jtag_scan+0x298>
 8003d70:	2100      	movs	r1, #0
		for(j = 0; dev_descr[j].idcode; j++)
 8003d72:	4a15      	ldr	r2, [pc, #84]	; (8003dc8 <jtag_scan+0x2b0>)
 8003d74:	010b      	lsls	r3, r1, #4
 8003d76:	4694      	mov	ip, r2
 8003d78:	320c      	adds	r2, #12
 8003d7a:	5898      	ldr	r0, [r3, r2]
 8003d7c:	2800      	cmp	r0, #0
 8003d7e:	d014      	beq.n	8003daa <jtag_scan+0x292>
 8003d80:	18d2      	adds	r2, r2, r3
			if((jtag_devs[i].idcode & dev_descr[j].idmask) ==
 8003d82:	6852      	ldr	r2, [r2, #4]
 8003d84:	682f      	ldr	r7, [r5, #0]
 8003d86:	403a      	ands	r2, r7
 8003d88:	4282      	cmp	r2, r0
 8003d8a:	d10c      	bne.n	8003da6 <jtag_scan+0x28e>
			   dev_descr[j].idcode) {
				jtag_devs[i].current_ir = -1;
 8003d8c:	2201      	movs	r2, #1
				/* Save description in table */
				jtag_devs[i].descr = dev_descr[j].descr;
 8003d8e:	4463      	add	r3, ip
	/* Check for known devices and handle accordingly */
	for(i = 0; i < jtag_dev_count; i++)
		for(j = 0; dev_descr[j].idcode; j++)
			if((jtag_devs[i].idcode & dev_descr[j].idmask) ==
			   dev_descr[j].idcode) {
				jtag_devs[i].current_ir = -1;
 8003d90:	4252      	negs	r2, r2
 8003d92:	60aa      	str	r2, [r5, #8]
				/* Save description in table */
				jtag_devs[i].descr = dev_descr[j].descr;
 8003d94:	695a      	ldr	r2, [r3, #20]
				/* Call handler to initialise/probe device further */
				if(dev_descr[j].handler)
 8003d96:	699b      	ldr	r3, [r3, #24]
		for(j = 0; dev_descr[j].idcode; j++)
			if((jtag_devs[i].idcode & dev_descr[j].idmask) ==
			   dev_descr[j].idcode) {
				jtag_devs[i].current_ir = -1;
				/* Save description in table */
				jtag_devs[i].descr = dev_descr[j].descr;
 8003d98:	606a      	str	r2, [r5, #4]
				/* Call handler to initialise/probe device further */
				if(dev_descr[j].handler)
 8003d9a:	2b00      	cmp	r3, #0
 8003d9c:	d005      	beq.n	8003daa <jtag_scan+0x292>
 8003d9e:	1c28      	adds	r0, r5, #0
 8003da0:	3808      	subs	r0, #8
					dev_descr[j].handler(&jtag_devs[i]);
 8003da2:	4798      	blx	r3
 8003da4:	e001      	b.n	8003daa <jtag_scan+0x292>
	jtagtap_next(1, 1);
	jtagtap_return_idle();

	/* Check for known devices and handle accordingly */
	for(i = 0; i < jtag_dev_count; i++)
		for(j = 0; dev_descr[j].idcode; j++)
 8003da6:	3101      	adds	r1, #1
 8003da8:	e7e3      	b.n	8003d72 <jtag_scan+0x25a>
	DEBUG("Return to Run-Test/Idle\n");
	jtagtap_next(1, 1);
	jtagtap_return_idle();

	/* Check for known devices and handle accordingly */
	for(i = 0; i < jtag_dev_count; i++)
 8003daa:	3401      	adds	r4, #1
 8003dac:	3514      	adds	r5, #20
 8003dae:	e7dc      	b.n	8003d6a <jtag_scan+0x252>
					dev_descr[j].handler(&jtag_devs[i]);
				break;
			}

	return jtag_dev_count;
}
 8003db0:	b007      	add	sp, #28
 8003db2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003db4:	20001dcc 	.word	0x20001dcc
 8003db8:	20001dc8 	.word	0x20001dc8
 8003dbc:	08012078 	.word	0x08012078
 8003dc0:	08012086 	.word	0x08012086
 8003dc4:	080120af 	.word	0x080120af
 8003dc8:	08011f5c 	.word	0x08011f5c
 8003dcc:	080120c8 	.word	0x080120c8
 8003dd0:	080120e1 	.word	0x080120e1
 8003dd4:	080120f2 	.word	0x080120f2
 8003dd8:	08012129 	.word	0x08012129
 8003ddc:	08012152 	.word	0x08012152
 8003de0:	08012178 	.word	0x08012178
 8003de4:	08012190 	.word	0x08012190
 8003de8:	080121a9 	.word	0x080121a9
 8003dec:	20001dd4 	.word	0x20001dd4

08003df0 <jtag_dev_write_ir>:

void jtag_dev_write_ir(jtag_dev_t *d, uint32_t ir)
{
 8003df0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if(ir == d->current_ir) return;
 8003df2:	6903      	ldr	r3, [r0, #16]

	return jtag_dev_count;
}

void jtag_dev_write_ir(jtag_dev_t *d, uint32_t ir)
{
 8003df4:	9101      	str	r1, [sp, #4]
	if(ir == d->current_ir) return;
 8003df6:	4299      	cmp	r1, r3
 8003df8:	d02a      	beq.n	8003e50 <jtag_dev_write_ir+0x60>
	for(int i = 0; i < jtag_dev_count; i++)
 8003dfa:	4b16      	ldr	r3, [pc, #88]	; (8003e54 <jtag_dev_write_ir+0x64>)
 8003dfc:	681c      	ldr	r4, [r3, #0]
 8003dfe:	2300      	movs	r3, #0
 8003e00:	42a3      	cmp	r3, r4
 8003e02:	da08      	bge.n	8003e16 <jtag_dev_write_ir+0x26>
 8003e04:	2214      	movs	r2, #20
 8003e06:	435a      	muls	r2, r3
 8003e08:	4d13      	ldr	r5, [pc, #76]	; (8003e58 <jtag_dev_write_ir+0x68>)
 8003e0a:	3301      	adds	r3, #1
 8003e0c:	1952      	adds	r2, r2, r5
		jtag_devs[i].current_ir = -1;
 8003e0e:	2501      	movs	r5, #1
 8003e10:	426d      	negs	r5, r5
 8003e12:	6115      	str	r5, [r2, #16]
 8003e14:	e7f4      	b.n	8003e00 <jtag_dev_write_ir+0x10>
 8003e16:	1c04      	adds	r4, r0, #0
	d->current_ir = ir;
 8003e18:	6101      	str	r1, [r0, #16]

	jtagtap_shift_ir();
 8003e1a:	2003      	movs	r0, #3
 8003e1c:	2104      	movs	r1, #4
 8003e1e:	f000 f883 	bl	8003f28 <jtagtap_tms_seq>
	jtagtap_tdi_seq(0, ones, d->ir_prescan);
 8003e22:	4d0e      	ldr	r5, [pc, #56]	; (8003e5c <jtag_dev_write_ir+0x6c>)
 8003e24:	78e2      	ldrb	r2, [r4, #3]
 8003e26:	2000      	movs	r0, #0
 8003e28:	1c29      	adds	r1, r5, #0
 8003e2a:	f000 f8ad 	bl	8003f88 <jtagtap_tdi_seq>
	jtagtap_tdi_seq(d->ir_postscan?0:1, (void*)&ir, d->ir_len);
 8003e2e:	7923      	ldrb	r3, [r4, #4]
 8003e30:	78a2      	ldrb	r2, [r4, #2]
 8003e32:	4258      	negs	r0, r3
 8003e34:	4158      	adcs	r0, r3
 8003e36:	a901      	add	r1, sp, #4
 8003e38:	b2c0      	uxtb	r0, r0
 8003e3a:	f000 f8a5 	bl	8003f88 <jtagtap_tdi_seq>
	jtagtap_tdi_seq(1, ones, d->ir_postscan);
 8003e3e:	2001      	movs	r0, #1
 8003e40:	1c29      	adds	r1, r5, #0
 8003e42:	7922      	ldrb	r2, [r4, #4]
 8003e44:	f000 f8a0 	bl	8003f88 <jtagtap_tdi_seq>
	jtagtap_return_idle();
 8003e48:	2001      	movs	r0, #1
 8003e4a:	2102      	movs	r1, #2
 8003e4c:	f000 f86c 	bl	8003f28 <jtagtap_tms_seq>
}
 8003e50:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 8003e52:	46c0      	nop			; (mov r8, r8)
 8003e54:	20001dc8 	.word	0x20001dc8
 8003e58:	20001dcc 	.word	0x20001dcc
 8003e5c:	08011f5c 	.word	0x08011f5c

08003e60 <jtag_dev_shift_dr>:

void jtag_dev_shift_dr(jtag_dev_t *d, uint8_t *dout, const uint8_t *din, int ticks)
{
 8003e60:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003e62:	1c04      	adds	r4, r0, #0
 8003e64:	1c0f      	adds	r7, r1, #0
	jtagtap_shift_dr();
 8003e66:	2001      	movs	r0, #1
 8003e68:	2103      	movs	r1, #3
	jtagtap_tdi_seq(1, ones, d->ir_postscan);
	jtagtap_return_idle();
}

void jtag_dev_shift_dr(jtag_dev_t *d, uint8_t *dout, const uint8_t *din, int ticks)
{
 8003e6a:	1c1d      	adds	r5, r3, #0
 8003e6c:	1c16      	adds	r6, r2, #0
	jtagtap_shift_dr();
 8003e6e:	f000 f85b 	bl	8003f28 <jtagtap_tms_seq>
	jtagtap_tdi_seq(0, ones, d->dr_prescan);
 8003e72:	4912      	ldr	r1, [pc, #72]	; (8003ebc <jtag_dev_shift_dr+0x5c>)
 8003e74:	7822      	ldrb	r2, [r4, #0]
 8003e76:	2000      	movs	r0, #0
 8003e78:	f000 f886 	bl	8003f88 <jtagtap_tdi_seq>
 8003e7c:	4b0f      	ldr	r3, [pc, #60]	; (8003ebc <jtag_dev_shift_dr+0x5c>)
 8003e7e:	7861      	ldrb	r1, [r4, #1]
 8003e80:	9301      	str	r3, [sp, #4]
	if(dout)
 8003e82:	2f00      	cmp	r7, #0
 8003e84:	d008      	beq.n	8003e98 <jtag_dev_shift_dr+0x38>
		jtagtap_tdi_tdo_seq((void*)dout, d->dr_postscan?0:1, (void*)din, ticks);
 8003e86:	4248      	negs	r0, r1
 8003e88:	4141      	adcs	r1, r0
 8003e8a:	1c32      	adds	r2, r6, #0
 8003e8c:	b2c9      	uxtb	r1, r1
 8003e8e:	1c38      	adds	r0, r7, #0
 8003e90:	1c2b      	adds	r3, r5, #0
 8003e92:	f000 f857 	bl	8003f44 <jtagtap_tdi_tdo_seq>
 8003e96:	e006      	b.n	8003ea6 <jtag_dev_shift_dr+0x46>
	else
		jtagtap_tdi_seq(d->dr_postscan?0:1, (void*)din, ticks);
 8003e98:	4248      	negs	r0, r1
 8003e9a:	4148      	adcs	r0, r1
 8003e9c:	1c2a      	adds	r2, r5, #0
 8003e9e:	b2c0      	uxtb	r0, r0
 8003ea0:	1c31      	adds	r1, r6, #0
 8003ea2:	f000 f871 	bl	8003f88 <jtagtap_tdi_seq>
	jtagtap_tdi_seq(1, ones, d->dr_postscan);
 8003ea6:	7862      	ldrb	r2, [r4, #1]
 8003ea8:	9901      	ldr	r1, [sp, #4]
 8003eaa:	2001      	movs	r0, #1
 8003eac:	f000 f86c 	bl	8003f88 <jtagtap_tdi_seq>
	jtagtap_return_idle();
 8003eb0:	2001      	movs	r0, #1
 8003eb2:	2102      	movs	r1, #2
 8003eb4:	f000 f838 	bl	8003f28 <jtagtap_tms_seq>
}
 8003eb8:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003eba:	46c0      	nop			; (mov r8, r8)
 8003ebc:	08011f5c 	.word	0x08011f5c

08003ec0 <jtagtap_init>:
#include "jtagtap.h"
#include "gdb_packet.h"

int jtagtap_init(void)
{
	TMS_SET_MODE();
 8003ec0:	e7fe      	b.n	8003ec0 <jtagtap_init>

08003ec2 <jtagtap_reset>:

	return 0;
}

void jtagtap_reset(void)
{
 8003ec2:	b508      	push	{r3, lr}
		gpio_clear(TRST_PORT, TRST_PIN);
		for(i = 0; i < 10000; i++) asm("nop");
		gpio_set(TRST_PORT, TRST_PIN);
	}
#endif
	jtagtap_soft_reset();
 8003ec4:	201f      	movs	r0, #31
 8003ec6:	2106      	movs	r1, #6
 8003ec8:	f000 f82e 	bl	8003f28 <jtagtap_tms_seq>
}
 8003ecc:	bd08      	pop	{r3, pc}

08003ece <jtagtap_next>:

inline uint8_t jtagtap_next(uint8_t dTMS, uint8_t dTDI)
{
 8003ece:	b510      	push	{r4, lr}
 8003ed0:	1c0c      	adds	r4, r1, #0
	uint16_t ret;

	gpio_set_val(TMS_PORT, TMS_PIN, dTMS);
 8003ed2:	2800      	cmp	r0, #0
 8003ed4:	d005      	beq.n	8003ee2 <jtagtap_next+0x14>
 8003ed6:	2090      	movs	r0, #144	; 0x90
 8003ed8:	2101      	movs	r1, #1
 8003eda:	05c0      	lsls	r0, r0, #23
 8003edc:	f007 fbea 	bl	800b6b4 <gpio_set>
 8003ee0:	e004      	b.n	8003eec <jtagtap_next+0x1e>
 8003ee2:	2090      	movs	r0, #144	; 0x90
 8003ee4:	2101      	movs	r1, #1
 8003ee6:	05c0      	lsls	r0, r0, #23
 8003ee8:	f007 fbe6 	bl	800b6b8 <gpio_clear>
	gpio_set_val(TDI_PORT, TDI_PIN, dTDI);
 8003eec:	2090      	movs	r0, #144	; 0x90
 8003eee:	2101      	movs	r1, #1
 8003ef0:	05c0      	lsls	r0, r0, #23
 8003ef2:	2c00      	cmp	r4, #0
 8003ef4:	d002      	beq.n	8003efc <jtagtap_next+0x2e>
 8003ef6:	f007 fbdd 	bl	800b6b4 <gpio_set>
 8003efa:	e001      	b.n	8003f00 <jtagtap_next+0x32>
 8003efc:	f007 fbdc 	bl	800b6b8 <gpio_clear>
	gpio_set(TCK_PORT, TCK_PIN);
 8003f00:	2090      	movs	r0, #144	; 0x90
 8003f02:	2101      	movs	r1, #1
 8003f04:	05c0      	lsls	r0, r0, #23
 8003f06:	f007 fbd5 	bl	800b6b4 <gpio_set>
	ret = gpio_get(TDO_PORT, TDO_PIN);
 8003f0a:	2090      	movs	r0, #144	; 0x90
 8003f0c:	2101      	movs	r1, #1
 8003f0e:	05c0      	lsls	r0, r0, #23
 8003f10:	f007 fbd5 	bl	800b6be <gpio_get>
 8003f14:	1c04      	adds	r4, r0, #0
	gpio_clear(TCK_PORT, TCK_PIN);
 8003f16:	2090      	movs	r0, #144	; 0x90
 8003f18:	2101      	movs	r1, #1
 8003f1a:	05c0      	lsls	r0, r0, #23
 8003f1c:	f007 fbcc 	bl	800b6b8 <gpio_clear>

	//DEBUG("jtagtap_next(TMS = %d, TDI = %d) = %d\n", dTMS, dTDI, ret);

	return ret != 0;
 8003f20:	1e60      	subs	r0, r4, #1
 8003f22:	4184      	sbcs	r4, r0
 8003f24:	b2e0      	uxtb	r0, r4
}
 8003f26:	bd10      	pop	{r4, pc}

08003f28 <jtagtap_tms_seq>:
#include "general.h"
#include "jtagtap.h"

void __attribute__((weak))
jtagtap_tms_seq(uint32_t MS, int ticks)
{
 8003f28:	b538      	push	{r3, r4, r5, lr}
 8003f2a:	1c05      	adds	r5, r0, #0
 8003f2c:	1c0c      	adds	r4, r1, #0
	while(ticks--) {
 8003f2e:	2c00      	cmp	r4, #0
 8003f30:	d007      	beq.n	8003f42 <jtagtap_tms_seq+0x1a>
		jtagtap_next(MS & 1, 1);
 8003f32:	2101      	movs	r1, #1
 8003f34:	1c28      	adds	r0, r5, #0
 8003f36:	4008      	ands	r0, r1
 8003f38:	f7ff ffc9 	bl	8003ece <jtagtap_next>
		MS >>= 1;
 8003f3c:	086d      	lsrs	r5, r5, #1
 8003f3e:	3c01      	subs	r4, #1
 8003f40:	e7f5      	b.n	8003f2e <jtagtap_tms_seq+0x6>
	}
}
 8003f42:	bd38      	pop	{r3, r4, r5, pc}

08003f44 <jtagtap_tdi_tdo_seq>:

void __attribute__((weak))
jtagtap_tdi_tdo_seq(uint8_t *DO, const uint8_t final_tms, const uint8_t *DI, int ticks)
{
 8003f44:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003f46:	1c06      	adds	r6, r0, #0
 8003f48:	1c17      	adds	r7, r2, #0
	uint8_t index = 1;
 8003f4a:	2401      	movs	r4, #1
	}
}

void __attribute__((weak))
jtagtap_tdi_tdo_seq(uint8_t *DO, const uint8_t final_tms, const uint8_t *DI, int ticks)
{
 8003f4c:	9101      	str	r1, [sp, #4]
 8003f4e:	1e5d      	subs	r5, r3, #1
	uint8_t index = 1;
	while(ticks--) {
 8003f50:	1c6b      	adds	r3, r5, #1
 8003f52:	d018      	beq.n	8003f86 <jtagtap_tdi_tdo_seq+0x42>
		if(jtagtap_next(ticks?0:final_tms, *DI & index)) {
 8003f54:	426b      	negs	r3, r5
 8003f56:	416b      	adcs	r3, r5
 8003f58:	9801      	ldr	r0, [sp, #4]
 8003f5a:	7839      	ldrb	r1, [r7, #0]
 8003f5c:	425b      	negs	r3, r3
 8003f5e:	4018      	ands	r0, r3
 8003f60:	4021      	ands	r1, r4
 8003f62:	f7ff ffb4 	bl	8003ece <jtagtap_next>
 8003f66:	7833      	ldrb	r3, [r6, #0]
 8003f68:	2800      	cmp	r0, #0
 8003f6a:	d001      	beq.n	8003f70 <jtagtap_tdi_tdo_seq+0x2c>
			*DO |= index;
 8003f6c:	4323      	orrs	r3, r4
 8003f6e:	e000      	b.n	8003f72 <jtagtap_tdi_tdo_seq+0x2e>
		} else {
			*DO &= ~index;
 8003f70:	43a3      	bics	r3, r4
		}
		if(!(index <<= 1)) {
 8003f72:	0064      	lsls	r4, r4, #1
 8003f74:	b2e4      	uxtb	r4, r4
	uint8_t index = 1;
	while(ticks--) {
		if(jtagtap_next(ticks?0:final_tms, *DI & index)) {
			*DO |= index;
		} else {
			*DO &= ~index;
 8003f76:	7033      	strb	r3, [r6, #0]
		}
		if(!(index <<= 1)) {
 8003f78:	2c00      	cmp	r4, #0
 8003f7a:	d102      	bne.n	8003f82 <jtagtap_tdi_tdo_seq+0x3e>
			index = 1;
			DI++; DO++;
 8003f7c:	3701      	adds	r7, #1
 8003f7e:	3601      	adds	r6, #1
			*DO |= index;
		} else {
			*DO &= ~index;
		}
		if(!(index <<= 1)) {
			index = 1;
 8003f80:	3401      	adds	r4, #1
 8003f82:	3d01      	subs	r5, #1
 8003f84:	e7e4      	b.n	8003f50 <jtagtap_tdi_tdo_seq+0xc>
			DI++; DO++;
		}
	}
}
 8003f86:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003f88 <jtagtap_tdi_seq>:

void __attribute__((weak))
jtagtap_tdi_seq(const uint8_t final_tms, const uint8_t *DI, int ticks)
{
 8003f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003f8a:	1c07      	adds	r7, r0, #0
 8003f8c:	1c0e      	adds	r6, r1, #0
	uint8_t index = 1;
 8003f8e:	2401      	movs	r4, #1
 8003f90:	1e55      	subs	r5, r2, #1
	while(ticks--) {
 8003f92:	1c6b      	adds	r3, r5, #1
 8003f94:	d010      	beq.n	8003fb8 <jtagtap_tdi_seq+0x30>
		jtagtap_next(ticks?0:final_tms, *DI & index);
 8003f96:	426b      	negs	r3, r5
 8003f98:	416b      	adcs	r3, r5
 8003f9a:	1c38      	adds	r0, r7, #0
 8003f9c:	7831      	ldrb	r1, [r6, #0]
 8003f9e:	425b      	negs	r3, r3
 8003fa0:	4021      	ands	r1, r4
		if(!(index <<= 1)) {
 8003fa2:	0064      	lsls	r4, r4, #1
void __attribute__((weak))
jtagtap_tdi_seq(const uint8_t final_tms, const uint8_t *DI, int ticks)
{
	uint8_t index = 1;
	while(ticks--) {
		jtagtap_next(ticks?0:final_tms, *DI & index);
 8003fa4:	4018      	ands	r0, r3
		if(!(index <<= 1)) {
 8003fa6:	b2e4      	uxtb	r4, r4
void __attribute__((weak))
jtagtap_tdi_seq(const uint8_t final_tms, const uint8_t *DI, int ticks)
{
	uint8_t index = 1;
	while(ticks--) {
		jtagtap_next(ticks?0:final_tms, *DI & index);
 8003fa8:	f7ff ff91 	bl	8003ece <jtagtap_next>
		if(!(index <<= 1)) {
 8003fac:	2c00      	cmp	r4, #0
 8003fae:	d101      	bne.n	8003fb4 <jtagtap_tdi_seq+0x2c>
			index = 1;
			DI++;
 8003fb0:	3601      	adds	r6, #1
{
	uint8_t index = 1;
	while(ticks--) {
		jtagtap_next(ticks?0:final_tms, *DI & index);
		if(!(index <<= 1)) {
			index = 1;
 8003fb2:	3401      	adds	r4, #1
 8003fb4:	3d01      	subs	r5, #1
 8003fb6:	e7ec      	b.n	8003f92 <jtagtap_tdi_seq+0xa>
			DI++;
		}
	}
}
 8003fb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08003fbc <lmi_add_flash>:
static const uint16_t lmi_flash_write_stub[] = {
#include "flashstub/lmi.stub"
};

static void lmi_add_flash(target *t, size_t length)
{
 8003fbc:	b538      	push	{r3, r4, r5, lr}
 8003fbe:	1c0d      	adds	r5, r1, #0
 8003fc0:	1c04      	adds	r4, r0, #0
	struct target_flash *f = calloc(1, sizeof(*f));
 8003fc2:	2138      	movs	r1, #56	; 0x38
 8003fc4:	2001      	movs	r0, #1
 8003fc6:	f008 fc57 	bl	800c878 <calloc>
	f->start = 0;
 8003fca:	2300      	movs	r3, #0
 8003fcc:	6003      	str	r3, [r0, #0]
	f->length = length;
	f->blocksize = 0x400;
 8003fce:	2380      	movs	r3, #128	; 0x80
 8003fd0:	00db      	lsls	r3, r3, #3
 8003fd2:	6083      	str	r3, [r0, #8]
	f->erase = lmi_flash_erase;
 8003fd4:	4b07      	ldr	r3, [pc, #28]	; (8003ff4 <lmi_add_flash+0x38>)
	f->write = lmi_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8003fd6:	22ff      	movs	r2, #255	; 0xff
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = 0;
	f->length = length;
	f->blocksize = 0x400;
	f->erase = lmi_flash_erase;
 8003fd8:	60c3      	str	r3, [r0, #12]
	f->write = lmi_flash_write;
 8003fda:	4b07      	ldr	r3, [pc, #28]	; (8003ff8 <lmi_add_flash+0x3c>)

static void lmi_add_flash(target *t, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = 0;
	f->length = length;
 8003fdc:	6045      	str	r5, [r0, #4]
	f->blocksize = 0x400;
	f->erase = lmi_flash_erase;
	f->write = lmi_flash_write;
 8003fde:	6103      	str	r3, [r0, #16]
	f->align = 4;
 8003fe0:	2304      	movs	r3, #4
 8003fe2:	6203      	str	r3, [r0, #32]
	f->erased = 0xff;
 8003fe4:	1d43      	adds	r3, r0, #5
#include "flashstub/lmi.stub"
};

static void lmi_add_flash(target *t, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8003fe6:	1c01      	adds	r1, r0, #0
	f->length = length;
	f->blocksize = 0x400;
	f->erase = lmi_flash_erase;
	f->write = lmi_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8003fe8:	77da      	strb	r2, [r3, #31]
	target_add_flash(t, f);
 8003fea:	1c20      	adds	r0, r4, #0
 8003fec:	f004 f8af 	bl	800814e <target_add_flash>
}
 8003ff0:	bd38      	pop	{r3, r4, r5, pc}
 8003ff2:	46c0      	nop			; (mov r8, r8)
 8003ff4:	08004045 	.word	0x08004045
 8003ff8:	08003ffd 	.word	0x08003ffd

08003ffc <lmi_flash_write>:
	return 0;
}

int lmi_flash_write(struct target_flash *f,
                    target_addr dest, const void *src, size_t len)
{
 8003ffc:	b5f0      	push	{r4, r5, r6, r7, lr}
	target  *t = f->t;

	target_mem_write(t, SRAM_BASE, lmi_flash_write_stub,
 8003ffe:	2580      	movs	r5, #128	; 0x80
	return 0;
}

int lmi_flash_write(struct target_flash *f,
                    target_addr dest, const void *src, size_t len)
{
 8004000:	1c1e      	adds	r6, r3, #0
	target  *t = f->t;
 8004002:	6984      	ldr	r4, [r0, #24]
	return 0;
}

int lmi_flash_write(struct target_flash *f,
                    target_addr dest, const void *src, size_t len)
{
 8004004:	b085      	sub	sp, #20
	target  *t = f->t;

	target_mem_write(t, SRAM_BASE, lmi_flash_write_stub,
 8004006:	05ad      	lsls	r5, r5, #22
	                 sizeof(lmi_flash_write_stub));
	target_mem_write(t, STUB_BUFFER_BASE, src, len);
 8004008:	4f0c      	ldr	r7, [pc, #48]	; (800403c <lmi_flash_write+0x40>)
	return 0;
}

int lmi_flash_write(struct target_flash *f,
                    target_addr dest, const void *src, size_t len)
{
 800400a:	9102      	str	r1, [sp, #8]
 800400c:	9203      	str	r2, [sp, #12]
	target  *t = f->t;

	target_mem_write(t, SRAM_BASE, lmi_flash_write_stub,
 800400e:	1c29      	adds	r1, r5, #0
 8004010:	1c20      	adds	r0, r4, #0
 8004012:	4a0b      	ldr	r2, [pc, #44]	; (8004040 <lmi_flash_write+0x44>)
 8004014:	2340      	movs	r3, #64	; 0x40
 8004016:	f004 fa0d 	bl	8008434 <target_mem_write>
	                 sizeof(lmi_flash_write_stub));
	target_mem_write(t, STUB_BUFFER_BASE, src, len);
 800401a:	1c39      	adds	r1, r7, #0
 800401c:	9a03      	ldr	r2, [sp, #12]
 800401e:	1c33      	adds	r3, r6, #0
 8004020:	1c20      	adds	r0, r4, #0
 8004022:	f004 fa07 	bl	8008434 <target_mem_write>
	return cortexm_run_stub(t, SRAM_BASE, dest, STUB_BUFFER_BASE, len, 0);
 8004026:	2300      	movs	r3, #0
 8004028:	9600      	str	r6, [sp, #0]
 800402a:	9301      	str	r3, [sp, #4]
 800402c:	1c20      	adds	r0, r4, #0
 800402e:	1c29      	adds	r1, r5, #0
 8004030:	9a02      	ldr	r2, [sp, #8]
 8004032:	1c3b      	adds	r3, r7, #0
 8004034:	f7fe fa38 	bl	80024a8 <cortexm_run_stub>
}
 8004038:	b005      	add	sp, #20
 800403a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800403c:	20000040 	.word	0x20000040
 8004040:	080123ee 	.word	0x080123ee

08004044 <lmi_flash_erase>:
	}
	return false;
}

int lmi_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8004044:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004046:	1c0f      	adds	r7, r1, #0
 8004048:	1c16      	adds	r6, r2, #0
	target  *t = f->t;
	while(len) {
 800404a:	1c14      	adds	r4, r2, #0
	return false;
}

int lmi_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	target  *t = f->t;
 800404c:	6985      	ldr	r5, [r0, #24]
 800404e:	19ba      	adds	r2, r7, r6
 8004050:	1b12      	subs	r2, r2, r4
	while(len) {
 8004052:	2c00      	cmp	r4, #0
 8004054:	d011      	beq.n	800407a <lmi_flash_erase+0x36>
		target_mem_write32(t, LMI_FLASH_FMA, addr);
 8004056:	1c28      	adds	r0, r5, #0
 8004058:	4909      	ldr	r1, [pc, #36]	; (8004080 <lmi_flash_erase+0x3c>)
 800405a:	f004 fa6f 	bl	800853c <target_mem_write32>
		target_mem_write32(t, LMI_FLASH_FMC,
 800405e:	1c28      	adds	r0, r5, #0
 8004060:	4908      	ldr	r1, [pc, #32]	; (8004084 <lmi_flash_erase+0x40>)
 8004062:	4a09      	ldr	r2, [pc, #36]	; (8004088 <lmi_flash_erase+0x44>)
 8004064:	f004 fa6a 	bl	800853c <target_mem_write32>
		                   LMI_FLASH_FMC_WRKEY | LMI_FLASH_FMC_ERASE);
		while (target_mem_read32(t, LMI_FLASH_FMC) &
 8004068:	1c28      	adds	r0, r5, #0
 800406a:	4906      	ldr	r1, [pc, #24]	; (8004084 <lmi_flash_erase+0x40>)
 800406c:	f004 fa5e 	bl	800852c <target_mem_read32>
 8004070:	0783      	lsls	r3, r0, #30
 8004072:	d4f9      	bmi.n	8004068 <lmi_flash_erase+0x24>
		       LMI_FLASH_FMC_ERASE);

		len -= BLOCK_SIZE;
 8004074:	4b05      	ldr	r3, [pc, #20]	; (800408c <lmi_flash_erase+0x48>)
 8004076:	18e4      	adds	r4, r4, r3
 8004078:	e7e9      	b.n	800404e <lmi_flash_erase+0xa>
		addr += BLOCK_SIZE;
	}
	return 0;
}
 800407a:	1c20      	adds	r0, r4, #0
 800407c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800407e:	46c0      	nop			; (mov r8, r8)
 8004080:	400fd000 	.word	0x400fd000
 8004084:	400fd008 	.word	0x400fd008
 8004088:	a4420002 	.word	0xa4420002
 800408c:	fffffc00 	.word	0xfffffc00

08004090 <lmi_probe>:
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool lmi_probe(target *t)
{
 8004090:	b510      	push	{r4, lr}
	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
 8004092:	4916      	ldr	r1, [pc, #88]	; (80040ec <lmi_probe+0x5c>)
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool lmi_probe(target *t)
{
 8004094:	1c04      	adds	r4, r0, #0
	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
 8004096:	f004 fa49 	bl	800852c <target_mem_read32>
	switch (did1 >> 16) {
 800409a:	4b15      	ldr	r3, [pc, #84]	; (80040f0 <lmi_probe+0x60>)
 800409c:	0c00      	lsrs	r0, r0, #16
 800409e:	4298      	cmp	r0, r3
 80040a0:	d010      	beq.n	80040c4 <lmi_probe+0x34>
 80040a2:	4b14      	ldr	r3, [pc, #80]	; (80040f4 <lmi_probe+0x64>)
 80040a4:	4298      	cmp	r0, r3
 80040a6:	d11e      	bne.n	80040e6 <lmi_probe+0x56>
		lmi_add_flash(t, 0x40000);
		return true;

	case 0x10A1:	/* TM4C123GH6PM */
		t->driver = lmi_driver_str;
		target_add_ram(t, 0x20000000, 0x10000);
 80040a8:	2180      	movs	r1, #128	; 0x80
 80040aa:	2280      	movs	r2, #128	; 0x80
		target_add_ram(t, 0x20000000, 0x8000);
		lmi_add_flash(t, 0x40000);
		return true;

	case 0x10A1:	/* TM4C123GH6PM */
		t->driver = lmi_driver_str;
 80040ac:	4b12      	ldr	r3, [pc, #72]	; (80040f8 <lmi_probe+0x68>)
		target_add_ram(t, 0x20000000, 0x10000);
 80040ae:	1c20      	adds	r0, r4, #0
		target_add_ram(t, 0x20000000, 0x8000);
		lmi_add_flash(t, 0x40000);
		return true;

	case 0x10A1:	/* TM4C123GH6PM */
		t->driver = lmi_driver_str;
 80040b0:	3340      	adds	r3, #64	; 0x40
		target_add_ram(t, 0x20000000, 0x10000);
 80040b2:	0589      	lsls	r1, r1, #22
		target_add_ram(t, 0x20000000, 0x8000);
		lmi_add_flash(t, 0x40000);
		return true;

	case 0x10A1:	/* TM4C123GH6PM */
		t->driver = lmi_driver_str;
 80040b4:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x10000);
 80040b6:	0252      	lsls	r2, r2, #9
 80040b8:	f004 f83c 	bl	8008134 <target_add_ram>
		lmi_add_flash(t, 0x80000);
 80040bc:	2180      	movs	r1, #128	; 0x80
 80040be:	1c20      	adds	r0, r4, #0
 80040c0:	0309      	lsls	r1, r1, #12
 80040c2:	e00c      	b.n	80040de <lmi_probe+0x4e>
{
	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
	switch (did1 >> 16) {
	case 0x1049:	/* LM3S3748 */
		t->driver = lmi_driver_str;
		target_add_ram(t, 0x20000000, 0x8000);
 80040c4:	2180      	movs	r1, #128	; 0x80
 80040c6:	2280      	movs	r2, #128	; 0x80
bool lmi_probe(target *t)
{
	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
	switch (did1 >> 16) {
	case 0x1049:	/* LM3S3748 */
		t->driver = lmi_driver_str;
 80040c8:	4b0b      	ldr	r3, [pc, #44]	; (80040f8 <lmi_probe+0x68>)
		target_add_ram(t, 0x20000000, 0x8000);
 80040ca:	1c20      	adds	r0, r4, #0
bool lmi_probe(target *t)
{
	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
	switch (did1 >> 16) {
	case 0x1049:	/* LM3S3748 */
		t->driver = lmi_driver_str;
 80040cc:	3340      	adds	r3, #64	; 0x40
		target_add_ram(t, 0x20000000, 0x8000);
 80040ce:	0589      	lsls	r1, r1, #22
bool lmi_probe(target *t)
{
	uint32_t did1 = target_mem_read32(t, LMI_SCB_DID1);
	switch (did1 >> 16) {
	case 0x1049:	/* LM3S3748 */
		t->driver = lmi_driver_str;
 80040d0:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x8000);
 80040d2:	0212      	lsls	r2, r2, #8
 80040d4:	f004 f82e 	bl	8008134 <target_add_ram>
		lmi_add_flash(t, 0x40000);
 80040d8:	2180      	movs	r1, #128	; 0x80
 80040da:	1c20      	adds	r0, r4, #0
 80040dc:	02c9      	lsls	r1, r1, #11
		return true;

	case 0x10A1:	/* TM4C123GH6PM */
		t->driver = lmi_driver_str;
		target_add_ram(t, 0x20000000, 0x10000);
		lmi_add_flash(t, 0x80000);
 80040de:	f7ff ff6d 	bl	8003fbc <lmi_add_flash>
		return true;
 80040e2:	2001      	movs	r0, #1
 80040e4:	e000      	b.n	80040e8 <lmi_probe+0x58>
	}
	return false;
 80040e6:	2000      	movs	r0, #0
}
 80040e8:	bd10      	pop	{r4, pc}
 80040ea:	46c0      	nop			; (mov r8, r8)
 80040ec:	400fe004 	.word	0x400fe004
 80040f0:	00001049 	.word	0x00001049
 80040f4:	000010a1 	.word	0x000010a1
 80040f8:	080123ee 	.word	0x080123ee

080040fc <lpc_add_flash>:
	uint32_t result;
} __attribute__((aligned(4)));


struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length)
{
 80040fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80040fe:	1c05      	adds	r5, r0, #0
 8004100:	1c0f      	adds	r7, r1, #0
	struct lpc_flash *lf = calloc(1, sizeof(*lf));
 8004102:	2001      	movs	r0, #1
 8004104:	214c      	movs	r1, #76	; 0x4c
	uint32_t result;
} __attribute__((aligned(4)));


struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length)
{
 8004106:	1c16      	adds	r6, r2, #0
	struct lpc_flash *lf = calloc(1, sizeof(*lf));
 8004108:	f008 fbb6 	bl	800c878 <calloc>
	f->length = length;
	f->erase = lpc_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = lpc_flash_write;
	f->erased = 0xff;
 800410c:	22ff      	movs	r2, #255	; 0xff
} __attribute__((aligned(4)));


struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length)
{
	struct lpc_flash *lf = calloc(1, sizeof(*lf));
 800410e:	1c04      	adds	r4, r0, #0
	struct target_flash *f = &lf->f;
	f->start = addr;
	f->length = length;
	f->erase = lpc_flash_erase;
 8004110:	4b08      	ldr	r3, [pc, #32]	; (8004134 <lpc_add_flash+0x38>)

struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length)
{
	struct lpc_flash *lf = calloc(1, sizeof(*lf));
	struct target_flash *f = &lf->f;
	f->start = addr;
 8004112:	6007      	str	r7, [r0, #0]
	f->length = length;
	f->erase = lpc_flash_erase;
 8004114:	60c3      	str	r3, [r0, #12]
	f->write = target_flash_write_buffered;
 8004116:	4b08      	ldr	r3, [pc, #32]	; (8004138 <lpc_add_flash+0x3c>)
struct lpc_flash *lpc_add_flash(target *t, target_addr addr, size_t length)
{
	struct lpc_flash *lf = calloc(1, sizeof(*lf));
	struct target_flash *f = &lf->f;
	f->start = addr;
	f->length = length;
 8004118:	6046      	str	r6, [r0, #4]
	f->erase = lpc_flash_erase;
	f->write = target_flash_write_buffered;
 800411a:	6103      	str	r3, [r0, #16]
	f->done = target_flash_done_buffered;
 800411c:	4b07      	ldr	r3, [pc, #28]	; (800413c <lpc_add_flash+0x40>)
	f->write_buf = lpc_flash_write;
	f->erased = 0xff;
	target_add_flash(t, f);
 800411e:	1c21      	adds	r1, r4, #0
	struct target_flash *f = &lf->f;
	f->start = addr;
	f->length = length;
	f->erase = lpc_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 8004120:	6143      	str	r3, [r0, #20]
	f->write_buf = lpc_flash_write;
 8004122:	4b07      	ldr	r3, [pc, #28]	; (8004140 <lpc_add_flash+0x44>)
 8004124:	62c3      	str	r3, [r0, #44]	; 0x2c
	f->erased = 0xff;
 8004126:	1d43      	adds	r3, r0, #5
 8004128:	77da      	strb	r2, [r3, #31]
	target_add_flash(t, f);
 800412a:	1c28      	adds	r0, r5, #0
 800412c:	f004 f80f 	bl	800814e <target_add_flash>
	return lf;
}
 8004130:	1c20      	adds	r0, r4, #0
 8004132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004134:	08004201 	.word	0x08004201
 8004138:	0800834b 	.word	0x0800834b
 800413c:	080083dd 	.word	0x080083dd
 8004140:	08004295 	.word	0x08004295

08004144 <lpc_iap_call>:

enum iap_status lpc_iap_call(struct lpc_flash *f, enum iap_cmd cmd, ...)
{
 8004144:	b40e      	push	{r1, r2, r3}
 8004146:	2334      	movs	r3, #52	; 0x34
 8004148:	b5f0      	push	{r4, r5, r6, r7, lr}
 800414a:	1c05      	adds	r5, r0, #0
 800414c:	b088      	sub	sp, #32
 800414e:	af00      	add	r7, sp, #0
 8004150:	18fb      	adds	r3, r7, r3
	target *t = f->f.t;
 8004152:	6984      	ldr	r4, [r0, #24]
	struct flash_param param = {
 8004154:	2100      	movs	r1, #0
 8004156:	1d38      	adds	r0, r7, #4
 8004158:	221c      	movs	r2, #28
	target_add_flash(t, f);
	return lf;
}

enum iap_status lpc_iap_call(struct lpc_flash *f, enum iap_cmd cmd, ...)
{
 800415a:	781e      	ldrb	r6, [r3, #0]
	target *t = f->f.t;
	struct flash_param param = {
 800415c:	f008 fbc9 	bl	800c8f2 <memset>
 8004160:	4b26      	ldr	r3, [pc, #152]	; (80041fc <lpc_iap_call+0xb8>)
 8004162:	60be      	str	r6, [r7, #8]
 8004164:	80bb      	strh	r3, [r7, #4]
		.opcode = ARM_THUMB_BREAKPOINT,
		.command = cmd,
	};

	/* Pet WDT before each IAP call, if it is on */
	if (f->wdt_kick)
 8004166:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8004168:	2b00      	cmp	r3, #0
 800416a:	d001      	beq.n	8004170 <lpc_iap_call+0x2c>
		f->wdt_kick(t);
 800416c:	1c20      	adds	r0, r4, #0
 800416e:	4798      	blx	r3

	/* fill out the remainder of the parameters */
	va_list ap;
	va_start(ap, cmd);
 8004170:	2338      	movs	r3, #56	; 0x38
 8004172:	18fa      	adds	r2, r7, r3
 8004174:	2300      	movs	r3, #0
 8004176:	603a      	str	r2, [r7, #0]
	for (int i = 0; i < 4; i++)
		param.words[i] = va_arg(ap, uint32_t);
 8004178:	58d0      	ldr	r0, [r2, r3]
 800417a:	1d39      	adds	r1, r7, #4
 800417c:	18c9      	adds	r1, r1, r3
 800417e:	3304      	adds	r3, #4
 8004180:	6088      	str	r0, [r1, #8]
		f->wdt_kick(t);

	/* fill out the remainder of the parameters */
	va_list ap;
	va_start(ap, cmd);
	for (int i = 0; i < 4; i++)
 8004182:	2b10      	cmp	r3, #16
 8004184:	d1f8      	bne.n	8004178 <lpc_iap_call+0x34>
		param.words[i] = va_arg(ap, uint32_t);
	va_end(ap);

	/* copy the structure to RAM */
	target_mem_write(t, f->iap_ram, &param, sizeof(param));
 8004186:	6c69      	ldr	r1, [r5, #68]	; 0x44
 8004188:	1d3a      	adds	r2, r7, #4
 800418a:	330c      	adds	r3, #12
 800418c:	1c20      	adds	r0, r4, #0
 800418e:	f004 f951 	bl	8008434 <target_mem_write>

	/* set up for the call to the IAP ROM */
	uint32_t regs[t->regs_size / sizeof(uint32_t)];
 8004192:	466a      	mov	r2, sp
 8004194:	69e3      	ldr	r3, [r4, #28]
	target_regs_read(t, regs);
 8004196:	1c20      	adds	r0, r4, #0

	/* copy the structure to RAM */
	target_mem_write(t, f->iap_ram, &param, sizeof(param));

	/* set up for the call to the IAP ROM */
	uint32_t regs[t->regs_size / sizeof(uint32_t)];
 8004198:	089b      	lsrs	r3, r3, #2
 800419a:	009b      	lsls	r3, r3, #2
 800419c:	330a      	adds	r3, #10
 800419e:	08db      	lsrs	r3, r3, #3
 80041a0:	00db      	lsls	r3, r3, #3
 80041a2:	1ad3      	subs	r3, r2, r3
 80041a4:	469d      	mov	sp, r3
	target_regs_read(t, regs);
 80041a6:	4669      	mov	r1, sp
 80041a8:	f004 f94c 	bl	8008444 <target_regs_read>
	regs[0] = f->iap_ram + offsetof(struct flash_param, command);
 80041ac:	6c6b      	ldr	r3, [r5, #68]	; 0x44
	regs[1] = f->iap_ram + offsetof(struct flash_param, result);
	regs[REG_MSP] = f->iap_msp;
	regs[REG_LR] = f->iap_ram | 1;
	regs[REG_PC] = f->iap_entry;
	target_regs_write(t, regs);
 80041ae:	1c20      	adds	r0, r4, #0
	target_mem_write(t, f->iap_ram, &param, sizeof(param));

	/* set up for the call to the IAP ROM */
	uint32_t regs[t->regs_size / sizeof(uint32_t)];
	target_regs_read(t, regs);
	regs[0] = f->iap_ram + offsetof(struct flash_param, command);
 80041b0:	1d1a      	adds	r2, r3, #4
 80041b2:	9200      	str	r2, [sp, #0]
	regs[1] = f->iap_ram + offsetof(struct flash_param, result);
 80041b4:	3214      	adds	r2, #20
 80041b6:	9201      	str	r2, [sp, #4]
	regs[REG_MSP] = f->iap_msp;
 80041b8:	6caa      	ldr	r2, [r5, #72]	; 0x48
	regs[REG_LR] = f->iap_ram | 1;
	regs[REG_PC] = f->iap_entry;
	target_regs_write(t, regs);
 80041ba:	4669      	mov	r1, sp
	/* set up for the call to the IAP ROM */
	uint32_t regs[t->regs_size / sizeof(uint32_t)];
	target_regs_read(t, regs);
	regs[0] = f->iap_ram + offsetof(struct flash_param, command);
	regs[1] = f->iap_ram + offsetof(struct flash_param, result);
	regs[REG_MSP] = f->iap_msp;
 80041bc:	9211      	str	r2, [sp, #68]	; 0x44
	regs[REG_LR] = f->iap_ram | 1;
 80041be:	2201      	movs	r2, #1
 80041c0:	4313      	orrs	r3, r2
 80041c2:	930e      	str	r3, [sp, #56]	; 0x38
	regs[REG_PC] = f->iap_entry;
 80041c4:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80041c6:	930f      	str	r3, [sp, #60]	; 0x3c
	target_regs_write(t, regs);
 80041c8:	f004 f940 	bl	800844c <target_regs_write>

	/* start the target and wait for it to halt again */
	target_halt_resume(t, false);
 80041cc:	1c20      	adds	r0, r4, #0
 80041ce:	2100      	movs	r1, #0
 80041d0:	f004 f94c 	bl	800846c <target_halt_resume>
	while (!target_halt_poll(t, NULL));
 80041d4:	1c20      	adds	r0, r4, #0
 80041d6:	2100      	movs	r1, #0
 80041d8:	f004 f944 	bl	8008464 <target_halt_poll>
 80041dc:	2800      	cmp	r0, #0
 80041de:	d0f9      	beq.n	80041d4 <lpc_iap_call+0x90>

	/* copy back just the parameters structure */
	target_mem_read(t, &param, f->iap_ram, sizeof(param));
 80041e0:	1c20      	adds	r0, r4, #0
 80041e2:	1d39      	adds	r1, r7, #4
 80041e4:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80041e6:	231c      	movs	r3, #28
 80041e8:	f004 f91c 	bl	8008424 <target_mem_read>
	return param.result;
}
 80041ec:	46bd      	mov	sp, r7
	target_halt_resume(t, false);
	while (!target_halt_poll(t, NULL));

	/* copy back just the parameters structure */
	target_mem_read(t, &param, f->iap_ram, sizeof(param));
	return param.result;
 80041ee:	69f8      	ldr	r0, [r7, #28]
 80041f0:	b2c0      	uxtb	r0, r0
}
 80041f2:	b008      	add	sp, #32
 80041f4:	bcf0      	pop	{r4, r5, r6, r7}
 80041f6:	bc08      	pop	{r3}
 80041f8:	b003      	add	sp, #12
 80041fa:	4718      	bx	r3
 80041fc:	ffffbe00 	.word	0xffffbe00

08004200 <lpc_flash_erase>:

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 8004200:	1c03      	adds	r3, r0, #0
}

int lpc_flash_erase(struct target_flash *tf, target_addr addr, size_t len)
{
 8004202:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004204:	b087      	sub	sp, #28
 8004206:	9205      	str	r2, [sp, #20]
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 8004208:	3338      	adds	r3, #56	; 0x38
 800420a:	781b      	ldrb	r3, [r3, #0]
 800420c:	6887      	ldr	r7, [r0, #8]
 800420e:	9303      	str	r3, [sp, #12]
 8004210:	6803      	ldr	r3, [r0, #0]
}

int lpc_flash_erase(struct target_flash *tf, target_addr addr, size_t len)
{
 8004212:	1c05      	adds	r5, r0, #0
 8004214:	1c0e      	adds	r6, r1, #0
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 8004216:	1ac8      	subs	r0, r1, r3
 8004218:	1c39      	adds	r1, r7, #0
 800421a:	9304      	str	r3, [sp, #16]
 800421c:	f00a fbb8 	bl	800e990 <__aeabi_uidiv>
 8004220:	9b03      	ldr	r3, [sp, #12]
 8004222:	1c39      	adds	r1, r7, #0
 8004224:	181c      	adds	r4, r3, r0
 8004226:	9b04      	ldr	r3, [sp, #16]
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	uint32_t start = lpc_sector_for_addr(f, addr);
	uint32_t end = lpc_sector_for_addr(f, addr + len - 1);

	if (lpc_iap_call(f, IAP_CMD_PREPARE, start, end, f->bank))
 8004228:	1c2f      	adds	r7, r5, #0
 800422a:	43d8      	mvns	r0, r3
 800422c:	9b05      	ldr	r3, [sp, #20]
 800422e:	3739      	adds	r7, #57	; 0x39
 8004230:	18c0      	adds	r0, r0, r3
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 8004232:	1980      	adds	r0, r0, r6
 8004234:	f00a fbac 	bl	800e990 <__aeabi_uidiv>
 8004238:	9b03      	ldr	r3, [sp, #12]
}

int lpc_flash_erase(struct target_flash *tf, target_addr addr, size_t len)
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	uint32_t start = lpc_sector_for_addr(f, addr);
 800423a:	b2e4      	uxtb	r4, r4
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 800423c:	181e      	adds	r6, r3, r0
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	uint32_t start = lpc_sector_for_addr(f, addr);
	uint32_t end = lpc_sector_for_addr(f, addr + len - 1);

	if (lpc_iap_call(f, IAP_CMD_PREPARE, start, end, f->bank))
 800423e:	783b      	ldrb	r3, [r7, #0]

int lpc_flash_erase(struct target_flash *tf, target_addr addr, size_t len)
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	uint32_t start = lpc_sector_for_addr(f, addr);
	uint32_t end = lpc_sector_for_addr(f, addr + len - 1);
 8004240:	b2f6      	uxtb	r6, r6

	if (lpc_iap_call(f, IAP_CMD_PREPARE, start, end, f->bank))
 8004242:	9300      	str	r3, [sp, #0]
 8004244:	1c28      	adds	r0, r5, #0
 8004246:	2132      	movs	r1, #50	; 0x32
 8004248:	1c22      	adds	r2, r4, #0
 800424a:	1c33      	adds	r3, r6, #0
 800424c:	f7ff ff7a 	bl	8004144 <lpc_iap_call>
 8004250:	2800      	cmp	r0, #0
 8004252:	d117      	bne.n	8004284 <lpc_flash_erase+0x84>
		return -1;

	/* and now erase them */
	if (lpc_iap_call(f, IAP_CMD_ERASE, start, end, CPU_CLK_KHZ, f->bank))
 8004254:	4b0e      	ldr	r3, [pc, #56]	; (8004290 <lpc_flash_erase+0x90>)
 8004256:	1c28      	adds	r0, r5, #0
 8004258:	9300      	str	r3, [sp, #0]
 800425a:	783b      	ldrb	r3, [r7, #0]
 800425c:	2134      	movs	r1, #52	; 0x34
 800425e:	9301      	str	r3, [sp, #4]
 8004260:	1c22      	adds	r2, r4, #0
 8004262:	1c33      	adds	r3, r6, #0
 8004264:	f7ff ff6e 	bl	8004144 <lpc_iap_call>
 8004268:	2800      	cmp	r0, #0
 800426a:	d10d      	bne.n	8004288 <lpc_flash_erase+0x88>
		return -2;

	/* check erase ok */
	if (lpc_iap_call(f, IAP_CMD_BLANKCHECK, start, end, f->bank))
 800426c:	783b      	ldrb	r3, [r7, #0]
 800426e:	1c28      	adds	r0, r5, #0
 8004270:	9300      	str	r3, [sp, #0]
 8004272:	2135      	movs	r1, #53	; 0x35
 8004274:	1c22      	adds	r2, r4, #0
 8004276:	1c33      	adds	r3, r6, #0
 8004278:	f7ff ff64 	bl	8004144 <lpc_iap_call>
 800427c:	2800      	cmp	r0, #0
 800427e:	d005      	beq.n	800428c <lpc_flash_erase+0x8c>
		return -3;
 8004280:	2003      	movs	r0, #3
 8004282:	e002      	b.n	800428a <lpc_flash_erase+0x8a>
	struct lpc_flash *f = (struct lpc_flash *)tf;
	uint32_t start = lpc_sector_for_addr(f, addr);
	uint32_t end = lpc_sector_for_addr(f, addr + len - 1);

	if (lpc_iap_call(f, IAP_CMD_PREPARE, start, end, f->bank))
		return -1;
 8004284:	2001      	movs	r0, #1
 8004286:	e000      	b.n	800428a <lpc_flash_erase+0x8a>

	/* and now erase them */
	if (lpc_iap_call(f, IAP_CMD_ERASE, start, end, CPU_CLK_KHZ, f->bank))
		return -2;
 8004288:	2002      	movs	r0, #2

	/* check erase ok */
	if (lpc_iap_call(f, IAP_CMD_BLANKCHECK, start, end, f->bank))
		return -3;
 800428a:	4240      	negs	r0, r0

	return 0;
}
 800428c:	b007      	add	sp, #28
 800428e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004290:	00002ee0 	.word	0x00002ee0

08004294 <lpc_flash_write>:

int lpc_flash_write(struct target_flash *tf,
                    target_addr dest, const void *src, size_t len)
{
 8004294:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004296:	1c04      	adds	r4, r0, #0
 8004298:	1c1e      	adds	r6, r3, #0
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 800429a:	6803      	ldr	r3, [r0, #0]
	return 0;
}

int lpc_flash_write(struct target_flash *tf,
                    target_addr dest, const void *src, size_t len)
{
 800429c:	b085      	sub	sp, #20
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 800429e:	1ac8      	subs	r0, r1, r3
	return 0;
}

int lpc_flash_write(struct target_flash *tf,
                    target_addr dest, const void *src, size_t len)
{
 80042a0:	1c0d      	adds	r5, r1, #0
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 80042a2:	68a1      	ldr	r1, [r4, #8]
	return 0;
}

int lpc_flash_write(struct target_flash *tf,
                    target_addr dest, const void *src, size_t len)
{
 80042a4:	9203      	str	r2, [sp, #12]
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 80042a6:	f00a fb73 	bl	800e990 <__aeabi_uidiv>
 80042aa:	1c23      	adds	r3, r4, #0
                    target_addr dest, const void *src, size_t len)
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	/* prepare... */
	uint32_t sector = lpc_sector_for_addr(f, dest);
	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
 80042ac:	1c22      	adds	r2, r4, #0
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 80042ae:	3338      	adds	r3, #56	; 0x38
 80042b0:	781b      	ldrb	r3, [r3, #0]
                    target_addr dest, const void *src, size_t len)
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	/* prepare... */
	uint32_t sector = lpc_sector_for_addr(f, dest);
	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
 80042b2:	3239      	adds	r2, #57	; 0x39
	return param.result;
}

static uint8_t lpc_sector_for_addr(struct lpc_flash *f, uint32_t addr)
{
	return f->base_sector + (addr - f->f.start) / f->f.blocksize;
 80042b4:	18c3      	adds	r3, r0, r3
                    target_addr dest, const void *src, size_t len)
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	/* prepare... */
	uint32_t sector = lpc_sector_for_addr(f, dest);
	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
 80042b6:	7812      	ldrb	r2, [r2, #0]
int lpc_flash_write(struct target_flash *tf,
                    target_addr dest, const void *src, size_t len)
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	/* prepare... */
	uint32_t sector = lpc_sector_for_addr(f, dest);
 80042b8:	b2db      	uxtb	r3, r3
	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
 80042ba:	9200      	str	r2, [sp, #0]
 80042bc:	1c20      	adds	r0, r4, #0
 80042be:	2132      	movs	r1, #50	; 0x32
 80042c0:	1c1a      	adds	r2, r3, #0
 80042c2:	f7ff ff3f 	bl	8004144 <lpc_iap_call>
 80042c6:	2800      	cmp	r0, #0
 80042c8:	d117      	bne.n	80042fa <lpc_flash_write+0x66>
		return -1;

	/* Write payload to target ram */
	uint32_t bufaddr = ALIGN(f->iap_ram + sizeof(struct flash_param), 4);
 80042ca:	2203      	movs	r2, #3
 80042cc:	6c63      	ldr	r3, [r4, #68]	; 0x44
	target_mem_write(f->f.t, bufaddr, src, len);
 80042ce:	69a0      	ldr	r0, [r4, #24]
	uint32_t sector = lpc_sector_for_addr(f, dest);
	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
		return -1;

	/* Write payload to target ram */
	uint32_t bufaddr = ALIGN(f->iap_ram + sizeof(struct flash_param), 4);
 80042d0:	331f      	adds	r3, #31
 80042d2:	4393      	bics	r3, r2
 80042d4:	1c1f      	adds	r7, r3, #0
	target_mem_write(f->f.t, bufaddr, src, len);
 80042d6:	1c19      	adds	r1, r3, #0
 80042d8:	9a03      	ldr	r2, [sp, #12]
 80042da:	1c33      	adds	r3, r6, #0
 80042dc:	f004 f8aa 	bl	8008434 <target_mem_write>

	/* set the destination address and program */
	if (lpc_iap_call(f, IAP_CMD_PROGRAM, dest, bufaddr, len, CPU_CLK_KHZ))
 80042e0:	4b08      	ldr	r3, [pc, #32]	; (8004304 <lpc_flash_write+0x70>)
 80042e2:	9600      	str	r6, [sp, #0]
 80042e4:	9301      	str	r3, [sp, #4]
 80042e6:	1c20      	adds	r0, r4, #0
 80042e8:	2133      	movs	r1, #51	; 0x33
 80042ea:	1c2a      	adds	r2, r5, #0
 80042ec:	1c3b      	adds	r3, r7, #0
 80042ee:	f7ff ff29 	bl	8004144 <lpc_iap_call>
 80042f2:	2800      	cmp	r0, #0
 80042f4:	d003      	beq.n	80042fe <lpc_flash_write+0x6a>
		return -2;
 80042f6:	2002      	movs	r0, #2
 80042f8:	e000      	b.n	80042fc <lpc_flash_write+0x68>
{
	struct lpc_flash *f = (struct lpc_flash *)tf;
	/* prepare... */
	uint32_t sector = lpc_sector_for_addr(f, dest);
	if (lpc_iap_call(f, IAP_CMD_PREPARE, sector, sector, f->bank))
		return -1;
 80042fa:	2001      	movs	r0, #1
	uint32_t bufaddr = ALIGN(f->iap_ram + sizeof(struct flash_param), 4);
	target_mem_write(f->f.t, bufaddr, src, len);

	/* set the destination address and program */
	if (lpc_iap_call(f, IAP_CMD_PROGRAM, dest, bufaddr, len, CPU_CLK_KHZ))
		return -2;
 80042fc:	4240      	negs	r0, r0

	return 0;
}
 80042fe:	b005      	add	sp, #20
 8004300:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004302:	46c0      	nop			; (mov r8, r8)
 8004304:	00002ee0 	.word	0x00002ee0

08004308 <lpc_flash_write_magic_vect>:

int lpc_flash_write_magic_vect(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8004308:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (dest == 0) {
 800430a:	2900      	cmp	r1, #0
 800430c:	d109      	bne.n	8004322 <lpc_flash_write_magic_vect+0x1a>
 800430e:	1c16      	adds	r6, r2, #0
 8004310:	1c15      	adds	r5, r2, #0
 8004312:	1c0c      	adds	r4, r1, #0
 8004314:	361c      	adds	r6, #28
		/* Fill in the magic vector to allow booting the flash */
		uint32_t *w = (uint32_t *)src;
		uint32_t sum = 0;

		for (unsigned i = 0; i < 7; i++)
			sum += w[i];
 8004316:	cd80      	ldmia	r5!, {r7}
 8004318:	19e4      	adds	r4, r4, r7
	if (dest == 0) {
		/* Fill in the magic vector to allow booting the flash */
		uint32_t *w = (uint32_t *)src;
		uint32_t sum = 0;

		for (unsigned i = 0; i < 7; i++)
 800431a:	42b5      	cmp	r5, r6
 800431c:	d1fb      	bne.n	8004316 <lpc_flash_write_magic_vect+0xe>
			sum += w[i];
		w[7] = ~sum + 1;
 800431e:	4264      	negs	r4, r4
 8004320:	61d4      	str	r4, [r2, #28]
	}
	return lpc_flash_write(f, dest, src, len);
 8004322:	f7ff ffb7 	bl	8004294 <lpc_flash_write>
}
 8004326:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004328 <lpc11xx_add_flash>:

#define LPC11XX_DEVICE_ID  0x400483F4
#define LPC8XX_DEVICE_ID   0x400483F8

void lpc11xx_add_flash(target *t, uint32_t addr, size_t len, size_t erasesize)
{
 8004328:	b510      	push	{r4, lr}
 800432a:	1c1c      	adds	r4, r3, #0
	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
 800432c:	f7ff fee6 	bl	80040fc <lpc_add_flash>
	lf->f.blocksize = erasesize;
	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
 8004330:	2380      	movs	r3, #128	; 0x80
 8004332:	009b      	lsls	r3, r3, #2
 8004334:	6283      	str	r3, [r0, #40]	; 0x28
	lf->f.write_buf = lpc_flash_write_magic_vect;
 8004336:	4b05      	ldr	r3, [pc, #20]	; (800434c <lpc11xx_add_flash+0x24>)
#define LPC8XX_DEVICE_ID   0x400483F8

void lpc11xx_add_flash(target *t, uint32_t addr, size_t len, size_t erasesize)
{
	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
	lf->f.blocksize = erasesize;
 8004338:	6084      	str	r4, [r0, #8]
	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
	lf->f.write_buf = lpc_flash_write_magic_vect;
 800433a:	62c3      	str	r3, [r0, #44]	; 0x2c
	lf->iap_entry = IAP_ENTRYPOINT;
 800433c:	4b04      	ldr	r3, [pc, #16]	; (8004350 <lpc11xx_add_flash+0x28>)
 800433e:	6403      	str	r3, [r0, #64]	; 0x40
	lf->iap_ram = IAP_RAM_BASE;
 8004340:	2380      	movs	r3, #128	; 0x80
 8004342:	055b      	lsls	r3, r3, #21
 8004344:	6443      	str	r3, [r0, #68]	; 0x44
	lf->iap_msp = IAP_RAM_BASE + MIN_RAM_SIZE - RAM_USAGE_FOR_IAP_ROUTINES;
 8004346:	4b03      	ldr	r3, [pc, #12]	; (8004354 <lpc11xx_add_flash+0x2c>)
 8004348:	6483      	str	r3, [r0, #72]	; 0x48
}
 800434a:	bd10      	pop	{r4, pc}
 800434c:	08004309 	.word	0x08004309
 8004350:	1fff1ff1 	.word	0x1fff1ff1
 8004354:	100003e0 	.word	0x100003e0

08004358 <lpc11xx_probe>:

bool
lpc11xx_probe(target *t)
{
 8004358:	b510      	push	{r4, lr}
	uint32_t idcode;

	/* read the device ID register */
	idcode = target_mem_read32(t, LPC11XX_DEVICE_ID);
 800435a:	4958      	ldr	r1, [pc, #352]	; (80044bc <lpc11xx_probe+0x164>)
	lf->iap_msp = IAP_RAM_BASE + MIN_RAM_SIZE - RAM_USAGE_FOR_IAP_ROUTINES;
}

bool
lpc11xx_probe(target *t)
{
 800435c:	1c04      	adds	r4, r0, #0
	uint32_t idcode;

	/* read the device ID register */
	idcode = target_mem_read32(t, LPC11XX_DEVICE_ID);
 800435e:	f004 f8e5 	bl	800852c <target_mem_read32>
	switch (idcode) {
 8004362:	4b57      	ldr	r3, [pc, #348]	; (80044c0 <lpc11xx_probe+0x168>)
 8004364:	4298      	cmp	r0, r3
 8004366:	d059      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004368:	d82b      	bhi.n	80043c2 <lpc11xx_probe+0x6a>
 800436a:	4b56      	ldr	r3, [pc, #344]	; (80044c4 <lpc11xx_probe+0x16c>)
 800436c:	4298      	cmp	r0, r3
 800436e:	d055      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004370:	d813      	bhi.n	800439a <lpc11xx_probe+0x42>
 8004372:	4b55      	ldr	r3, [pc, #340]	; (80044c8 <lpc11xx_probe+0x170>)
 8004374:	4298      	cmp	r0, r3
 8004376:	d051      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004378:	d807      	bhi.n	800438a <lpc11xx_probe+0x32>
 800437a:	4b54      	ldr	r3, [pc, #336]	; (80044cc <lpc11xx_probe+0x174>)
 800437c:	4298      	cmp	r0, r3
 800437e:	d04d      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004380:	4b53      	ldr	r3, [pc, #332]	; (80044d0 <lpc11xx_probe+0x178>)
 8004382:	4298      	cmp	r0, r3
 8004384:	d04a      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004386:	4b53      	ldr	r3, [pc, #332]	; (80044d4 <lpc11xx_probe+0x17c>)
 8004388:	e046      	b.n	8004418 <lpc11xx_probe+0xc0>
 800438a:	4b53      	ldr	r3, [pc, #332]	; (80044d8 <lpc11xx_probe+0x180>)
 800438c:	4298      	cmp	r0, r3
 800438e:	d045      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004390:	4b52      	ldr	r3, [pc, #328]	; (80044dc <lpc11xx_probe+0x184>)
 8004392:	4298      	cmp	r0, r3
 8004394:	d042      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004396:	4b52      	ldr	r3, [pc, #328]	; (80044e0 <lpc11xx_probe+0x188>)
 8004398:	e03e      	b.n	8004418 <lpc11xx_probe+0xc0>
 800439a:	4b52      	ldr	r3, [pc, #328]	; (80044e4 <lpc11xx_probe+0x18c>)
 800439c:	4298      	cmp	r0, r3
 800439e:	d03d      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043a0:	d807      	bhi.n	80043b2 <lpc11xx_probe+0x5a>
 80043a2:	4b51      	ldr	r3, [pc, #324]	; (80044e8 <lpc11xx_probe+0x190>)
 80043a4:	4298      	cmp	r0, r3
 80043a6:	d039      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043a8:	4b50      	ldr	r3, [pc, #320]	; (80044ec <lpc11xx_probe+0x194>)
 80043aa:	4298      	cmp	r0, r3
 80043ac:	d036      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043ae:	4b50      	ldr	r3, [pc, #320]	; (80044f0 <lpc11xx_probe+0x198>)
 80043b0:	e032      	b.n	8004418 <lpc11xx_probe+0xc0>
 80043b2:	4b50      	ldr	r3, [pc, #320]	; (80044f4 <lpc11xx_probe+0x19c>)
 80043b4:	4298      	cmp	r0, r3
 80043b6:	d031      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043b8:	4b4f      	ldr	r3, [pc, #316]	; (80044f8 <lpc11xx_probe+0x1a0>)
 80043ba:	4298      	cmp	r0, r3
 80043bc:	d02e      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043be:	4b4f      	ldr	r3, [pc, #316]	; (80044fc <lpc11xx_probe+0x1a4>)
 80043c0:	e02a      	b.n	8004418 <lpc11xx_probe+0xc0>
 80043c2:	4b4f      	ldr	r3, [pc, #316]	; (8004500 <lpc11xx_probe+0x1a8>)
 80043c4:	4298      	cmp	r0, r3
 80043c6:	d029      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043c8:	d813      	bhi.n	80043f2 <lpc11xx_probe+0x9a>
 80043ca:	4b4e      	ldr	r3, [pc, #312]	; (8004504 <lpc11xx_probe+0x1ac>)
 80043cc:	4298      	cmp	r0, r3
 80043ce:	d025      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043d0:	d807      	bhi.n	80043e2 <lpc11xx_probe+0x8a>
 80043d2:	4b4d      	ldr	r3, [pc, #308]	; (8004508 <lpc11xx_probe+0x1b0>)
 80043d4:	4298      	cmp	r0, r3
 80043d6:	d021      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043d8:	4b4c      	ldr	r3, [pc, #304]	; (800450c <lpc11xx_probe+0x1b4>)
 80043da:	4298      	cmp	r0, r3
 80043dc:	d01e      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043de:	4b4c      	ldr	r3, [pc, #304]	; (8004510 <lpc11xx_probe+0x1b8>)
 80043e0:	e01a      	b.n	8004418 <lpc11xx_probe+0xc0>
 80043e2:	4b4c      	ldr	r3, [pc, #304]	; (8004514 <lpc11xx_probe+0x1bc>)
 80043e4:	4298      	cmp	r0, r3
 80043e6:	d019      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043e8:	4b4b      	ldr	r3, [pc, #300]	; (8004518 <lpc11xx_probe+0x1c0>)
 80043ea:	4298      	cmp	r0, r3
 80043ec:	d016      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043ee:	4b4b      	ldr	r3, [pc, #300]	; (800451c <lpc11xx_probe+0x1c4>)
 80043f0:	e012      	b.n	8004418 <lpc11xx_probe+0xc0>
 80043f2:	4b4b      	ldr	r3, [pc, #300]	; (8004520 <lpc11xx_probe+0x1c8>)
 80043f4:	4298      	cmp	r0, r3
 80043f6:	d011      	beq.n	800441c <lpc11xx_probe+0xc4>
 80043f8:	d807      	bhi.n	800440a <lpc11xx_probe+0xb2>
 80043fa:	4b4a      	ldr	r3, [pc, #296]	; (8004524 <lpc11xx_probe+0x1cc>)
 80043fc:	4298      	cmp	r0, r3
 80043fe:	d00d      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004400:	4b49      	ldr	r3, [pc, #292]	; (8004528 <lpc11xx_probe+0x1d0>)
 8004402:	4298      	cmp	r0, r3
 8004404:	d00a      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004406:	4b49      	ldr	r3, [pc, #292]	; (800452c <lpc11xx_probe+0x1d4>)
 8004408:	e006      	b.n	8004418 <lpc11xx_probe+0xc0>
 800440a:	4b49      	ldr	r3, [pc, #292]	; (8004530 <lpc11xx_probe+0x1d8>)
 800440c:	4298      	cmp	r0, r3
 800440e:	d005      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004410:	4b48      	ldr	r3, [pc, #288]	; (8004534 <lpc11xx_probe+0x1dc>)
 8004412:	4298      	cmp	r0, r3
 8004414:	d002      	beq.n	800441c <lpc11xx_probe+0xc4>
 8004416:	4b48      	ldr	r3, [pc, #288]	; (8004538 <lpc11xx_probe+0x1e0>)
 8004418:	4298      	cmp	r0, r3
 800441a:	d10f      	bne.n	800443c <lpc11xx_probe+0xe4>
	case 0x2998802B:
	case 0x2972402B:	/* lpc11u23/301 */
	case 0x2988402B:	/* lpc11u24x/301 */
	case 0x2980002B:	/* lpc11u24x/401 */
		t->driver = "LPC11xx";
		target_add_ram(t, 0x10000000, 0x2000);
 800441c:	2180      	movs	r1, #128	; 0x80
 800441e:	2280      	movs	r2, #128	; 0x80
	case 0x0998802B:	/* lpc11u14x/201 */
	case 0x2998802B:
	case 0x2972402B:	/* lpc11u23/301 */
	case 0x2988402B:	/* lpc11u24x/301 */
	case 0x2980002B:	/* lpc11u24x/401 */
		t->driver = "LPC11xx";
 8004420:	4b46      	ldr	r3, [pc, #280]	; (800453c <lpc11xx_probe+0x1e4>)
		target_add_ram(t, 0x10000000, 0x2000);
 8004422:	1c20      	adds	r0, r4, #0
	case 0x0998802B:	/* lpc11u14x/201 */
	case 0x2998802B:
	case 0x2972402B:	/* lpc11u23/301 */
	case 0x2988402B:	/* lpc11u24x/301 */
	case 0x2980002B:	/* lpc11u24x/401 */
		t->driver = "LPC11xx";
 8004424:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x10000000, 0x2000);
 8004426:	0549      	lsls	r1, r1, #21
 8004428:	0192      	lsls	r2, r2, #6
 800442a:	f003 fe83 	bl	8008134 <target_add_ram>
		lpc11xx_add_flash(t, 0x00000000, 0x20000, 0x1000);
 800442e:	2280      	movs	r2, #128	; 0x80
 8004430:	2380      	movs	r3, #128	; 0x80
 8004432:	1c20      	adds	r0, r4, #0
 8004434:	2100      	movs	r1, #0
 8004436:	0292      	lsls	r2, r2, #10
 8004438:	015b      	lsls	r3, r3, #5
 800443a:	e038      	b.n	80044ae <lpc11xx_probe+0x156>
		return true;
	}

	idcode = target_mem_read32(t, LPC8XX_DEVICE_ID);
 800443c:	1c20      	adds	r0, r4, #0
 800443e:	4940      	ldr	r1, [pc, #256]	; (8004540 <lpc11xx_probe+0x1e8>)
 8004440:	f004 f874 	bl	800852c <target_mem_read32>
	switch (idcode) {
 8004444:	4b3f      	ldr	r3, [pc, #252]	; (8004544 <lpc11xx_probe+0x1ec>)
 8004446:	4298      	cmp	r0, r3
 8004448:	d809      	bhi.n	800445e <lpc11xx_probe+0x106>
 800444a:	4b3f      	ldr	r3, [pc, #252]	; (8004548 <lpc11xx_probe+0x1f0>)
 800444c:	4298      	cmp	r0, r3
 800444e:	d211      	bcs.n	8004474 <lpc11xx_probe+0x11c>
 8004450:	3b20      	subs	r3, #32
 8004452:	4298      	cmp	r0, r3
 8004454:	d00e      	beq.n	8004474 <lpc11xx_probe+0x11c>
 8004456:	4b3d      	ldr	r3, [pc, #244]	; (800454c <lpc11xx_probe+0x1f4>)
 8004458:	4298      	cmp	r0, r3
 800445a:	d12c      	bne.n	80044b6 <lpc11xx_probe+0x15e>
 800445c:	e00a      	b.n	8004474 <lpc11xx_probe+0x11c>
 800445e:	4b3c      	ldr	r3, [pc, #240]	; (8004550 <lpc11xx_probe+0x1f8>)
 8004460:	4298      	cmp	r0, r3
 8004462:	d328      	bcc.n	80044b6 <lpc11xx_probe+0x15e>
 8004464:	4b3b      	ldr	r3, [pc, #236]	; (8004554 <lpc11xx_probe+0x1fc>)
 8004466:	4298      	cmp	r0, r3
 8004468:	d912      	bls.n	8004490 <lpc11xx_probe+0x138>
 800446a:	4b3b      	ldr	r3, [pc, #236]	; (8004558 <lpc11xx_probe+0x200>)
 800446c:	18c0      	adds	r0, r0, r3
 800446e:	2801      	cmp	r0, #1
 8004470:	d90e      	bls.n	8004490 <lpc11xx_probe+0x138>
 8004472:	e020      	b.n	80044b6 <lpc11xx_probe+0x15e>
	case 0x00008110:  /* LPC811M001JDH16 */
	case 0x00008120:  /* LPC812M101JDH16 */
	case 0x00008121:  /* LPC812M101JD20 */
	case 0x00008122:  /* LPC812M101JDH20 / LPC812M101JTB16 */
		t->driver = "LPC81x";
		target_add_ram(t, 0x10000000, 0x1000);
 8004474:	2180      	movs	r1, #128	; 0x80
 8004476:	2280      	movs	r2, #128	; 0x80
	case 0x00008100:  /* LPC810M021FN8 */
	case 0x00008110:  /* LPC811M001JDH16 */
	case 0x00008120:  /* LPC812M101JDH16 */
	case 0x00008121:  /* LPC812M101JD20 */
	case 0x00008122:  /* LPC812M101JDH20 / LPC812M101JTB16 */
		t->driver = "LPC81x";
 8004478:	4b38      	ldr	r3, [pc, #224]	; (800455c <lpc11xx_probe+0x204>)
		target_add_ram(t, 0x10000000, 0x1000);
 800447a:	1c20      	adds	r0, r4, #0
 800447c:	0549      	lsls	r1, r1, #21
 800447e:	0152      	lsls	r2, r2, #5
	case 0x00008100:  /* LPC810M021FN8 */
	case 0x00008110:  /* LPC811M001JDH16 */
	case 0x00008120:  /* LPC812M101JDH16 */
	case 0x00008121:  /* LPC812M101JD20 */
	case 0x00008122:  /* LPC812M101JDH20 / LPC812M101JTB16 */
		t->driver = "LPC81x";
 8004480:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x10000000, 0x1000);
 8004482:	f003 fe57 	bl	8008134 <target_add_ram>
		lpc11xx_add_flash(t, 0x00000000, 0x4000, 0x400);
 8004486:	2280      	movs	r2, #128	; 0x80
 8004488:	1c20      	adds	r0, r4, #0
 800448a:	2100      	movs	r1, #0
 800448c:	01d2      	lsls	r2, r2, #7
 800448e:	e00c      	b.n	80044aa <lpc11xx_probe+0x152>
        case 0x00008221:  /* LPC822M101JHI33 */
        case 0x00008222:  /* LPC822M101JDH20 */
        case 0x00008241:  /* LPC824M201JHI33 */
        case 0x00008242:  /* LPC824M201JDH20 */
		t->driver = "LPC82x";
		target_add_ram(t, 0x10000000, 0x2000);
 8004490:	2180      	movs	r1, #128	; 0x80
 8004492:	2280      	movs	r2, #128	; 0x80
		return true;
        case 0x00008221:  /* LPC822M101JHI33 */
        case 0x00008222:  /* LPC822M101JDH20 */
        case 0x00008241:  /* LPC824M201JHI33 */
        case 0x00008242:  /* LPC824M201JDH20 */
		t->driver = "LPC82x";
 8004494:	4b32      	ldr	r3, [pc, #200]	; (8004560 <lpc11xx_probe+0x208>)
		target_add_ram(t, 0x10000000, 0x2000);
 8004496:	1c20      	adds	r0, r4, #0
 8004498:	0549      	lsls	r1, r1, #21
 800449a:	0192      	lsls	r2, r2, #6
		return true;
        case 0x00008221:  /* LPC822M101JHI33 */
        case 0x00008222:  /* LPC822M101JDH20 */
        case 0x00008241:  /* LPC824M201JHI33 */
        case 0x00008242:  /* LPC824M201JDH20 */
		t->driver = "LPC82x";
 800449c:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x10000000, 0x2000);
 800449e:	f003 fe49 	bl	8008134 <target_add_ram>
		lpc11xx_add_flash(t, 0x00000000, 0x8000, 0x400);
 80044a2:	2280      	movs	r2, #128	; 0x80
 80044a4:	1c20      	adds	r0, r4, #0
 80044a6:	2100      	movs	r1, #0
 80044a8:	0212      	lsls	r2, r2, #8
 80044aa:	2380      	movs	r3, #128	; 0x80
 80044ac:	00db      	lsls	r3, r3, #3
 80044ae:	f7ff ff3b 	bl	8004328 <lpc11xx_add_flash>
		return true;
 80044b2:	2001      	movs	r0, #1
 80044b4:	e000      	b.n	80044b8 <lpc11xx_probe+0x160>

	}

	return false;
 80044b6:	2000      	movs	r0, #0
}
 80044b8:	bd10      	pop	{r4, pc}
 80044ba:	46c0      	nop			; (mov r8, r8)
 80044bc:	400483f4 	.word	0x400483f4
 80044c0:	1a40902b 	.word	0x1a40902b
 80044c4:	095c802b 	.word	0x095c802b
 80044c8:	0434102b 	.word	0x0434102b
 80044cc:	041e502b 	.word	0x041e502b
 80044d0:	0425502b 	.word	0x0425502b
 80044d4:	0416502b 	.word	0x0416502b
 80044d8:	0444102b 	.word	0x0444102b
 80044dc:	0444502b 	.word	0x0444502b
 80044e0:	0434502b 	.word	0x0434502b
 80044e4:	1421102b 	.word	0x1421102b
 80044e8:	0998802b 	.word	0x0998802b
 80044ec:	0a40902b 	.word	0x0a40902b
 80044f0:	097a802b 	.word	0x097a802b
 80044f4:	1431102b 	.word	0x1431102b
 80044f8:	1440102b 	.word	0x1440102b
 80044fc:	1430102b 	.word	0x1430102b
 8004500:	2540102b 	.word	0x2540102b
 8004504:	2524902b 	.word	0x2524902b
 8004508:	2516902b 	.word	0x2516902b
 800450c:	2516d02b 	.word	0x2516d02b
 8004510:	2058002b 	.word	0x2058002b
 8004514:	2532102b 	.word	0x2532102b
 8004518:	2532902b 	.word	0x2532902b
 800451c:	2524d02b 	.word	0x2524d02b
 8004520:	297a802b 	.word	0x297a802b
 8004524:	295c802b 	.word	0x295c802b
 8004528:	2972402b 	.word	0x2972402b
 800452c:	2540902b 	.word	0x2540902b
 8004530:	2988402b 	.word	0x2988402b
 8004534:	2998802b 	.word	0x2998802b
 8004538:	2980002b 	.word	0x2980002b
 800453c:	08012440 	.word	0x08012440
 8004540:	400483f8 	.word	0x400483f8
 8004544:	00008122 	.word	0x00008122
 8004548:	00008120 	.word	0x00008120
 800454c:	00008110 	.word	0x00008110
 8004550:	00008221 	.word	0x00008221
 8004554:	00008222 	.word	0x00008222
 8004558:	ffff7dbf 	.word	0xffff7dbf
 800455c:	08012448 	.word	0x08012448
 8004560:	0801244f 	.word	0x0801244f

08004564 <lpc15xx_add_flash>:
#define IAP_RAM_BASE	0x02000000

#define LPC15XX_DEVICE_ID  0x400743F8

void lpc15xx_add_flash(target *t, uint32_t addr, size_t len, size_t erasesize)
{
 8004564:	b510      	push	{r4, lr}
 8004566:	1c1c      	adds	r4, r3, #0
	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
 8004568:	f7ff fdc8 	bl	80040fc <lpc_add_flash>
	lf->f.blocksize = erasesize;
	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
 800456c:	2380      	movs	r3, #128	; 0x80
 800456e:	009b      	lsls	r3, r3, #2
 8004570:	6283      	str	r3, [r0, #40]	; 0x28
	lf->f.write_buf = lpc_flash_write_magic_vect;
 8004572:	4b05      	ldr	r3, [pc, #20]	; (8004588 <lpc15xx_add_flash+0x24>)
#define LPC15XX_DEVICE_ID  0x400743F8

void lpc15xx_add_flash(target *t, uint32_t addr, size_t len, size_t erasesize)
{
	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
	lf->f.blocksize = erasesize;
 8004574:	6084      	str	r4, [r0, #8]
	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
	lf->f.write_buf = lpc_flash_write_magic_vect;
 8004576:	62c3      	str	r3, [r0, #44]	; 0x2c
	lf->iap_entry = IAP_ENTRYPOINT;
 8004578:	4b04      	ldr	r3, [pc, #16]	; (800458c <lpc15xx_add_flash+0x28>)
 800457a:	6403      	str	r3, [r0, #64]	; 0x40
	lf->iap_ram = IAP_RAM_BASE;
 800457c:	2380      	movs	r3, #128	; 0x80
 800457e:	049b      	lsls	r3, r3, #18
 8004580:	6443      	str	r3, [r0, #68]	; 0x44
	lf->iap_msp = IAP_RAM_BASE + MIN_RAM_SIZE - RAM_USAGE_FOR_IAP_ROUTINES;
 8004582:	4b03      	ldr	r3, [pc, #12]	; (8004590 <lpc15xx_add_flash+0x2c>)
 8004584:	6483      	str	r3, [r0, #72]	; 0x48
}
 8004586:	bd10      	pop	{r4, pc}
 8004588:	08004309 	.word	0x08004309
 800458c:	03000205 	.word	0x03000205
 8004590:	020003e0 	.word	0x020003e0

08004594 <lpc15xx_probe>:

bool
lpc15xx_probe(target *t)
{
 8004594:	b510      	push	{r4, lr}
	uint32_t idcode;
	uint32_t ram_size = 0;

	/* read the device ID register */
	idcode = target_mem_read32(t, LPC15XX_DEVICE_ID);
 8004596:	491a      	ldr	r1, [pc, #104]	; (8004600 <lpc15xx_probe+0x6c>)
	lf->iap_msp = IAP_RAM_BASE + MIN_RAM_SIZE - RAM_USAGE_FOR_IAP_ROUTINES;
}

bool
lpc15xx_probe(target *t)
{
 8004598:	1c04      	adds	r4, r0, #0
	uint32_t idcode;
	uint32_t ram_size = 0;

	/* read the device ID register */
	idcode = target_mem_read32(t, LPC15XX_DEVICE_ID);
 800459a:	f003 ffc7 	bl	800852c <target_mem_read32>
	switch (idcode) {
 800459e:	4b19      	ldr	r3, [pc, #100]	; (8004604 <lpc15xx_probe+0x70>)
 80045a0:	4298      	cmp	r0, r3
 80045a2:	d016      	beq.n	80045d2 <lpc15xx_probe+0x3e>
 80045a4:	d806      	bhi.n	80045b4 <lpc15xx_probe+0x20>
 80045a6:	4b18      	ldr	r3, [pc, #96]	; (8004608 <lpc15xx_probe+0x74>)
 80045a8:	4298      	cmp	r0, r3
 80045aa:	d015      	beq.n	80045d8 <lpc15xx_probe+0x44>
 80045ac:	4b17      	ldr	r3, [pc, #92]	; (800460c <lpc15xx_probe+0x78>)
 80045ae:	4298      	cmp	r0, r3
 80045b0:	d00a      	beq.n	80045c8 <lpc15xx_probe+0x34>
 80045b2:	e00c      	b.n	80045ce <lpc15xx_probe+0x3a>
 80045b4:	4b16      	ldr	r3, [pc, #88]	; (8004610 <lpc15xx_probe+0x7c>)
 80045b6:	4298      	cmp	r0, r3
 80045b8:	d006      	beq.n	80045c8 <lpc15xx_probe+0x34>
 80045ba:	4b16      	ldr	r3, [pc, #88]	; (8004614 <lpc15xx_probe+0x80>)
 80045bc:	4298      	cmp	r0, r3
 80045be:	d008      	beq.n	80045d2 <lpc15xx_probe+0x3e>
 80045c0:	4b15      	ldr	r3, [pc, #84]	; (8004618 <lpc15xx_probe+0x84>)
 80045c2:	4298      	cmp	r0, r3
 80045c4:	d103      	bne.n	80045ce <lpc15xx_probe+0x3a>
 80045c6:	e007      	b.n	80045d8 <lpc15xx_probe+0x44>
	case 0x00001519:
		ram_size = 0x9000;
		break;
	case 0x00001548:
	case 0x00001518:
		ram_size = 0x5000;
 80045c8:	22a0      	movs	r2, #160	; 0xa0
 80045ca:	01d2      	lsls	r2, r2, #7
 80045cc:	e006      	b.n	80045dc <lpc15xx_probe+0x48>
		target_add_ram(t, 0x02000000, ram_size);
		lpc15xx_add_flash(t, 0x00000000, 0x40000, 0x1000);
		return true;
	}

	return false;
 80045ce:	2000      	movs	r0, #0
 80045d0:	e014      	b.n	80045fc <lpc15xx_probe+0x68>
	/* read the device ID register */
	idcode = target_mem_read32(t, LPC15XX_DEVICE_ID);
	switch (idcode) {
	case 0x00001549:
	case 0x00001519:
		ram_size = 0x9000;
 80045d2:	2290      	movs	r2, #144	; 0x90
 80045d4:	0212      	lsls	r2, r2, #8
 80045d6:	e001      	b.n	80045dc <lpc15xx_probe+0x48>
	case 0x00001518:
		ram_size = 0x5000;
		break;
	case 0x00001547:
	case 0x00001517:
		ram_size = 0x3000;
 80045d8:	22c0      	movs	r2, #192	; 0xc0
 80045da:	0192      	lsls	r2, r2, #6
		break;
	}
	if (ram_size) {
		t->driver = "LPC15xx";
		target_add_ram(t, 0x02000000, ram_size);
 80045dc:	2180      	movs	r1, #128	; 0x80
	case 0x00001517:
		ram_size = 0x3000;
		break;
	}
	if (ram_size) {
		t->driver = "LPC15xx";
 80045de:	4b0f      	ldr	r3, [pc, #60]	; (800461c <lpc15xx_probe+0x88>)
		target_add_ram(t, 0x02000000, ram_size);
 80045e0:	1c20      	adds	r0, r4, #0
	case 0x00001517:
		ram_size = 0x3000;
		break;
	}
	if (ram_size) {
		t->driver = "LPC15xx";
 80045e2:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x02000000, ram_size);
 80045e4:	0489      	lsls	r1, r1, #18
 80045e6:	f003 fda5 	bl	8008134 <target_add_ram>
		lpc15xx_add_flash(t, 0x00000000, 0x40000, 0x1000);
 80045ea:	2280      	movs	r2, #128	; 0x80
 80045ec:	2380      	movs	r3, #128	; 0x80
 80045ee:	1c20      	adds	r0, r4, #0
 80045f0:	2100      	movs	r1, #0
 80045f2:	02d2      	lsls	r2, r2, #11
 80045f4:	015b      	lsls	r3, r3, #5
 80045f6:	f7ff ffb5 	bl	8004564 <lpc15xx_add_flash>
		return true;
 80045fa:	2001      	movs	r0, #1
	}

	return false;
}
 80045fc:	bd10      	pop	{r4, pc}
 80045fe:	46c0      	nop			; (mov r8, r8)
 8004600:	400743f8 	.word	0x400743f8
 8004604:	00001519 	.word	0x00001519
 8004608:	00001517 	.word	0x00001517
 800460c:	00001518 	.word	0x00001518
 8004610:	00001548 	.word	0x00001548
 8004614:	00001549 	.word	0x00001549
 8004618:	00001547 	.word	0x00001547
 800461c:	08012456 	.word	0x08012456

08004620 <lpc43xx_flash_init>:

	return true;
}

static int lpc43xx_flash_init(target *t)
{
 8004620:	b510      	push	{r4, lr}
}

static void lpc43xx_wdt_set_period(target *t)
{
	/* Check if WDT is on */
	uint32_t wdt_mode = target_mem_read32(t, LPC43XX_WDT_MODE);
 8004622:	490d      	ldr	r1, [pc, #52]	; (8004658 <lpc43xx_flash_init+0x38>)

	return true;
}

static int lpc43xx_flash_init(target *t)
{
 8004624:	1c04      	adds	r4, r0, #0
}

static void lpc43xx_wdt_set_period(target *t)
{
	/* Check if WDT is on */
	uint32_t wdt_mode = target_mem_read32(t, LPC43XX_WDT_MODE);
 8004626:	f003 ff81 	bl	800852c <target_mem_read32>

	/* If WDT on, we can't disable it, but we may be able to set a long period */
	if (wdt_mode && !(wdt_mode & LPC43XX_WDT_PROTECT))
 800462a:	2800      	cmp	r0, #0
 800462c:	d006      	beq.n	800463c <lpc43xx_flash_init+0x1c>
 800462e:	06c3      	lsls	r3, r0, #27
 8004630:	d404      	bmi.n	800463c <lpc43xx_flash_init+0x1c>
		target_mem_write32(t, LPC43XX_WDT_CNT, LPC43XX_WDT_PERIOD_MAX);
 8004632:	1c20      	adds	r0, r4, #0
 8004634:	4909      	ldr	r1, [pc, #36]	; (800465c <lpc43xx_flash_init+0x3c>)
 8004636:	4a0a      	ldr	r2, [pc, #40]	; (8004660 <lpc43xx_flash_init+0x40>)
 8004638:	f003 ff80 	bl	800853c <target_mem_write32>
}

static void lpc43xx_set_internal_clock(target *t)
{
	const uint32_t val2 = (1 << 11) | (1 << 24);
	target_mem_write32(t, 0x40050000 + 0x06C, val2);
 800463c:	1c20      	adds	r0, r4, #0
 800463e:	4a09      	ldr	r2, [pc, #36]	; (8004664 <lpc43xx_flash_init+0x44>)
 8004640:	4909      	ldr	r1, [pc, #36]	; (8004668 <lpc43xx_flash_init+0x48>)
 8004642:	f003 ff7b 	bl	800853c <target_mem_write32>
	/* Force internal clock */
	lpc43xx_set_internal_clock(t);

	/* Initialize flash IAP */
	struct lpc_flash *f = (struct lpc_flash *)t->flash;
	if (lpc_iap_call(f, IAP_CMD_INIT))
 8004646:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8004648:	2131      	movs	r1, #49	; 0x31
 800464a:	f7ff fd7b 	bl	8004144 <lpc_iap_call>
 800464e:	1e43      	subs	r3, r0, #1
 8004650:	4198      	sbcs	r0, r3
 8004652:	4240      	negs	r0, r0
		return -1;

	return 0;
}
 8004654:	bd10      	pop	{r4, pc}
 8004656:	46c0      	nop			; (mov r8, r8)
 8004658:	40080000 	.word	0x40080000
 800465c:	40080004 	.word	0x40080004
 8004660:	00ffffff 	.word	0x00ffffff
 8004664:	01000800 	.word	0x01000800
 8004668:	4005006c 	.word	0x4005006c

0800466c <lpc43xx_cmd_erase>:

	return true;
}

static bool lpc43xx_cmd_erase(target *t, int argc, const char *argv[])
{
 800466c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800466e:	1c05      	adds	r5, r0, #0
	(void)argc;
	(void)argv;

	lpc43xx_flash_init(t);

	for (int bank = 0; bank < FLASH_NUM_BANK; bank++)
 8004670:	2400      	movs	r4, #0
static bool lpc43xx_cmd_erase(target *t, int argc, const char *argv[])
{
	(void)argc;
	(void)argv;

	lpc43xx_flash_init(t);
 8004672:	f7ff ffd5 	bl	8004620 <lpc43xx_flash_init>

	for (int bank = 0; bank < FLASH_NUM_BANK; bank++)
	{
		struct lpc_flash *f = (struct lpc_flash *)t->flash;
 8004676:	6dee      	ldr	r6, [r5, #92]	; 0x5c
		if (lpc_iap_call(f, IAP_CMD_PREPARE,
 8004678:	2200      	movs	r2, #0
 800467a:	9400      	str	r4, [sp, #0]
 800467c:	1c30      	adds	r0, r6, #0
 800467e:	2132      	movs	r1, #50	; 0x32
 8004680:	230e      	movs	r3, #14
 8004682:	f7ff fd5f 	bl	8004144 <lpc_iap_call>
 8004686:	1e02      	subs	r2, r0, #0
 8004688:	d001      	beq.n	800468e <lpc43xx_cmd_erase+0x22>
		                 0, FLASH_NUM_SECTOR-1, bank))
			return false;
 800468a:	2000      	movs	r0, #0
 800468c:	e012      	b.n	80046b4 <lpc43xx_cmd_erase+0x48>

		if (lpc_iap_call(f, IAP_CMD_ERASE,
 800468e:	4b0a      	ldr	r3, [pc, #40]	; (80046b8 <lpc43xx_cmd_erase+0x4c>)
 8004690:	9401      	str	r4, [sp, #4]
 8004692:	9300      	str	r3, [sp, #0]
 8004694:	1c30      	adds	r0, r6, #0
 8004696:	2134      	movs	r1, #52	; 0x34
 8004698:	230e      	movs	r3, #14
 800469a:	f7ff fd53 	bl	8004144 <lpc_iap_call>
 800469e:	2800      	cmp	r0, #0
 80046a0:	d1f3      	bne.n	800468a <lpc43xx_cmd_erase+0x1e>
	(void)argc;
	(void)argv;

	lpc43xx_flash_init(t);

	for (int bank = 0; bank < FLASH_NUM_BANK; bank++)
 80046a2:	2c01      	cmp	r4, #1
 80046a4:	d001      	beq.n	80046aa <lpc43xx_cmd_erase+0x3e>
 80046a6:	2401      	movs	r4, #1
 80046a8:	e7e5      	b.n	8004676 <lpc43xx_cmd_erase+0xa>
		if (lpc_iap_call(f, IAP_CMD_ERASE,
		                 0, FLASH_NUM_SECTOR-1, CPU_CLK_KHZ, bank))
			return false;
	}

	tc_printf(t, "Erase OK.\n");
 80046aa:	1c28      	adds	r0, r5, #0
 80046ac:	4903      	ldr	r1, [pc, #12]	; (80046bc <lpc43xx_cmd_erase+0x50>)
 80046ae:	f003 ff9c 	bl	80085ea <tc_printf>

	return true;
 80046b2:	1c20      	adds	r0, r4, #0
}
 80046b4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 80046b6:	46c0      	nop			; (mov r8, r8)
 80046b8:	00002ee0 	.word	0x00002ee0
 80046bc:	08012494 	.word	0x08012494

080046c0 <lpc43xx_cmd_reset>:
	return false;
}

/* Reset all major systems _except_ debug */
static bool lpc43xx_cmd_reset(target *t, int argc, const char *argv[])
{
 80046c0:	b508      	push	{r3, lr}
	static const uint32_t AIRCR = 0xE000ED0C;
	/* Magic value key */
	static const uint32_t reset_val = 0x05FA0004;

	/* System reset on target */
	target_mem_write(t, AIRCR, &reset_val, sizeof(reset_val));
 80046c2:	4903      	ldr	r1, [pc, #12]	; (80046d0 <lpc43xx_cmd_reset+0x10>)
 80046c4:	4a03      	ldr	r2, [pc, #12]	; (80046d4 <lpc43xx_cmd_reset+0x14>)
 80046c6:	2304      	movs	r3, #4
 80046c8:	f003 feb4 	bl	8008434 <target_mem_write>

	return true;
}
 80046cc:	2001      	movs	r0, #1
 80046ce:	bd08      	pop	{r3, pc}
 80046d0:	e000ed0c 	.word	0xe000ed0c
 80046d4:	08012460 	.word	0x08012460

080046d8 <lpc43xx_flash_erase>:

	return 0;
}

static int lpc43xx_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 80046d8:	b570      	push	{r4, r5, r6, lr}
 80046da:	1c04      	adds	r4, r0, #0
	if (lpc43xx_flash_init(f->t))
 80046dc:	6980      	ldr	r0, [r0, #24]

	return 0;
}

static int lpc43xx_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 80046de:	1c0e      	adds	r6, r1, #0
 80046e0:	1c15      	adds	r5, r2, #0
	if (lpc43xx_flash_init(f->t))
 80046e2:	f7ff ff9d 	bl	8004620 <lpc43xx_flash_init>
 80046e6:	2800      	cmp	r0, #0
 80046e8:	d105      	bne.n	80046f6 <lpc43xx_flash_erase+0x1e>
		return -1;

	return lpc_flash_erase(f, addr, len);
 80046ea:	1c20      	adds	r0, r4, #0
 80046ec:	1c31      	adds	r1, r6, #0
 80046ee:	1c2a      	adds	r2, r5, #0
 80046f0:	f7ff fd86 	bl	8004200 <lpc_flash_erase>
 80046f4:	e001      	b.n	80046fa <lpc43xx_flash_erase+0x22>
}

static int lpc43xx_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	if (lpc43xx_flash_init(f->t))
		return -1;
 80046f6:	2001      	movs	r0, #1
 80046f8:	4240      	negs	r0, r0

	return lpc_flash_erase(f, addr, len);
}
 80046fa:	bd70      	pop	{r4, r5, r6, pc}

080046fc <lpc43xx_cmd_mkboot>:
 *
 * This is done indepently of writing to give the user a chance to verify flash
 * before changing it.
 */
static bool lpc43xx_cmd_mkboot(target *t, int argc, const char *argv[])
{
 80046fc:	b538      	push	{r3, r4, r5, lr}
 80046fe:	1c04      	adds	r4, r0, #0
	/* Usage: mkboot 0 or mkboot 1 */
	if (argc != 2) {
 8004700:	2902      	cmp	r1, #2
 8004702:	d001      	beq.n	8004708 <lpc43xx_cmd_mkboot+0xc>
		tc_printf(t, "Expected bank argument 0 or 1.\n");
 8004704:	4910      	ldr	r1, [pc, #64]	; (8004748 <lpc43xx_cmd_mkboot+0x4c>)
 8004706:	e015      	b.n	8004734 <lpc43xx_cmd_mkboot+0x38>
		return false;
	}

	const long int bank = strtol(argv[1], NULL, 0);
 8004708:	2100      	movs	r1, #0
 800470a:	6850      	ldr	r0, [r2, #4]
 800470c:	1c0a      	adds	r2, r1, #0
 800470e:	f008 fcd3 	bl	800d0b8 <strtol>

	if ((bank != 0) && (bank != 1)) {
		tc_printf(t, "Unexpected bank number, should be 0 or 1.\n");
 8004712:	490e      	ldr	r1, [pc, #56]	; (800474c <lpc43xx_cmd_mkboot+0x50>)
	if (argc != 2) {
		tc_printf(t, "Expected bank argument 0 or 1.\n");
		return false;
	}

	const long int bank = strtol(argv[1], NULL, 0);
 8004714:	1c05      	adds	r5, r0, #0

	if ((bank != 0) && (bank != 1)) {
		tc_printf(t, "Unexpected bank number, should be 0 or 1.\n");
 8004716:	1c20      	adds	r0, r4, #0
		return false;
	}

	const long int bank = strtol(argv[1], NULL, 0);

	if ((bank != 0) && (bank != 1)) {
 8004718:	2d01      	cmp	r5, #1
 800471a:	d80b      	bhi.n	8004734 <lpc43xx_cmd_mkboot+0x38>
		tc_printf(t, "Unexpected bank number, should be 0 or 1.\n");
		return false;
	}

	lpc43xx_flash_init(t);
 800471c:	f7ff ff80 	bl	8004620 <lpc43xx_flash_init>

	/* special command to compute/write magic vector for signature */
	struct lpc_flash *f = (struct lpc_flash *)t->flash;
	if (lpc_iap_call(f, IAP_CMD_SET_ACTIVE_BANK, bank, CPU_CLK_KHZ)) {
 8004720:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8004722:	213c      	movs	r1, #60	; 0x3c
 8004724:	1c2a      	adds	r2, r5, #0
 8004726:	4b0a      	ldr	r3, [pc, #40]	; (8004750 <lpc43xx_cmd_mkboot+0x54>)
 8004728:	f7ff fd0c 	bl	8004144 <lpc_iap_call>
 800472c:	2800      	cmp	r0, #0
 800472e:	d005      	beq.n	800473c <lpc43xx_cmd_mkboot+0x40>
		tc_printf(t, "Set bootable failed.\n");
 8004730:	1c20      	adds	r0, r4, #0
 8004732:	4908      	ldr	r1, [pc, #32]	; (8004754 <lpc43xx_cmd_mkboot+0x58>)
 8004734:	f003 ff59 	bl	80085ea <tc_printf>
		return false;
 8004738:	2000      	movs	r0, #0
 800473a:	e004      	b.n	8004746 <lpc43xx_cmd_mkboot+0x4a>
	}

	tc_printf(t, "Set bootable OK.\n");
 800473c:	1c20      	adds	r0, r4, #0
 800473e:	4906      	ldr	r1, [pc, #24]	; (8004758 <lpc43xx_cmd_mkboot+0x5c>)
 8004740:	f003 ff53 	bl	80085ea <tc_printf>
	return true;
 8004744:	2001      	movs	r0, #1
}
 8004746:	bd38      	pop	{r3, r4, r5, pc}
 8004748:	0801249f 	.word	0x0801249f
 800474c:	080124bf 	.word	0x080124bf
 8004750:	00002ee0 	.word	0x00002ee0
 8004754:	080124ea 	.word	0x080124ea
 8004758:	08012500 	.word	0x08012500

0800475c <lpc43xx_wdt_pet>:
	if (wdt_mode && !(wdt_mode & LPC43XX_WDT_PROTECT))
		target_mem_write32(t, LPC43XX_WDT_CNT, LPC43XX_WDT_PERIOD_MAX);
}

static void lpc43xx_wdt_pet(target *t)
{
 800475c:	b510      	push	{r4, lr}
	/* Check if WDT is on */
	uint32_t wdt_mode = target_mem_read32(t, LPC43XX_WDT_MODE);
 800475e:	4908      	ldr	r1, [pc, #32]	; (8004780 <lpc43xx_wdt_pet+0x24>)
	if (wdt_mode && !(wdt_mode & LPC43XX_WDT_PROTECT))
		target_mem_write32(t, LPC43XX_WDT_CNT, LPC43XX_WDT_PERIOD_MAX);
}

static void lpc43xx_wdt_pet(target *t)
{
 8004760:	1c04      	adds	r4, r0, #0
	/* Check if WDT is on */
	uint32_t wdt_mode = target_mem_read32(t, LPC43XX_WDT_MODE);
 8004762:	f003 fee3 	bl	800852c <target_mem_read32>

	/* If WDT on, pet */
	if (wdt_mode) {
 8004766:	2800      	cmp	r0, #0
 8004768:	d009      	beq.n	800477e <lpc43xx_wdt_pet+0x22>
		target_mem_write32(t, LPC43XX_WDT_FEED, 0xAA);
 800476a:	1c20      	adds	r0, r4, #0
 800476c:	4905      	ldr	r1, [pc, #20]	; (8004784 <lpc43xx_wdt_pet+0x28>)
 800476e:	22aa      	movs	r2, #170	; 0xaa
 8004770:	f003 fee4 	bl	800853c <target_mem_write32>
		target_mem_write32(t, LPC43XX_WDT_FEED, 0xFF);
 8004774:	1c20      	adds	r0, r4, #0
 8004776:	4903      	ldr	r1, [pc, #12]	; (8004784 <lpc43xx_wdt_pet+0x28>)
 8004778:	22ff      	movs	r2, #255	; 0xff
 800477a:	f003 fedf 	bl	800853c <target_mem_write32>
	}
}
 800477e:	bd10      	pop	{r4, pc}
 8004780:	40080000 	.word	0x40080000
 8004784:	40080008 	.word	0x40080008

08004788 <lpc43xx_add_flash>:
};

void lpc43xx_add_flash(target *t, uint32_t iap_entry,
                       uint8_t bank, uint8_t base_sector,
                       uint32_t addr, size_t len, size_t erasesize)
{
 8004788:	b570      	push	{r4, r5, r6, lr}
 800478a:	1c16      	adds	r6, r2, #0
 800478c:	1c0c      	adds	r4, r1, #0
	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
 800478e:	9a05      	ldr	r2, [sp, #20]
 8004790:	9904      	ldr	r1, [sp, #16]
};

void lpc43xx_add_flash(target *t, uint32_t iap_entry,
                       uint8_t bank, uint8_t base_sector,
                       uint32_t addr, size_t len, size_t erasesize)
{
 8004792:	1c1d      	adds	r5, r3, #0
	struct lpc_flash *lf = lpc_add_flash(t, addr, len);
 8004794:	f7ff fcb2 	bl	80040fc <lpc_add_flash>
	lf->f.erase = lpc43xx_flash_erase;
 8004798:	4b09      	ldr	r3, [pc, #36]	; (80047c0 <lpc43xx_add_flash+0x38>)
 800479a:	60c3      	str	r3, [r0, #12]
	lf->f.blocksize = erasesize;
 800479c:	9b06      	ldr	r3, [sp, #24]
 800479e:	6083      	str	r3, [r0, #8]
	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
 80047a0:	2380      	movs	r3, #128	; 0x80
 80047a2:	015b      	lsls	r3, r3, #5
 80047a4:	6283      	str	r3, [r0, #40]	; 0x28
	lf->bank = bank;
 80047a6:	1c03      	adds	r3, r0, #0
 80047a8:	3339      	adds	r3, #57	; 0x39
 80047aa:	701e      	strb	r6, [r3, #0]
	lf->base_sector = base_sector;
 80047ac:	3b01      	subs	r3, #1
 80047ae:	701d      	strb	r5, [r3, #0]
	lf->iap_entry = iap_entry;
	lf->iap_ram = IAP_RAM_BASE;
 80047b0:	4b04      	ldr	r3, [pc, #16]	; (80047c4 <lpc43xx_add_flash+0x3c>)
	lf->f.erase = lpc43xx_flash_erase;
	lf->f.blocksize = erasesize;
	lf->f.buf_size = IAP_PGM_CHUNKSIZE;
	lf->bank = bank;
	lf->base_sector = base_sector;
	lf->iap_entry = iap_entry;
 80047b2:	6404      	str	r4, [r0, #64]	; 0x40
	lf->iap_ram = IAP_RAM_BASE;
 80047b4:	6443      	str	r3, [r0, #68]	; 0x44
	lf->iap_msp = IAP_RAM_BASE + IAP_RAM_SIZE;
 80047b6:	4b04      	ldr	r3, [pc, #16]	; (80047c8 <lpc43xx_add_flash+0x40>)
 80047b8:	6483      	str	r3, [r0, #72]	; 0x48
	lf->wdt_kick = lpc43xx_wdt_pet;
 80047ba:	4b04      	ldr	r3, [pc, #16]	; (80047cc <lpc43xx_add_flash+0x44>)
 80047bc:	63c3      	str	r3, [r0, #60]	; 0x3c
}
 80047be:	bd70      	pop	{r4, r5, r6, pc}
 80047c0:	080046d9 	.word	0x080046d9
 80047c4:	2000c000 	.word	0x2000c000
 80047c8:	20010000 	.word	0x20010000
 80047cc:	0800475d 	.word	0x0800475d

080047d0 <lpc43xx_probe>:

bool lpc43xx_probe(target *t)
{
 80047d0:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t chipid, cpuid;
	uint32_t iap_entry;

	chipid = target_mem_read32(t, LPC43XX_CHIPID);
 80047d2:	4946      	ldr	r1, [pc, #280]	; (80048ec <lpc43xx_probe+0x11c>)
	lf->iap_msp = IAP_RAM_BASE + IAP_RAM_SIZE;
	lf->wdt_kick = lpc43xx_wdt_pet;
}

bool lpc43xx_probe(target *t)
{
 80047d4:	b085      	sub	sp, #20
 80047d6:	1c04      	adds	r4, r0, #0
	uint32_t chipid, cpuid;
	uint32_t iap_entry;

	chipid = target_mem_read32(t, LPC43XX_CHIPID);
 80047d8:	f003 fea8 	bl	800852c <target_mem_read32>
	cpuid = target_mem_read32(t, ARM_CPUID);
 80047dc:	4944      	ldr	r1, [pc, #272]	; (80048f0 <lpc43xx_probe+0x120>)
bool lpc43xx_probe(target *t)
{
	uint32_t chipid, cpuid;
	uint32_t iap_entry;

	chipid = target_mem_read32(t, LPC43XX_CHIPID);
 80047de:	1c05      	adds	r5, r0, #0
	cpuid = target_mem_read32(t, ARM_CPUID);
 80047e0:	1c20      	adds	r0, r4, #0
 80047e2:	f003 fea3 	bl	800852c <target_mem_read32>

	switch(chipid) {
 80047e6:	4b43      	ldr	r3, [pc, #268]	; (80048f4 <lpc43xx_probe+0x124>)
 80047e8:	429d      	cmp	r5, r3
 80047ea:	d06a      	beq.n	80048c2 <lpc43xx_probe+0xf2>
 80047ec:	d801      	bhi.n	80047f2 <lpc43xx_probe+0x22>
 80047ee:	4b42      	ldr	r3, [pc, #264]	; (80048f8 <lpc43xx_probe+0x128>)
 80047f0:	e003      	b.n	80047fa <lpc43xx_probe+0x2a>
 80047f2:	4b42      	ldr	r3, [pc, #264]	; (80048fc <lpc43xx_probe+0x12c>)
 80047f4:	429d      	cmp	r5, r3
 80047f6:	d064      	beq.n	80048c2 <lpc43xx_probe+0xf2>
 80047f8:	4b41      	ldr	r3, [pc, #260]	; (8004900 <lpc43xx_probe+0x130>)
 80047fa:	429d      	cmp	r5, r3
 80047fc:	d171      	bne.n	80048e2 <lpc43xx_probe+0x112>
	case 0x4906002B:	/* Parts with on-chip flash */
	case 0x7906002B:	/* LM43S?? - Undocumented? */
		switch (cpuid & 0xFF00FFF0) {
 80047fe:	4b41      	ldr	r3, [pc, #260]	; (8004904 <lpc43xx_probe+0x134>)
 8004800:	4a41      	ldr	r2, [pc, #260]	; (8004908 <lpc43xx_probe+0x138>)
 8004802:	4003      	ands	r3, r0
 8004804:	4293      	cmp	r3, r2
 8004806:	d066      	beq.n	80048d6 <lpc43xx_probe+0x106>
 8004808:	4a40      	ldr	r2, [pc, #256]	; (800490c <lpc43xx_probe+0x13c>)
 800480a:	4293      	cmp	r3, r2
 800480c:	d167      	bne.n	80048de <lpc43xx_probe+0x10e>
		case 0x4100C240:
			t->driver = "LPC43xx Cortex-M4";
 800480e:	4b40      	ldr	r3, [pc, #256]	; (8004910 <lpc43xx_probe+0x140>)
			t->driver = "LPC43xx Cortex-M0";
			break;
		default:
			t->driver = "LPC43xx <Unknown>";
		}
		return true;
 8004810:	2501      	movs	r5, #1
	switch(chipid) {
	case 0x4906002B:	/* Parts with on-chip flash */
	case 0x7906002B:	/* LM43S?? - Undocumented? */
		switch (cpuid & 0xFF00FFF0) {
		case 0x4100C240:
			t->driver = "LPC43xx Cortex-M4";
 8004812:	6623      	str	r3, [r4, #96]	; 0x60
			if (cpuid == 0x410FC241)
 8004814:	4b3f      	ldr	r3, [pc, #252]	; (8004914 <lpc43xx_probe+0x144>)
 8004816:	4298      	cmp	r0, r3
 8004818:	d164      	bne.n	80048e4 <lpc43xx_probe+0x114>
			{
				/* LPC4337 */
				iap_entry = target_mem_read32(t,
 800481a:	493f      	ldr	r1, [pc, #252]	; (8004918 <lpc43xx_probe+0x148>)
 800481c:	1c20      	adds	r0, r4, #0
				                  IAP_ENTRYPOINT_LOCATION);
				target_add_ram(t, 0, 0x1A000000);
 800481e:	27d0      	movs	r7, #208	; 0xd0
		case 0x4100C240:
			t->driver = "LPC43xx Cortex-M4";
			if (cpuid == 0x410FC241)
			{
				/* LPC4337 */
				iap_entry = target_mem_read32(t,
 8004820:	f003 fe84 	bl	800852c <target_mem_read32>
				                  IAP_ENTRYPOINT_LOCATION);
				target_add_ram(t, 0, 0x1A000000);
 8004824:	057f      	lsls	r7, r7, #21
		case 0x4100C240:
			t->driver = "LPC43xx Cortex-M4";
			if (cpuid == 0x410FC241)
			{
				/* LPC4337 */
				iap_entry = target_mem_read32(t,
 8004826:	1c06      	adds	r6, r0, #0
				                  IAP_ENTRYPOINT_LOCATION);
				target_add_ram(t, 0, 0x1A000000);
 8004828:	1c3a      	adds	r2, r7, #0
 800482a:	1c20      	adds	r0, r4, #0
 800482c:	2100      	movs	r1, #0
 800482e:	f003 fc81 	bl	8008134 <target_add_ram>
				lpc43xx_add_flash(t, iap_entry, 0, 0,
 8004832:	9700      	str	r7, [sp, #0]
 8004834:	2380      	movs	r3, #128	; 0x80
 8004836:	2780      	movs	r7, #128	; 0x80
 8004838:	2200      	movs	r2, #0
 800483a:	027f      	lsls	r7, r7, #9
 800483c:	019b      	lsls	r3, r3, #6
 800483e:	9302      	str	r3, [sp, #8]
 8004840:	1c20      	adds	r0, r4, #0
 8004842:	1c13      	adds	r3, r2, #0
 8004844:	1c31      	adds	r1, r6, #0
 8004846:	9701      	str	r7, [sp, #4]
 8004848:	f7ff ff9e 	bl	8004788 <lpc43xx_add_flash>
				                  0x1A000000, 0x10000, 0x2000);
				lpc43xx_add_flash(t, iap_entry, 0, 8,
 800484c:	4b33      	ldr	r3, [pc, #204]	; (800491c <lpc43xx_probe+0x14c>)
 800484e:	1c20      	adds	r0, r4, #0
 8004850:	9300      	str	r3, [sp, #0]
 8004852:	23e0      	movs	r3, #224	; 0xe0
 8004854:	02db      	lsls	r3, r3, #11
 8004856:	9301      	str	r3, [sp, #4]
 8004858:	1c31      	adds	r1, r6, #0
 800485a:	2308      	movs	r3, #8
 800485c:	2200      	movs	r2, #0
 800485e:	9702      	str	r7, [sp, #8]
 8004860:	f7ff ff92 	bl	8004788 <lpc43xx_add_flash>
				                  0x1A010000, 0x70000, 0x10000);
				target_add_ram(t, 0x1A080000, 0xF80000);
 8004864:	22f8      	movs	r2, #248	; 0xf8
 8004866:	1c20      	adds	r0, r4, #0
 8004868:	492d      	ldr	r1, [pc, #180]	; (8004920 <lpc43xx_probe+0x150>)
 800486a:	0412      	lsls	r2, r2, #16
 800486c:	f003 fc62 	bl	8008134 <target_add_ram>
				lpc43xx_add_flash(t, iap_entry, 1, 0,
 8004870:	23d8      	movs	r3, #216	; 0xd8
 8004872:	055b      	lsls	r3, r3, #21
 8004874:	9300      	str	r3, [sp, #0]
 8004876:	2380      	movs	r3, #128	; 0x80
 8004878:	019b      	lsls	r3, r3, #6
 800487a:	9302      	str	r3, [sp, #8]
 800487c:	1c20      	adds	r0, r4, #0
 800487e:	1c31      	adds	r1, r6, #0
 8004880:	1c2a      	adds	r2, r5, #0
 8004882:	2300      	movs	r3, #0
 8004884:	9701      	str	r7, [sp, #4]
 8004886:	f7ff ff7f 	bl	8004788 <lpc43xx_add_flash>
				                  0x1B000000, 0x10000, 0x2000);
				lpc43xx_add_flash(t, iap_entry, 1, 8,
 800488a:	4b26      	ldr	r3, [pc, #152]	; (8004924 <lpc43xx_probe+0x154>)
 800488c:	1c20      	adds	r0, r4, #0
 800488e:	9300      	str	r3, [sp, #0]
 8004890:	23e0      	movs	r3, #224	; 0xe0
 8004892:	02db      	lsls	r3, r3, #11
 8004894:	9301      	str	r3, [sp, #4]
 8004896:	1c31      	adds	r1, r6, #0
 8004898:	2308      	movs	r3, #8
 800489a:	1c2a      	adds	r2, r5, #0
 800489c:	9702      	str	r7, [sp, #8]
 800489e:	f7ff ff73 	bl	8004788 <lpc43xx_add_flash>
				                  0x1B010000, 0x70000, 0x10000);
				target_add_commands(t, lpc43xx_cmd_list, "LPC43xx");
 80048a2:	4921      	ldr	r1, [pc, #132]	; (8004928 <lpc43xx_probe+0x158>)
 80048a4:	1c20      	adds	r0, r4, #0
 80048a6:	3104      	adds	r1, #4
 80048a8:	4a20      	ldr	r2, [pc, #128]	; (800492c <lpc43xx_probe+0x15c>)
 80048aa:	f003 fc03 	bl	80080b4 <target_add_commands>
				target_add_ram(t, 0x1B080000, 0xE4F80000UL);
 80048ae:	4a20      	ldr	r2, [pc, #128]	; (8004930 <lpc43xx_probe+0x160>)
 80048b0:	1c20      	adds	r0, r4, #0
 80048b2:	4920      	ldr	r1, [pc, #128]	; (8004934 <lpc43xx_probe+0x164>)
 80048b4:	f003 fc3e 	bl	8008134 <target_add_ram>
				t->target_options |= CORTEXM_TOPT_INHIBIT_SRST;
 80048b8:	2304      	movs	r3, #4
 80048ba:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80048bc:	4313      	orrs	r3, r2
 80048be:	64e3      	str	r3, [r4, #76]	; 0x4c
 80048c0:	e010      	b.n	80048e4 <lpc43xx_probe+0x114>
			t->driver = "LPC43xx <Unknown>";
		}
		return true;
	case 0x5906002B:	/* Flashless parts */
	case 0x6906002B:
		switch (cpuid & 0xFF00FFF0) {
 80048c2:	4b10      	ldr	r3, [pc, #64]	; (8004904 <lpc43xx_probe+0x134>)
 80048c4:	4018      	ands	r0, r3
 80048c6:	4b10      	ldr	r3, [pc, #64]	; (8004908 <lpc43xx_probe+0x138>)
 80048c8:	4298      	cmp	r0, r3
 80048ca:	d004      	beq.n	80048d6 <lpc43xx_probe+0x106>
 80048cc:	4b0f      	ldr	r3, [pc, #60]	; (800490c <lpc43xx_probe+0x13c>)
 80048ce:	4298      	cmp	r0, r3
 80048d0:	d105      	bne.n	80048de <lpc43xx_probe+0x10e>
		case 0x4100C240:
			t->driver = "LPC43xx Cortex-M4";
 80048d2:	4b0f      	ldr	r3, [pc, #60]	; (8004910 <lpc43xx_probe+0x140>)
 80048d4:	e000      	b.n	80048d8 <lpc43xx_probe+0x108>
			break;
		case 0x4100C200:
			t->driver = "LPC43xx Cortex-M0";
 80048d6:	4b18      	ldr	r3, [pc, #96]	; (8004938 <lpc43xx_probe+0x168>)
 80048d8:	6623      	str	r3, [r4, #96]	; 0x60
			break;
		default:
			t->driver = "LPC43xx <Unknown>";
		}
		return true;
 80048da:	2501      	movs	r5, #1
		case 0x4100C240:
			t->driver = "LPC43xx Cortex-M4";
			break;
		case 0x4100C200:
			t->driver = "LPC43xx Cortex-M0";
			break;
 80048dc:	e002      	b.n	80048e4 <lpc43xx_probe+0x114>
		default:
			t->driver = "LPC43xx <Unknown>";
 80048de:	4b17      	ldr	r3, [pc, #92]	; (800493c <lpc43xx_probe+0x16c>)
 80048e0:	e7fa      	b.n	80048d8 <lpc43xx_probe+0x108>
		}
		return true;
	}

	return false;
 80048e2:	2500      	movs	r5, #0
}
 80048e4:	1c28      	adds	r0, r5, #0
 80048e6:	b005      	add	sp, #20
 80048e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80048ea:	46c0      	nop			; (mov r8, r8)
 80048ec:	40043200 	.word	0x40043200
 80048f0:	e000ed00 	.word	0xe000ed00
 80048f4:	5906002b 	.word	0x5906002b
 80048f8:	4906002b 	.word	0x4906002b
 80048fc:	6906002b 	.word	0x6906002b
 8004900:	7906002b 	.word	0x7906002b
 8004904:	ff00fff0 	.word	0xff00fff0
 8004908:	4100c200 	.word	0x4100c200
 800490c:	4100c240 	.word	0x4100c240
 8004910:	08012512 	.word	0x08012512
 8004914:	410fc241 	.word	0x410fc241
 8004918:	10400100 	.word	0x10400100
 800491c:	1a010000 	.word	0x1a010000
 8004920:	1a080000 	.word	0x1a080000
 8004924:	1b010000 	.word	0x1b010000
 8004928:	08012460 	.word	0x08012460
 800492c:	08012524 	.word	0x08012524
 8004930:	e4f80000 	.word	0xe4f80000
 8004934:	1b080000 	.word	0x1b080000
 8004938:	0801252c 	.word	0x0801252c
 800493c:	0801253e 	.word	0x0801253e

08004940 <kl_gen_command>:
	return false;
}

static bool
kl_gen_command(target *t, uint8_t cmd, uint32_t addr, const uint8_t data[8])
{
 8004940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004942:	1c0f      	adds	r7, r1, #0
 8004944:	1c15      	adds	r5, r2, #0
	uint8_t fstat;

	/* clear errors unconditionally, so we can start a new operation */
	target_mem_write8(t,FTFA_FSTAT,(FTFA_FSTAT_ACCERR | FTFA_FSTAT_FPVIOL));
 8004946:	4919      	ldr	r1, [pc, #100]	; (80049ac <kl_gen_command+0x6c>)
 8004948:	2230      	movs	r2, #48	; 0x30
	return false;
}

static bool
kl_gen_command(target *t, uint8_t cmd, uint32_t addr, const uint8_t data[8])
{
 800494a:	1c04      	adds	r4, r0, #0
 800494c:	1c1e      	adds	r6, r3, #0
	uint8_t fstat;

	/* clear errors unconditionally, so we can start a new operation */
	target_mem_write8(t,FTFA_FSTAT,(FTFA_FSTAT_ACCERR | FTFA_FSTAT_FPVIOL));
 800494e:	f003 fe19 	bl	8008584 <target_mem_write8>

	/* Wait for CCIF to be high */
	do {
		fstat = target_mem_read8(t, FTFA_FSTAT);
 8004952:	1c20      	adds	r0, r4, #0
 8004954:	4915      	ldr	r1, [pc, #84]	; (80049ac <kl_gen_command+0x6c>)
 8004956:	f003 fe0b 	bl	8008570 <target_mem_read8>
	} while (!(fstat & FTFA_FSTAT_CCIF));
 800495a:	0603      	lsls	r3, r0, #24
 800495c:	d5f9      	bpl.n	8004952 <kl_gen_command+0x12>

	/* Write command to FCCOB */
	addr &= 0xffffff;
 800495e:	022d      	lsls	r5, r5, #8
 8004960:	0a2d      	lsrs	r5, r5, #8
	addr |= (uint32_t)cmd << 24;
 8004962:	063a      	lsls	r2, r7, #24
 8004964:	432a      	orrs	r2, r5
	target_mem_write32(t, FTFA_FCCOB_0, addr);
 8004966:	1c20      	adds	r0, r4, #0
 8004968:	4911      	ldr	r1, [pc, #68]	; (80049b0 <kl_gen_command+0x70>)
 800496a:	f003 fde7 	bl	800853c <target_mem_write32>
	if (data) {
 800496e:	2e00      	cmp	r6, #0
 8004970:	d009      	beq.n	8004986 <kl_gen_command+0x46>
		target_mem_write32(t, FTFA_FCCOB_1, *(uint32_t*)&data[0]);
 8004972:	1c20      	adds	r0, r4, #0
 8004974:	490f      	ldr	r1, [pc, #60]	; (80049b4 <kl_gen_command+0x74>)
 8004976:	6832      	ldr	r2, [r6, #0]
 8004978:	f003 fde0 	bl	800853c <target_mem_write32>
		target_mem_write32(t, FTFA_FCCOB_2, *(uint32_t*)&data[4]);
 800497c:	1c20      	adds	r0, r4, #0
 800497e:	490e      	ldr	r1, [pc, #56]	; (80049b8 <kl_gen_command+0x78>)
 8004980:	6872      	ldr	r2, [r6, #4]
 8004982:	f003 fddb 	bl	800853c <target_mem_write32>
	}

	/* Enable execution by clearing CCIF */
	target_mem_write8(t, FTFA_FSTAT, FTFA_FSTAT_CCIF);
 8004986:	1c20      	adds	r0, r4, #0
 8004988:	4908      	ldr	r1, [pc, #32]	; (80049ac <kl_gen_command+0x6c>)
 800498a:	2280      	movs	r2, #128	; 0x80
 800498c:	f003 fdfa 	bl	8008584 <target_mem_write8>

	/* Wait for execution to complete */
	do {
		fstat = target_mem_read8(t, FTFA_FSTAT);
 8004990:	1c20      	adds	r0, r4, #0
 8004992:	4906      	ldr	r1, [pc, #24]	; (80049ac <kl_gen_command+0x6c>)
 8004994:	f003 fdec 	bl	8008570 <target_mem_read8>
		/* Check ACCERR and FPVIOL are zero in FSTAT */
		if (fstat & (FTFA_FSTAT_ACCERR | FTFA_FSTAT_FPVIOL))
 8004998:	2330      	movs	r3, #48	; 0x30
 800499a:	4218      	tst	r0, r3
 800499c:	d103      	bne.n	80049a6 <kl_gen_command+0x66>
			return false;
	} while (!(fstat & FTFA_FSTAT_CCIF));
 800499e:	0603      	lsls	r3, r0, #24
 80049a0:	d5f6      	bpl.n	8004990 <kl_gen_command+0x50>

	return true;
 80049a2:	2001      	movs	r0, #1
 80049a4:	e000      	b.n	80049a8 <kl_gen_command+0x68>
	/* Wait for execution to complete */
	do {
		fstat = target_mem_read8(t, FTFA_FSTAT);
		/* Check ACCERR and FPVIOL are zero in FSTAT */
		if (fstat & (FTFA_FSTAT_ACCERR | FTFA_FSTAT_FPVIOL))
			return false;
 80049a6:	2000      	movs	r0, #0
	} while (!(fstat & FTFA_FSTAT_CCIF));

	return true;
}
 80049a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80049aa:	46c0      	nop			; (mov r8, r8)
 80049ac:	40020000 	.word	0x40020000
 80049b0:	40020004 	.word	0x40020004
 80049b4:	40020008 	.word	0x40020008
 80049b8:	4002000c 	.word	0x4002000c

080049bc <kl_gen_flash_write>:
	return 0;
}

static int kl_gen_flash_write(struct target_flash *f,
                              target_addr dest, const void *src, size_t len)
{
 80049bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80049be:	1c07      	adds	r7, r0, #0
 80049c0:	1c0e      	adds	r6, r1, #0
 80049c2:	1c15      	adds	r5, r2, #0
	while (len) {
 80049c4:	1c14      	adds	r4, r2, #0
	return 0;
}

static int kl_gen_flash_write(struct target_flash *f,
                              target_addr dest, const void *src, size_t len)
{
 80049c6:	9301      	str	r3, [sp, #4]
 80049c8:	9b01      	ldr	r3, [sp, #4]
 80049ca:	1b72      	subs	r2, r6, r5
 80049cc:	1b18      	subs	r0, r3, r4
 80049ce:	1828      	adds	r0, r5, r0
 80049d0:	18a2      	adds	r2, r4, r2
	while (len) {
 80049d2:	2800      	cmp	r0, #0
 80049d4:	d009      	beq.n	80049ea <kl_gen_flash_write+0x2e>
		if (kl_gen_command(f->t, FTFA_CMD_PROGRAM_LONGWORD, dest, src)) {
 80049d6:	69b8      	ldr	r0, [r7, #24]
 80049d8:	2106      	movs	r1, #6
 80049da:	1c23      	adds	r3, r4, #0
 80049dc:	f7ff ffb0 	bl	8004940 <kl_gen_command>
 80049e0:	2800      	cmp	r0, #0
 80049e2:	d001      	beq.n	80049e8 <kl_gen_flash_write+0x2c>
			len -= 4;
			dest += 4;
			src += 4;
 80049e4:	3404      	adds	r4, #4
 80049e6:	e7ef      	b.n	80049c8 <kl_gen_flash_write+0xc>
		} else {
			return 1;
 80049e8:	2001      	movs	r0, #1
		}
	}
	return 0;
}
 80049ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080049ec <kl_gen_flash_erase>:

	return true;
}

static int kl_gen_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 80049ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80049ee:	1c07      	adds	r7, r0, #0
 80049f0:	1c0e      	adds	r6, r1, #0
 80049f2:	1c15      	adds	r5, r2, #0
	while (len) {
 80049f4:	1c14      	adds	r4, r2, #0
 80049f6:	1972      	adds	r2, r6, r5
 80049f8:	1b12      	subs	r2, r2, r4
 80049fa:	2c00      	cmp	r4, #0
 80049fc:	d009      	beq.n	8004a12 <kl_gen_flash_erase+0x26>
		if (kl_gen_command(f->t, FTFA_CMD_ERASE_SECTOR, addr, NULL)) {
 80049fe:	69b8      	ldr	r0, [r7, #24]
 8004a00:	2109      	movs	r1, #9
 8004a02:	2300      	movs	r3, #0
 8004a04:	f7ff ff9c 	bl	8004940 <kl_gen_command>
 8004a08:	2800      	cmp	r0, #0
 8004a0a:	d004      	beq.n	8004a16 <kl_gen_flash_erase+0x2a>
			len -= KL_GEN_PAGESIZE;
 8004a0c:	4b03      	ldr	r3, [pc, #12]	; (8004a1c <kl_gen_flash_erase+0x30>)
 8004a0e:	18e4      	adds	r4, r4, r3
 8004a10:	e7f1      	b.n	80049f6 <kl_gen_flash_erase+0xa>
			addr += KL_GEN_PAGESIZE;
		} else {
			return 1;
		}
	}
	return 0;
 8004a12:	1c20      	adds	r0, r4, #0
 8004a14:	e000      	b.n	8004a18 <kl_gen_flash_erase+0x2c>
	while (len) {
		if (kl_gen_command(f->t, FTFA_CMD_ERASE_SECTOR, addr, NULL)) {
			len -= KL_GEN_PAGESIZE;
			addr += KL_GEN_PAGESIZE;
		} else {
			return 1;
 8004a16:	2001      	movs	r0, #1
		}
	}
	return 0;
}
 8004a18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004a1a:	46c0      	nop			; (mov r8, r8)
 8004a1c:	fffffc00 	.word	0xfffffc00

08004a20 <kl_gen_add_flash.constprop.0>:

static int kl_gen_flash_erase(struct target_flash *f, target_addr addr, size_t len);
static int kl_gen_flash_write(struct target_flash *f,
                              target_addr dest, const void *src, size_t len);

static void kl_gen_add_flash(target *t,
 8004a20:	b538      	push	{r3, r4, r5, lr}
 8004a22:	1c0d      	adds	r5, r1, #0
 8004a24:	1c04      	adds	r4, r0, #0
                           uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8004a26:	2138      	movs	r1, #56	; 0x38
 8004a28:	2001      	movs	r0, #1
 8004a2a:	f007 ff25 	bl	800c878 <calloc>
	f->start = addr;
 8004a2e:	2300      	movs	r3, #0
 8004a30:	6003      	str	r3, [r0, #0]
	f->length = length;
	f->blocksize = erasesize;
 8004a32:	2380      	movs	r3, #128	; 0x80
 8004a34:	00db      	lsls	r3, r3, #3
 8004a36:	6083      	str	r3, [r0, #8]
	f->erase = kl_gen_flash_erase;
 8004a38:	4b07      	ldr	r3, [pc, #28]	; (8004a58 <kl_gen_add_flash.constprop.0+0x38>)
	f->write = kl_gen_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8004a3a:	22ff      	movs	r2, #255	; 0xff
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
	f->erase = kl_gen_flash_erase;
 8004a3c:	60c3      	str	r3, [r0, #12]
	f->write = kl_gen_flash_write;
 8004a3e:	4b07      	ldr	r3, [pc, #28]	; (8004a5c <kl_gen_add_flash.constprop.0+0x3c>)
static void kl_gen_add_flash(target *t,
                           uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
 8004a40:	6045      	str	r5, [r0, #4]
	f->blocksize = erasesize;
	f->erase = kl_gen_flash_erase;
	f->write = kl_gen_flash_write;
 8004a42:	6103      	str	r3, [r0, #16]
	f->align = 4;
 8004a44:	2304      	movs	r3, #4
 8004a46:	6203      	str	r3, [r0, #32]
	f->erased = 0xff;
 8004a48:	1d43      	adds	r3, r0, #5
                              target_addr dest, const void *src, size_t len);

static void kl_gen_add_flash(target *t,
                           uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8004a4a:	1c01      	adds	r1, r0, #0
	f->length = length;
	f->blocksize = erasesize;
	f->erase = kl_gen_flash_erase;
	f->write = kl_gen_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8004a4c:	77da      	strb	r2, [r3, #31]
	target_add_flash(t, f);
 8004a4e:	1c20      	adds	r0, r4, #0
 8004a50:	f003 fb7d 	bl	800814e <target_add_flash>
}
 8004a54:	bd38      	pop	{r3, r4, r5, pc}
 8004a56:	46c0      	nop			; (mov r8, r8)
 8004a58:	080049ed 	.word	0x080049ed
 8004a5c:	080049bd 	.word	0x080049bd

08004a60 <kinetis_probe>:

bool kinetis_probe(target *t)
{
 8004a60:	b538      	push	{r3, r4, r5, lr}
	uint32_t sdid = target_mem_read32(t, SIM_SDID);
 8004a62:	493b      	ldr	r1, [pc, #236]	; (8004b50 <kinetis_probe+0xf0>)
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool kinetis_probe(target *t)
{
 8004a64:	1c04      	adds	r4, r0, #0
	uint32_t sdid = target_mem_read32(t, SIM_SDID);
 8004a66:	f003 fd61 	bl	800852c <target_mem_read32>
	switch (sdid >> 20) {
 8004a6a:	4a3a      	ldr	r2, [pc, #232]	; (8004b54 <kinetis_probe+0xf4>)
 8004a6c:	0d03      	lsrs	r3, r0, #20
 8004a6e:	4293      	cmp	r3, r2
 8004a70:	d01b      	beq.n	8004aaa <kinetis_probe+0x4a>
 8004a72:	4a39      	ldr	r2, [pc, #228]	; (8004b58 <kinetis_probe+0xf8>)
 8004a74:	4293      	cmp	r3, r2
 8004a76:	d002      	beq.n	8004a7e <kinetis_probe+0x1e>
 8004a78:	2b21      	cmp	r3, #33	; 0x21
 8004a7a:	d167      	bne.n	8004b4c <kinetis_probe+0xec>
 8004a7c:	e028      	b.n	8004ad0 <kinetis_probe+0x70>
	case 0x251:
		t->driver = "KL25";
		target_add_ram(t, 0x1ffff000, 0x1000);
 8004a7e:	2280      	movs	r2, #128	; 0x80
bool kinetis_probe(target *t)
{
	uint32_t sdid = target_mem_read32(t, SIM_SDID);
	switch (sdid >> 20) {
	case 0x251:
		t->driver = "KL25";
 8004a80:	4b36      	ldr	r3, [pc, #216]	; (8004b5c <kinetis_probe+0xfc>)
		target_add_ram(t, 0x1ffff000, 0x1000);
 8004a82:	1c20      	adds	r0, r4, #0
bool kinetis_probe(target *t)
{
	uint32_t sdid = target_mem_read32(t, SIM_SDID);
	switch (sdid >> 20) {
	case 0x251:
		t->driver = "KL25";
 8004a84:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x1ffff000, 0x1000);
 8004a86:	4936      	ldr	r1, [pc, #216]	; (8004b60 <kinetis_probe+0x100>)
 8004a88:	0152      	lsls	r2, r2, #5
 8004a8a:	f003 fb53 	bl	8008134 <target_add_ram>
		target_add_ram(t, 0x20000000, 0x3000);
 8004a8e:	2180      	movs	r1, #128	; 0x80
 8004a90:	22c0      	movs	r2, #192	; 0xc0
 8004a92:	1c20      	adds	r0, r4, #0
 8004a94:	0589      	lsls	r1, r1, #22
 8004a96:	0192      	lsls	r2, r2, #6
 8004a98:	f003 fb4c 	bl	8008134 <target_add_ram>
		kl_gen_add_flash(t, 0x00000000, 0x20000, 0x400);
 8004a9c:	2180      	movs	r1, #128	; 0x80
 8004a9e:	1c20      	adds	r0, r4, #0
 8004aa0:	0289      	lsls	r1, r1, #10
 8004aa2:	f7ff ffbd 	bl	8004a20 <kl_gen_add_flash.constprop.0>
		return true;
 8004aa6:	2001      	movs	r0, #1
 8004aa8:	e051      	b.n	8004b4e <kinetis_probe+0xee>
	case 0x231:
		t->driver = "KL27";
		target_add_ram(t, 0x1fffe000, 0x2000);
 8004aaa:	2280      	movs	r2, #128	; 0x80
		target_add_ram(t, 0x1ffff000, 0x1000);
		target_add_ram(t, 0x20000000, 0x3000);
		kl_gen_add_flash(t, 0x00000000, 0x20000, 0x400);
		return true;
	case 0x231:
		t->driver = "KL27";
 8004aac:	4b2d      	ldr	r3, [pc, #180]	; (8004b64 <kinetis_probe+0x104>)
		target_add_ram(t, 0x1fffe000, 0x2000);
 8004aae:	1c20      	adds	r0, r4, #0
		target_add_ram(t, 0x1ffff000, 0x1000);
		target_add_ram(t, 0x20000000, 0x3000);
		kl_gen_add_flash(t, 0x00000000, 0x20000, 0x400);
		return true;
	case 0x231:
		t->driver = "KL27";
 8004ab0:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x1fffe000, 0x2000);
 8004ab2:	492d      	ldr	r1, [pc, #180]	; (8004b68 <kinetis_probe+0x108>)
 8004ab4:	0192      	lsls	r2, r2, #6
 8004ab6:	f003 fb3d 	bl	8008134 <target_add_ram>
		target_add_ram(t, 0x20000000, 0x6000);
 8004aba:	2180      	movs	r1, #128	; 0x80
 8004abc:	22c0      	movs	r2, #192	; 0xc0
 8004abe:	1c20      	adds	r0, r4, #0
 8004ac0:	0589      	lsls	r1, r1, #22
 8004ac2:	01d2      	lsls	r2, r2, #7
 8004ac4:	f003 fb36 	bl	8008134 <target_add_ram>
		kl_gen_add_flash(t, 0x00000000, 0x40000, 0x400);
 8004ac8:	2180      	movs	r1, #128	; 0x80
 8004aca:	1c20      	adds	r0, r4, #0
 8004acc:	02c9      	lsls	r1, r1, #11
 8004ace:	e7e8      	b.n	8004aa2 <kinetis_probe+0x42>
		return true;
	case 0x021: /* KL02 family */
		switch((sdid>>16) & 0x0f){
 8004ad0:	0300      	lsls	r0, r0, #12
 8004ad2:	0f05      	lsrs	r5, r0, #28
 8004ad4:	2d02      	cmp	r5, #2
 8004ad6:	d027      	beq.n	8004b28 <kinetis_probe+0xc8>
 8004ad8:	2d03      	cmp	r5, #3
 8004ada:	d013      	beq.n	8004b04 <kinetis_probe+0xa4>
 8004adc:	2d01      	cmp	r5, #1
 8004ade:	d135      	bne.n	8004b4c <kinetis_probe+0xec>
				target_add_ram(t, 0x20000000, 0x600);
				kl_gen_add_flash(t, 0x00000000, 0x3FFF, 0x400);
				break;
			case 1:
				t->driver = "KL02x8";
				target_add_ram(t, 0x1FFFFF00, 0x100);
 8004ae0:	2280      	movs	r2, #128	; 0x80
				target_add_ram(t, 0x1FFFFE00, 0x200);
				target_add_ram(t, 0x20000000, 0x600);
				kl_gen_add_flash(t, 0x00000000, 0x3FFF, 0x400);
				break;
			case 1:
				t->driver = "KL02x8";
 8004ae2:	4b22      	ldr	r3, [pc, #136]	; (8004b6c <kinetis_probe+0x10c>)
				target_add_ram(t, 0x1FFFFF00, 0x100);
 8004ae4:	1c20      	adds	r0, r4, #0
				target_add_ram(t, 0x1FFFFE00, 0x200);
				target_add_ram(t, 0x20000000, 0x600);
				kl_gen_add_flash(t, 0x00000000, 0x3FFF, 0x400);
				break;
			case 1:
				t->driver = "KL02x8";
 8004ae6:	6623      	str	r3, [r4, #96]	; 0x60
				target_add_ram(t, 0x1FFFFF00, 0x100);
 8004ae8:	4921      	ldr	r1, [pc, #132]	; (8004b70 <kinetis_probe+0x110>)
 8004aea:	0052      	lsls	r2, r2, #1
 8004aec:	f003 fb22 	bl	8008134 <target_add_ram>
				target_add_ram(t, 0x20000000, 0x300);
 8004af0:	2180      	movs	r1, #128	; 0x80
 8004af2:	22c0      	movs	r2, #192	; 0xc0
 8004af4:	1c20      	adds	r0, r4, #0
 8004af6:	0589      	lsls	r1, r1, #22
 8004af8:	0092      	lsls	r2, r2, #2
 8004afa:	f003 fb1b 	bl	8008134 <target_add_ram>
				kl_gen_add_flash(t, 0x00000000, 0x1FFF, 0x400);
 8004afe:	1c20      	adds	r0, r4, #0
 8004b00:	491c      	ldr	r1, [pc, #112]	; (8004b74 <kinetis_probe+0x114>)
 8004b02:	e7ce      	b.n	8004aa2 <kinetis_probe+0x42>
		return true;
	case 0x021: /* KL02 family */
		switch((sdid>>16) & 0x0f){
			case 3:
				t->driver = "KL02x32";
				target_add_ram(t, 0x1FFFFC00, 0x400);
 8004b04:	2280      	movs	r2, #128	; 0x80
		kl_gen_add_flash(t, 0x00000000, 0x40000, 0x400);
		return true;
	case 0x021: /* KL02 family */
		switch((sdid>>16) & 0x0f){
			case 3:
				t->driver = "KL02x32";
 8004b06:	4b1c      	ldr	r3, [pc, #112]	; (8004b78 <kinetis_probe+0x118>)
				target_add_ram(t, 0x1FFFFC00, 0x400);
 8004b08:	1c20      	adds	r0, r4, #0
		kl_gen_add_flash(t, 0x00000000, 0x40000, 0x400);
		return true;
	case 0x021: /* KL02 family */
		switch((sdid>>16) & 0x0f){
			case 3:
				t->driver = "KL02x32";
 8004b0a:	6623      	str	r3, [r4, #96]	; 0x60
				target_add_ram(t, 0x1FFFFC00, 0x400);
 8004b0c:	491b      	ldr	r1, [pc, #108]	; (8004b7c <kinetis_probe+0x11c>)
 8004b0e:	00d2      	lsls	r2, r2, #3
 8004b10:	f003 fb10 	bl	8008134 <target_add_ram>
				target_add_ram(t, 0x20000000, 0xc00);
 8004b14:	2180      	movs	r1, #128	; 0x80
 8004b16:	22c0      	movs	r2, #192	; 0xc0
 8004b18:	1c20      	adds	r0, r4, #0
 8004b1a:	0589      	lsls	r1, r1, #22
 8004b1c:	0112      	lsls	r2, r2, #4
 8004b1e:	f003 fb09 	bl	8008134 <target_add_ram>
				kl_gen_add_flash(t, 0x00000000, 0x7FFF, 0x400);
 8004b22:	1c20      	adds	r0, r4, #0
 8004b24:	4916      	ldr	r1, [pc, #88]	; (8004b80 <kinetis_probe+0x120>)
 8004b26:	e7bc      	b.n	8004aa2 <kinetis_probe+0x42>
				break;
			case 2:
				t->driver = "KL02x16";
				target_add_ram(t, 0x1FFFFE00, 0x200);
 8004b28:	2280      	movs	r2, #128	; 0x80
				target_add_ram(t, 0x1FFFFC00, 0x400);
				target_add_ram(t, 0x20000000, 0xc00);
				kl_gen_add_flash(t, 0x00000000, 0x7FFF, 0x400);
				break;
			case 2:
				t->driver = "KL02x16";
 8004b2a:	4b16      	ldr	r3, [pc, #88]	; (8004b84 <kinetis_probe+0x124>)
				target_add_ram(t, 0x1FFFFE00, 0x200);
 8004b2c:	1c20      	adds	r0, r4, #0
				target_add_ram(t, 0x1FFFFC00, 0x400);
				target_add_ram(t, 0x20000000, 0xc00);
				kl_gen_add_flash(t, 0x00000000, 0x7FFF, 0x400);
				break;
			case 2:
				t->driver = "KL02x16";
 8004b2e:	6623      	str	r3, [r4, #96]	; 0x60
				target_add_ram(t, 0x1FFFFE00, 0x200);
 8004b30:	4915      	ldr	r1, [pc, #84]	; (8004b88 <kinetis_probe+0x128>)
 8004b32:	0092      	lsls	r2, r2, #2
 8004b34:	f003 fafe 	bl	8008134 <target_add_ram>
				target_add_ram(t, 0x20000000, 0x600);
 8004b38:	2180      	movs	r1, #128	; 0x80
 8004b3a:	22c0      	movs	r2, #192	; 0xc0
 8004b3c:	1c20      	adds	r0, r4, #0
 8004b3e:	0589      	lsls	r1, r1, #22
 8004b40:	00d2      	lsls	r2, r2, #3
 8004b42:	f003 faf7 	bl	8008134 <target_add_ram>
				kl_gen_add_flash(t, 0x00000000, 0x3FFF, 0x400);
 8004b46:	1c20      	adds	r0, r4, #0
 8004b48:	4910      	ldr	r1, [pc, #64]	; (8004b8c <kinetis_probe+0x12c>)
 8004b4a:	e7aa      	b.n	8004aa2 <kinetis_probe+0x42>
				target_add_ram(t, 0x1FFFFF00, 0x100);
				target_add_ram(t, 0x20000000, 0x300);
				kl_gen_add_flash(t, 0x00000000, 0x1FFF, 0x400);
				break;
			default:
				return false;
 8004b4c:	2000      	movs	r0, #0
			}
		return true;
	}
	return false;
}
 8004b4e:	bd38      	pop	{r3, r4, r5, pc}
 8004b50:	40048024 	.word	0x40048024
 8004b54:	00000231 	.word	0x00000231
 8004b58:	00000251 	.word	0x00000251
 8004b5c:	0801257d 	.word	0x0801257d
 8004b60:	1ffff000 	.word	0x1ffff000
 8004b64:	08012582 	.word	0x08012582
 8004b68:	1fffe000 	.word	0x1fffe000
 8004b6c:	08012597 	.word	0x08012597
 8004b70:	1fffff00 	.word	0x1fffff00
 8004b74:	00001fff 	.word	0x00001fff
 8004b78:	08012587 	.word	0x08012587
 8004b7c:	1ffffc00 	.word	0x1ffffc00
 8004b80:	00007fff 	.word	0x00007fff
 8004b84:	0801258f 	.word	0x0801258f
 8004b88:	1ffffe00 	.word	0x1ffffe00
 8004b8c:	00003fff 	.word	0x00003fff

08004b90 <main>:
#include "gdb_packet.h"
#include "morse.h"

int
main(int argc, char **argv)
{
 8004b90:	b530      	push	{r4, r5, lr}
 8004b92:	b09d      	sub	sp, #116	; 0x74
#if defined(LIBFTDI)
	platform_init(argc, argv);
#else
	(void) argc;
	(void) argv;
	platform_init();
 8004b94:	f000 fcac 	bl	80054f0 <platform_init>
#endif

	while (true) {
		volatile struct exception e;
		TRY_CATCH(e, EXCEPTION_ALL) {
 8004b98:	2200      	movs	r2, #0
 8004b9a:	9201      	str	r2, [sp, #4]
 8004b9c:	3a01      	subs	r2, #1
 8004b9e:	9203      	str	r2, [sp, #12]
 8004ba0:	4a10      	ldr	r2, [pc, #64]	; (8004be4 <main+0x54>)
 8004ba2:	ab01      	add	r3, sp, #4
 8004ba4:	6811      	ldr	r1, [r2, #0]
 8004ba6:	a804      	add	r0, sp, #16
 8004ba8:	911b      	str	r1, [sp, #108]	; 0x6c
 8004baa:	6013      	str	r3, [r2, #0]
 8004bac:	f008 f802 	bl	800cbb4 <setjmp>
 8004bb0:	2800      	cmp	r0, #0
 8004bb2:	d00d      	beq.n	8004bd0 <main+0x40>
			gdb_main();
		}
		if (e.type) {
 8004bb4:	9b01      	ldr	r3, [sp, #4]
 8004bb6:	2b00      	cmp	r3, #0
 8004bb8:	d0ee      	beq.n	8004b98 <main+0x8>
			gdb_putpacketz("EFF");
 8004bba:	480b      	ldr	r0, [pc, #44]	; (8004be8 <main+0x58>)
 8004bbc:	2103      	movs	r1, #3
 8004bbe:	f7fe feb1 	bl	8003924 <gdb_putpacket>
			target_list_free();
 8004bc2:	f003 fa29 	bl	8008018 <target_list_free>
			morse("TARGET LOST.", 1);
 8004bc6:	4809      	ldr	r0, [pc, #36]	; (8004bec <main+0x5c>)
 8004bc8:	2101      	movs	r1, #1
 8004bca:	f000 f811 	bl	8004bf0 <morse>
 8004bce:	e7e3      	b.n	8004b98 <main+0x8>
	platform_init();
#endif

	while (true) {
		volatile struct exception e;
		TRY_CATCH(e, EXCEPTION_ALL) {
 8004bd0:	4d04      	ldr	r5, [pc, #16]	; (8004be4 <main+0x54>)
 8004bd2:	ab01      	add	r3, sp, #4
 8004bd4:	682c      	ldr	r4, [r5, #0]
 8004bd6:	429c      	cmp	r4, r3
 8004bd8:	d1ec      	bne.n	8004bb4 <main+0x24>
			gdb_main();
 8004bda:	f7fe fc8d 	bl	80034f8 <gdb_main>
	platform_init();
#endif

	while (true) {
		volatile struct exception e;
		TRY_CATCH(e, EXCEPTION_ALL) {
 8004bde:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8004be0:	602b      	str	r3, [r5, #0]
 8004be2:	e7f5      	b.n	8004bd0 <main+0x40>
 8004be4:	20001dc4 	.word	0x20001dc4
 8004be8:	08011cd2 	.word	0x08011cd2
 8004bec:	08011d5b 	.word	0x08011d5b

08004bf0 <morse>:
static const char * volatile morse_ptr;
static char morse_repeat;

void morse(const char *msg, char repeat)
{
	morse_msg = morse_ptr = msg;
 8004bf0:	4b02      	ldr	r3, [pc, #8]	; (8004bfc <morse+0xc>)
 8004bf2:	4a03      	ldr	r2, [pc, #12]	; (8004c00 <morse+0x10>)
 8004bf4:	6018      	str	r0, [r3, #0]
 8004bf6:	6010      	str	r0, [r2, #0]
	morse_repeat = repeat;
 8004bf8:	7119      	strb	r1, [r3, #4]
}
 8004bfa:	4770      	bx	lr
 8004bfc:	200011d4 	.word	0x200011d4
 8004c00:	20002060 	.word	0x20002060

08004c04 <morse_update>:
bool morse_update(void)
{
	static uint16_t code;
	static uint8_t bits;

	if (!morse_ptr)
 8004c04:	4919      	ldr	r1, [pc, #100]	; (8004c6c <morse_update+0x68>)
 8004c06:	680a      	ldr	r2, [r1, #0]
 8004c08:	1c0b      	adds	r3, r1, #0
		return false;
 8004c0a:	1e10      	subs	r0, r2, #0
bool morse_update(void)
{
	static uint16_t code;
	static uint8_t bits;

	if (!morse_ptr)
 8004c0c:	d02c      	beq.n	8004c68 <morse_update+0x64>
		return false;

	if (!bits) {
 8004c0e:	794a      	ldrb	r2, [r1, #5]
 8004c10:	2a00      	cmp	r2, #0
 8004c12:	d121      	bne.n	8004c58 <morse_update+0x54>
		char c = *morse_ptr++;
 8004c14:	680a      	ldr	r2, [r1, #0]
 8004c16:	1c50      	adds	r0, r2, #1
 8004c18:	7812      	ldrb	r2, [r2, #0]
 8004c1a:	6008      	str	r0, [r1, #0]
		if (!c) {
 8004c1c:	2a00      	cmp	r2, #0
 8004c1e:	d10c      	bne.n	8004c3a <morse_update+0x36>
			if(morse_repeat) {
 8004c20:	7908      	ldrb	r0, [r1, #4]
 8004c22:	2800      	cmp	r0, #0
 8004c24:	d007      	beq.n	8004c36 <morse_update+0x32>
				morse_ptr = morse_msg;
 8004c26:	4a12      	ldr	r2, [pc, #72]	; (8004c70 <morse_update+0x6c>)
 8004c28:	6812      	ldr	r2, [r2, #0]
 8004c2a:	600a      	str	r2, [r1, #0]
				c = *morse_ptr++;
 8004c2c:	680a      	ldr	r2, [r1, #0]
 8004c2e:	1c51      	adds	r1, r2, #1
 8004c30:	6019      	str	r1, [r3, #0]
 8004c32:	7812      	ldrb	r2, [r2, #0]
 8004c34:	e001      	b.n	8004c3a <morse_update+0x36>
			} else {
				morse_ptr = 0;
 8004c36:	6008      	str	r0, [r1, #0]
				return false;
 8004c38:	e016      	b.n	8004c68 <morse_update+0x64>
			}
		}
		if ((c >= 'A') && (c <= 'Z')) {
 8004c3a:	3a41      	subs	r2, #65	; 0x41
 8004c3c:	b2d2      	uxtb	r2, r2
 8004c3e:	2a19      	cmp	r2, #25
 8004c40:	d806      	bhi.n	8004c50 <morse_update+0x4c>
			c -= 'A';
			code = morse_letter[c].code;
 8004c42:	490c      	ldr	r1, [pc, #48]	; (8004c74 <morse_update+0x70>)
 8004c44:	0092      	lsls	r2, r2, #2
 8004c46:	5a50      	ldrh	r0, [r2, r1]
			bits = morse_letter[c].bits;
 8004c48:	188a      	adds	r2, r1, r2
				return false;
			}
		}
		if ((c >= 'A') && (c <= 'Z')) {
			c -= 'A';
			code = morse_letter[c].code;
 8004c4a:	80d8      	strh	r0, [r3, #6]
			bits = morse_letter[c].bits;
 8004c4c:	7892      	ldrb	r2, [r2, #2]
 8004c4e:	e002      	b.n	8004c56 <morse_update+0x52>
		} else {
			code = 0; bits = 4;
 8004c50:	2200      	movs	r2, #0
 8004c52:	80da      	strh	r2, [r3, #6]
 8004c54:	3204      	adds	r2, #4
 8004c56:	715a      	strb	r2, [r3, #5]
		}
	}

	bool ret = code & 1;
 8004c58:	88d8      	ldrh	r0, [r3, #6]
	code >>= 1;
 8004c5a:	0842      	lsrs	r2, r0, #1
 8004c5c:	80da      	strh	r2, [r3, #6]
	bits--;
 8004c5e:	795a      	ldrb	r2, [r3, #5]
 8004c60:	3a01      	subs	r2, #1
 8004c62:	715a      	strb	r2, [r3, #5]

	return ret;
 8004c64:	2301      	movs	r3, #1
 8004c66:	4018      	ands	r0, r3
}
 8004c68:	4770      	bx	lr
 8004c6a:	46c0      	nop			; (mov r8, r8)
 8004c6c:	200011d4 	.word	0x200011d4
 8004c70:	20002060 	.word	0x20002060
 8004c74:	0801259e 	.word	0x0801259e

08004c78 <nrf51_cmd_read_help>:
	}

	return true;
}
static bool nrf51_cmd_read_help(target *t)
{
 8004c78:	b538      	push	{r3, r4, r5, lr}
	const struct command_s *c;

	tc_printf(t, "Read commands:\n");
 8004c7a:	490a      	ldr	r1, [pc, #40]	; (8004ca4 <nrf51_cmd_read_help+0x2c>)
	}

	return true;
}
static bool nrf51_cmd_read_help(target *t)
{
 8004c7c:	1c05      	adds	r5, r0, #0
	const struct command_s *c;

	tc_printf(t, "Read commands:\n");
 8004c7e:	f003 fcb4 	bl	80085ea <tc_printf>
 8004c82:	4c09      	ldr	r4, [pc, #36]	; (8004ca8 <nrf51_cmd_read_help+0x30>)
 8004c84:	3408      	adds	r4, #8
 8004c86:	1c23      	adds	r3, r4, #0
 8004c88:	3b08      	subs	r3, #8
	for(c = nrf51_read_cmd_list; c->cmd; c++)
 8004c8a:	681a      	ldr	r2, [r3, #0]
 8004c8c:	2a00      	cmp	r2, #0
 8004c8e:	d006      	beq.n	8004c9e <nrf51_cmd_read_help+0x26>
		tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);
 8004c90:	6823      	ldr	r3, [r4, #0]
 8004c92:	1c28      	adds	r0, r5, #0
 8004c94:	4905      	ldr	r1, [pc, #20]	; (8004cac <nrf51_cmd_read_help+0x34>)
 8004c96:	f003 fca8 	bl	80085ea <tc_printf>
 8004c9a:	340c      	adds	r4, #12
 8004c9c:	e7f3      	b.n	8004c86 <nrf51_cmd_read_help+0xe>

	return true;
}
 8004c9e:	2001      	movs	r0, #1
 8004ca0:	bd38      	pop	{r3, r4, r5, pc}
 8004ca2:	46c0      	nop			; (mov r8, r8)
 8004ca4:	080126b0 	.word	0x080126b0
 8004ca8:	08012608 	.word	0x08012608
 8004cac:	0800fd6c 	.word	0x0800fd6c

08004cb0 <nrf51_cmd_read>:
static bool nrf51_cmd_read(target *t, int argc, const char *argv[])
{
 8004cb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004cb2:	1c06      	adds	r6, r0, #0
 8004cb4:	1c15      	adds	r5, r2, #0
	const struct command_s *c;

	for(c = nrf51_read_cmd_list; c->cmd; c++) {
 8004cb6:	4c10      	ldr	r4, [pc, #64]	; (8004cf8 <nrf51_cmd_read+0x48>)
		tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);

	return true;
}
static bool nrf51_cmd_read(target *t, int argc, const char *argv[])
{
 8004cb8:	9101      	str	r1, [sp, #4]
	const struct command_s *c;

	for(c = nrf51_read_cmd_list; c->cmd; c++) {
 8004cba:	6827      	ldr	r7, [r4, #0]
 8004cbc:	2f00      	cmp	r7, #0
 8004cbe:	d017      	beq.n	8004cf0 <nrf51_cmd_read+0x40>
		/* Accept a partial match as GDB does.
		 * So 'mon ver' will match 'monitor version'
		 */
		if(!strncmp(argv[1], c->cmd, strlen(argv[1])))
 8004cc0:	686b      	ldr	r3, [r5, #4]
 8004cc2:	1c18      	adds	r0, r3, #0
 8004cc4:	9300      	str	r3, [sp, #0]
 8004cc6:	f008 f8af 	bl	800ce28 <strlen>
 8004cca:	1c39      	adds	r1, r7, #0
 8004ccc:	1c02      	adds	r2, r0, #0
 8004cce:	9800      	ldr	r0, [sp, #0]
 8004cd0:	f008 f8d8 	bl	800ce84 <strncmp>
 8004cd4:	2800      	cmp	r0, #0
 8004cd6:	d109      	bne.n	8004cec <nrf51_cmd_read+0x3c>
			return !c->handler(t, argc - 1, &argv[1]);
 8004cd8:	9901      	ldr	r1, [sp, #4]
 8004cda:	6863      	ldr	r3, [r4, #4]
 8004cdc:	3901      	subs	r1, #1
 8004cde:	1d2a      	adds	r2, r5, #4
 8004ce0:	1c30      	adds	r0, r6, #0
 8004ce2:	4798      	blx	r3
 8004ce4:	2301      	movs	r3, #1
 8004ce6:	4058      	eors	r0, r3
 8004ce8:	b2c0      	uxtb	r0, r0
 8004cea:	e004      	b.n	8004cf6 <nrf51_cmd_read+0x46>
}
static bool nrf51_cmd_read(target *t, int argc, const char *argv[])
{
	const struct command_s *c;

	for(c = nrf51_read_cmd_list; c->cmd; c++) {
 8004cec:	340c      	adds	r4, #12
 8004cee:	e7e4      	b.n	8004cba <nrf51_cmd_read+0xa>
		 */
		if(!strncmp(argv[1], c->cmd, strlen(argv[1])))
			return !c->handler(t, argc - 1, &argv[1]);
	}

	return nrf51_cmd_read_help(t);
 8004cf0:	1c30      	adds	r0, r6, #0
 8004cf2:	f7ff ffc1 	bl	8004c78 <nrf51_cmd_read_help>
}
 8004cf6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8004cf8:	08012608 	.word	0x08012608

08004cfc <nrf51_cmd_read_deviceaddr>:
	tc_printf(t, "Device ID: 0x%08X%08X\n", deviceid_high, deviceid_low);

	return true;
}
static bool nrf51_cmd_read_deviceaddr(target *t)
{
 8004cfc:	b570      	push	{r4, r5, r6, lr}
	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
 8004cfe:	490c      	ldr	r1, [pc, #48]	; (8004d30 <nrf51_cmd_read_deviceaddr+0x34>)
	tc_printf(t, "Device ID: 0x%08X%08X\n", deviceid_high, deviceid_low);

	return true;
}
static bool nrf51_cmd_read_deviceaddr(target *t)
{
 8004d00:	1c04      	adds	r4, r0, #0
	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
 8004d02:	f003 fc13 	bl	800852c <target_mem_read32>
	uint32_t addr_low = target_mem_read32(t, NRF51_FICR_DEVICEADDR_LOW);
 8004d06:	490b      	ldr	r1, [pc, #44]	; (8004d34 <nrf51_cmd_read_deviceaddr+0x38>)

	return true;
}
static bool nrf51_cmd_read_deviceaddr(target *t)
{
	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
 8004d08:	1c06      	adds	r6, r0, #0
	uint32_t addr_low = target_mem_read32(t, NRF51_FICR_DEVICEADDR_LOW);
 8004d0a:	1c20      	adds	r0, r4, #0
 8004d0c:	f003 fc0e 	bl	800852c <target_mem_read32>
	uint32_t addr_high = target_mem_read32(t, NRF51_FICR_DEVICEADDR_HIGH) & 0xFFFF;
 8004d10:	4909      	ldr	r1, [pc, #36]	; (8004d38 <nrf51_cmd_read_deviceaddr+0x3c>)
	return true;
}
static bool nrf51_cmd_read_deviceaddr(target *t)
{
	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
	uint32_t addr_low = target_mem_read32(t, NRF51_FICR_DEVICEADDR_LOW);
 8004d12:	1c05      	adds	r5, r0, #0
	uint32_t addr_high = target_mem_read32(t, NRF51_FICR_DEVICEADDR_HIGH) & 0xFFFF;
 8004d14:	1c20      	adds	r0, r4, #0
 8004d16:	f003 fc09 	bl	800852c <target_mem_read32>

	if ((addr_type & 1) == 0) {
		tc_printf(t, "Publicly Listed Address: 0x%04X%08X\n", addr_high, addr_low);
 8004d1a:	4908      	ldr	r1, [pc, #32]	; (8004d3c <nrf51_cmd_read_deviceaddr+0x40>)
}
static bool nrf51_cmd_read_deviceaddr(target *t)
{
	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
	uint32_t addr_low = target_mem_read32(t, NRF51_FICR_DEVICEADDR_LOW);
	uint32_t addr_high = target_mem_read32(t, NRF51_FICR_DEVICEADDR_HIGH) & 0xFFFF;
 8004d1c:	b282      	uxth	r2, r0

	if ((addr_type & 1) == 0) {
		tc_printf(t, "Publicly Listed Address: 0x%04X%08X\n", addr_high, addr_low);
 8004d1e:	1c20      	adds	r0, r4, #0
{
	uint32_t addr_type = target_mem_read32(t, NRF51_FICR_DEVICEADDRTYPE);
	uint32_t addr_low = target_mem_read32(t, NRF51_FICR_DEVICEADDR_LOW);
	uint32_t addr_high = target_mem_read32(t, NRF51_FICR_DEVICEADDR_HIGH) & 0xFFFF;

	if ((addr_type & 1) == 0) {
 8004d20:	07f3      	lsls	r3, r6, #31
 8004d22:	d500      	bpl.n	8004d26 <nrf51_cmd_read_deviceaddr+0x2a>
		tc_printf(t, "Publicly Listed Address: 0x%04X%08X\n", addr_high, addr_low);
	} else {
		tc_printf(t, "Randomly Assigned Address: 0x%04X%08X\n", addr_high, addr_low);
 8004d24:	4906      	ldr	r1, [pc, #24]	; (8004d40 <nrf51_cmd_read_deviceaddr+0x44>)
 8004d26:	1c2b      	adds	r3, r5, #0
 8004d28:	f003 fc5f 	bl	80085ea <tc_printf>
	}

	return true;
}
 8004d2c:	2001      	movs	r0, #1
 8004d2e:	bd70      	pop	{r4, r5, r6, pc}
 8004d30:	100000a0 	.word	0x100000a0
 8004d34:	100000a4 	.word	0x100000a4
 8004d38:	100000a8 	.word	0x100000a8
 8004d3c:	080126c0 	.word	0x080126c0
 8004d40:	080126e5 	.word	0x080126e5

08004d44 <nrf51_cmd_read_deviceid>:
	tc_printf(t, "Firmware ID: 0x%04X\n", fwid);

	return true;
}
static bool nrf51_cmd_read_deviceid(target *t)
{
 8004d44:	b538      	push	{r3, r4, r5, lr}
	uint32_t deviceid_low = target_mem_read32(t, NRF51_FICR_DEVICEID_LOW);
 8004d46:	4908      	ldr	r1, [pc, #32]	; (8004d68 <nrf51_cmd_read_deviceid+0x24>)
	tc_printf(t, "Firmware ID: 0x%04X\n", fwid);

	return true;
}
static bool nrf51_cmd_read_deviceid(target *t)
{
 8004d48:	1c04      	adds	r4, r0, #0
	uint32_t deviceid_low = target_mem_read32(t, NRF51_FICR_DEVICEID_LOW);
 8004d4a:	f003 fbef 	bl	800852c <target_mem_read32>
	uint32_t deviceid_high = target_mem_read32(t, NRF51_FICR_DEVICEID_HIGH);
 8004d4e:	4907      	ldr	r1, [pc, #28]	; (8004d6c <nrf51_cmd_read_deviceid+0x28>)

	return true;
}
static bool nrf51_cmd_read_deviceid(target *t)
{
	uint32_t deviceid_low = target_mem_read32(t, NRF51_FICR_DEVICEID_LOW);
 8004d50:	1c05      	adds	r5, r0, #0
	uint32_t deviceid_high = target_mem_read32(t, NRF51_FICR_DEVICEID_HIGH);
 8004d52:	1c20      	adds	r0, r4, #0
 8004d54:	f003 fbea 	bl	800852c <target_mem_read32>

	tc_printf(t, "Device ID: 0x%08X%08X\n", deviceid_high, deviceid_low);
 8004d58:	1c2b      	adds	r3, r5, #0
	return true;
}
static bool nrf51_cmd_read_deviceid(target *t)
{
	uint32_t deviceid_low = target_mem_read32(t, NRF51_FICR_DEVICEID_LOW);
	uint32_t deviceid_high = target_mem_read32(t, NRF51_FICR_DEVICEID_HIGH);
 8004d5a:	1c02      	adds	r2, r0, #0

	tc_printf(t, "Device ID: 0x%08X%08X\n", deviceid_high, deviceid_low);
 8004d5c:	4904      	ldr	r1, [pc, #16]	; (8004d70 <nrf51_cmd_read_deviceid+0x2c>)
 8004d5e:	1c20      	adds	r0, r4, #0
 8004d60:	f003 fc43 	bl	80085ea <tc_printf>

	return true;
}
 8004d64:	2001      	movs	r0, #1
 8004d66:	bd38      	pop	{r3, r4, r5, pc}
 8004d68:	10000060 	.word	0x10000060
 8004d6c:	10000064 	.word	0x10000064
 8004d70:	0801270c 	.word	0x0801270c

08004d74 <nrf51_cmd_read_fwid>:
	tc_printf(t, "Hardware ID: 0x%04X\n", hwid);

	return true;
}
static bool nrf51_cmd_read_fwid(target *t)
{
 8004d74:	b510      	push	{r4, lr}
	uint32_t fwid = (target_mem_read32(t, NRF51_FICR_CONFIGID) >> 16) & 0xFFFF;
 8004d76:	4905      	ldr	r1, [pc, #20]	; (8004d8c <nrf51_cmd_read_fwid+0x18>)
	tc_printf(t, "Hardware ID: 0x%04X\n", hwid);

	return true;
}
static bool nrf51_cmd_read_fwid(target *t)
{
 8004d78:	1c04      	adds	r4, r0, #0
	uint32_t fwid = (target_mem_read32(t, NRF51_FICR_CONFIGID) >> 16) & 0xFFFF;
 8004d7a:	f003 fbd7 	bl	800852c <target_mem_read32>
	tc_printf(t, "Firmware ID: 0x%04X\n", fwid);
 8004d7e:	4904      	ldr	r1, [pc, #16]	; (8004d90 <nrf51_cmd_read_fwid+0x1c>)

	return true;
}
static bool nrf51_cmd_read_fwid(target *t)
{
	uint32_t fwid = (target_mem_read32(t, NRF51_FICR_CONFIGID) >> 16) & 0xFFFF;
 8004d80:	0c02      	lsrs	r2, r0, #16
	tc_printf(t, "Firmware ID: 0x%04X\n", fwid);
 8004d82:	1c20      	adds	r0, r4, #0
 8004d84:	f003 fc31 	bl	80085ea <tc_printf>

	return true;
}
 8004d88:	2001      	movs	r0, #1
 8004d8a:	bd10      	pop	{r4, pc}
 8004d8c:	1000005c 	.word	0x1000005c
 8004d90:	08012723 	.word	0x08012723

08004d94 <nrf51_cmd_read_hwid>:

	return true;
}

static bool nrf51_cmd_read_hwid(target *t)
{
 8004d94:	b510      	push	{r4, lr}
	uint32_t hwid = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
 8004d96:	4905      	ldr	r1, [pc, #20]	; (8004dac <nrf51_cmd_read_hwid+0x18>)

	return true;
}

static bool nrf51_cmd_read_hwid(target *t)
{
 8004d98:	1c04      	adds	r4, r0, #0
	uint32_t hwid = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
 8004d9a:	f003 fbc7 	bl	800852c <target_mem_read32>
	tc_printf(t, "Hardware ID: 0x%04X\n", hwid);
 8004d9e:	4904      	ldr	r1, [pc, #16]	; (8004db0 <nrf51_cmd_read_hwid+0x1c>)
	return true;
}

static bool nrf51_cmd_read_hwid(target *t)
{
	uint32_t hwid = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
 8004da0:	b282      	uxth	r2, r0
	tc_printf(t, "Hardware ID: 0x%04X\n", hwid);
 8004da2:	1c20      	adds	r0, r4, #0
 8004da4:	f003 fc21 	bl	80085ea <tc_printf>

	return true;
}
 8004da8:	2001      	movs	r0, #1
 8004daa:	bd10      	pop	{r4, pc}
 8004dac:	1000005c 	.word	0x1000005c
 8004db0:	08012738 	.word	0x08012738

08004db4 <nrf51_flash_erase>:

	return false;
}

static int nrf51_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8004db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	target *t = f->t;
 8004db6:	6984      	ldr	r4, [r0, #24]

	return false;
}

static int nrf51_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8004db8:	1c07      	adds	r7, r0, #0
 8004dba:	1c0e      	adds	r6, r1, #0
 8004dbc:	1c15      	adds	r5, r2, #0
	target *t = f->t;
	/* Enable erase */
	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_EEN);
 8004dbe:	1c20      	adds	r0, r4, #0
 8004dc0:	4920      	ldr	r1, [pc, #128]	; (8004e44 <nrf51_flash_erase+0x90>)
 8004dc2:	2202      	movs	r2, #2
 8004dc4:	f003 fbba 	bl	800853c <target_mem_write32>

	/* Poll for NVMC_READY */
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
 8004dc8:	1c20      	adds	r0, r4, #0
 8004dca:	491f      	ldr	r1, [pc, #124]	; (8004e48 <nrf51_flash_erase+0x94>)
 8004dcc:	f003 fbae 	bl	800852c <target_mem_read32>
 8004dd0:	2800      	cmp	r0, #0
 8004dd2:	d118      	bne.n	8004e06 <nrf51_flash_erase+0x52>
		if(target_check_error(t))
 8004dd4:	1c20      	adds	r0, r4, #0
 8004dd6:	f003 fb1f 	bl	8008418 <target_check_error>
 8004dda:	2800      	cmp	r0, #0
 8004ddc:	d0f4      	beq.n	8004dc8 <nrf51_flash_erase+0x14>
			return -1;
 8004dde:	2001      	movs	r0, #1
 8004de0:	4240      	negs	r0, r0
 8004de2:	e02e      	b.n	8004e42 <nrf51_flash_erase+0x8e>

	while (len) {
		if (addr == NRF51_UICR) { // Special Case
 8004de4:	4b19      	ldr	r3, [pc, #100]	; (8004e4c <nrf51_flash_erase+0x98>)
			/* Write to the ERASE_UICR register to erase */
			target_mem_write32(t, NRF51_NVMC_ERASEUICR, 0x1);
 8004de6:	1c20      	adds	r0, r4, #0
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
		if(target_check_error(t))
			return -1;

	while (len) {
		if (addr == NRF51_UICR) { // Special Case
 8004de8:	429e      	cmp	r6, r3
 8004dea:	d10f      	bne.n	8004e0c <nrf51_flash_erase+0x58>
			/* Write to the ERASE_UICR register to erase */
			target_mem_write32(t, NRF51_NVMC_ERASEUICR, 0x1);
 8004dec:	2201      	movs	r2, #1
 8004dee:	4918      	ldr	r1, [pc, #96]	; (8004e50 <nrf51_flash_erase+0x9c>)

		} else { // Standard Flash Page
			/* Write address of first word in page to erase it */
			target_mem_write32(t, NRF51_NVMC_ERASEPAGE, addr);
 8004df0:	f003 fba4 	bl	800853c <target_mem_write32>
		}

		/* Poll for NVMC_READY */
		while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
 8004df4:	1c20      	adds	r0, r4, #0
 8004df6:	4914      	ldr	r1, [pc, #80]	; (8004e48 <nrf51_flash_erase+0x94>)
 8004df8:	f003 fb98 	bl	800852c <target_mem_read32>
 8004dfc:	2800      	cmp	r0, #0
 8004dfe:	d008      	beq.n	8004e12 <nrf51_flash_erase+0x5e>
			if(target_check_error(t))
				return -1;

		addr += f->blocksize;
 8004e00:	68bb      	ldr	r3, [r7, #8]
 8004e02:	18f6      	adds	r6, r6, r3
		len -= f->blocksize;
 8004e04:	1aed      	subs	r5, r5, r3
	/* Poll for NVMC_READY */
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
		if(target_check_error(t))
			return -1;

	while (len) {
 8004e06:	2d00      	cmp	r5, #0
 8004e08:	d1ec      	bne.n	8004de4 <nrf51_flash_erase+0x30>
 8004e0a:	e008      	b.n	8004e1e <nrf51_flash_erase+0x6a>
			/* Write to the ERASE_UICR register to erase */
			target_mem_write32(t, NRF51_NVMC_ERASEUICR, 0x1);

		} else { // Standard Flash Page
			/* Write address of first word in page to erase it */
			target_mem_write32(t, NRF51_NVMC_ERASEPAGE, addr);
 8004e0c:	4911      	ldr	r1, [pc, #68]	; (8004e54 <nrf51_flash_erase+0xa0>)
 8004e0e:	1c32      	adds	r2, r6, #0
 8004e10:	e7ee      	b.n	8004df0 <nrf51_flash_erase+0x3c>
		}

		/* Poll for NVMC_READY */
		while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
			if(target_check_error(t))
 8004e12:	1c20      	adds	r0, r4, #0
 8004e14:	f003 fb00 	bl	8008418 <target_check_error>
 8004e18:	2800      	cmp	r0, #0
 8004e1a:	d0eb      	beq.n	8004df4 <nrf51_flash_erase+0x40>
 8004e1c:	e7df      	b.n	8004dde <nrf51_flash_erase+0x2a>
		addr += f->blocksize;
		len -= f->blocksize;
	}

	/* Return to read-only */
	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_REN);
 8004e1e:	1c20      	adds	r0, r4, #0
 8004e20:	4908      	ldr	r1, [pc, #32]	; (8004e44 <nrf51_flash_erase+0x90>)
 8004e22:	1c2a      	adds	r2, r5, #0
 8004e24:	f003 fb8a 	bl	800853c <target_mem_write32>

	/* Poll for NVMC_READY */
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
 8004e28:	1c20      	adds	r0, r4, #0
 8004e2a:	4907      	ldr	r1, [pc, #28]	; (8004e48 <nrf51_flash_erase+0x94>)
 8004e2c:	f003 fb7e 	bl	800852c <target_mem_read32>
 8004e30:	2800      	cmp	r0, #0
 8004e32:	d105      	bne.n	8004e40 <nrf51_flash_erase+0x8c>
		if(target_check_error(t))
 8004e34:	1c20      	adds	r0, r4, #0
 8004e36:	f003 faef 	bl	8008418 <target_check_error>
 8004e3a:	2800      	cmp	r0, #0
 8004e3c:	d0f4      	beq.n	8004e28 <nrf51_flash_erase+0x74>
 8004e3e:	e7ce      	b.n	8004dde <nrf51_flash_erase+0x2a>
			return -1;

	return 0;
 8004e40:	2000      	movs	r0, #0
}
 8004e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004e44:	4001e504 	.word	0x4001e504
 8004e48:	4001e400 	.word	0x4001e400
 8004e4c:	10001000 	.word	0x10001000
 8004e50:	4001e514 	.word	0x4001e514
 8004e54:	4001e508 	.word	0x4001e508

08004e58 <nrf51_add_flash>:
#include "flashstub/nrf51.stub"
};

static void nrf51_add_flash(target *t,
                            uint32_t addr, size_t length, size_t erasesize)
{
 8004e58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004e5a:	1c0f      	adds	r7, r1, #0
 8004e5c:	1c04      	adds	r4, r0, #0
	struct target_flash *f = calloc(1, sizeof(*f));
 8004e5e:	2138      	movs	r1, #56	; 0x38
 8004e60:	2001      	movs	r0, #1
#include "flashstub/nrf51.stub"
};

static void nrf51_add_flash(target *t,
                            uint32_t addr, size_t length, size_t erasesize)
{
 8004e62:	1c16      	adds	r6, r2, #0
 8004e64:	1c1d      	adds	r5, r3, #0
	struct target_flash *f = calloc(1, sizeof(*f));
 8004e66:	f007 fd07 	bl	800c878 <calloc>
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
	f->erase = nrf51_flash_erase;
 8004e6a:	4b08      	ldr	r3, [pc, #32]	; (8004e8c <nrf51_add_flash+0x34>)
	f->write = nrf51_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8004e6c:	22ff      	movs	r2, #255	; 0xff
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
	f->erase = nrf51_flash_erase;
 8004e6e:	60c3      	str	r3, [r0, #12]
	f->write = nrf51_flash_write;
 8004e70:	4b07      	ldr	r3, [pc, #28]	; (8004e90 <nrf51_add_flash+0x38>)

static void nrf51_add_flash(target *t,
                            uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
 8004e72:	6007      	str	r7, [r0, #0]
	f->length = length;
	f->blocksize = erasesize;
	f->erase = nrf51_flash_erase;
	f->write = nrf51_flash_write;
 8004e74:	6103      	str	r3, [r0, #16]
	f->align = 4;
 8004e76:	2304      	movs	r3, #4
 8004e78:	6203      	str	r3, [r0, #32]
	f->erased = 0xff;
 8004e7a:	1d43      	adds	r3, r0, #5
static void nrf51_add_flash(target *t,
                            uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
 8004e7c:	6046      	str	r6, [r0, #4]
	f->blocksize = erasesize;
 8004e7e:	6085      	str	r5, [r0, #8]
};

static void nrf51_add_flash(target *t,
                            uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8004e80:	1c01      	adds	r1, r0, #0
	f->length = length;
	f->blocksize = erasesize;
	f->erase = nrf51_flash_erase;
	f->write = nrf51_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8004e82:	77da      	strb	r2, [r3, #31]
	target_add_flash(t, f);
 8004e84:	1c20      	adds	r0, r4, #0
 8004e86:	f003 f962 	bl	800814e <target_add_flash>
}
 8004e8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004e8c:	08004db5 	.word	0x08004db5
 8004e90:	08004e95 	.word	0x08004e95

08004e94 <nrf51_flash_write>:
	return 0;
}

static int nrf51_flash_write(struct target_flash *f,
                             target_addr dest, const void *src, size_t len)
{
 8004e94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004e96:	1c1c      	adds	r4, r3, #0
	target *t = f->t;
 8004e98:	6985      	ldr	r5, [r0, #24]
	uint32_t data[2 + len/4];
 8004e9a:	0898      	lsrs	r0, r3, #2
 8004e9c:	466b      	mov	r3, sp
 8004e9e:	0080      	lsls	r0, r0, #2
 8004ea0:	3012      	adds	r0, #18
 8004ea2:	08c0      	lsrs	r0, r0, #3
 8004ea4:	00c0      	lsls	r0, r0, #3
 8004ea6:	1a1b      	subs	r3, r3, r0
	return 0;
}

static int nrf51_flash_write(struct target_flash *f,
                             target_addr dest, const void *src, size_t len)
{
 8004ea8:	af02      	add	r7, sp, #8
	target *t = f->t;
	uint32_t data[2 + len/4];
 8004eaa:	469d      	mov	sp, r3
 8004eac:	ae02      	add	r6, sp, #8
	/* FIXME rewrite stub to use register args */

	/* Construct data buffer used by stub */
	data[0] = dest;
	data[1] = len;		/* length must always be a multiple of 4 */
	memcpy((uint8_t *)&data[2], src, len);
 8004eae:	1c30      	adds	r0, r6, #0
	uint32_t data[2 + len/4];

	/* FIXME rewrite stub to use register args */

	/* Construct data buffer used by stub */
	data[0] = dest;
 8004eb0:	6031      	str	r1, [r6, #0]
	data[1] = len;		/* length must always be a multiple of 4 */
 8004eb2:	6074      	str	r4, [r6, #4]
	memcpy((uint8_t *)&data[2], src, len);
 8004eb4:	1c11      	adds	r1, r2, #0
 8004eb6:	3008      	adds	r0, #8
 8004eb8:	1c22      	adds	r2, r4, #0
 8004eba:	f007 fcfd 	bl	800c8b8 <memcpy>

	/* Enable write */
	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_WEN);
 8004ebe:	1c28      	adds	r0, r5, #0
 8004ec0:	4919      	ldr	r1, [pc, #100]	; (8004f28 <nrf51_flash_write+0x94>)
 8004ec2:	2201      	movs	r2, #1
 8004ec4:	f003 fb3a 	bl	800853c <target_mem_write32>

	/* Poll for NVMC_READY */
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
 8004ec8:	1c28      	adds	r0, r5, #0
 8004eca:	4918      	ldr	r1, [pc, #96]	; (8004f2c <nrf51_flash_write+0x98>)
 8004ecc:	f003 fb2e 	bl	800852c <target_mem_read32>
 8004ed0:	2800      	cmp	r0, #0
 8004ed2:	d107      	bne.n	8004ee4 <nrf51_flash_write+0x50>
		if(target_check_error(t))
 8004ed4:	1c28      	adds	r0, r5, #0
 8004ed6:	f003 fa9f 	bl	8008418 <target_check_error>
 8004eda:	2800      	cmp	r0, #0
 8004edc:	d0f4      	beq.n	8004ec8 <nrf51_flash_write+0x34>
			return -1;
 8004ede:	2001      	movs	r0, #1
 8004ee0:	4240      	negs	r0, r0
 8004ee2:	e01e      	b.n	8004f22 <nrf51_flash_write+0x8e>

	/* Write stub and data to target ram and call stub */
	target_mem_write(t, SRAM_BASE, nrf51_flash_write_stub,
 8004ee4:	2180      	movs	r1, #128	; 0x80
 8004ee6:	4a12      	ldr	r2, [pc, #72]	; (8004f30 <nrf51_flash_write+0x9c>)
 8004ee8:	0589      	lsls	r1, r1, #22
 8004eea:	3248      	adds	r2, #72	; 0x48
 8004eec:	233c      	movs	r3, #60	; 0x3c
 8004eee:	1c28      	adds	r0, r5, #0
 8004ef0:	f003 faa0 	bl	8008434 <target_mem_write>
	                 sizeof(nrf51_flash_write_stub));
	target_mem_write(t, STUB_BUFFER_BASE, data, len + 8);
 8004ef4:	1c23      	adds	r3, r4, #0
 8004ef6:	490f      	ldr	r1, [pc, #60]	; (8004f34 <nrf51_flash_write+0xa0>)
 8004ef8:	3308      	adds	r3, #8
 8004efa:	1c32      	adds	r2, r6, #0
 8004efc:	1c28      	adds	r0, r5, #0
 8004efe:	f003 fa99 	bl	8008434 <target_mem_write>
	cortexm_run_stub(t, SRAM_BASE, 0, 0, 0, 0);
 8004f02:	2400      	movs	r4, #0
 8004f04:	2180      	movs	r1, #128	; 0x80
 8004f06:	1c22      	adds	r2, r4, #0
 8004f08:	0589      	lsls	r1, r1, #22
 8004f0a:	1c23      	adds	r3, r4, #0
 8004f0c:	9400      	str	r4, [sp, #0]
 8004f0e:	9401      	str	r4, [sp, #4]
 8004f10:	1c28      	adds	r0, r5, #0
 8004f12:	f7fd fac9 	bl	80024a8 <cortexm_run_stub>

	/* Return to read-only */
	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_REN);
 8004f16:	1c28      	adds	r0, r5, #0
 8004f18:	4903      	ldr	r1, [pc, #12]	; (8004f28 <nrf51_flash_write+0x94>)
 8004f1a:	1c22      	adds	r2, r4, #0
 8004f1c:	f003 fb0e 	bl	800853c <target_mem_write32>

	return 0;
 8004f20:	1c20      	adds	r0, r4, #0
}
 8004f22:	46bd      	mov	sp, r7
 8004f24:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8004f26:	46c0      	nop			; (mov r8, r8)
 8004f28:	4001e504 	.word	0x4001e504
 8004f2c:	4001e400 	.word	0x4001e400
 8004f30:	08012608 	.word	0x08012608
 8004f34:	20000028 	.word	0x20000028

08004f38 <nrf51_cmd_erase_all>:

static bool nrf51_cmd_erase_all(target *t)
{
 8004f38:	b510      	push	{r4, lr}
 8004f3a:	1c04      	adds	r4, r0, #0
	tc_printf(t, "erase..\n");
 8004f3c:	4913      	ldr	r1, [pc, #76]	; (8004f8c <nrf51_cmd_erase_all+0x54>)
 8004f3e:	f003 fb54 	bl	80085ea <tc_printf>

	/* Enable erase */
	target_mem_write32(t, NRF51_NVMC_CONFIG, NRF51_NVMC_CONFIG_EEN);
 8004f42:	1c20      	adds	r0, r4, #0
 8004f44:	4912      	ldr	r1, [pc, #72]	; (8004f90 <nrf51_cmd_erase_all+0x58>)
 8004f46:	2202      	movs	r2, #2
 8004f48:	f003 faf8 	bl	800853c <target_mem_write32>

	/* Poll for NVMC_READY */
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
 8004f4c:	1c20      	adds	r0, r4, #0
 8004f4e:	4911      	ldr	r1, [pc, #68]	; (8004f94 <nrf51_cmd_erase_all+0x5c>)
 8004f50:	f003 faec 	bl	800852c <target_mem_read32>
 8004f54:	2800      	cmp	r0, #0
 8004f56:	d106      	bne.n	8004f66 <nrf51_cmd_erase_all+0x2e>
		if(target_check_error(t))
 8004f58:	1c20      	adds	r0, r4, #0
 8004f5a:	f003 fa5d 	bl	8008418 <target_check_error>
 8004f5e:	2800      	cmp	r0, #0
 8004f60:	d0f4      	beq.n	8004f4c <nrf51_cmd_erase_all+0x14>
			return false;
 8004f62:	2000      	movs	r0, #0
 8004f64:	e011      	b.n	8004f8a <nrf51_cmd_erase_all+0x52>

	/* Erase all */
	target_mem_write32(t, NRF51_NVMC_ERASEALL, 1);
 8004f66:	1c20      	adds	r0, r4, #0
 8004f68:	490b      	ldr	r1, [pc, #44]	; (8004f98 <nrf51_cmd_erase_all+0x60>)
 8004f6a:	2201      	movs	r2, #1
 8004f6c:	f003 fae6 	bl	800853c <target_mem_write32>

	/* Poll for NVMC_READY */
	while (target_mem_read32(t, NRF51_NVMC_READY) == 0)
 8004f70:	1c20      	adds	r0, r4, #0
 8004f72:	4908      	ldr	r1, [pc, #32]	; (8004f94 <nrf51_cmd_erase_all+0x5c>)
 8004f74:	f003 fada 	bl	800852c <target_mem_read32>
 8004f78:	2800      	cmp	r0, #0
 8004f7a:	d105      	bne.n	8004f88 <nrf51_cmd_erase_all+0x50>
		if(target_check_error(t))
 8004f7c:	1c20      	adds	r0, r4, #0
 8004f7e:	f003 fa4b 	bl	8008418 <target_check_error>
 8004f82:	2800      	cmp	r0, #0
 8004f84:	d0f4      	beq.n	8004f70 <nrf51_cmd_erase_all+0x38>
 8004f86:	e7ec      	b.n	8004f62 <nrf51_cmd_erase_all+0x2a>
			return false;

	return true;
 8004f88:	2001      	movs	r0, #1
}
 8004f8a:	bd10      	pop	{r4, pc}
 8004f8c:	0801274d 	.word	0x0801274d
 8004f90:	4001e504 	.word	0x4001e504
 8004f94:	4001e400 	.word	0x4001e400
 8004f98:	4001e50c 	.word	0x4001e50c

08004f9c <nrf51_probe>:
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool nrf51_probe(target *t)
{
 8004f9c:	b510      	push	{r4, lr}
	t->idcode = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
 8004f9e:	4951      	ldr	r1, [pc, #324]	; (80050e4 <nrf51_probe+0x148>)
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool nrf51_probe(target *t)
{
 8004fa0:	1c04      	adds	r4, r0, #0
	t->idcode = target_mem_read32(t, NRF51_FICR_CONFIGID) & 0xFFFF;
 8004fa2:	f003 fac3 	bl	800852c <target_mem_read32>
 8004fa6:	b280      	uxth	r0, r0
 8004fa8:	6520      	str	r0, [r4, #80]	; 0x50

	switch (t->idcode) {
 8004faa:	284d      	cmp	r0, #77	; 0x4d
 8004fac:	d045      	beq.n	800503a <nrf51_probe+0x9e>
 8004fae:	d825      	bhi.n	8004ffc <nrf51_probe+0x60>
 8004fb0:	282f      	cmp	r0, #47	; 0x2f
 8004fb2:	d814      	bhi.n	8004fde <nrf51_probe+0x42>
 8004fb4:	282d      	cmp	r0, #45	; 0x2d
 8004fb6:	d240      	bcs.n	800503a <nrf51_probe+0x9e>
 8004fb8:	2824      	cmp	r0, #36	; 0x24
 8004fba:	d03e      	beq.n	800503a <nrf51_probe+0x9e>
 8004fbc:	d807      	bhi.n	8004fce <nrf51_probe+0x32>
 8004fbe:	281d      	cmp	r0, #29
 8004fc0:	d200      	bcs.n	8004fc4 <nrf51_probe+0x28>
 8004fc2:	e08d      	b.n	80050e0 <nrf51_probe+0x144>
 8004fc4:	281e      	cmp	r0, #30
 8004fc6:	d938      	bls.n	800503a <nrf51_probe+0x9e>
 8004fc8:	2820      	cmp	r0, #32
 8004fca:	d036      	beq.n	800503a <nrf51_probe+0x9e>
 8004fcc:	e088      	b.n	80050e0 <nrf51_probe+0x144>
 8004fce:	2826      	cmp	r0, #38	; 0x26
 8004fd0:	d200      	bcs.n	8004fd4 <nrf51_probe+0x38>
 8004fd2:	e085      	b.n	80050e0 <nrf51_probe+0x144>
 8004fd4:	2827      	cmp	r0, #39	; 0x27
 8004fd6:	d938      	bls.n	800504a <nrf51_probe+0xae>
 8004fd8:	282a      	cmp	r0, #42	; 0x2a
 8004fda:	d02e      	beq.n	800503a <nrf51_probe+0x9e>
 8004fdc:	e080      	b.n	80050e0 <nrf51_probe+0x144>
 8004fde:	2840      	cmp	r0, #64	; 0x40
 8004fe0:	d02b      	beq.n	800503a <nrf51_probe+0x9e>
 8004fe2:	d804      	bhi.n	8004fee <nrf51_probe+0x52>
 8004fe4:	2831      	cmp	r0, #49	; 0x31
 8004fe6:	d028      	beq.n	800503a <nrf51_probe+0x9e>
 8004fe8:	283c      	cmp	r0, #60	; 0x3c
 8004fea:	d179      	bne.n	80050e0 <nrf51_probe+0x144>
 8004fec:	e025      	b.n	800503a <nrf51_probe+0x9e>
 8004fee:	2847      	cmp	r0, #71	; 0x47
 8004ff0:	d023      	beq.n	800503a <nrf51_probe+0x9e>
 8004ff2:	284c      	cmp	r0, #76	; 0x4c
 8004ff4:	d029      	beq.n	800504a <nrf51_probe+0xae>
 8004ff6:	2844      	cmp	r0, #68	; 0x44
 8004ff8:	d172      	bne.n	80050e0 <nrf51_probe+0x144>
 8004ffa:	e01e      	b.n	800503a <nrf51_probe+0x9e>
 8004ffc:	287a      	cmp	r0, #122	; 0x7a
 8004ffe:	d80f      	bhi.n	8005020 <nrf51_probe+0x84>
 8005000:	2879      	cmp	r0, #121	; 0x79
 8005002:	d21a      	bcs.n	800503a <nrf51_probe+0x9e>
 8005004:	2861      	cmp	r0, #97	; 0x61
 8005006:	d020      	beq.n	800504a <nrf51_probe+0xae>
 8005008:	d804      	bhi.n	8005014 <nrf51_probe+0x78>
 800500a:	2850      	cmp	r0, #80	; 0x50
 800500c:	d015      	beq.n	800503a <nrf51_probe+0x9e>
 800500e:	2857      	cmp	r0, #87	; 0x57
 8005010:	d166      	bne.n	80050e0 <nrf51_probe+0x144>
 8005012:	e012      	b.n	800503a <nrf51_probe+0x9e>
 8005014:	2871      	cmp	r0, #113	; 0x71
 8005016:	d026      	beq.n	8005066 <nrf51_probe+0xca>
 8005018:	d362      	bcc.n	80050e0 <nrf51_probe+0x144>
 800501a:	2873      	cmp	r0, #115	; 0x73
 800501c:	d860      	bhi.n	80050e0 <nrf51_probe+0x144>
 800501e:	e00c      	b.n	800503a <nrf51_probe+0x9e>
 8005020:	2888      	cmp	r0, #136	; 0x88
 8005022:	d804      	bhi.n	800502e <nrf51_probe+0x92>
 8005024:	2883      	cmp	r0, #131	; 0x83
 8005026:	d21e      	bcs.n	8005066 <nrf51_probe+0xca>
 8005028:	287e      	cmp	r0, #126	; 0x7e
 800502a:	d90e      	bls.n	800504a <nrf51_probe+0xae>
 800502c:	e058      	b.n	80050e0 <nrf51_probe+0x144>
 800502e:	28ac      	cmp	r0, #172	; 0xac
 8005030:	d036      	beq.n	80050a0 <nrf51_probe+0x104>
 8005032:	28c7      	cmp	r0, #199	; 0xc7
 8005034:	d034      	beq.n	80050a0 <nrf51_probe+0x104>
 8005036:	288f      	cmp	r0, #143	; 0x8f
 8005038:	d152      	bne.n	80050e0 <nrf51_probe+0x144>
	case 0x0073: /* nRF51422 (rev 3) QFAA F0 */
	case 0x0079: /* nRF51822 (rev 3) CEAA E0 */
	case 0x007A: /* nRF51422 (rev 3) CEAA C0 */
	case 0x008F: /* nRF51822 (rev 3) QFAA H1 See https://devzone.nordicsemi.com/question/97769/can-someone-conform-the-config-id-code-for-the-nrf51822qfaah1/ */
		t->driver = "Nordic nRF51";
		target_add_ram(t, 0x20000000, 0x4000);
 800503a:	2180      	movs	r1, #128	; 0x80
 800503c:	2280      	movs	r2, #128	; 0x80
	case 0x0072: /* nRF51822 (rev 3) QFAA H0 */
	case 0x0073: /* nRF51422 (rev 3) QFAA F0 */
	case 0x0079: /* nRF51822 (rev 3) CEAA E0 */
	case 0x007A: /* nRF51422 (rev 3) CEAA C0 */
	case 0x008F: /* nRF51822 (rev 3) QFAA H1 See https://devzone.nordicsemi.com/question/97769/can-someone-conform-the-config-id-code-for-the-nrf51822qfaah1/ */
		t->driver = "Nordic nRF51";
 800503e:	4b2a      	ldr	r3, [pc, #168]	; (80050e8 <nrf51_probe+0x14c>)
		target_add_ram(t, 0x20000000, 0x4000);
 8005040:	1c20      	adds	r0, r4, #0
	case 0x0072: /* nRF51822 (rev 3) QFAA H0 */
	case 0x0073: /* nRF51422 (rev 3) QFAA F0 */
	case 0x0079: /* nRF51822 (rev 3) CEAA E0 */
	case 0x007A: /* nRF51422 (rev 3) CEAA C0 */
	case 0x008F: /* nRF51822 (rev 3) QFAA H1 See https://devzone.nordicsemi.com/question/97769/can-someone-conform-the-config-id-code-for-the-nrf51822qfaah1/ */
		t->driver = "Nordic nRF51";
 8005042:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x4000);
 8005044:	0589      	lsls	r1, r1, #22
 8005046:	01d2      	lsls	r2, r2, #7
 8005048:	e014      	b.n	8005074 <nrf51_probe+0xd8>
	case 0x007B: /* nRF51822 (rev 3) QFAB C0 */
	case 0x007C: /* nRF51422 (rev 3) QFAB B0 */
	case 0x007D: /* nRF51822 (rev 3) CDAB A0 */
	case 0x007E: /* nRF51422 (rev 3) CDAB A0 */
		t->driver = "Nordic nRF51";
		target_add_ram(t, 0x20000000, 0x4000);
 800504a:	2180      	movs	r1, #128	; 0x80
 800504c:	2280      	movs	r2, #128	; 0x80
	case 0x0061: /* nRF51422 (rev 2) QFAB A00 */
	case 0x007B: /* nRF51822 (rev 3) QFAB C0 */
	case 0x007C: /* nRF51422 (rev 3) QFAB B0 */
	case 0x007D: /* nRF51822 (rev 3) CDAB A0 */
	case 0x007E: /* nRF51422 (rev 3) CDAB A0 */
		t->driver = "Nordic nRF51";
 800504e:	4b26      	ldr	r3, [pc, #152]	; (80050e8 <nrf51_probe+0x14c>)
		target_add_ram(t, 0x20000000, 0x4000);
 8005050:	1c20      	adds	r0, r4, #0
 8005052:	0589      	lsls	r1, r1, #22
 8005054:	01d2      	lsls	r2, r2, #7
	case 0x0061: /* nRF51422 (rev 2) QFAB A00 */
	case 0x007B: /* nRF51822 (rev 3) QFAB C0 */
	case 0x007C: /* nRF51422 (rev 3) QFAB B0 */
	case 0x007D: /* nRF51822 (rev 3) CDAB A0 */
	case 0x007E: /* nRF51422 (rev 3) CDAB A0 */
		t->driver = "Nordic nRF51";
 8005056:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x4000);
 8005058:	f003 f86c 	bl	8008134 <target_add_ram>
		nrf51_add_flash(t, 0x00000000, 0x20000, NRF51_PAGE_SIZE);
 800505c:	2280      	movs	r2, #128	; 0x80
 800505e:	1c20      	adds	r0, r4, #0
 8005060:	2100      	movs	r1, #0
 8005062:	0292      	lsls	r2, r2, #10
 8005064:	e00c      	b.n	8005080 <nrf51_probe+0xe4>
	case 0x0085: /* nRF51422 (rev 3) QFAC A0 */
	case 0x0086: /* nRF51422 (rev 3) QFAC A1 */
	case 0x0087: /* nRF51822 (rev 3) CFAC A0 */
	case 0x0088: /* nRF51422 (rev 3) CFAC A0 */
		t->driver = "Nordic nRF51";
		target_add_ram(t, 0x20000000, 0x8000);
 8005066:	2180      	movs	r1, #128	; 0x80
 8005068:	2280      	movs	r2, #128	; 0x80
 800506a:	1c20      	adds	r0, r4, #0
	case 0x0084: /* nRF51422 (rev 3) QFAC A1 */
	case 0x0085: /* nRF51422 (rev 3) QFAC A0 */
	case 0x0086: /* nRF51422 (rev 3) QFAC A1 */
	case 0x0087: /* nRF51822 (rev 3) CFAC A0 */
	case 0x0088: /* nRF51422 (rev 3) CFAC A0 */
		t->driver = "Nordic nRF51";
 800506c:	4b1e      	ldr	r3, [pc, #120]	; (80050e8 <nrf51_probe+0x14c>)
		target_add_ram(t, 0x20000000, 0x8000);
 800506e:	0589      	lsls	r1, r1, #22
	case 0x0084: /* nRF51422 (rev 3) QFAC A1 */
	case 0x0085: /* nRF51422 (rev 3) QFAC A0 */
	case 0x0086: /* nRF51422 (rev 3) QFAC A1 */
	case 0x0087: /* nRF51822 (rev 3) CFAC A0 */
	case 0x0088: /* nRF51422 (rev 3) CFAC A0 */
		t->driver = "Nordic nRF51";
 8005070:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x8000);
 8005072:	0212      	lsls	r2, r2, #8
 8005074:	f003 f85e 	bl	8008134 <target_add_ram>
		nrf51_add_flash(t, 0x00000000, 0x40000, NRF51_PAGE_SIZE);
 8005078:	2280      	movs	r2, #128	; 0x80
 800507a:	1c20      	adds	r0, r4, #0
 800507c:	2100      	movs	r1, #0
 800507e:	02d2      	lsls	r2, r2, #11
 8005080:	2380      	movs	r3, #128	; 0x80
 8005082:	00db      	lsls	r3, r3, #3
 8005084:	f7ff fee8 	bl	8004e58 <nrf51_add_flash>
		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
 8005088:	2280      	movs	r2, #128	; 0x80
 800508a:	0052      	lsls	r2, r2, #1
 800508c:	1c20      	adds	r0, r4, #0
 800508e:	4917      	ldr	r1, [pc, #92]	; (80050ec <nrf51_probe+0x150>)
 8005090:	1c13      	adds	r3, r2, #0
 8005092:	f7ff fee1 	bl	8004e58 <nrf51_add_flash>
		target_add_commands(t, nrf51_cmd_list, "nRF51");
 8005096:	4916      	ldr	r1, [pc, #88]	; (80050f0 <nrf51_probe+0x154>)
 8005098:	1c20      	adds	r0, r4, #0
 800509a:	3104      	adds	r1, #4
 800509c:	4a15      	ldr	r2, [pc, #84]	; (80050f4 <nrf51_probe+0x158>)
 800509e:	e01b      	b.n	80050d8 <nrf51_probe+0x13c>
		return true;
	case 0x00AC: /* nRF52832 Preview QFAA BA0 */
    	case 0x00C7: /* nRF52832 Revision 1 QFAA B00 */
		t->driver = "Nordic nRF52";
		target_add_ram(t, 0x20000000, 64*1024);
 80050a0:	2180      	movs	r1, #128	; 0x80
 80050a2:	2280      	movs	r2, #128	; 0x80
		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
		target_add_commands(t, nrf51_cmd_list, "nRF51");
		return true;
	case 0x00AC: /* nRF52832 Preview QFAA BA0 */
    	case 0x00C7: /* nRF52832 Revision 1 QFAA B00 */
		t->driver = "Nordic nRF52";
 80050a4:	4b14      	ldr	r3, [pc, #80]	; (80050f8 <nrf51_probe+0x15c>)
		target_add_ram(t, 0x20000000, 64*1024);
 80050a6:	1c20      	adds	r0, r4, #0
		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
		target_add_commands(t, nrf51_cmd_list, "nRF51");
		return true;
	case 0x00AC: /* nRF52832 Preview QFAA BA0 */
    	case 0x00C7: /* nRF52832 Revision 1 QFAA B00 */
		t->driver = "Nordic nRF52";
 80050a8:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 64*1024);
 80050aa:	0589      	lsls	r1, r1, #22
 80050ac:	0252      	lsls	r2, r2, #9
 80050ae:	f003 f841 	bl	8008134 <target_add_ram>
		nrf51_add_flash(t, 0x00000000, 512*1024, NRF52_PAGE_SIZE);
 80050b2:	2280      	movs	r2, #128	; 0x80
 80050b4:	2380      	movs	r3, #128	; 0x80
 80050b6:	1c20      	adds	r0, r4, #0
 80050b8:	2100      	movs	r1, #0
 80050ba:	0312      	lsls	r2, r2, #12
 80050bc:	015b      	lsls	r3, r3, #5
 80050be:	f7ff fecb 	bl	8004e58 <nrf51_add_flash>
		nrf51_add_flash(t, NRF51_UICR, 0x100, 0x100);
 80050c2:	2280      	movs	r2, #128	; 0x80
 80050c4:	0052      	lsls	r2, r2, #1
 80050c6:	1c20      	adds	r0, r4, #0
 80050c8:	4908      	ldr	r1, [pc, #32]	; (80050ec <nrf51_probe+0x150>)
 80050ca:	1c13      	adds	r3, r2, #0
 80050cc:	f7ff fec4 	bl	8004e58 <nrf51_add_flash>
		target_add_commands(t, nrf51_cmd_list, "nRF52");
 80050d0:	1c20      	adds	r0, r4, #0
 80050d2:	4907      	ldr	r1, [pc, #28]	; (80050f0 <nrf51_probe+0x154>)
 80050d4:	4a09      	ldr	r2, [pc, #36]	; (80050fc <nrf51_probe+0x160>)
 80050d6:	3104      	adds	r1, #4
 80050d8:	f002 ffec 	bl	80080b4 <target_add_commands>
		return true;
 80050dc:	2001      	movs	r0, #1
 80050de:	e000      	b.n	80050e2 <nrf51_probe+0x146>
	}

	return false;
 80050e0:	2000      	movs	r0, #0
}
 80050e2:	bd10      	pop	{r4, pc}
 80050e4:	1000005c 	.word	0x1000005c
 80050e8:	08012756 	.word	0x08012756
 80050ec:	10001000 	.word	0x10001000
 80050f0:	08012688 	.word	0x08012688
 80050f4:	0801275d 	.word	0x0801275d
 80050f8:	08012763 	.word	0x08012763
 80050fc:	0801276a 	.word	0x0801276a

08005100 <swdptap_seq_in_32bits_optimized_asm>:
};
#endif
static uint32_t swdptap_seq_in_32bits_optimized_asm(struct sw_driving_data * sw) __attribute__((naked));
static uint32_t swdptap_seq_in_32bits_optimized_asm(struct sw_driving_data * sw)
{
	asm("push	{ r4, r5, r6, r7, lr }");
 8005100:	b5f0      	push	{r4, r5, r6, r7, lr}
	asm("ldmia	r0,	{ r0, r1, r2, r3, r4, r5, r6 }");
 8005102:	c87f      	ldmia	r0, {r0, r1, r2, r3, r4, r5, r6}
	asm("mov	r0,	r6");
 8005104:	1c30      	adds	r0, r6, #0
	
	asm("mov	r7,	#1");
 8005106:	2701      	movs	r7, #1
	asm("mov	r6,	#0");
 8005108:	2600      	movs	r6, #0

	/* read bit */
	asm("ldr	r2,	[r0]");
 800510a:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800510c:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800510e:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005110:	420a      	tst	r2, r1
	asm("beq	2f");
 8005112:	d000      	beq.n	8005116 <swdptap_seq_in_32bits_optimized_asm+0x16>
	asm("orr	r6,	r7");
 8005114:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005116:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005118:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800511a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800511c:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800511e:	420a      	tst	r2, r1
	asm("beq	2f");
 8005120:	d000      	beq.n	8005124 <swdptap_seq_in_32bits_optimized_asm+0x24>
	asm("orr	r6,	r7");
 8005122:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005124:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005126:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005128:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800512a:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800512c:	420a      	tst	r2, r1
	asm("beq	2f");
 800512e:	d000      	beq.n	8005132 <swdptap_seq_in_32bits_optimized_asm+0x32>
	asm("orr	r6,	r7");
 8005130:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005132:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005134:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005136:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005138:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800513a:	420a      	tst	r2, r1
	asm("beq	2f");
 800513c:	d000      	beq.n	8005140 <swdptap_seq_in_32bits_optimized_asm+0x40>
	asm("orr	r6,	r7");
 800513e:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005140:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005142:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005144:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005146:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005148:	420a      	tst	r2, r1
	asm("beq	2f");
 800514a:	d000      	beq.n	800514e <swdptap_seq_in_32bits_optimized_asm+0x4e>
	asm("orr	r6,	r7");
 800514c:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800514e:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005150:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005152:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005154:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005156:	420a      	tst	r2, r1
	asm("beq	2f");
 8005158:	d000      	beq.n	800515c <swdptap_seq_in_32bits_optimized_asm+0x5c>
	asm("orr	r6,	r7");
 800515a:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800515c:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 800515e:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005160:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005162:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005164:	420a      	tst	r2, r1
	asm("beq	2f");
 8005166:	d000      	beq.n	800516a <swdptap_seq_in_32bits_optimized_asm+0x6a>
	asm("orr	r6,	r7");
 8005168:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800516a:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 800516c:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800516e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005170:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005172:	420a      	tst	r2, r1
	asm("beq	2f");
 8005174:	d000      	beq.n	8005178 <swdptap_seq_in_32bits_optimized_asm+0x78>
	asm("orr	r6,	r7");
 8005176:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005178:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 800517a:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800517c:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800517e:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005180:	420a      	tst	r2, r1
	asm("beq	2f");
 8005182:	d000      	beq.n	8005186 <swdptap_seq_in_32bits_optimized_asm+0x86>
	asm("orr	r6,	r7");
 8005184:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005186:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005188:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800518a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800518c:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800518e:	420a      	tst	r2, r1
	asm("beq	2f");
 8005190:	d000      	beq.n	8005194 <swdptap_seq_in_32bits_optimized_asm+0x94>
	asm("orr	r6,	r7");
 8005192:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005194:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005196:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005198:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800519a:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800519c:	420a      	tst	r2, r1
	asm("beq	2f");
 800519e:	d000      	beq.n	80051a2 <swdptap_seq_in_32bits_optimized_asm+0xa2>
	asm("orr	r6,	r7");
 80051a0:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051a2:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051a4:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051a6:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051a8:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051aa:	420a      	tst	r2, r1
	asm("beq	2f");
 80051ac:	d000      	beq.n	80051b0 <swdptap_seq_in_32bits_optimized_asm+0xb0>
	asm("orr	r6,	r7");
 80051ae:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051b0:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051b2:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051b4:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051b6:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051b8:	420a      	tst	r2, r1
	asm("beq	2f");
 80051ba:	d000      	beq.n	80051be <swdptap_seq_in_32bits_optimized_asm+0xbe>
	asm("orr	r6,	r7");
 80051bc:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051be:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051c0:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051c2:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051c4:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051c6:	420a      	tst	r2, r1
	asm("beq	2f");
 80051c8:	d000      	beq.n	80051cc <swdptap_seq_in_32bits_optimized_asm+0xcc>
	asm("orr	r6,	r7");
 80051ca:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051cc:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051ce:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051d0:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051d2:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051d4:	420a      	tst	r2, r1
	asm("beq	2f");
 80051d6:	d000      	beq.n	80051da <swdptap_seq_in_32bits_optimized_asm+0xda>
	asm("orr	r6,	r7");
 80051d8:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051da:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051dc:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051de:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051e0:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051e2:	420a      	tst	r2, r1
	asm("beq	2f");
 80051e4:	d000      	beq.n	80051e8 <swdptap_seq_in_32bits_optimized_asm+0xe8>
	asm("orr	r6,	r7");
 80051e6:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051e8:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051ea:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051ec:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051ee:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051f0:	420a      	tst	r2, r1
	asm("beq	2f");
 80051f2:	d000      	beq.n	80051f6 <swdptap_seq_in_32bits_optimized_asm+0xf6>
	asm("orr	r6,	r7");
 80051f4:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80051f6:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80051f8:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80051fa:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80051fc:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80051fe:	420a      	tst	r2, r1
	asm("beq	2f");
 8005200:	d000      	beq.n	8005204 <swdptap_seq_in_32bits_optimized_asm+0x104>
	asm("orr	r6,	r7");
 8005202:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005204:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005206:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005208:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800520a:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800520c:	420a      	tst	r2, r1
	asm("beq	2f");
 800520e:	d000      	beq.n	8005212 <swdptap_seq_in_32bits_optimized_asm+0x112>
	asm("orr	r6,	r7");
 8005210:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005212:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005214:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005216:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005218:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800521a:	420a      	tst	r2, r1
	asm("beq	2f");
 800521c:	d000      	beq.n	8005220 <swdptap_seq_in_32bits_optimized_asm+0x120>
	asm("orr	r6,	r7");
 800521e:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005220:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005222:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005224:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005226:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005228:	420a      	tst	r2, r1
	asm("beq	2f");
 800522a:	d000      	beq.n	800522e <swdptap_seq_in_32bits_optimized_asm+0x12e>
	asm("orr	r6,	r7");
 800522c:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800522e:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005230:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005232:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005234:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005236:	420a      	tst	r2, r1
	asm("beq	2f");
 8005238:	d000      	beq.n	800523c <swdptap_seq_in_32bits_optimized_asm+0x13c>
	asm("orr	r6,	r7");
 800523a:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800523c:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 800523e:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005240:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005242:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005244:	420a      	tst	r2, r1
	asm("beq	2f");
 8005246:	d000      	beq.n	800524a <swdptap_seq_in_32bits_optimized_asm+0x14a>
	asm("orr	r6,	r7");
 8005248:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800524a:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 800524c:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800524e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005250:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005252:	420a      	tst	r2, r1
	asm("beq	2f");
 8005254:	d000      	beq.n	8005258 <swdptap_seq_in_32bits_optimized_asm+0x158>
	asm("orr	r6,	r7");
 8005256:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005258:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 800525a:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800525c:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800525e:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005260:	420a      	tst	r2, r1
	asm("beq	2f");
 8005262:	d000      	beq.n	8005266 <swdptap_seq_in_32bits_optimized_asm+0x166>
	asm("orr	r6,	r7");
 8005264:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005266:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005268:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 800526a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800526c:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800526e:	420a      	tst	r2, r1
	asm("beq	2f");
 8005270:	d000      	beq.n	8005274 <swdptap_seq_in_32bits_optimized_asm+0x174>
	asm("orr	r6,	r7");
 8005272:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005274:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005276:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005278:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800527a:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800527c:	420a      	tst	r2, r1
	asm("beq	2f");
 800527e:	d000      	beq.n	8005282 <swdptap_seq_in_32bits_optimized_asm+0x182>
	asm("orr	r6,	r7");
 8005280:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005282:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005284:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005286:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005288:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 800528a:	420a      	tst	r2, r1
	asm("beq	2f");
 800528c:	d000      	beq.n	8005290 <swdptap_seq_in_32bits_optimized_asm+0x190>
	asm("orr	r6,	r7");
 800528e:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 8005290:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 8005292:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005294:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005296:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 8005298:	420a      	tst	r2, r1
	asm("beq	2f");
 800529a:	d000      	beq.n	800529e <swdptap_seq_in_32bits_optimized_asm+0x19e>
	asm("orr	r6,	r7");
 800529c:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 800529e:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80052a0:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052a2:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80052a4:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80052a6:	420a      	tst	r2, r1
	asm("beq	2f");
 80052a8:	d000      	beq.n	80052ac <swdptap_seq_in_32bits_optimized_asm+0x1ac>
	asm("orr	r6,	r7");
 80052aa:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80052ac:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80052ae:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052b0:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80052b2:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80052b4:	420a      	tst	r2, r1
	asm("beq	2f");
 80052b6:	d000      	beq.n	80052ba <swdptap_seq_in_32bits_optimized_asm+0x1ba>
	asm("orr	r6,	r7");
 80052b8:	433e      	orrs	r6, r7
	asm("2:");
	asm("lsl	r7,	r7,	#1");
 80052ba:	007f      	lsls	r7, r7, #1

	/* read bit */
	asm("ldr	r2,	[r0]");
 80052bc:	6802      	ldr	r2, [r0, #0]
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052be:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80052c0:	601d      	str	r5, [r3, #0]
	asm("tst	r2,	r1");
 80052c2:	420a      	tst	r2, r1
	asm("beq	2f");
 80052c4:	d000      	beq.n	80052c8 <swdptap_seq_in_32bits_optimized_asm+0x1c8>
	asm("orr	r6,	r7");
 80052c6:	433e      	orrs	r6, r7
	asm("2:");

	asm("mov	r0,	r6");
 80052c8:	1c30      	adds	r0, r6, #0
	asm("pop	{ r4, r5, r6, r7, pc }");
 80052ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

080052cc <swdptap_seq_out_32bits_optimized_asm>:
}

static void swdptap_seq_out_32bits_optimized_asm(struct sw_driving_data * sw, uint32_t data) __attribute__((naked));
static void swdptap_seq_out_32bits_optimized_asm(struct sw_driving_data * sw, uint32_t data)
{
	asm("push	{ r4, r5, r6, lr }");
 80052cc:	b570      	push	{r4, r5, r6, lr}
	asm("mov	r6,	r1");
 80052ce:	1c0e      	adds	r6, r1, #0
	asm("ldmia	r0,	{ r0, r1, r2, r3, r4, r5 }");
 80052d0:	c83f      	ldmia	r0, {r0, r1, r2, r3, r4, r5}

	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80052d2:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80052d4:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80052d6:	d200      	bcs.n	80052da <swdptap_seq_out_32bits_optimized_asm+0xe>
	asm("str	r2,	[r0]");
 80052d8:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052da:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80052dc:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80052de:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80052e0:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80052e2:	d200      	bcs.n	80052e6 <swdptap_seq_out_32bits_optimized_asm+0x1a>
	asm("str	r2,	[r0]");
 80052e4:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052e6:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80052e8:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80052ea:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80052ec:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80052ee:	d200      	bcs.n	80052f2 <swdptap_seq_out_32bits_optimized_asm+0x26>
	asm("str	r2,	[r0]");
 80052f0:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052f2:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80052f4:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80052f6:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80052f8:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80052fa:	d200      	bcs.n	80052fe <swdptap_seq_out_32bits_optimized_asm+0x32>
	asm("str	r2,	[r0]");
 80052fc:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80052fe:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005300:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005302:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005304:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005306:	d200      	bcs.n	800530a <swdptap_seq_out_32bits_optimized_asm+0x3e>
	asm("str	r2,	[r0]");
 8005308:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800530a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800530c:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800530e:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005310:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005312:	d200      	bcs.n	8005316 <swdptap_seq_out_32bits_optimized_asm+0x4a>
	asm("str	r2,	[r0]");
 8005314:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005316:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005318:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800531a:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 800531c:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800531e:	d200      	bcs.n	8005322 <swdptap_seq_out_32bits_optimized_asm+0x56>
	asm("str	r2,	[r0]");
 8005320:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005322:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005324:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005326:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005328:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800532a:	d200      	bcs.n	800532e <swdptap_seq_out_32bits_optimized_asm+0x62>
	asm("str	r2,	[r0]");
 800532c:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800532e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005330:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005332:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005334:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005336:	d200      	bcs.n	800533a <swdptap_seq_out_32bits_optimized_asm+0x6e>
	asm("str	r2,	[r0]");
 8005338:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800533a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800533c:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800533e:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005340:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005342:	d200      	bcs.n	8005346 <swdptap_seq_out_32bits_optimized_asm+0x7a>
	asm("str	r2,	[r0]");
 8005344:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005346:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005348:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800534a:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 800534c:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800534e:	d200      	bcs.n	8005352 <swdptap_seq_out_32bits_optimized_asm+0x86>
	asm("str	r2,	[r0]");
 8005350:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005352:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005354:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005356:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005358:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800535a:	d200      	bcs.n	800535e <swdptap_seq_out_32bits_optimized_asm+0x92>
	asm("str	r2,	[r0]");
 800535c:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800535e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005360:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005362:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005364:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005366:	d200      	bcs.n	800536a <swdptap_seq_out_32bits_optimized_asm+0x9e>
	asm("str	r2,	[r0]");
 8005368:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800536a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800536c:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800536e:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005370:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005372:	d200      	bcs.n	8005376 <swdptap_seq_out_32bits_optimized_asm+0xaa>
	asm("str	r2,	[r0]");
 8005374:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005376:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005378:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800537a:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 800537c:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800537e:	d200      	bcs.n	8005382 <swdptap_seq_out_32bits_optimized_asm+0xb6>
	asm("str	r2,	[r0]");
 8005380:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005382:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005384:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005386:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005388:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800538a:	d200      	bcs.n	800538e <swdptap_seq_out_32bits_optimized_asm+0xc2>
	asm("str	r2,	[r0]");
 800538c:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800538e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005390:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005392:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005394:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005396:	d200      	bcs.n	800539a <swdptap_seq_out_32bits_optimized_asm+0xce>
	asm("str	r2,	[r0]");
 8005398:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800539a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800539c:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800539e:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053a0:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053a2:	d200      	bcs.n	80053a6 <swdptap_seq_out_32bits_optimized_asm+0xda>
	asm("str	r2,	[r0]");
 80053a4:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053a6:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053a8:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053aa:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053ac:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053ae:	d200      	bcs.n	80053b2 <swdptap_seq_out_32bits_optimized_asm+0xe6>
	asm("str	r2,	[r0]");
 80053b0:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053b2:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053b4:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053b6:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053b8:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053ba:	d200      	bcs.n	80053be <swdptap_seq_out_32bits_optimized_asm+0xf2>
	asm("str	r2,	[r0]");
 80053bc:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053be:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053c0:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053c2:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053c4:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053c6:	d200      	bcs.n	80053ca <swdptap_seq_out_32bits_optimized_asm+0xfe>
	asm("str	r2,	[r0]");
 80053c8:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053ca:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053cc:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053ce:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053d0:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053d2:	d200      	bcs.n	80053d6 <swdptap_seq_out_32bits_optimized_asm+0x10a>
	asm("str	r2,	[r0]");
 80053d4:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053d6:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053d8:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053da:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053dc:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053de:	d200      	bcs.n	80053e2 <swdptap_seq_out_32bits_optimized_asm+0x116>
	asm("str	r2,	[r0]");
 80053e0:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053e2:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053e4:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053e6:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053e8:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053ea:	d200      	bcs.n	80053ee <swdptap_seq_out_32bits_optimized_asm+0x122>
	asm("str	r2,	[r0]");
 80053ec:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053ee:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053f0:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053f2:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 80053f4:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 80053f6:	d200      	bcs.n	80053fa <swdptap_seq_out_32bits_optimized_asm+0x12e>
	asm("str	r2,	[r0]");
 80053f8:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 80053fa:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 80053fc:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 80053fe:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005400:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005402:	d200      	bcs.n	8005406 <swdptap_seq_out_32bits_optimized_asm+0x13a>
	asm("str	r2,	[r0]");
 8005404:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005406:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005408:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800540a:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 800540c:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800540e:	d200      	bcs.n	8005412 <swdptap_seq_out_32bits_optimized_asm+0x146>
	asm("str	r2,	[r0]");
 8005410:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005412:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005414:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005416:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005418:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800541a:	d200      	bcs.n	800541e <swdptap_seq_out_32bits_optimized_asm+0x152>
	asm("str	r2,	[r0]");
 800541c:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800541e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005420:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005422:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005424:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005426:	d200      	bcs.n	800542a <swdptap_seq_out_32bits_optimized_asm+0x15e>
	asm("str	r2,	[r0]");
 8005428:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800542a:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 800542c:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800542e:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005430:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 8005432:	d200      	bcs.n	8005436 <swdptap_seq_out_32bits_optimized_asm+0x16a>
	asm("str	r2,	[r0]");
 8005434:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005436:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005438:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 800543a:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 800543c:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800543e:	d200      	bcs.n	8005442 <swdptap_seq_out_32bits_optimized_asm+0x176>
	asm("str	r2,	[r0]");
 8005440:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 8005442:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005444:	601d      	str	r5, [r3, #0]
	/* drive data */
	asm("lsr	r6,	r6,	#1");
 8005446:	0876      	lsrs	r6, r6, #1
	asm("str	r1,	[r0]");
 8005448:	6001      	str	r1, [r0, #0]
	asm("bcs	1f");
 800544a:	d200      	bcs.n	800544e <swdptap_seq_out_32bits_optimized_asm+0x182>
	asm("str	r2,	[r0]");
 800544c:	6002      	str	r2, [r0, #0]
	asm("1:");
	/* pulse clock */
	asm("str	r4,	[r3]");
 800544e:	601c      	str	r4, [r3, #0]
	asm("str	r5,	[r3]");
 8005450:	601d      	str	r5, [r3, #0]

	asm("pop	{ r4, r5, r6, pc }");
 8005452:	bd70      	pop	{r4, r5, r6, pc}

08005454 <swdptap_turnaround>:
	unsigned	seq_out_parity;
}
counters;

static inline void swdptap_turnaround(uint8_t dir)
{
 8005454:	b570      	push	{r4, r5, r6, lr}
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
 8005456:	4b1c      	ldr	r3, [pc, #112]	; (80054c8 <swdptap_turnaround+0x74>)
 8005458:	781a      	ldrb	r2, [r3, #0]
 800545a:	4282      	cmp	r2, r0
 800545c:	d011      	beq.n	8005482 <swdptap_turnaround+0x2e>
	olddir = dir;
 800545e:	7018      	strb	r0, [r3, #0]

	//DEBUG("%s", dir ? "\n-> ":"\n<- ");

	if(dir)
 8005460:	2800      	cmp	r0, #0
 8005462:	d00f      	beq.n	8005484 <swdptap_turnaround+0x30>
		SWDIO_MODE_FLOAT();
 8005464:	2290      	movs	r2, #144	; 0x90
	SWCLK_PULSE
 8005466:	2040      	movs	r0, #64	; 0x40
	olddir = dir;

	//DEBUG("%s", dir ? "\n-> ":"\n<- ");

	if(dir)
		SWDIO_MODE_FLOAT();
 8005468:	05d2      	lsls	r2, r2, #23
 800546a:	6811      	ldr	r1, [r2, #0]
 800546c:	4b17      	ldr	r3, [pc, #92]	; (80054cc <swdptap_turnaround+0x78>)
 800546e:	4c18      	ldr	r4, [pc, #96]	; (80054d0 <swdptap_turnaround+0x7c>)
 8005470:	4019      	ands	r1, r3
 8005472:	6011      	str	r1, [r2, #0]
 8005474:	6825      	ldr	r5, [r4, #0]
	SWCLK_PULSE
 8005476:	4917      	ldr	r1, [pc, #92]	; (80054d4 <swdptap_turnaround+0x80>)
 8005478:	4a17      	ldr	r2, [pc, #92]	; (80054d8 <swdptap_turnaround+0x84>)
	olddir = dir;

	//DEBUG("%s", dir ? "\n-> ":"\n<- ");

	if(dir)
		SWDIO_MODE_FLOAT();
 800547a:	402b      	ands	r3, r5
 800547c:	6023      	str	r3, [r4, #0]
	SWCLK_PULSE
 800547e:	6008      	str	r0, [r1, #0]
 8005480:	6010      	str	r0, [r2, #0]
	if(!dir)
		SWDIO_MODE_DRIVE();
}
 8005482:	bd70      	pop	{r4, r5, r6, pc}

	//DEBUG("%s", dir ? "\n-> ":"\n<- ");

	if(dir)
		SWDIO_MODE_FLOAT();
	SWCLK_PULSE
 8005484:	2040      	movs	r0, #64	; 0x40
	if(!dir)
		SWDIO_MODE_DRIVE();
 8005486:	2390      	movs	r3, #144	; 0x90
 8005488:	2680      	movs	r6, #128	; 0x80

	//DEBUG("%s", dir ? "\n-> ":"\n<- ");

	if(dir)
		SWDIO_MODE_FLOAT();
	SWCLK_PULSE
 800548a:	4d12      	ldr	r5, [pc, #72]	; (80054d4 <swdptap_turnaround+0x80>)
 800548c:	4a12      	ldr	r2, [pc, #72]	; (80054d8 <swdptap_turnaround+0x84>)
 800548e:	6028      	str	r0, [r5, #0]
	if(!dir)
		SWDIO_MODE_DRIVE();
 8005490:	05db      	lsls	r3, r3, #23

	//DEBUG("%s", dir ? "\n-> ":"\n<- ");

	if(dir)
		SWDIO_MODE_FLOAT();
	SWCLK_PULSE
 8005492:	6010      	str	r0, [r2, #0]
	if(!dir)
		SWDIO_MODE_DRIVE();
 8005494:	6818      	ldr	r0, [r3, #0]
 8005496:	4a0d      	ldr	r2, [pc, #52]	; (80054cc <swdptap_turnaround+0x78>)
 8005498:	4d0d      	ldr	r5, [pc, #52]	; (80054d0 <swdptap_turnaround+0x7c>)
 800549a:	4010      	ands	r0, r2
 800549c:	6018      	str	r0, [r3, #0]
 800549e:	6828      	ldr	r0, [r5, #0]
 80054a0:	00f6      	lsls	r6, r6, #3
 80054a2:	4002      	ands	r2, r0
 80054a4:	602a      	str	r2, [r5, #0]
 80054a6:	1c32      	adds	r2, r6, #0
 80054a8:	243f      	movs	r4, #63	; 0x3f
 80054aa:	21c0      	movs	r1, #192	; 0xc0
 80054ac:	6818      	ldr	r0, [r3, #0]
 80054ae:	4d0b      	ldr	r5, [pc, #44]	; (80054dc <swdptap_turnaround+0x88>)
 80054b0:	4302      	orrs	r2, r0
 80054b2:	601a      	str	r2, [r3, #0]
 80054b4:	682b      	ldr	r3, [r5, #0]
 80054b6:	480a      	ldr	r0, [pc, #40]	; (80054e0 <swdptap_turnaround+0x8c>)
 80054b8:	43a3      	bics	r3, r4
 80054ba:	602b      	str	r3, [r5, #0]
 80054bc:	6802      	ldr	r2, [r0, #0]
 80054be:	010b      	lsls	r3, r1, #4
 80054c0:	4313      	orrs	r3, r2
 80054c2:	6003      	str	r3, [r0, #0]
 80054c4:	e7dd      	b.n	8005482 <swdptap_turnaround+0x2e>
 80054c6:	46c0      	nop			; (mov r8, r8)
 80054c8:	200011dc 	.word	0x200011dc
 80054cc:	fffff3ff 	.word	0xfffff3ff
 80054d0:	4800000c 	.word	0x4800000c
 80054d4:	48000018 	.word	0x48000018
 80054d8:	48000028 	.word	0x48000028
 80054dc:	48000004 	.word	0x48000004
 80054e0:	48000008 	.word	0x48000008

080054e4 <is_sforth_mode_active>:
	gpio_mode_setup(GPIOC, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO14);
	return (GPIOC_IDR & (1 << 14)) ? true : false;
}

static bool sforth_mode_active;
bool is_sforth_mode_active(void) { return sforth_mode_active; }
 80054e4:	4b01      	ldr	r3, [pc, #4]	; (80054ec <is_sforth_mode_active+0x8>)
 80054e6:	7858      	ldrb	r0, [r3, #1]
 80054e8:	4770      	bx	lr
 80054ea:	46c0      	nop			; (mov r8, r8)
 80054ec:	200011dc 	.word	0x200011dc

080054f0 <platform_init>:
	rcc_apb1_frequency = 48000000;
	rcc_ahb_frequency = 48000000;
}

void platform_init(void)
{
 80054f0:	b510      	push	{r4, lr}
	rcc_set_usbclk_source(RCC_PLL);
 80054f2:	2003      	movs	r0, #3
 80054f4:	f006 f89e 	bl	800b634 <rcc_set_usbclk_source>
static bool sforth_mode_active;
bool is_sforth_mode_active(void) { return sforth_mode_active; }

static void rcc_clock_setup_in_hse_8mhz_out_48mhz(void)
{
	rcc_osc_on(RCC_HSE);
 80054f8:	2002      	movs	r0, #2
 80054fa:	f006 f84f 	bl	800b59c <rcc_osc_on>
	rcc_wait_for_osc_ready(RCC_HSE);
 80054fe:	2002      	movs	r0, #2
 8005500:	f006 f844 	bl	800b58c <rcc_wait_for_osc_ready>
	rcc_set_sysclk_source(RCC_HSE);
 8005504:	2002      	movs	r0, #2
 8005506:	f006 f873 	bl	800b5f0 <rcc_set_sysclk_source>

	rcc_set_hpre(RCC_CFGR_HPRE_NODIV);
 800550a:	2000      	movs	r0, #0
 800550c:	f006 f8bc 	bl	800b688 <rcc_set_hpre>
	rcc_set_ppre(RCC_CFGR_PPRE_NODIV);
 8005510:	2000      	movs	r0, #0
 8005512:	f006 f8ad 	bl	800b670 <rcc_set_ppre>

	flash_set_ws(FLASH_ACR_LATENCY_024_048MHZ);
 8005516:	2001      	movs	r0, #1
 8005518:	f006 f916 	bl	800b748 <flash_set_ws>

	/* 8MHz * 12 / 2 = 48MHz */
	rcc_set_pll_multiplication_factor(RCC_CFGR_PLLMUL_MUL12);
 800551c:	20a0      	movs	r0, #160	; 0xa0
 800551e:	0380      	lsls	r0, r0, #14
 8005520:	f006 f89a 	bl	800b658 <rcc_set_pll_multiplication_factor>

	RCC_CFGR &= ~RCC_CFGR_PLLSRC;
 8005524:	4a4e      	ldr	r2, [pc, #312]	; (8005660 <platform_init+0x170>)
 8005526:	4b4f      	ldr	r3, [pc, #316]	; (8005664 <platform_init+0x174>)
 8005528:	6811      	ldr	r1, [r2, #0]

	rcc_osc_on(RCC_PLL);
 800552a:	2003      	movs	r0, #3
	flash_set_ws(FLASH_ACR_LATENCY_024_048MHZ);

	/* 8MHz * 12 / 2 = 48MHz */
	rcc_set_pll_multiplication_factor(RCC_CFGR_PLLMUL_MUL12);

	RCC_CFGR &= ~RCC_CFGR_PLLSRC;
 800552c:	400b      	ands	r3, r1
 800552e:	6013      	str	r3, [r2, #0]

	rcc_osc_on(RCC_PLL);
 8005530:	f006 f834 	bl	800b59c <rcc_osc_on>
	rcc_wait_for_osc_ready(RCC_PLL);
 8005534:	2003      	movs	r0, #3
 8005536:	f006 f829 	bl	800b58c <rcc_wait_for_osc_ready>
	rcc_set_sysclk_source(RCC_PLL);
 800553a:	2003      	movs	r0, #3
 800553c:	f006 f858 	bl	800b5f0 <rcc_set_sysclk_source>

	rcc_apb1_frequency = 48000000;
 8005540:	4b49      	ldr	r3, [pc, #292]	; (8005668 <platform_init+0x178>)
 8005542:	4a4a      	ldr	r2, [pc, #296]	; (800566c <platform_init+0x17c>)
{
	rcc_set_usbclk_source(RCC_PLL);
	rcc_clock_setup_in_hse_8mhz_out_48mhz();

	/* Enable peripherals */
	rcc_periph_clock_enable(RCC_USB);
 8005544:	484a      	ldr	r0, [pc, #296]	; (8005670 <platform_init+0x180>)

	rcc_osc_on(RCC_PLL);
	rcc_wait_for_osc_ready(RCC_PLL);
	rcc_set_sysclk_source(RCC_PLL);

	rcc_apb1_frequency = 48000000;
 8005546:	6013      	str	r3, [r2, #0]
	rcc_ahb_frequency = 48000000;
 8005548:	4a4a      	ldr	r2, [pc, #296]	; (8005674 <platform_init+0x184>)
 800554a:	6013      	str	r3, [r2, #0]
{
	rcc_set_usbclk_source(RCC_PLL);
	rcc_clock_setup_in_hse_8mhz_out_48mhz();

	/* Enable peripherals */
	rcc_periph_clock_enable(RCC_USB);
 800554c:	f006 f90a 	bl	800b764 <rcc_periph_clock_enable>
	rcc_periph_clock_enable(RCC_GPIOA);
 8005550:	4849      	ldr	r0, [pc, #292]	; (8005678 <platform_init+0x188>)
 8005552:	f006 f907 	bl	800b764 <rcc_periph_clock_enable>
	rcc_periph_clock_enable(RCC_GPIOB);
 8005556:	4849      	ldr	r0, [pc, #292]	; (800567c <platform_init+0x18c>)
 8005558:	f006 f904 	bl	800b764 <rcc_periph_clock_enable>
	rcc_periph_clock_enable(RCC_GPIOC);
 800555c:	4848      	ldr	r0, [pc, #288]	; (8005680 <platform_init+0x190>)
 800555e:	f006 f901 	bl	800b764 <rcc_periph_clock_enable>

	/* Setup GPIO ports */
	gpio_mode_setup(TMS_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, TMS_PIN);
 8005562:	2101      	movs	r1, #1
 8005564:	2090      	movs	r0, #144	; 0x90
 8005566:	1c0b      	adds	r3, r1, #0
 8005568:	05c0      	lsls	r0, r0, #23
 800556a:	2200      	movs	r2, #0
 800556c:	f006 f8b2 	bl	800b6d4 <gpio_mode_setup>
	gpio_set_output_options(TMS_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, TMS_PIN);
 8005570:	2090      	movs	r0, #144	; 0x90
 8005572:	2100      	movs	r1, #0
 8005574:	05c0      	lsls	r0, r0, #23
 8005576:	2203      	movs	r2, #3
 8005578:	2301      	movs	r3, #1
 800557a:	f006 f8c9 	bl	800b710 <gpio_set_output_options>
	
	gpio_mode_setup(TCK_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, TCK_PIN);
 800557e:	2101      	movs	r1, #1
 8005580:	2090      	movs	r0, #144	; 0x90
 8005582:	1c0b      	adds	r3, r1, #0
 8005584:	05c0      	lsls	r0, r0, #23
 8005586:	2200      	movs	r2, #0
 8005588:	f006 f8a4 	bl	800b6d4 <gpio_mode_setup>
	gpio_set_output_options(TCK_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, TCK_PIN);
 800558c:	2090      	movs	r0, #144	; 0x90
 800558e:	2100      	movs	r1, #0
 8005590:	05c0      	lsls	r0, r0, #23
 8005592:	2203      	movs	r2, #3
 8005594:	2301      	movs	r3, #1
 8005596:	f006 f8bb 	bl	800b710 <gpio_set_output_options>
	
	gpio_mode_setup(TDI_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, TDI_PIN);
 800559a:	2101      	movs	r1, #1
 800559c:	2090      	movs	r0, #144	; 0x90
 800559e:	1c0b      	adds	r3, r1, #0
 80055a0:	05c0      	lsls	r0, r0, #23
 80055a2:	2200      	movs	r2, #0
 80055a4:	f006 f896 	bl	800b6d4 <gpio_mode_setup>
	gpio_set_output_options(TDI_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, TDI_PIN);
 80055a8:	2090      	movs	r0, #144	; 0x90
 80055aa:	2203      	movs	r2, #3
 80055ac:	2301      	movs	r3, #1
 80055ae:	05c0      	lsls	r0, r0, #23
 80055b0:	2100      	movs	r1, #0
 80055b2:	f006 f8ad 	bl	800b710 <gpio_set_output_options>
	
	
	uint16_t srst_pin = SRST_PIN_V1;
	gpio_set(SRST_PORT, srst_pin);
 80055b6:	2090      	movs	r0, #144	; 0x90
 80055b8:	2101      	movs	r1, #1
 80055ba:	05c0      	lsls	r0, r0, #23
 80055bc:	f006 f87a 	bl	800b6b4 <gpio_set>
	
	gpio_mode_setup(SRST_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, srst_pin);
 80055c0:	2101      	movs	r1, #1
 80055c2:	2090      	movs	r0, #144	; 0x90
 80055c4:	1c0b      	adds	r3, r1, #0
 80055c6:	05c0      	lsls	r0, r0, #23
 80055c8:	2200      	movs	r2, #0
 80055ca:	f006 f883 	bl	800b6d4 <gpio_mode_setup>
	gpio_set_output_options(SRST_PORT, GPIO_OTYPE_OD, GPIO_OSPEED_HIGH, srst_pin);
 80055ce:	2101      	movs	r1, #1
 80055d0:	2090      	movs	r0, #144	; 0x90
 80055d2:	1c0b      	adds	r3, r1, #0
 80055d4:	05c0      	lsls	r0, r0, #23
 80055d6:	2203      	movs	r2, #3
 80055d8:	f006 f89a 	bl	800b710 <gpio_set_output_options>
	
	gpio_mode_setup(LED_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, led_idle_run);
 80055dc:	2090      	movs	r0, #144	; 0x90
 80055de:	4c29      	ldr	r4, [pc, #164]	; (8005684 <platform_init+0x194>)
 80055e0:	05c0      	lsls	r0, r0, #23
 80055e2:	8823      	ldrh	r3, [r4, #0]
 80055e4:	2101      	movs	r1, #1
 80055e6:	2200      	movs	r2, #0
 80055e8:	f006 f874 	bl	800b6d4 <gpio_mode_setup>
	gpio_set_output_options(LED_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, led_idle_run);
 80055ec:	2090      	movs	r0, #144	; 0x90
 80055ee:	8823      	ldrh	r3, [r4, #0]
 80055f0:	05c0      	lsls	r0, r0, #23
 80055f2:	2100      	movs	r1, #0
 80055f4:	2203      	movs	r2, #3
 80055f6:	f006 f88b 	bl	800b710 <gpio_set_output_options>

	/* initialize swd port */
	gpio_mode_setup(SWCLK_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWCLK_PIN);
 80055fa:	2090      	movs	r0, #144	; 0x90
 80055fc:	2101      	movs	r1, #1
 80055fe:	05c0      	lsls	r0, r0, #23
 8005600:	2200      	movs	r2, #0
 8005602:	2340      	movs	r3, #64	; 0x40
 8005604:	f006 f866 	bl	800b6d4 <gpio_mode_setup>
	gpio_set_output_options(SWCLK_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SWCLK_PIN);
 8005608:	2090      	movs	r0, #144	; 0x90
 800560a:	2100      	movs	r1, #0
 800560c:	05c0      	lsls	r0, r0, #23
 800560e:	2203      	movs	r2, #3
 8005610:	2340      	movs	r3, #64	; 0x40
 8005612:	f006 f87d 	bl	800b710 <gpio_set_output_options>
	
	gpio_mode_setup(SWDIO_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWDIO_PIN);
 8005616:	2090      	movs	r0, #144	; 0x90
 8005618:	2101      	movs	r1, #1
 800561a:	05c0      	lsls	r0, r0, #23
 800561c:	2200      	movs	r2, #0
 800561e:	2320      	movs	r3, #32
 8005620:	f006 f858 	bl	800b6d4 <gpio_mode_setup>

uint16_t led_idle_run;

static bool platform_sforth_entry_requested(void)
{
	gpio_mode_setup(GPIOC, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO14);
 8005624:	2480      	movs	r4, #128	; 0x80
	/* initialize swd port */
	gpio_mode_setup(SWCLK_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWCLK_PIN);
	gpio_set_output_options(SWCLK_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SWCLK_PIN);
	
	gpio_mode_setup(SWDIO_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWDIO_PIN);
	gpio_set_output_options(SWDIO_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SWDIO_PIN);
 8005626:	2090      	movs	r0, #144	; 0x90
 8005628:	2100      	movs	r1, #0
 800562a:	05c0      	lsls	r0, r0, #23
 800562c:	2203      	movs	r2, #3
 800562e:	2320      	movs	r3, #32

uint16_t led_idle_run;

static bool platform_sforth_entry_requested(void)
{
	gpio_mode_setup(GPIOC, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO14);
 8005630:	01e4      	lsls	r4, r4, #7
	/* initialize swd port */
	gpio_mode_setup(SWCLK_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWCLK_PIN);
	gpio_set_output_options(SWCLK_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SWCLK_PIN);
	
	gpio_mode_setup(SWDIO_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWDIO_PIN);
	gpio_set_output_options(SWDIO_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SWDIO_PIN);
 8005632:	f006 f86d 	bl	800b710 <gpio_set_output_options>

uint16_t led_idle_run;

static bool platform_sforth_entry_requested(void)
{
	gpio_mode_setup(GPIOC, GPIO_MODE_INPUT, GPIO_PUPD_PULLDOWN, GPIO14);
 8005636:	1c23      	adds	r3, r4, #0
 8005638:	4813      	ldr	r0, [pc, #76]	; (8005688 <platform_init+0x198>)
 800563a:	2100      	movs	r1, #0
 800563c:	2202      	movs	r2, #2
 800563e:	f006 f849 	bl	800b6d4 <gpio_mode_setup>
	return (GPIOC_IDR & (1 << 14)) ? true : false;
 8005642:	4b12      	ldr	r3, [pc, #72]	; (800568c <platform_init+0x19c>)
 8005644:	681b      	ldr	r3, [r3, #0]
	
	gpio_mode_setup(SWDIO_PORT, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, SWDIO_PIN);
	gpio_set_output_options(SWDIO_PORT, GPIO_OTYPE_PP, GPIO_OSPEED_HIGH, SWDIO_PIN);

	//SCB_VTOR = 0x0000; /* Relocate interrupt vector table here */
	if (platform_sforth_entry_requested())
 8005646:	4223      	tst	r3, r4
 8005648:	d002      	beq.n	8005650 <platform_init+0x160>
		sforth_mode_active = true;
 800564a:	2201      	movs	r2, #1
 800564c:	4b10      	ldr	r3, [pc, #64]	; (8005690 <platform_init+0x1a0>)
 800564e:	705a      	strb	r2, [r3, #1]

	platform_timing_init();
 8005650:	f005 ff30 	bl	800b4b4 <platform_timing_init>
	cdcacm_init();
 8005654:	f005 fe70 	bl	800b338 <cdcacm_init>
	usbuart_init();
 8005658:	f005 fea6 	bl	800b3a8 <usbuart_init>
}
 800565c:	bd10      	pop	{r4, pc}
 800565e:	46c0      	nop			; (mov r8, r8)
 8005660:	40021004 	.word	0x40021004
 8005664:	fffeffff 	.word	0xfffeffff
 8005668:	02dc6c00 	.word	0x02dc6c00
 800566c:	200000cc 	.word	0x200000cc
 8005670:	00000397 	.word	0x00000397
 8005674:	200000c8 	.word	0x200000c8
 8005678:	00000291 	.word	0x00000291
 800567c:	00000292 	.word	0x00000292
 8005680:	00000293 	.word	0x00000293
 8005684:	20002064 	.word	0x20002064
 8005688:	48000800 	.word	0x48000800
 800568c:	48000810 	.word	0x48000810
 8005690:	200011dc 	.word	0x200011dc

08005694 <platform_srst_set_val>:

void platform_srst_set_val(bool assert)
{
 8005694:	b508      	push	{r3, lr}
	uint16_t pin;
	pin = SRST_PIN_V1;
	if (assert)
 8005696:	2800      	cmp	r0, #0
 8005698:	d005      	beq.n	80056a6 <platform_srst_set_val+0x12>
		gpio_clear(SRST_PORT, pin);
 800569a:	2090      	movs	r0, #144	; 0x90
 800569c:	2101      	movs	r1, #1
 800569e:	05c0      	lsls	r0, r0, #23
 80056a0:	f006 f80a 	bl	800b6b8 <gpio_clear>
 80056a4:	e004      	b.n	80056b0 <platform_srst_set_val+0x1c>
	else
		gpio_set(SRST_PORT, pin);
 80056a6:	2090      	movs	r0, #144	; 0x90
 80056a8:	2101      	movs	r1, #1
 80056aa:	05c0      	lsls	r0, r0, #23
 80056ac:	f006 f802 	bl	800b6b4 <gpio_set>
}
 80056b0:	bd08      	pop	{r3, pc}

080056b2 <platform_srst_get_val>:

bool platform_srst_get_val()
{
	uint16_t pin;
	pin = SRST_PIN_V1;
	return gpio_get(SRST_PORT, pin) == 0;
 80056b2:	2090      	movs	r0, #144	; 0x90
	else
		gpio_set(SRST_PORT, pin);
}

bool platform_srst_get_val()
{
 80056b4:	b508      	push	{r3, lr}
	uint16_t pin;
	pin = SRST_PIN_V1;
	return gpio_get(SRST_PORT, pin) == 0;
 80056b6:	05c0      	lsls	r0, r0, #23
 80056b8:	2101      	movs	r1, #1
 80056ba:	f006 f800 	bl	800b6be <gpio_get>
 80056be:	4243      	negs	r3, r0
 80056c0:	4158      	adcs	r0, r3
 80056c2:	b2c0      	uxtb	r0, r0
}
 80056c4:	bd08      	pop	{r3, pc}

080056c6 <platform_target_voltage>:

const char *platform_target_voltage(void)
{
	return "unknown";
}
 80056c6:	4801      	ldr	r0, [pc, #4]	; (80056cc <platform_target_voltage+0x6>)
 80056c8:	4770      	bx	lr
 80056ca:	46c0      	nop			; (mov r8, r8)
 80056cc:	08012858 	.word	0x08012858

080056d0 <platform_request_boot>:

void platform_request_boot(void)
{
	while (1);
 80056d0:	e7fe      	b.n	80056d0 <platform_request_boot>

080056d2 <swdptap_seq_in>:
	return ret;
}

uint32_t swdptap_seq_in(int ticks)
{
	counters.seq_in ++;
 80056d2:	4a21      	ldr	r2, [pc, #132]	; (8005758 <swdptap_seq_in+0x86>)
                
	return ret;
}

uint32_t swdptap_seq_in(int ticks)
{
 80056d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	counters.seq_in ++;
 80056d6:	6813      	ldr	r3, [r2, #0]
                
	return ret;
}

uint32_t swdptap_seq_in(int ticks)
{
 80056d8:	1c04      	adds	r4, r0, #0
	counters.seq_in ++;
 80056da:	3301      	adds	r3, #1
	swdptap_turnaround(1);
 80056dc:	2001      	movs	r0, #1
	return ret;
}

uint32_t swdptap_seq_in(int ticks)
{
	counters.seq_in ++;
 80056de:	6013      	str	r3, [r2, #0]
	swdptap_turnaround(1);
 80056e0:	f7ff feb8 	bl	8005454 <swdptap_turnaround>
	if (/* ;-) */ ticks == 3)
 80056e4:	2c03      	cmp	r4, #3
 80056e6:	d017      	beq.n	8005718 <swdptap_seq_in+0x46>
	else
	{
		uint32_t index = 1;
		uint32_t ret = 0;

		while (ticks--) {
 80056e8:	1e63      	subs	r3, r4, #1
 80056ea:	2000      	movs	r0, #0
 80056ec:	2201      	movs	r2, #1
 80056ee:	2c00      	cmp	r4, #0
 80056f0:	d011      	beq.n	8005716 <swdptap_seq_in+0x44>
			if (SWDIO_READ)
 80056f2:	4c1a      	ldr	r4, [pc, #104]	; (800575c <swdptap_seq_in+0x8a>)
				ret |= index;
			SWCLK_PULSE
 80056f4:	2140      	movs	r1, #64	; 0x40
	{
		uint32_t index = 1;
		uint32_t ret = 0;

		while (ticks--) {
			if (SWDIO_READ)
 80056f6:	46a4      	mov	ip, r4
				ret |= index;
			SWCLK_PULSE
 80056f8:	4f19      	ldr	r7, [pc, #100]	; (8005760 <swdptap_seq_in+0x8e>)
	{
		uint32_t index = 1;
		uint32_t ret = 0;

		while (ticks--) {
			if (SWDIO_READ)
 80056fa:	4664      	mov	r4, ip
				ret |= index;
 80056fc:	1c06      	adds	r6, r0, #0
	{
		uint32_t index = 1;
		uint32_t ret = 0;

		while (ticks--) {
			if (SWDIO_READ)
 80056fe:	6825      	ldr	r5, [r4, #0]
 8005700:	2420      	movs	r4, #32
				ret |= index;
 8005702:	4316      	orrs	r6, r2
 8005704:	422c      	tst	r4, r5
 8005706:	d000      	beq.n	800570a <swdptap_seq_in+0x38>
 8005708:	1c30      	adds	r0, r6, #0
			SWCLK_PULSE
 800570a:	4c16      	ldr	r4, [pc, #88]	; (8005764 <swdptap_seq_in+0x92>)
 800570c:	6039      	str	r1, [r7, #0]
			index <<= 1;
 800570e:	0052      	lsls	r2, r2, #1
		uint32_t ret = 0;

		while (ticks--) {
			if (SWDIO_READ)
				ret |= index;
			SWCLK_PULSE
 8005710:	6021      	str	r1, [r4, #0]
	else
	{
		uint32_t index = 1;
		uint32_t ret = 0;

		while (ticks--) {
 8005712:	3b01      	subs	r3, #1
 8005714:	d2f1      	bcs.n	80056fa <swdptap_seq_in+0x28>
			index <<= 1;
		}

		return ret;
	}
}
 8005716:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (/* ;-) */ ticks == 3)
	{
		int res = 0;
		if (SWDIO_READ)
			res |= 1;
		SWCLK_PULSE
 8005718:	2240      	movs	r2, #64	; 0x40
	counters.seq_in ++;
	swdptap_turnaround(1);
	if (/* ;-) */ ticks == 3)
	{
		int res = 0;
		if (SWDIO_READ)
 800571a:	4b10      	ldr	r3, [pc, #64]	; (800575c <swdptap_seq_in+0x8a>)
			res |= 1;
		SWCLK_PULSE
 800571c:	4c10      	ldr	r4, [pc, #64]	; (8005760 <swdptap_seq_in+0x8e>)
 800571e:	4911      	ldr	r1, [pc, #68]	; (8005764 <swdptap_seq_in+0x92>)
	counters.seq_in ++;
	swdptap_turnaround(1);
	if (/* ;-) */ ticks == 3)
	{
		int res = 0;
		if (SWDIO_READ)
 8005720:	6818      	ldr	r0, [r3, #0]
			res |= 1;
		SWCLK_PULSE
 8005722:	6022      	str	r2, [r4, #0]
 8005724:	600a      	str	r2, [r1, #0]
		if (SWDIO_READ)
 8005726:	681b      	ldr	r3, [r3, #0]
	counters.seq_in ++;
	swdptap_turnaround(1);
	if (/* ;-) */ ticks == 3)
	{
		int res = 0;
		if (SWDIO_READ)
 8005728:	0680      	lsls	r0, r0, #26
 800572a:	0fc0      	lsrs	r0, r0, #31
			res |= 1;
		SWCLK_PULSE
		if (SWDIO_READ)
 800572c:	069b      	lsls	r3, r3, #26
 800572e:	d501      	bpl.n	8005734 <swdptap_seq_in+0x62>
			res |= 2;
 8005730:	2302      	movs	r3, #2
 8005732:	4318      	orrs	r0, r3
		SWCLK_PULSE
 8005734:	2340      	movs	r3, #64	; 0x40
 8005736:	4c0a      	ldr	r4, [pc, #40]	; (8005760 <swdptap_seq_in+0x8e>)
 8005738:	490a      	ldr	r1, [pc, #40]	; (8005764 <swdptap_seq_in+0x92>)
		if (SWDIO_READ)
 800573a:	4a08      	ldr	r2, [pc, #32]	; (800575c <swdptap_seq_in+0x8a>)
		if (SWDIO_READ)
			res |= 1;
		SWCLK_PULSE
		if (SWDIO_READ)
			res |= 2;
		SWCLK_PULSE
 800573c:	6023      	str	r3, [r4, #0]
 800573e:	600b      	str	r3, [r1, #0]
		if (SWDIO_READ)
 8005740:	6813      	ldr	r3, [r2, #0]
 8005742:	069b      	lsls	r3, r3, #26
 8005744:	d501      	bpl.n	800574a <swdptap_seq_in+0x78>
			res |= 4;
 8005746:	2304      	movs	r3, #4
 8005748:	4318      	orrs	r0, r3
		SWCLK_PULSE
 800574a:	2340      	movs	r3, #64	; 0x40
 800574c:	4904      	ldr	r1, [pc, #16]	; (8005760 <swdptap_seq_in+0x8e>)
 800574e:	4a05      	ldr	r2, [pc, #20]	; (8005764 <swdptap_seq_in+0x92>)
 8005750:	600b      	str	r3, [r1, #0]
 8005752:	6013      	str	r3, [r2, #0]
		return res;
 8005754:	e7df      	b.n	8005716 <swdptap_seq_in+0x44>
 8005756:	46c0      	nop			; (mov r8, r8)
 8005758:	2000206c 	.word	0x2000206c
 800575c:	48000010 	.word	0x48000010
 8005760:	48000018 	.word	0x48000018
 8005764:	48000028 	.word	0x48000028

08005768 <swdptap_seq_in_parity_32bits_optimized>:
	asm("mov	r0,	r6");
	asm("pop	{ r4, r5, r6, r7, pc }");
}

bool swdptap_seq_in_parity_32bits_optimized(uint32_t * ret)
{
 8005768:	b510      	push	{r4, lr}
 800576a:	1c04      	adds	r4, r0, #0
uint32_t x = 0, cnt = 1;
		swdptap_turnaround(1);
 800576c:	2001      	movs	r0, #1
 800576e:	f7ff fe71 	bl	8005454 <swdptap_turnaround>
#if 1
		x = swdptap_seq_in_32bits_optimized_asm(& vx_sw_driving_data);
 8005772:	480e      	ldr	r0, [pc, #56]	; (80057ac <swdptap_seq_in_parity_32bits_optimized+0x44>)
 8005774:	f7ff fcc4 	bl	8005100 <swdptap_seq_in_32bits_optimized_asm>
 8005778:	1c02      	adds	r2, r0, #0
		x |= SWDIO_READ_MSB; SWCLK_PULSE x >>= 1;
		x |= SWDIO_READ_MSB; SWCLK_PULSE x >>= 1;
		x |= SWDIO_READ_MSB; SWCLK_PULSE
#endif
		* ret = x;
		x ^= x >> 16;
 800577a:	0c03      	lsrs	r3, r0, #16
 800577c:	4043      	eors	r3, r0
		x ^= x >> 8;
 800577e:	0a18      	lsrs	r0, r3, #8
 8005780:	4043      	eors	r3, r0
		x ^= x >> 4;
 8005782:	0918      	lsrs	r0, r3, #4
 8005784:	4043      	eors	r3, r0
		x ^= x >> 2;
		x ^= x >> 1;
		
		if (SWDIO_READ)
 8005786:	490a      	ldr	r1, [pc, #40]	; (80057b0 <swdptap_seq_in_parity_32bits_optimized+0x48>)
		x |= SWDIO_READ_MSB; SWCLK_PULSE x >>= 1;
		x |= SWDIO_READ_MSB; SWCLK_PULSE x >>= 1;
		x |= SWDIO_READ_MSB; SWCLK_PULSE x >>= 1;
		x |= SWDIO_READ_MSB; SWCLK_PULSE
#endif
		* ret = x;
 8005788:	6022      	str	r2, [r4, #0]
		x ^= x >> 16;
		x ^= x >> 8;
		x ^= x >> 4;
		x ^= x >> 2;
 800578a:	0898      	lsrs	r0, r3, #2
 800578c:	4058      	eors	r0, r3
		x ^= x >> 1;
		
		if (SWDIO_READ)
 800578e:	680b      	ldr	r3, [r1, #0]
		* ret = x;
		x ^= x >> 16;
		x ^= x >> 8;
		x ^= x >> 4;
		x ^= x >> 2;
		x ^= x >> 1;
 8005790:	0842      	lsrs	r2, r0, #1
 8005792:	4050      	eors	r0, r2
		
		if (SWDIO_READ)
 8005794:	069b      	lsls	r3, r3, #26
 8005796:	d501      	bpl.n	800579c <swdptap_seq_in_parity_32bits_optimized+0x34>
			x ^= 1;
 8005798:	2301      	movs	r3, #1
 800579a:	4058      	eors	r0, r3
		SWCLK_PULSE
 800579c:	2340      	movs	r3, #64	; 0x40

		return x & 1;
 800579e:	2401      	movs	r4, #1
		x ^= x >> 2;
		x ^= x >> 1;
		
		if (SWDIO_READ)
			x ^= 1;
		SWCLK_PULSE
 80057a0:	4904      	ldr	r1, [pc, #16]	; (80057b4 <swdptap_seq_in_parity_32bits_optimized+0x4c>)
 80057a2:	4a05      	ldr	r2, [pc, #20]	; (80057b8 <swdptap_seq_in_parity_32bits_optimized+0x50>)

		return x & 1;
 80057a4:	4020      	ands	r0, r4
		x ^= x >> 2;
		x ^= x >> 1;
		
		if (SWDIO_READ)
			x ^= 1;
		SWCLK_PULSE
 80057a6:	600b      	str	r3, [r1, #0]
 80057a8:	6013      	str	r3, [r2, #0]

		return x & 1;
}
 80057aa:	bd10      	pop	{r4, pc}
 80057ac:	08012834 	.word	0x08012834
 80057b0:	48000010 	.word	0x48000010
 80057b4:	48000018 	.word	0x48000018
 80057b8:	48000028 	.word	0x48000028

080057bc <swdptap_seq_in_parity>:

bool swdptap_seq_in_parity(uint32_t *ret, int ticks)
{
 80057bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80057be:	b083      	sub	sp, #12
 80057c0:	9001      	str	r0, [sp, #4]
 80057c2:	1e0d      	subs	r5, r1, #0
uint32_t x;
	if (ticks == 32)
 80057c4:	2d20      	cmp	r5, #32
 80057c6:	d036      	beq.n	8005836 <swdptap_seq_in_parity+0x7a>
	else
	{
		uint32_t index = 1;
		uint32_t parity = 0;
		x = 0;
		swdptap_turnaround(1);
 80057c8:	2001      	movs	r0, #1
 80057ca:	f7ff fe43 	bl	8005454 <swdptap_turnaround>
		counters.seq_in_parity ++;
 80057ce:	4a1c      	ldr	r2, [pc, #112]	; (8005840 <swdptap_seq_in_parity+0x84>)

		while (ticks--) {
 80057d0:	1e6c      	subs	r4, r5, #1
	{
		uint32_t index = 1;
		uint32_t parity = 0;
		x = 0;
		swdptap_turnaround(1);
		counters.seq_in_parity ++;
 80057d2:	6853      	ldr	r3, [r2, #4]

		while (ticks--) {
 80057d4:	2000      	movs	r0, #0
	{
		uint32_t index = 1;
		uint32_t parity = 0;
		x = 0;
		swdptap_turnaround(1);
		counters.seq_in_parity ++;
 80057d6:	3301      	adds	r3, #1
 80057d8:	6053      	str	r3, [r2, #4]

		while (ticks--) {
 80057da:	2d00      	cmp	r5, #0
 80057dc:	d02e      	beq.n	800583c <swdptap_seq_in_parity+0x80>
			if (SWDIO_READ)
 80057de:	4a19      	ldr	r2, [pc, #100]	; (8005844 <swdptap_seq_in_parity+0x88>)
		uint32_t parity = 0;
		x = 0;
		swdptap_turnaround(1);
		counters.seq_in_parity ++;

		while (ticks--) {
 80057e0:	2501      	movs	r5, #1
 80057e2:	2300      	movs	r3, #0
			if (SWDIO_READ)
				x ^= index, parity ^= 1;
			SWCLK_PULSE
 80057e4:	2740      	movs	r7, #64	; 0x40
		x = 0;
		swdptap_turnaround(1);
		counters.seq_in_parity ++;

		while (ticks--) {
			if (SWDIO_READ)
 80057e6:	4694      	mov	ip, r2
 80057e8:	4662      	mov	r2, ip
 80057ea:	2620      	movs	r6, #32
 80057ec:	6812      	ldr	r2, [r2, #0]
				x ^= index, parity ^= 1;
 80057ee:	2101      	movs	r1, #1
		x = 0;
		swdptap_turnaround(1);
		counters.seq_in_parity ++;

		while (ticks--) {
			if (SWDIO_READ)
 80057f0:	4032      	ands	r2, r6
				x ^= index, parity ^= 1;
 80057f2:	1c2e      	adds	r6, r5, #0
 80057f4:	4041      	eors	r1, r0
 80057f6:	405e      	eors	r6, r3
 80057f8:	2a00      	cmp	r2, #0
 80057fa:	d000      	beq.n	80057fe <swdptap_seq_in_parity+0x42>
 80057fc:	1c33      	adds	r3, r6, #0
 80057fe:	2a00      	cmp	r2, #0
 8005800:	d000      	beq.n	8005804 <swdptap_seq_in_parity+0x48>
 8005802:	1c08      	adds	r0, r1, #0
			SWCLK_PULSE
 8005804:	4a10      	ldr	r2, [pc, #64]	; (8005848 <swdptap_seq_in_parity+0x8c>)
			index <<= 1;
 8005806:	006d      	lsls	r5, r5, #1
		counters.seq_in_parity ++;

		while (ticks--) {
			if (SWDIO_READ)
				x ^= index, parity ^= 1;
			SWCLK_PULSE
 8005808:	6017      	str	r7, [r2, #0]
 800580a:	4a10      	ldr	r2, [pc, #64]	; (800584c <swdptap_seq_in_parity+0x90>)
 800580c:	6017      	str	r7, [r2, #0]
		uint32_t parity = 0;
		x = 0;
		swdptap_turnaround(1);
		counters.seq_in_parity ++;

		while (ticks--) {
 800580e:	3c01      	subs	r4, #1
 8005810:	d2ea      	bcs.n	80057e8 <swdptap_seq_in_parity+0x2c>
			if (SWDIO_READ)
				x ^= index, parity ^= 1;
			SWCLK_PULSE
			index <<= 1;
		}
		if (SWDIO_READ)
 8005812:	4a0c      	ldr	r2, [pc, #48]	; (8005844 <swdptap_seq_in_parity+0x88>)
 8005814:	6812      	ldr	r2, [r2, #0]
 8005816:	0692      	lsls	r2, r2, #26
 8005818:	d40a      	bmi.n	8005830 <swdptap_seq_in_parity+0x74>
			parity ^= 1;
		SWCLK_PULSE
 800581a:	2240      	movs	r2, #64	; 0x40
		* ret = x;

		return parity;
 800581c:	2401      	movs	r4, #1
			SWCLK_PULSE
			index <<= 1;
		}
		if (SWDIO_READ)
			parity ^= 1;
		SWCLK_PULSE
 800581e:	4d0a      	ldr	r5, [pc, #40]	; (8005848 <swdptap_seq_in_parity+0x8c>)
 8005820:	490a      	ldr	r1, [pc, #40]	; (800584c <swdptap_seq_in_parity+0x90>)
 8005822:	602a      	str	r2, [r5, #0]
 8005824:	600a      	str	r2, [r1, #0]
		* ret = x;
 8005826:	9a01      	ldr	r2, [sp, #4]

		return parity;
 8005828:	4020      	ands	r0, r4
			index <<= 1;
		}
		if (SWDIO_READ)
			parity ^= 1;
		SWCLK_PULSE
		* ret = x;
 800582a:	6013      	str	r3, [r2, #0]

		return parity;
	}
}
 800582c:	b003      	add	sp, #12
 800582e:	bdf0      	pop	{r4, r5, r6, r7, pc}
				x ^= index, parity ^= 1;
			SWCLK_PULSE
			index <<= 1;
		}
		if (SWDIO_READ)
			parity ^= 1;
 8005830:	2201      	movs	r2, #1
 8005832:	4050      	eors	r0, r2
 8005834:	e7f1      	b.n	800581a <swdptap_seq_in_parity+0x5e>

bool swdptap_seq_in_parity(uint32_t *ret, int ticks)
{
uint32_t x;
	if (ticks == 32)
		return swdptap_seq_in_parity_32bits_optimized(ret);
 8005836:	f7ff ff97 	bl	8005768 <swdptap_seq_in_parity_32bits_optimized>
 800583a:	e7f7      	b.n	800582c <swdptap_seq_in_parity+0x70>
	else
	{
		uint32_t index = 1;
		uint32_t parity = 0;
		x = 0;
 800583c:	2300      	movs	r3, #0
 800583e:	e7e8      	b.n	8005812 <swdptap_seq_in_parity+0x56>
 8005840:	2000206c 	.word	0x2000206c
 8005844:	48000010 	.word	0x48000010
 8005848:	48000018 	.word	0x48000018
 800584c:	48000028 	.word	0x48000028

08005850 <swdptap_seq_out_32bits_optimized>:
	//if (x & 1) SWDIO_HI else SWDIO_LOW SWCLK_PULSE x >>= 1;
	//SWDIO_BIT_PORT_ADDR = masks[x & 1]; SWCLK_PULSE x >>= 1;
int i = 32;
	while (i --)
	{
		* SWDIO_BIT_PORT_ADDR = (uint32_t[2]){SWDIO_RESET_BIT_PORT_MASK, SWDIO_SET_BIT_PORT_MASK, } [x & 1]; SWCLK_PULSE x >>= 1;
 8005850:	2340      	movs	r3, #64	; 0x40
	asm("pop	{ r4, r5, r6, pc }");
}


void swdptap_seq_out_32bits_optimized(uint32_t x)
{
 8005852:	b5f0      	push	{r4, r5, r6, r7, lr}
	//if (x & 1) SWDIO_HI else SWDIO_LOW SWCLK_PULSE x >>= 1;
	//SWDIO_BIT_PORT_ADDR = masks[x & 1]; SWCLK_PULSE x >>= 1;
int i = 32;
	while (i --)
	{
		* SWDIO_BIT_PORT_ADDR = (uint32_t[2]){SWDIO_RESET_BIT_PORT_MASK, SWDIO_SET_BIT_PORT_MASK, } [x & 1]; SWCLK_PULSE x >>= 1;
 8005854:	469c      	mov	ip, r3
	asm("pop	{ r4, r5, r6, pc }");
}


void swdptap_seq_out_32bits_optimized(uint32_t x)
{
 8005856:	2420      	movs	r4, #32
 8005858:	490c      	ldr	r1, [pc, #48]	; (800588c <swdptap_seq_out_32bits_optimized+0x3c>)
 800585a:	b085      	sub	sp, #20
	//if (x & 1) SWDIO_HI else SWDIO_LOW SWCLK_PULSE x >>= 1;
	//SWDIO_BIT_PORT_ADDR = masks[x & 1]; SWCLK_PULSE x >>= 1;
int i = 32;
	while (i --)
	{
		* SWDIO_BIT_PORT_ADDR = (uint32_t[2]){SWDIO_RESET_BIT_PORT_MASK, SWDIO_SET_BIT_PORT_MASK, } [x & 1]; SWCLK_PULSE x >>= 1;
 800585c:	311c      	adds	r1, #28
 800585e:	4e0c      	ldr	r6, [pc, #48]	; (8005890 <swdptap_seq_out_32bits_optimized+0x40>)
 8005860:	9101      	str	r1, [sp, #4]
 8005862:	aa02      	add	r2, sp, #8
 8005864:	1c17      	adds	r7, r2, #0
 8005866:	9b01      	ldr	r3, [sp, #4]
 8005868:	3c01      	subs	r4, #1
 800586a:	cb22      	ldmia	r3!, {r1, r5}
 800586c:	c722      	stmia	r7!, {r1, r5}
 800586e:	2301      	movs	r3, #1
 8005870:	4661      	mov	r1, ip
 8005872:	4003      	ands	r3, r0
 8005874:	009b      	lsls	r3, r3, #2
 8005876:	58d7      	ldr	r7, [r2, r3]
 8005878:	4b06      	ldr	r3, [pc, #24]	; (8005894 <swdptap_seq_out_32bits_optimized+0x44>)
 800587a:	6037      	str	r7, [r6, #0]
 800587c:	0840      	lsrs	r0, r0, #1
 800587e:	6031      	str	r1, [r6, #0]
 8005880:	6019      	str	r1, [r3, #0]
{
//static const uint32_t masks[2] = { SWDIO_RESET_BIT_PORT_MASK, SWDIO_SET_BIT_PORT_MASK, };
	//if (x & 1) SWDIO_HI else SWDIO_LOW SWCLK_PULSE x >>= 1;
	//SWDIO_BIT_PORT_ADDR = masks[x & 1]; SWCLK_PULSE x >>= 1;
int i = 32;
	while (i --)
 8005882:	2c00      	cmp	r4, #0
 8005884:	d1ee      	bne.n	8005864 <swdptap_seq_out_32bits_optimized+0x14>
	{
		* SWDIO_BIT_PORT_ADDR = (uint32_t[2]){SWDIO_RESET_BIT_PORT_MASK, SWDIO_SET_BIT_PORT_MASK, } [x & 1]; SWCLK_PULSE x >>= 1;
	}
}
 8005886:	b005      	add	sp, #20
 8005888:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800588a:	46c0      	nop			; (mov r8, r8)
 800588c:	08012834 	.word	0x08012834
 8005890:	48000018 	.word	0x48000018
 8005894:	48000028 	.word	0x48000028

08005898 <swdptap_seq_out>:

void swdptap_seq_out(uint32_t MS, int ticks)
{
 8005898:	b570      	push	{r4, r5, r6, lr}
 800589a:	1c04      	adds	r4, r0, #0
	swdptap_turnaround(0);
 800589c:	2000      	movs	r0, #0
		* SWDIO_BIT_PORT_ADDR = (uint32_t[2]){SWDIO_RESET_BIT_PORT_MASK, SWDIO_SET_BIT_PORT_MASK, } [x & 1]; SWCLK_PULSE x >>= 1;
	}
}

void swdptap_seq_out(uint32_t MS, int ticks)
{
 800589e:	1c0d      	adds	r5, r1, #0
	swdptap_turnaround(0);
 80058a0:	f7ff fdd8 	bl	8005454 <swdptap_turnaround>
	if (ticks == 32)
 80058a4:	2d20      	cmp	r5, #32
 80058a6:	d01d      	beq.n	80058e4 <swdptap_seq_out+0x4c>
		swdptap_seq_out_32bits_optimized_asm(& vx_sw_driving_data, MS);
	else
	{
		counters.seq_out ++;
 80058a8:	4911      	ldr	r1, [pc, #68]	; (80058f0 <swdptap_seq_out+0x58>)

		while (ticks--) {
 80058aa:	1e6b      	subs	r3, r5, #1
	swdptap_turnaround(0);
	if (ticks == 32)
		swdptap_seq_out_32bits_optimized_asm(& vx_sw_driving_data, MS);
	else
	{
		counters.seq_out ++;
 80058ac:	688a      	ldr	r2, [r1, #8]
 80058ae:	3201      	adds	r2, #1
 80058b0:	608a      	str	r2, [r1, #8]

		while (ticks--) {
 80058b2:	2d00      	cmp	r5, #0
 80058b4:	d015      	beq.n	80058e2 <swdptap_seq_out+0x4a>
			if (MS & 1)
 80058b6:	2501      	movs	r5, #1
				SWDIO_HI
 80058b8:	2620      	movs	r6, #32
			else
				SWDIO_LOW
			SWCLK_PULSE
 80058ba:	2240      	movs	r2, #64	; 0x40
	{
		counters.seq_out ++;

		while (ticks--) {
			if (MS & 1)
				SWDIO_HI
 80058bc:	480d      	ldr	r0, [pc, #52]	; (80058f4 <swdptap_seq_out+0x5c>)
 80058be:	e006      	b.n	80058ce <swdptap_seq_out+0x36>
			else
				SWDIO_LOW
			SWCLK_PULSE
 80058c0:	490d      	ldr	r1, [pc, #52]	; (80058f8 <swdptap_seq_out+0x60>)
	{
		counters.seq_out ++;

		while (ticks--) {
			if (MS & 1)
				SWDIO_HI
 80058c2:	6006      	str	r6, [r0, #0]
			else
				SWDIO_LOW
			SWCLK_PULSE
			MS >>= 1;
 80058c4:	0864      	lsrs	r4, r4, #1
		while (ticks--) {
			if (MS & 1)
				SWDIO_HI
			else
				SWDIO_LOW
			SWCLK_PULSE
 80058c6:	6002      	str	r2, [r0, #0]
 80058c8:	600a      	str	r2, [r1, #0]
		swdptap_seq_out_32bits_optimized_asm(& vx_sw_driving_data, MS);
	else
	{
		counters.seq_out ++;

		while (ticks--) {
 80058ca:	3b01      	subs	r3, #1
 80058cc:	d309      	bcc.n	80058e2 <swdptap_seq_out+0x4a>
			if (MS & 1)
 80058ce:	4225      	tst	r5, r4
 80058d0:	d1f6      	bne.n	80058c0 <swdptap_seq_out+0x28>
				SWDIO_HI
			else
				SWDIO_LOW
 80058d2:	4909      	ldr	r1, [pc, #36]	; (80058f8 <swdptap_seq_out+0x60>)
			SWCLK_PULSE
			MS >>= 1;
 80058d4:	0864      	lsrs	r4, r4, #1

		while (ticks--) {
			if (MS & 1)
				SWDIO_HI
			else
				SWDIO_LOW
 80058d6:	600e      	str	r6, [r1, #0]
			SWCLK_PULSE
 80058d8:	4907      	ldr	r1, [pc, #28]	; (80058f8 <swdptap_seq_out+0x60>)
 80058da:	6002      	str	r2, [r0, #0]
 80058dc:	600a      	str	r2, [r1, #0]
		swdptap_seq_out_32bits_optimized_asm(& vx_sw_driving_data, MS);
	else
	{
		counters.seq_out ++;

		while (ticks--) {
 80058de:	3b01      	subs	r3, #1
 80058e0:	d2f5      	bcs.n	80058ce <swdptap_seq_out+0x36>
				SWDIO_LOW
			SWCLK_PULSE
			MS >>= 1;
		}
	}
}
 80058e2:	bd70      	pop	{r4, r5, r6, pc}

void swdptap_seq_out(uint32_t MS, int ticks)
{
	swdptap_turnaround(0);
	if (ticks == 32)
		swdptap_seq_out_32bits_optimized_asm(& vx_sw_driving_data, MS);
 80058e4:	4805      	ldr	r0, [pc, #20]	; (80058fc <swdptap_seq_out+0x64>)
 80058e6:	1c21      	adds	r1, r4, #0
 80058e8:	f7ff fcf0 	bl	80052cc <swdptap_seq_out_32bits_optimized_asm>
 80058ec:	e7f9      	b.n	80058e2 <swdptap_seq_out+0x4a>
 80058ee:	46c0      	nop			; (mov r8, r8)
 80058f0:	2000206c 	.word	0x2000206c
 80058f4:	48000018 	.word	0x48000018
 80058f8:	48000028 	.word	0x48000028
 80058fc:	08012834 	.word	0x08012834

08005900 <swdptap_seq_out_parity>:
		}
	}
}

void swdptap_seq_out_parity(uint32_t MS, int ticks)
{
 8005900:	b538      	push	{r3, r4, r5, lr}
	int parity;
	counters.seq_out_parity ++;
	parity = MS ^ (MS >> 16);
 8005902:	0c03      	lsrs	r3, r0, #16
 8005904:	4043      	eors	r3, r0
	parity ^= parity >> 8;
 8005906:	121a      	asrs	r2, r3, #8
 8005908:	4053      	eors	r3, r2
	parity ^= parity >> 4;
 800590a:	111a      	asrs	r2, r3, #4
}

void swdptap_seq_out_parity(uint32_t MS, int ticks)
{
	int parity;
	counters.seq_out_parity ++;
 800590c:	4d0c      	ldr	r5, [pc, #48]	; (8005940 <swdptap_seq_out_parity+0x40>)
	parity = MS ^ (MS >> 16);
	parity ^= parity >> 8;
	parity ^= parity >> 4;
 800590e:	4053      	eors	r3, r2
	parity ^= parity >> 2;
 8005910:	109c      	asrs	r4, r3, #2
}

void swdptap_seq_out_parity(uint32_t MS, int ticks)
{
	int parity;
	counters.seq_out_parity ++;
 8005912:	68ea      	ldr	r2, [r5, #12]
	parity = MS ^ (MS >> 16);
	parity ^= parity >> 8;
	parity ^= parity >> 4;
	parity ^= parity >> 2;
 8005914:	4063      	eors	r3, r4
	parity ^= parity >> 1;
 8005916:	105c      	asrs	r4, r3, #1
}

void swdptap_seq_out_parity(uint32_t MS, int ticks)
{
	int parity;
	counters.seq_out_parity ++;
 8005918:	3201      	adds	r2, #1
	parity = MS ^ (MS >> 16);
	parity ^= parity >> 8;
	parity ^= parity >> 4;
	parity ^= parity >> 2;
	parity ^= parity >> 1;
 800591a:	405c      	eors	r4, r3
}

void swdptap_seq_out_parity(uint32_t MS, int ticks)
{
	int parity;
	counters.seq_out_parity ++;
 800591c:	60ea      	str	r2, [r5, #12]
	parity ^= parity >> 8;
	parity ^= parity >> 4;
	parity ^= parity >> 2;
	parity ^= parity >> 1;

	swdptap_seq_out(MS, ticks);
 800591e:	f7ff ffbb 	bl	8005898 <swdptap_seq_out>
	if (parity & 1)
		SWDIO_HI
 8005922:	2220      	movs	r2, #32
	parity ^= parity >> 4;
	parity ^= parity >> 2;
	parity ^= parity >> 1;

	swdptap_seq_out(MS, ticks);
	if (parity & 1)
 8005924:	07e3      	lsls	r3, r4, #31
 8005926:	d407      	bmi.n	8005938 <swdptap_seq_out_parity+0x38>
		SWDIO_HI
	else
		SWDIO_LOW
 8005928:	4b06      	ldr	r3, [pc, #24]	; (8005944 <swdptap_seq_out_parity+0x44>)
 800592a:	601a      	str	r2, [r3, #0]
	SWCLK_PULSE
 800592c:	2340      	movs	r3, #64	; 0x40
 800592e:	4906      	ldr	r1, [pc, #24]	; (8005948 <swdptap_seq_out_parity+0x48>)
 8005930:	4a04      	ldr	r2, [pc, #16]	; (8005944 <swdptap_seq_out_parity+0x44>)
 8005932:	600b      	str	r3, [r1, #0]
 8005934:	6013      	str	r3, [r2, #0]
}
 8005936:	bd38      	pop	{r3, r4, r5, pc}
	parity ^= parity >> 2;
	parity ^= parity >> 1;

	swdptap_seq_out(MS, ticks);
	if (parity & 1)
		SWDIO_HI
 8005938:	4b03      	ldr	r3, [pc, #12]	; (8005948 <swdptap_seq_out_parity+0x48>)
 800593a:	601a      	str	r2, [r3, #0]
 800593c:	e7f6      	b.n	800592c <swdptap_seq_out_parity+0x2c>
 800593e:	46c0      	nop			; (mov r8, r8)
 8005940:	2000206c 	.word	0x2000206c
 8005944:	48000028 	.word	0x48000028
 8005948:	48000018 	.word	0x48000018

0800594c <sam_flash_size>:
	target_add_flash(t, f);
}

static size_t sam_flash_size(uint32_t idcode)
{
	switch (idcode & CHIPID_CIDR_NVPSIZ_MASK) {
 800594c:	23f0      	movs	r3, #240	; 0xf0
 800594e:	011b      	lsls	r3, r3, #4
 8005950:	4018      	ands	r0, r3
 8005952:	23e0      	movs	r3, #224	; 0xe0
 8005954:	00db      	lsls	r3, r3, #3
 8005956:	4298      	cmp	r0, r3
 8005958:	d032      	beq.n	80059c0 <sam_flash_size+0x74>
 800595a:	d814      	bhi.n	8005986 <sam_flash_size+0x3a>
 800595c:	2380      	movs	r3, #128	; 0x80
 800595e:	009b      	lsls	r3, r3, #2
 8005960:	4298      	cmp	r0, r3
 8005962:	d027      	beq.n	80059b4 <sam_flash_size+0x68>
 8005964:	d804      	bhi.n	8005970 <sam_flash_size+0x24>
 8005966:	3b01      	subs	r3, #1
 8005968:	3bff      	subs	r3, #255	; 0xff
 800596a:	4298      	cmp	r0, r3
 800596c:	d033      	beq.n	80059d6 <sam_flash_size+0x8a>
 800596e:	e030      	b.n	80059d2 <sam_flash_size+0x86>
 8005970:	23c0      	movs	r3, #192	; 0xc0
 8005972:	009b      	lsls	r3, r3, #2
 8005974:	4298      	cmp	r0, r3
 8005976:	d020      	beq.n	80059ba <sam_flash_size+0x6e>
 8005978:	23a0      	movs	r3, #160	; 0xa0
 800597a:	00db      	lsls	r3, r3, #3
 800597c:	4298      	cmp	r0, r3
 800597e:	d128      	bne.n	80059d2 <sam_flash_size+0x86>
	case CHIPID_CIDR_NVPSIZ_16K:
		return 0x4000;
	case CHIPID_CIDR_NVPSIZ_32K:
		return 0x8000;
	case CHIPID_CIDR_NVPSIZ_64K:
		return 0x10000;
 8005980:	2080      	movs	r0, #128	; 0x80
 8005982:	0240      	lsls	r0, r0, #9
 8005984:	e029      	b.n	80059da <sam_flash_size+0x8e>
	target_add_flash(t, f);
}

static size_t sam_flash_size(uint32_t idcode)
{
	switch (idcode & CHIPID_CIDR_NVPSIZ_MASK) {
 8005986:	23a0      	movs	r3, #160	; 0xa0
 8005988:	011b      	lsls	r3, r3, #4
 800598a:	4298      	cmp	r0, r3
 800598c:	d01b      	beq.n	80059c6 <sam_flash_size+0x7a>
 800598e:	d806      	bhi.n	800599e <sam_flash_size+0x52>
 8005990:	3b01      	subs	r3, #1
 8005992:	3bff      	subs	r3, #255	; 0xff
 8005994:	4298      	cmp	r0, r3
 8005996:	d11c      	bne.n	80059d2 <sam_flash_size+0x86>
	case CHIPID_CIDR_NVPSIZ_64K:
		return 0x10000;
	case CHIPID_CIDR_NVPSIZ_128K:
		return 0x20000;
	case CHIPID_CIDR_NVPSIZ_256K:
		return 0x40000;
 8005998:	2080      	movs	r0, #128	; 0x80
 800599a:	02c0      	lsls	r0, r0, #11
 800599c:	e01d      	b.n	80059da <sam_flash_size+0x8e>
	target_add_flash(t, f);
}

static size_t sam_flash_size(uint32_t idcode)
{
	switch (idcode & CHIPID_CIDR_NVPSIZ_MASK) {
 800599e:	23c0      	movs	r3, #192	; 0xc0
 80059a0:	011b      	lsls	r3, r3, #4
 80059a2:	4298      	cmp	r0, r3
 80059a4:	d012      	beq.n	80059cc <sam_flash_size+0x80>
 80059a6:	23e0      	movs	r3, #224	; 0xe0
 80059a8:	011b      	lsls	r3, r3, #4
 80059aa:	4298      	cmp	r0, r3
 80059ac:	d111      	bne.n	80059d2 <sam_flash_size+0x86>
	case CHIPID_CIDR_NVPSIZ_512K:
		return 0x80000;
	case CHIPID_CIDR_NVPSIZ_1024K:
		return 0x100000;
	case CHIPID_CIDR_NVPSIZ_2048K:
		return 0x200000;
 80059ae:	2080      	movs	r0, #128	; 0x80
 80059b0:	0380      	lsls	r0, r0, #14
 80059b2:	e012      	b.n	80059da <sam_flash_size+0x8e>
{
	switch (idcode & CHIPID_CIDR_NVPSIZ_MASK) {
	case CHIPID_CIDR_NVPSIZ_8K:
		return 0x2000;
	case CHIPID_CIDR_NVPSIZ_16K:
		return 0x4000;
 80059b4:	2080      	movs	r0, #128	; 0x80
 80059b6:	01c0      	lsls	r0, r0, #7
 80059b8:	e00f      	b.n	80059da <sam_flash_size+0x8e>
	case CHIPID_CIDR_NVPSIZ_32K:
		return 0x8000;
 80059ba:	2080      	movs	r0, #128	; 0x80
 80059bc:	0200      	lsls	r0, r0, #8
 80059be:	e00c      	b.n	80059da <sam_flash_size+0x8e>
	case CHIPID_CIDR_NVPSIZ_64K:
		return 0x10000;
	case CHIPID_CIDR_NVPSIZ_128K:
		return 0x20000;
 80059c0:	2080      	movs	r0, #128	; 0x80
 80059c2:	0280      	lsls	r0, r0, #10
 80059c4:	e009      	b.n	80059da <sam_flash_size+0x8e>
	case CHIPID_CIDR_NVPSIZ_256K:
		return 0x40000;
	case CHIPID_CIDR_NVPSIZ_512K:
		return 0x80000;
 80059c6:	2080      	movs	r0, #128	; 0x80
 80059c8:	0300      	lsls	r0, r0, #12
 80059ca:	e006      	b.n	80059da <sam_flash_size+0x8e>
	case CHIPID_CIDR_NVPSIZ_1024K:
		return 0x100000;
 80059cc:	2080      	movs	r0, #128	; 0x80
 80059ce:	0340      	lsls	r0, r0, #13
 80059d0:	e003      	b.n	80059da <sam_flash_size+0x8e>
	case CHIPID_CIDR_NVPSIZ_2048K:
		return 0x200000;
	}
	return 0;
 80059d2:	2000      	movs	r0, #0
 80059d4:	e001      	b.n	80059da <sam_flash_size+0x8e>

static size_t sam_flash_size(uint32_t idcode)
{
	switch (idcode & CHIPID_CIDR_NVPSIZ_MASK) {
	case CHIPID_CIDR_NVPSIZ_8K:
		return 0x2000;
 80059d6:	2080      	movs	r0, #128	; 0x80
 80059d8:	0180      	lsls	r0, r0, #6
		return 0x100000;
	case CHIPID_CIDR_NVPSIZ_2048K:
		return 0x200000;
	}
	return 0;
}
 80059da:	4770      	bx	lr

080059dc <sam3_flash_erase>:
	/* The SAM3X/SAM3N don't really have a page erase function.
	 * We do nothing here and use Erase/Write page in flash_write.
	 */
	(void)f; (void)addr; (void)len;
	return 0;
}
 80059dc:	2000      	movs	r0, #0
 80059de:	4770      	bx	lr

080059e0 <sam3x_flash_cmd>:
	return false;
}

static int
sam3x_flash_cmd(target *t, uint32_t base, uint8_t cmd, uint16_t arg)
{
 80059e0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80059e2:	1c0e      	adds	r6, r1, #0
 80059e4:	1c17      	adds	r7, r2, #0
 80059e6:	1c05      	adds	r5, r0, #0
 80059e8:	1c1c      	adds	r4, r3, #0
	DEBUG("%s: base = 0x%08"PRIx32" cmd = 0x%02X, arg = 0x%06X\n",
 80059ea:	9300      	str	r3, [sp, #0]
 80059ec:	4912      	ldr	r1, [pc, #72]	; (8005a38 <sam3x_flash_cmd+0x58>)
 80059ee:	1c32      	adds	r2, r6, #0
 80059f0:	4812      	ldr	r0, [pc, #72]	; (8005a3c <sam3x_flash_cmd+0x5c>)
 80059f2:	1c3b      	adds	r3, r7, #0
 80059f4:	f007 f832 	bl	800ca5c <iprintf>
		__func__, base, cmd, arg);
	target_mem_write32(t, EEFC_FCR(base),
 80059f8:	22b4      	movs	r2, #180	; 0xb4
	                   EEFC_FCR_FKEY | cmd | ((uint32_t)arg << 8));
 80059fa:	0224      	lsls	r4, r4, #8
 80059fc:	433c      	orrs	r4, r7
static int
sam3x_flash_cmd(target *t, uint32_t base, uint8_t cmd, uint16_t arg)
{
	DEBUG("%s: base = 0x%08"PRIx32" cmd = 0x%02X, arg = 0x%06X\n",
		__func__, base, cmd, arg);
	target_mem_write32(t, EEFC_FCR(base),
 80059fe:	05d2      	lsls	r2, r2, #23
 8005a00:	1d31      	adds	r1, r6, #4
 8005a02:	4322      	orrs	r2, r4
 8005a04:	1c28      	adds	r0, r5, #0
 8005a06:	f002 fd99 	bl	800853c <target_mem_write32>
	                   EEFC_FCR_FKEY | cmd | ((uint32_t)arg << 8));

	while (!(target_mem_read32(t, EEFC_FSR(base)) & EEFC_FSR_FRDY))
 8005a0a:	1c34      	adds	r4, r6, #0
 8005a0c:	3408      	adds	r4, #8
 8005a0e:	1c28      	adds	r0, r5, #0
 8005a10:	1c21      	adds	r1, r4, #0
 8005a12:	f002 fd8b 	bl	800852c <target_mem_read32>
 8005a16:	07c3      	lsls	r3, r0, #31
 8005a18:	d407      	bmi.n	8005a2a <sam3x_flash_cmd+0x4a>
		if(target_check_error(t))
 8005a1a:	1c28      	adds	r0, r5, #0
 8005a1c:	f002 fcfc 	bl	8008418 <target_check_error>
 8005a20:	2800      	cmp	r0, #0
 8005a22:	d0f2      	beq.n	8005a0a <sam3x_flash_cmd+0x2a>
			return -1;
 8005a24:	2001      	movs	r0, #1
 8005a26:	4240      	negs	r0, r0
 8005a28:	e005      	b.n	8005a36 <sam3x_flash_cmd+0x56>

	uint32_t sr = target_mem_read32(t, EEFC_FSR(base));
 8005a2a:	1c28      	adds	r0, r5, #0
 8005a2c:	1c21      	adds	r1, r4, #0
 8005a2e:	f002 fd7d 	bl	800852c <target_mem_read32>
	return sr & EEFC_FSR_ERROR;
 8005a32:	2306      	movs	r3, #6
 8005a34:	4018      	ands	r0, r3
}
 8005a36:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005a38:	08012860 	.word	0x08012860
 8005a3c:	08012894 	.word	0x08012894

08005a40 <sam4_flash_erase>:
	}
	return SAM3N_EEFC_BASE;
}

static int sam4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8005a40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005a42:	1c06      	adds	r6, r0, #0
 8005a44:	1c14      	adds	r4, r2, #0
	target *t = f->t;
 8005a46:	6983      	ldr	r3, [r0, #24]
	uint32_t base = ((struct sam_flash *)f)->eefc_base;
 8005a48:	6b87      	ldr	r7, [r0, #56]	; 0x38
	return SAM3N_EEFC_BASE;
}

static int sam4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	target *t = f->t;
 8005a4a:	9301      	str	r3, [sp, #4]
	uint32_t base = ((struct sam_flash *)f)->eefc_base;
	uint32_t offset = addr - f->start;
 8005a4c:	6803      	ldr	r3, [r0, #0]
 8005a4e:	1acd      	subs	r5, r1, r3

	/* The SAM4S is the only supported device with a page erase command.
	 * Erasing is done in 8-page chunks. arg[15:2] contains the page
	 * number and arg[1:0] contains 0x1, indicating 8-page chunks.
	 */
	unsigned chunk = offset / SAM4_PAGE_SIZE;
 8005a50:	0a6d      	lsrs	r5, r5, #9

	while (len) {
 8005a52:	2c00      	cmp	r4, #0
 8005a54:	d00d      	beq.n	8005a72 <sam4_flash_erase+0x32>
		int16_t arg = chunk | 0x1;
 8005a56:	2301      	movs	r3, #1
 8005a58:	432b      	orrs	r3, r5
		if(sam3x_flash_cmd(t, base, EEFC_FCR_FCMD_EPA, arg))
 8005a5a:	b29b      	uxth	r3, r3
 8005a5c:	9801      	ldr	r0, [sp, #4]
 8005a5e:	1c39      	adds	r1, r7, #0
 8005a60:	2207      	movs	r2, #7
 8005a62:	f7ff ffbd 	bl	80059e0 <sam3x_flash_cmd>
 8005a66:	2800      	cmp	r0, #0
 8005a68:	d105      	bne.n	8005a76 <sam4_flash_erase+0x36>
			return -1;

		len -= f->blocksize;
 8005a6a:	68b3      	ldr	r3, [r6, #8]
		chunk += 8;
 8005a6c:	3508      	adds	r5, #8
	while (len) {
		int16_t arg = chunk | 0x1;
		if(sam3x_flash_cmd(t, base, EEFC_FCR_FCMD_EPA, arg))
			return -1;

		len -= f->blocksize;
 8005a6e:	1ae4      	subs	r4, r4, r3
 8005a70:	e7ef      	b.n	8005a52 <sam4_flash_erase+0x12>
		chunk += 8;
	}
	return 0;
 8005a72:	1c20      	adds	r0, r4, #0
 8005a74:	e001      	b.n	8005a7a <sam4_flash_erase+0x3a>
	unsigned chunk = offset / SAM4_PAGE_SIZE;

	while (len) {
		int16_t arg = chunk | 0x1;
		if(sam3x_flash_cmd(t, base, EEFC_FCR_FCMD_EPA, arg))
			return -1;
 8005a76:	2001      	movs	r0, #1
 8005a78:	4240      	negs	r0, r0

		len -= f->blocksize;
		chunk += 8;
	}
	return 0;
}
 8005a7a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08005a7c <sam3_add_flash>:
	uint8_t write_cmd;
};

static void sam3_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
 8005a7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005a7e:	1c0d      	adds	r5, r1, #0
 8005a80:	1c04      	adds	r4, r0, #0
	struct sam_flash *sf = calloc(1, sizeof(*sf));
 8005a82:	2140      	movs	r1, #64	; 0x40
 8005a84:	2001      	movs	r0, #1
	uint8_t write_cmd;
};

static void sam3_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
 8005a86:	1c17      	adds	r7, r2, #0
 8005a88:	1c1e      	adds	r6, r3, #0
	struct sam_flash *sf = calloc(1, sizeof(*sf));
 8005a8a:	f006 fef5 	bl	800c878 <calloc>
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = SAM3_PAGE_SIZE;
 8005a8e:	2380      	movs	r3, #128	; 0x80
	f->erase = sam3_flash_erase;
 8005a90:	4a0b      	ldr	r2, [pc, #44]	; (8005ac0 <sam3_add_flash+0x44>)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = SAM3_PAGE_SIZE;
 8005a92:	005b      	lsls	r3, r3, #1
	f->erase = sam3_flash_erase;
 8005a94:	60c2      	str	r2, [r0, #12]
	f->write = target_flash_write_buffered;
 8005a96:	4a0b      	ldr	r2, [pc, #44]	; (8005ac4 <sam3_add_flash+0x48>)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = SAM3_PAGE_SIZE;
 8005a98:	6083      	str	r3, [r0, #8]
	f->erase = sam3_flash_erase;
	f->write = target_flash_write_buffered;
 8005a9a:	6102      	str	r2, [r0, #16]
	f->done = target_flash_done_buffered;
 8005a9c:	4a0a      	ldr	r2, [pc, #40]	; (8005ac8 <sam3_add_flash+0x4c>)
	f->write_buf = sam3x_flash_write;
	f->buf_size = SAM3_PAGE_SIZE;
 8005a9e:	6283      	str	r3, [r0, #40]	; 0x28
	f->start = addr;
	f->length = length;
	f->blocksize = SAM3_PAGE_SIZE;
	f->erase = sam3_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 8005aa0:	6142      	str	r2, [r0, #20]
	f->write_buf = sam3x_flash_write;
 8005aa2:	4a0a      	ldr	r2, [pc, #40]	; (8005acc <sam3_add_flash+0x50>)
	f->buf_size = SAM3_PAGE_SIZE;
	sf->eefc_base = eefc_base;
	sf->write_cmd = EEFC_FCR_FCMD_EWP;
 8005aa4:	1c03      	adds	r3, r0, #0
	f->length = length;
	f->blocksize = SAM3_PAGE_SIZE;
	f->erase = sam3_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam3x_flash_write;
 8005aa6:	62c2      	str	r2, [r0, #44]	; 0x2c
	f->buf_size = SAM3_PAGE_SIZE;
	sf->eefc_base = eefc_base;
	sf->write_cmd = EEFC_FCR_FCMD_EWP;
 8005aa8:	2203      	movs	r2, #3
 8005aaa:	333c      	adds	r3, #60	; 0x3c
static void sam3_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
 8005aac:	6007      	str	r7, [r0, #0]
	f->length = length;
 8005aae:	6046      	str	r6, [r0, #4]
	f->erase = sam3_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam3x_flash_write;
	f->buf_size = SAM3_PAGE_SIZE;
	sf->eefc_base = eefc_base;
 8005ab0:	6385      	str	r5, [r0, #56]	; 0x38
};

static void sam3_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
 8005ab2:	1c01      	adds	r1, r0, #0
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam3x_flash_write;
	f->buf_size = SAM3_PAGE_SIZE;
	sf->eefc_base = eefc_base;
	sf->write_cmd = EEFC_FCR_FCMD_EWP;
 8005ab4:	701a      	strb	r2, [r3, #0]
	target_add_flash(t, f);
 8005ab6:	1c20      	adds	r0, r4, #0
 8005ab8:	f002 fb49 	bl	800814e <target_add_flash>
}
 8005abc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005abe:	46c0      	nop			; (mov r8, r8)
 8005ac0:	080059dd 	.word	0x080059dd
 8005ac4:	0800834b 	.word	0x0800834b
 8005ac8:	080083dd 	.word	0x080083dd
 8005acc:	08005b29 	.word	0x08005b29

08005ad0 <sam4_add_flash>:

static void sam4_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
 8005ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ad2:	1c0d      	adds	r5, r1, #0
 8005ad4:	1c04      	adds	r4, r0, #0
	struct sam_flash *sf = calloc(1, sizeof(*sf));
 8005ad6:	2140      	movs	r1, #64	; 0x40
 8005ad8:	2001      	movs	r0, #1
	target_add_flash(t, f);
}

static void sam4_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
 8005ada:	1c17      	adds	r7, r2, #0
 8005adc:	1c1e      	adds	r6, r3, #0
	struct sam_flash *sf = calloc(1, sizeof(*sf));
 8005ade:	f006 fecb 	bl	800c878 <calloc>
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = SAM4_PAGE_SIZE * 8;
 8005ae2:	2380      	movs	r3, #128	; 0x80
 8005ae4:	015b      	lsls	r3, r3, #5
 8005ae6:	6083      	str	r3, [r0, #8]
	f->erase = sam4_flash_erase;
 8005ae8:	4b0b      	ldr	r3, [pc, #44]	; (8005b18 <sam4_add_flash+0x48>)
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam3x_flash_write;
	f->buf_size = SAM4_PAGE_SIZE;
	sf->eefc_base = eefc_base;
	sf->write_cmd = EEFC_FCR_FCMD_WP;
 8005aea:	2201      	movs	r2, #1
	struct sam_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = SAM4_PAGE_SIZE * 8;
	f->erase = sam4_flash_erase;
 8005aec:	60c3      	str	r3, [r0, #12]
	f->write = target_flash_write_buffered;
 8005aee:	4b0b      	ldr	r3, [pc, #44]	; (8005b1c <sam4_add_flash+0x4c>)
static void sam4_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
 8005af0:	6007      	str	r7, [r0, #0]
	f->length = length;
	f->blocksize = SAM4_PAGE_SIZE * 8;
	f->erase = sam4_flash_erase;
	f->write = target_flash_write_buffered;
 8005af2:	6103      	str	r3, [r0, #16]
	f->done = target_flash_done_buffered;
 8005af4:	4b0a      	ldr	r3, [pc, #40]	; (8005b20 <sam4_add_flash+0x50>)
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
 8005af6:	6046      	str	r6, [r0, #4]
	f->blocksize = SAM4_PAGE_SIZE * 8;
	f->erase = sam4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 8005af8:	6143      	str	r3, [r0, #20]
	f->write_buf = sam3x_flash_write;
 8005afa:	4b0a      	ldr	r3, [pc, #40]	; (8005b24 <sam4_add_flash+0x54>)
	f->buf_size = SAM4_PAGE_SIZE;
	sf->eefc_base = eefc_base;
 8005afc:	6385      	str	r5, [r0, #56]	; 0x38
	f->length = length;
	f->blocksize = SAM4_PAGE_SIZE * 8;
	f->erase = sam4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam3x_flash_write;
 8005afe:	62c3      	str	r3, [r0, #44]	; 0x2c
	f->buf_size = SAM4_PAGE_SIZE;
 8005b00:	2380      	movs	r3, #128	; 0x80
 8005b02:	009b      	lsls	r3, r3, #2
 8005b04:	6283      	str	r3, [r0, #40]	; 0x28
	sf->eefc_base = eefc_base;
	sf->write_cmd = EEFC_FCR_FCMD_WP;
 8005b06:	1c03      	adds	r3, r0, #0
 8005b08:	333c      	adds	r3, #60	; 0x3c
}

static void sam4_add_flash(target *t,
                           uint32_t eefc_base, uint32_t addr, size_t length)
{
	struct sam_flash *sf = calloc(1, sizeof(*sf));
 8005b0a:	1c01      	adds	r1, r0, #0
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam3x_flash_write;
	f->buf_size = SAM4_PAGE_SIZE;
	sf->eefc_base = eefc_base;
	sf->write_cmd = EEFC_FCR_FCMD_WP;
 8005b0c:	701a      	strb	r2, [r3, #0]
	target_add_flash(t, f);
 8005b0e:	1c20      	adds	r0, r4, #0
 8005b10:	f002 fb1d 	bl	800814e <target_add_flash>
}
 8005b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005b16:	46c0      	nop			; (mov r8, r8)
 8005b18:	08005a41 	.word	0x08005a41
 8005b1c:	0800834b 	.word	0x0800834b
 8005b20:	080083dd 	.word	0x080083dd
 8005b24:	08005b29 	.word	0x08005b29

08005b28 <sam3x_flash_write>:
	return 0;
}

static int sam3x_flash_write(struct target_flash *f, target_addr dest,
                             const void *src, size_t len)
{
 8005b28:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005b2a:	1c04      	adds	r4, r0, #0
 8005b2c:	b085      	sub	sp, #20
 8005b2e:	9303      	str	r3, [sp, #12]
	target *t = f->t;
	struct sam_flash *sf = (struct sam_flash *)f;
	uint32_t base = sf->eefc_base;
 8005b30:	6b83      	ldr	r3, [r0, #56]	; 0x38
}

static int sam3x_flash_write(struct target_flash *f, target_addr dest,
                             const void *src, size_t len)
{
	target *t = f->t;
 8005b32:	6986      	ldr	r6, [r0, #24]
	struct sam_flash *sf = (struct sam_flash *)f;
	uint32_t base = sf->eefc_base;
 8005b34:	9301      	str	r3, [sp, #4]
	unsigned chunk = (dest - f->start) / f->buf_size;
 8005b36:	6803      	ldr	r3, [r0, #0]
	return 0;
}

static int sam3x_flash_write(struct target_flash *f, target_addr dest,
                             const void *src, size_t len)
{
 8005b38:	1c0f      	adds	r7, r1, #0
	target *t = f->t;
	struct sam_flash *sf = (struct sam_flash *)f;
	uint32_t base = sf->eefc_base;
	unsigned chunk = (dest - f->start) / f->buf_size;
 8005b3a:	1ac8      	subs	r0, r1, r3
 8005b3c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
	return 0;
}

static int sam3x_flash_write(struct target_flash *f, target_addr dest,
                             const void *src, size_t len)
{
 8005b3e:	9202      	str	r2, [sp, #8]
	target *t = f->t;
	struct sam_flash *sf = (struct sam_flash *)f;
	uint32_t base = sf->eefc_base;
	unsigned chunk = (dest - f->start) / f->buf_size;
 8005b40:	f008 ff26 	bl	800e990 <__aeabi_uidiv>
 8005b44:	1c05      	adds	r5, r0, #0

	target_mem_write(t, dest, src, len);
 8005b46:	1c39      	adds	r1, r7, #0
 8005b48:	9a02      	ldr	r2, [sp, #8]
 8005b4a:	9b03      	ldr	r3, [sp, #12]
 8005b4c:	1c30      	adds	r0, r6, #0
	if(sam3x_flash_cmd(t, base, sf->write_cmd, chunk))
 8005b4e:	343c      	adds	r4, #60	; 0x3c
	target *t = f->t;
	struct sam_flash *sf = (struct sam_flash *)f;
	uint32_t base = sf->eefc_base;
	unsigned chunk = (dest - f->start) / f->buf_size;

	target_mem_write(t, dest, src, len);
 8005b50:	f002 fc70 	bl	8008434 <target_mem_write>
	if(sam3x_flash_cmd(t, base, sf->write_cmd, chunk))
 8005b54:	b2ab      	uxth	r3, r5
 8005b56:	7822      	ldrb	r2, [r4, #0]
 8005b58:	1c30      	adds	r0, r6, #0
 8005b5a:	9901      	ldr	r1, [sp, #4]
 8005b5c:	f7ff ff40 	bl	80059e0 <sam3x_flash_cmd>
 8005b60:	1e43      	subs	r3, r0, #1
 8005b62:	4198      	sbcs	r0, r3
 8005b64:	4240      	negs	r0, r0
		return -1;

	return 0;
}
 8005b66:	b005      	add	sp, #20
 8005b68:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005b6a <sam3x_flash_base.isra.0>:

	uint32_t sr = target_mem_read32(t, EEFC_FSR(base));
	return sr & EEFC_FSR_ERROR;
}

static uint32_t sam3x_flash_base(target *t)
 8005b6a:	b510      	push	{r4, lr}
{
	if (strcmp(t->driver, "Atmel SAM3X") == 0) {
 8005b6c:	4907      	ldr	r1, [pc, #28]	; (8005b8c <sam3x_flash_base.isra.0+0x22>)

	uint32_t sr = target_mem_read32(t, EEFC_FSR(base));
	return sr & EEFC_FSR_ERROR;
}

static uint32_t sam3x_flash_base(target *t)
 8005b6e:	1c04      	adds	r4, r0, #0
{
	if (strcmp(t->driver, "Atmel SAM3X") == 0) {
 8005b70:	f007 f950 	bl	800ce14 <strcmp>
 8005b74:	2800      	cmp	r0, #0
 8005b76:	d005      	beq.n	8005b84 <sam3x_flash_base.isra.0+0x1a>
		return SAM3X_EEFC_BASE(0);
	}
	if (strcmp(t->driver, "Atmel SAM3U") == 0) {
 8005b78:	1c20      	adds	r0, r4, #0
 8005b7a:	4905      	ldr	r1, [pc, #20]	; (8005b90 <sam3x_flash_base.isra.0+0x26>)
 8005b7c:	f007 f94a 	bl	800ce14 <strcmp>
 8005b80:	2800      	cmp	r0, #0
 8005b82:	d001      	beq.n	8005b88 <sam3x_flash_base.isra.0+0x1e>
}

static uint32_t sam3x_flash_base(target *t)
{
	if (strcmp(t->driver, "Atmel SAM3X") == 0) {
		return SAM3X_EEFC_BASE(0);
 8005b84:	4803      	ldr	r0, [pc, #12]	; (8005b94 <sam3x_flash_base.isra.0+0x2a>)
 8005b86:	e000      	b.n	8005b8a <sam3x_flash_base.isra.0+0x20>
	}
	if (strcmp(t->driver, "Atmel SAM3U") == 0) {
		return SAM3U_EEFC_BASE(0);
 8005b88:	4803      	ldr	r0, [pc, #12]	; (8005b98 <sam3x_flash_base.isra.0+0x2e>)
	}
	if (strcmp(t->driver, "Atmel SAM4S") == 0) {
		return SAM4S_EEFC_BASE(0);
	}
	return SAM3N_EEFC_BASE;
}
 8005b8a:	bd10      	pop	{r4, pc}
 8005b8c:	080128c3 	.word	0x080128c3
 8005b90:	080128cf 	.word	0x080128cf
 8005b94:	400e0a00 	.word	0x400e0a00
 8005b98:	400e0800 	.word	0x400e0800

08005b9c <sam3x_cmd_gpnvm_get>:

	return 0;
}

static bool sam3x_cmd_gpnvm_get(target *t)
{
 8005b9c:	b538      	push	{r3, r4, r5, lr}
 8005b9e:	1c04      	adds	r4, r0, #0
	uint32_t base = sam3x_flash_base(t);
 8005ba0:	6e00      	ldr	r0, [r0, #96]	; 0x60
 8005ba2:	f7ff ffe2 	bl	8005b6a <sam3x_flash_base.isra.0>
 8005ba6:	1c05      	adds	r5, r0, #0

	sam3x_flash_cmd(t, base, EEFC_FCR_FCMD_GGPB, 0);
 8005ba8:	2300      	movs	r3, #0
 8005baa:	1c29      	adds	r1, r5, #0
 8005bac:	220d      	movs	r2, #13
 8005bae:	1c20      	adds	r0, r4, #0
 8005bb0:	f7ff ff16 	bl	80059e0 <sam3x_flash_cmd>
	tc_printf(t, "GPNVM: 0x%08X\n", target_mem_read32(t, EEFC_FRR(base)));
 8005bb4:	1c29      	adds	r1, r5, #0
 8005bb6:	1c20      	adds	r0, r4, #0
 8005bb8:	310c      	adds	r1, #12
 8005bba:	f002 fcb7 	bl	800852c <target_mem_read32>
 8005bbe:	4903      	ldr	r1, [pc, #12]	; (8005bcc <sam3x_cmd_gpnvm_get+0x30>)
 8005bc0:	1c02      	adds	r2, r0, #0
 8005bc2:	1c20      	adds	r0, r4, #0
 8005bc4:	f002 fd11 	bl	80085ea <tc_printf>

	return true;
}
 8005bc8:	2001      	movs	r0, #1
 8005bca:	bd38      	pop	{r3, r4, r5, pc}
 8005bcc:	080128db 	.word	0x080128db

08005bd0 <sam3x_cmd_gpnvm_set>:

static bool sam3x_cmd_gpnvm_set(target *t, int argc, char *argv[])
{
 8005bd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005bd2:	1c04      	adds	r4, r0, #0
	uint32_t bit, cmd;
	uint32_t base = sam3x_flash_base(t);
 8005bd4:	6e00      	ldr	r0, [r0, #96]	; 0x60

	return true;
}

static bool sam3x_cmd_gpnvm_set(target *t, int argc, char *argv[])
{
 8005bd6:	1c0d      	adds	r5, r1, #0
 8005bd8:	1c17      	adds	r7, r2, #0
	uint32_t bit, cmd;
	uint32_t base = sam3x_flash_base(t);
 8005bda:	f7ff ffc6 	bl	8005b6a <sam3x_flash_base.isra.0>
 8005bde:	1c06      	adds	r6, r0, #0

	if (argc != 3) {
 8005be0:	2d03      	cmp	r5, #3
 8005be2:	d005      	beq.n	8005bf0 <sam3x_cmd_gpnvm_set+0x20>
		tc_printf(t, "usage: monitor gpnvm_set <bit> <val>\n");
 8005be4:	1c20      	adds	r0, r4, #0
 8005be6:	490d      	ldr	r1, [pc, #52]	; (8005c1c <sam3x_cmd_gpnvm_set+0x4c>)
 8005be8:	f002 fcff 	bl	80085ea <tc_printf>
		return false;
 8005bec:	2000      	movs	r0, #0
 8005bee:	e014      	b.n	8005c1a <sam3x_cmd_gpnvm_set+0x4a>
	}
	bit = atol(argv[1]);
 8005bf0:	6878      	ldr	r0, [r7, #4]
 8005bf2:	f006 fe3a 	bl	800c86a <atol>
 8005bf6:	1c05      	adds	r5, r0, #0
	cmd = atol(argv[2]) ? EEFC_FCR_FCMD_SGPB : EEFC_FCR_FCMD_CGPB;
 8005bf8:	68b8      	ldr	r0, [r7, #8]
 8005bfa:	f006 fe36 	bl	800c86a <atol>
 8005bfe:	230c      	movs	r3, #12
 8005c00:	1e42      	subs	r2, r0, #1
 8005c02:	4190      	sbcs	r0, r2
 8005c04:	1a1a      	subs	r2, r3, r0

	sam3x_flash_cmd(t, base, cmd, bit);
 8005c06:	b2d2      	uxtb	r2, r2
 8005c08:	b2ab      	uxth	r3, r5
 8005c0a:	1c31      	adds	r1, r6, #0
 8005c0c:	1c20      	adds	r0, r4, #0
 8005c0e:	f7ff fee7 	bl	80059e0 <sam3x_flash_cmd>
	sam3x_cmd_gpnvm_get(t);
 8005c12:	1c20      	adds	r0, r4, #0
 8005c14:	f7ff ffc2 	bl	8005b9c <sam3x_cmd_gpnvm_get>

	return true;
 8005c18:	2001      	movs	r0, #1
}
 8005c1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005c1c:	080128ea 	.word	0x080128ea

08005c20 <sam3x_probe>:
	}
	return 0;
}

bool sam3x_probe(target *t)
{
 8005c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	t->idcode = target_mem_read32(t, SAM3X_CHIPID_CIDR);
 8005c22:	4967      	ldr	r1, [pc, #412]	; (8005dc0 <sam3x_probe+0x1a0>)
	}
	return 0;
}

bool sam3x_probe(target *t)
{
 8005c24:	1c04      	adds	r4, r0, #0
	t->idcode = target_mem_read32(t, SAM3X_CHIPID_CIDR);
 8005c26:	f002 fc81 	bl	800852c <target_mem_read32>
 8005c2a:	6520      	str	r0, [r4, #80]	; 0x50
 8005c2c:	1c05      	adds	r5, r0, #0
	size_t size = sam_flash_size(t->idcode);
 8005c2e:	f7ff fe8d 	bl	800594c <sam_flash_size>
	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
 8005c32:	4f64      	ldr	r7, [pc, #400]	; (8005dc4 <sam3x_probe+0x1a4>)
 8005c34:	4b64      	ldr	r3, [pc, #400]	; (8005dc8 <sam3x_probe+0x1a8>)
}

bool sam3x_probe(target *t)
{
	t->idcode = target_mem_read32(t, SAM3X_CHIPID_CIDR);
	size_t size = sam_flash_size(t->idcode);
 8005c36:	1c06      	adds	r6, r0, #0
	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
 8005c38:	403d      	ands	r5, r7
 8005c3a:	429d      	cmp	r5, r3
 8005c3c:	d005      	beq.n	8005c4a <sam3x_probe+0x2a>
 8005c3e:	4b63      	ldr	r3, [pc, #396]	; (8005dcc <sam3x_probe+0x1ac>)
 8005c40:	429d      	cmp	r5, r3
 8005c42:	d002      	beq.n	8005c4a <sam3x_probe+0x2a>
 8005c44:	4b62      	ldr	r3, [pc, #392]	; (8005dd0 <sam3x_probe+0x1b0>)
 8005c46:	429d      	cmp	r5, r3
 8005c48:	d11d      	bne.n	8005c86 <sam3x_probe+0x66>
	case CHIPID_CIDR_ARCH_SAM3XxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3XxE | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3XxG | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3X";
		target_add_ram(t, 0x20000000, 0x200000);
 8005c4a:	2180      	movs	r1, #128	; 0x80
 8005c4c:	2280      	movs	r2, #128	; 0x80
	size_t size = sam_flash_size(t->idcode);
	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
	case CHIPID_CIDR_ARCH_SAM3XxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3XxE | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3XxG | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3X";
 8005c4e:	4b61      	ldr	r3, [pc, #388]	; (8005dd4 <sam3x_probe+0x1b4>)
		target_add_ram(t, 0x20000000, 0x200000);
 8005c50:	1c20      	adds	r0, r4, #0
	size_t size = sam_flash_size(t->idcode);
	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
	case CHIPID_CIDR_ARCH_SAM3XxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3XxE | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3XxG | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3X";
 8005c52:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x200000);
 8005c54:	0589      	lsls	r1, r1, #22
 8005c56:	0392      	lsls	r2, r2, #14
 8005c58:	f002 fa6c 	bl	8008134 <target_add_ram>
		/* 2 Flash memories back-to-back starting at 0x80000 */
		sam3_add_flash(t, SAM3X_EEFC_BASE(0), 0x80000, size/2);
 8005c5c:	2280      	movs	r2, #128	; 0x80
 8005c5e:	0876      	lsrs	r6, r6, #1
 8005c60:	1c20      	adds	r0, r4, #0
 8005c62:	495d      	ldr	r1, [pc, #372]	; (8005dd8 <sam3x_probe+0x1b8>)
 8005c64:	0312      	lsls	r2, r2, #12
 8005c66:	1c33      	adds	r3, r6, #0
 8005c68:	f7ff ff08 	bl	8005a7c <sam3_add_flash>
		sam3_add_flash(t, SAM3X_EEFC_BASE(1), 0x80000 + size/2, size/2);
 8005c6c:	2380      	movs	r3, #128	; 0x80
 8005c6e:	031b      	lsls	r3, r3, #12
 8005c70:	18f2      	adds	r2, r6, r3
 8005c72:	1c20      	adds	r0, r4, #0
 8005c74:	4959      	ldr	r1, [pc, #356]	; (8005ddc <sam3x_probe+0x1bc>)
 8005c76:	1c33      	adds	r3, r6, #0
 8005c78:	f7ff ff00 	bl	8005a7c <sam3_add_flash>
		target_add_commands(t, sam3x_cmd_list, "SAM3X");
 8005c7c:	4958      	ldr	r1, [pc, #352]	; (8005de0 <sam3x_probe+0x1c0>)
 8005c7e:	1c20      	adds	r0, r4, #0
 8005c80:	3110      	adds	r1, #16
 8005c82:	4a58      	ldr	r2, [pc, #352]	; (8005de4 <sam3x_probe+0x1c4>)
 8005c84:	e095      	b.n	8005db2 <sam3x_probe+0x192>
		return true;
	}

	t->idcode = target_mem_read32(t, SAM34NSU_CHIPID_CIDR);
 8005c86:	4958      	ldr	r1, [pc, #352]	; (8005de8 <sam3x_probe+0x1c8>)
 8005c88:	1c20      	adds	r0, r4, #0
 8005c8a:	f002 fc4f 	bl	800852c <target_mem_read32>
 8005c8e:	6520      	str	r0, [r4, #80]	; 0x50
 8005c90:	1c06      	adds	r6, r0, #0
	size = sam_flash_size(t->idcode);
 8005c92:	f7ff fe5b 	bl	800594c <sam_flash_size>
 8005c96:	1c05      	adds	r5, r0, #0
	switch (t->idcode & (CHIPID_CIDR_ARCH_MASK | CHIPID_CIDR_EPROC_MASK)) {
 8005c98:	1c30      	adds	r0, r6, #0
 8005c9a:	4b54      	ldr	r3, [pc, #336]	; (8005dec <sam3x_probe+0x1cc>)
 8005c9c:	4038      	ands	r0, r7
 8005c9e:	4298      	cmp	r0, r3
 8005ca0:	d05d      	beq.n	8005d5e <sam3x_probe+0x13e>
 8005ca2:	d80f      	bhi.n	8005cc4 <sam3x_probe+0xa4>
 8005ca4:	4b52      	ldr	r3, [pc, #328]	; (8005df0 <sam3x_probe+0x1d0>)
 8005ca6:	4298      	cmp	r0, r3
 8005ca8:	d01d      	beq.n	8005ce6 <sam3x_probe+0xc6>
 8005caa:	d806      	bhi.n	8005cba <sam3x_probe+0x9a>
 8005cac:	4b51      	ldr	r3, [pc, #324]	; (8005df4 <sam3x_probe+0x1d4>)
 8005cae:	4298      	cmp	r0, r3
 8005cb0:	d031      	beq.n	8005d16 <sam3x_probe+0xf6>
 8005cb2:	4b51      	ldr	r3, [pc, #324]	; (8005df8 <sam3x_probe+0x1d8>)
 8005cb4:	4298      	cmp	r0, r3
 8005cb6:	d02e      	beq.n	8005d16 <sam3x_probe+0xf6>
 8005cb8:	e07f      	b.n	8005dba <sam3x_probe+0x19a>
 8005cba:	4b50      	ldr	r3, [pc, #320]	; (8005dfc <sam3x_probe+0x1dc>)
 8005cbc:	4298      	cmp	r0, r3
 8005cbe:	d04e      	beq.n	8005d5e <sam3x_probe+0x13e>
 8005cc0:	4b4f      	ldr	r3, [pc, #316]	; (8005e00 <sam3x_probe+0x1e0>)
 8005cc2:	e00e      	b.n	8005ce2 <sam3x_probe+0xc2>
 8005cc4:	4b4f      	ldr	r3, [pc, #316]	; (8005e04 <sam3x_probe+0x1e4>)
 8005cc6:	4298      	cmp	r0, r3
 8005cc8:	d00d      	beq.n	8005ce6 <sam3x_probe+0xc6>
 8005cca:	d806      	bhi.n	8005cda <sam3x_probe+0xba>
 8005ccc:	4b4e      	ldr	r3, [pc, #312]	; (8005e08 <sam3x_probe+0x1e8>)
 8005cce:	4298      	cmp	r0, r3
 8005cd0:	d009      	beq.n	8005ce6 <sam3x_probe+0xc6>
 8005cd2:	4b4e      	ldr	r3, [pc, #312]	; (8005e0c <sam3x_probe+0x1ec>)
 8005cd4:	4298      	cmp	r0, r3
 8005cd6:	d042      	beq.n	8005d5e <sam3x_probe+0x13e>
 8005cd8:	e06f      	b.n	8005dba <sam3x_probe+0x19a>
 8005cda:	4b4d      	ldr	r3, [pc, #308]	; (8005e10 <sam3x_probe+0x1f0>)
 8005cdc:	4298      	cmp	r0, r3
 8005cde:	d002      	beq.n	8005ce6 <sam3x_probe+0xc6>
 8005ce0:	4b4c      	ldr	r3, [pc, #304]	; (8005e14 <sam3x_probe+0x1f4>)
 8005ce2:	4298      	cmp	r0, r3
 8005ce4:	d169      	bne.n	8005dba <sam3x_probe+0x19a>
	case CHIPID_CIDR_ARCH_SAM3NxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxA | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxB | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxC | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3N/S";
		target_add_ram(t, 0x20000000, 0x200000);
 8005ce6:	2180      	movs	r1, #128	; 0x80
 8005ce8:	2280      	movs	r2, #128	; 0x80
	case CHIPID_CIDR_ARCH_SAM3NxB | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3NxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxA | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxB | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxC | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3N/S";
 8005cea:	4b4b      	ldr	r3, [pc, #300]	; (8005e18 <sam3x_probe+0x1f8>)
		target_add_ram(t, 0x20000000, 0x200000);
 8005cec:	0589      	lsls	r1, r1, #22
	case CHIPID_CIDR_ARCH_SAM3NxB | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3NxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxA | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxB | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxC | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3N/S";
 8005cee:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x200000);
 8005cf0:	0392      	lsls	r2, r2, #14
 8005cf2:	1c20      	adds	r0, r4, #0
 8005cf4:	f002 fa1e 	bl	8008134 <target_add_ram>
		/* These devices only have a single bank */
		size = sam_flash_size(t->idcode);
 8005cf8:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8005cfa:	f7ff fe27 	bl	800594c <sam_flash_size>
		sam3_add_flash(t, SAM3N_EEFC_BASE, 0x400000, size);
 8005cfe:	2280      	movs	r2, #128	; 0x80
	case CHIPID_CIDR_ARCH_SAM3SxB | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3SxC | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3N/S";
		target_add_ram(t, 0x20000000, 0x200000);
		/* These devices only have a single bank */
		size = sam_flash_size(t->idcode);
 8005d00:	1c03      	adds	r3, r0, #0
		sam3_add_flash(t, SAM3N_EEFC_BASE, 0x400000, size);
 8005d02:	4935      	ldr	r1, [pc, #212]	; (8005dd8 <sam3x_probe+0x1b8>)
 8005d04:	1c20      	adds	r0, r4, #0
 8005d06:	03d2      	lsls	r2, r2, #15
 8005d08:	f7ff feb8 	bl	8005a7c <sam3_add_flash>
		target_add_commands(t, sam3x_cmd_list, "SAM3N/S");
 8005d0c:	4934      	ldr	r1, [pc, #208]	; (8005de0 <sam3x_probe+0x1c0>)
 8005d0e:	1c20      	adds	r0, r4, #0
 8005d10:	3110      	adds	r1, #16
 8005d12:	4a42      	ldr	r2, [pc, #264]	; (8005e1c <sam3x_probe+0x1fc>)
 8005d14:	e04d      	b.n	8005db2 <sam3x_probe+0x192>
		return true;
	case CHIPID_CIDR_ARCH_SAM3UxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3UxE | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3U";
		target_add_ram(t, 0x20000000, 0x200000);
 8005d16:	2180      	movs	r1, #128	; 0x80
 8005d18:	2280      	movs	r2, #128	; 0x80
		sam3_add_flash(t, SAM3N_EEFC_BASE, 0x400000, size);
		target_add_commands(t, sam3x_cmd_list, "SAM3N/S");
		return true;
	case CHIPID_CIDR_ARCH_SAM3UxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3UxE | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3U";
 8005d1a:	4b41      	ldr	r3, [pc, #260]	; (8005e20 <sam3x_probe+0x200>)
		target_add_ram(t, 0x20000000, 0x200000);
 8005d1c:	0392      	lsls	r2, r2, #14
		sam3_add_flash(t, SAM3N_EEFC_BASE, 0x400000, size);
		target_add_commands(t, sam3x_cmd_list, "SAM3N/S");
		return true;
	case CHIPID_CIDR_ARCH_SAM3UxC | CHIPID_CIDR_EPROC_CM3:
	case CHIPID_CIDR_ARCH_SAM3UxE | CHIPID_CIDR_EPROC_CM3:
		t->driver = "Atmel SAM3U";
 8005d1e:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x200000);
 8005d20:	1c20      	adds	r0, r4, #0
 8005d22:	0589      	lsls	r1, r1, #22
 8005d24:	f002 fa06 	bl	8008134 <target_add_ram>
		/* One flash up to 512K at 0x80000 */
		sam3_add_flash(t, SAM3U_EEFC_BASE(0), 0x80000, MIN(size, 0x80000));
 8005d28:	2280      	movs	r2, #128	; 0x80
 8005d2a:	1c2b      	adds	r3, r5, #0
 8005d2c:	0312      	lsls	r2, r2, #12
 8005d2e:	4295      	cmp	r5, r2
 8005d30:	d900      	bls.n	8005d34 <sam3x_probe+0x114>
 8005d32:	1c13      	adds	r3, r2, #0
 8005d34:	2280      	movs	r2, #128	; 0x80
 8005d36:	1c20      	adds	r0, r4, #0
 8005d38:	493a      	ldr	r1, [pc, #232]	; (8005e24 <sam3x_probe+0x204>)
 8005d3a:	0312      	lsls	r2, r2, #12
 8005d3c:	f7ff fe9e 	bl	8005a7c <sam3_add_flash>
		if (size >= 0x80000) {
 8005d40:	4b39      	ldr	r3, [pc, #228]	; (8005e28 <sam3x_probe+0x208>)
 8005d42:	429d      	cmp	r5, r3
 8005d44:	d906      	bls.n	8005d54 <sam3x_probe+0x134>
			/* Larger devices have a second bank at 0x100000 */
			sam3_add_flash(t, SAM3U_EEFC_BASE(1),
 8005d46:	2280      	movs	r2, #128	; 0x80
 8005d48:	1c20      	adds	r0, r4, #0
 8005d4a:	4923      	ldr	r1, [pc, #140]	; (8005dd8 <sam3x_probe+0x1b8>)
 8005d4c:	0352      	lsls	r2, r2, #13
 8005d4e:	3301      	adds	r3, #1
 8005d50:	f7ff fe94 	bl	8005a7c <sam3_add_flash>
			               0x100000, 0x80000);
		}
		target_add_commands(t, sam3x_cmd_list, "SAM3U");
 8005d54:	4922      	ldr	r1, [pc, #136]	; (8005de0 <sam3x_probe+0x1c0>)
 8005d56:	1c20      	adds	r0, r4, #0
 8005d58:	3110      	adds	r1, #16
 8005d5a:	4a34      	ldr	r2, [pc, #208]	; (8005e2c <sam3x_probe+0x20c>)
 8005d5c:	e029      	b.n	8005db2 <sam3x_probe+0x192>
		return true;
	case CHIPID_CIDR_ARCH_SAM4SxA | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxB | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxC | CHIPID_CIDR_EPROC_CM4:
		t->driver = "Atmel SAM4S";
		target_add_ram(t, 0x20000000, 0x400000);
 8005d5e:	2180      	movs	r1, #128	; 0x80
 8005d60:	2280      	movs	r2, #128	; 0x80
		target_add_commands(t, sam3x_cmd_list, "SAM3U");
		return true;
	case CHIPID_CIDR_ARCH_SAM4SxA | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxB | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxC | CHIPID_CIDR_EPROC_CM4:
		t->driver = "Atmel SAM4S";
 8005d62:	4b33      	ldr	r3, [pc, #204]	; (8005e30 <sam3x_probe+0x210>)
		target_add_ram(t, 0x20000000, 0x400000);
 8005d64:	03d2      	lsls	r2, r2, #15
		target_add_commands(t, sam3x_cmd_list, "SAM3U");
		return true;
	case CHIPID_CIDR_ARCH_SAM4SxA | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxB | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxC | CHIPID_CIDR_EPROC_CM4:
		t->driver = "Atmel SAM4S";
 8005d66:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x400000);
 8005d68:	1c20      	adds	r0, r4, #0
 8005d6a:	0589      	lsls	r1, r1, #22
 8005d6c:	f002 f9e2 	bl	8008134 <target_add_ram>
		size_t size = sam_flash_size(t->idcode);
 8005d70:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8005d72:	f7ff fdeb 	bl	800594c <sam_flash_size>
		if (size <= 0x80000) {
 8005d76:	2280      	movs	r2, #128	; 0x80
	case CHIPID_CIDR_ARCH_SAM4SxA | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxB | CHIPID_CIDR_EPROC_CM4:
	case CHIPID_CIDR_ARCH_SAM4SxC | CHIPID_CIDR_EPROC_CM4:
		t->driver = "Atmel SAM4S";
		target_add_ram(t, 0x20000000, 0x400000);
		size_t size = sam_flash_size(t->idcode);
 8005d78:	1c03      	adds	r3, r0, #0
		if (size <= 0x80000) {
 8005d7a:	0312      	lsls	r2, r2, #12
 8005d7c:	4290      	cmp	r0, r2
 8005d7e:	d804      	bhi.n	8005d8a <sam3x_probe+0x16a>
			/* Smaller devices have a single bank */
			sam4_add_flash(t, SAM4S_EEFC_BASE(0), 0x400000, size);
 8005d80:	2280      	movs	r2, #128	; 0x80
 8005d82:	1c20      	adds	r0, r4, #0
 8005d84:	4914      	ldr	r1, [pc, #80]	; (8005dd8 <sam3x_probe+0x1b8>)
 8005d86:	03d2      	lsls	r2, r2, #15
 8005d88:	e00d      	b.n	8005da6 <sam3x_probe+0x186>
		} else {
			/* Larger devices are split evenly between 2 */
			sam4_add_flash(t, SAM4S_EEFC_BASE(0), 0x400000, size/2);
 8005d8a:	2280      	movs	r2, #128	; 0x80
 8005d8c:	0845      	lsrs	r5, r0, #1
 8005d8e:	4912      	ldr	r1, [pc, #72]	; (8005dd8 <sam3x_probe+0x1b8>)
 8005d90:	1c20      	adds	r0, r4, #0
 8005d92:	03d2      	lsls	r2, r2, #15
 8005d94:	1c2b      	adds	r3, r5, #0
 8005d96:	f7ff fe9b 	bl	8005ad0 <sam4_add_flash>
			sam4_add_flash(t, SAM4S_EEFC_BASE(1),
			               0x400000 + size/2, size/2);
 8005d9a:	2380      	movs	r3, #128	; 0x80
 8005d9c:	03db      	lsls	r3, r3, #15
 8005d9e:	18ea      	adds	r2, r5, r3
			/* Smaller devices have a single bank */
			sam4_add_flash(t, SAM4S_EEFC_BASE(0), 0x400000, size);
		} else {
			/* Larger devices are split evenly between 2 */
			sam4_add_flash(t, SAM4S_EEFC_BASE(0), 0x400000, size/2);
			sam4_add_flash(t, SAM4S_EEFC_BASE(1),
 8005da0:	1c20      	adds	r0, r4, #0
 8005da2:	1c2b      	adds	r3, r5, #0
 8005da4:	4923      	ldr	r1, [pc, #140]	; (8005e34 <sam3x_probe+0x214>)
 8005da6:	f7ff fe93 	bl	8005ad0 <sam4_add_flash>
			               0x400000 + size/2, size/2);
		}
		target_add_commands(t, sam3x_cmd_list, "SAM4S");
 8005daa:	1c20      	adds	r0, r4, #0
 8005dac:	490c      	ldr	r1, [pc, #48]	; (8005de0 <sam3x_probe+0x1c0>)
 8005dae:	4a22      	ldr	r2, [pc, #136]	; (8005e38 <sam3x_probe+0x218>)
 8005db0:	3110      	adds	r1, #16
 8005db2:	f002 f97f 	bl	80080b4 <target_add_commands>
		return true;
 8005db6:	2001      	movs	r0, #1
 8005db8:	e000      	b.n	8005dbc <sam3x_probe+0x19c>
	}

	return false;
 8005dba:	2000      	movs	r0, #0
}
 8005dbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005dbe:	46c0      	nop			; (mov r8, r8)
 8005dc0:	400e0940 	.word	0x400e0940
 8005dc4:	0ff000e0 	.word	0x0ff000e0
 8005dc8:	08500060 	.word	0x08500060
 8005dcc:	08600060 	.word	0x08600060
 8005dd0:	08400060 	.word	0x08400060
 8005dd4:	080128c3 	.word	0x080128c3
 8005dd8:	400e0a00 	.word	0x400e0a00
 8005ddc:	400e0e00 	.word	0x400e0e00
 8005de0:	08012860 	.word	0x08012860
 8005de4:	080128c9 	.word	0x080128c9
 8005de8:	400e0740 	.word	0x400e0740
 8005dec:	089000e0 	.word	0x089000e0
 8005df0:	08800060 	.word	0x08800060
 8005df4:	08000060 	.word	0x08000060
 8005df8:	08100060 	.word	0x08100060
 8005dfc:	088000e0 	.word	0x088000e0
 8005e00:	08900060 	.word	0x08900060
 8005e04:	09300060 	.word	0x09300060
 8005e08:	08a00060 	.word	0x08a00060
 8005e0c:	08a000e0 	.word	0x08a000e0
 8005e10:	09400060 	.word	0x09400060
 8005e14:	09500060 	.word	0x09500060
 8005e18:	08012910 	.word	0x08012910
 8005e1c:	08012916 	.word	0x08012916
 8005e20:	080128cf 	.word	0x080128cf
 8005e24:	400e0800 	.word	0x400e0800
 8005e28:	0007ffff 	.word	0x0007ffff
 8005e2c:	080128d5 	.word	0x080128d5
 8005e30:	0801291e 	.word	0x0801291e
 8005e34:	400e0c00 	.word	0x400e0c00
 8005e38:	08012924 	.word	0x08012924

08005e3c <sam4l_flash_command>:
 * Need the target struct to call the mem_read32 and mem_write32 function
 * pointers.
 */
static int
sam4l_flash_command(target *t, uint32_t page, uint32_t cmd)
{
 8005e3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005e3e:	1c0d      	adds	r5, r1, #0
 8005e40:	1c14      	adds	r4, r2, #0
 8005e42:	1c06      	adds	r6, r0, #0
	uint32_t cmd_reg;
	uint32_t status;
	int	timeout;
	DEBUG("\nSAM4L: sam4l_flash_command: FSR: 0x%08x, page = %d, command = %d\n",
 8005e44:	4914      	ldr	r1, [pc, #80]	; (8005e98 <sam4l_flash_command+0x5c>)
 8005e46:	4815      	ldr	r0, [pc, #84]	; (8005e9c <sam4l_flash_command+0x60>)
 8005e48:	1c2a      	adds	r2, r5, #0
 8005e4a:	1c23      	adds	r3, r4, #0
 8005e4c:	f006 fe06 	bl	800ca5c <iprintf>
 8005e50:	4f13      	ldr	r7, [pc, #76]	; (8005ea0 <sam4l_flash_command+0x64>)
		(unsigned int)(FLASHCALW_FSR), (int) page, (int) cmd);
	/* wait for Flash controller ready */
	for (timeout = 0; timeout < FLASH_TIMEOUT; timeout++) {
		status = target_mem_read32(t, FLASHCALW_FSR);
 8005e52:	4911      	ldr	r1, [pc, #68]	; (8005e98 <sam4l_flash_command+0x5c>)
 8005e54:	1c30      	adds	r0, r6, #0
 8005e56:	f002 fb69 	bl	800852c <target_mem_read32>
 8005e5a:	1c01      	adds	r1, r0, #0
		if (status & FLASHCALW_FSR_FRDY) {
 8005e5c:	07c3      	lsls	r3, r0, #31
 8005e5e:	d408      	bmi.n	8005e72 <sam4l_flash_command+0x36>
 8005e60:	3f01      	subs	r7, #1
	uint32_t status;
	int	timeout;
	DEBUG("\nSAM4L: sam4l_flash_command: FSR: 0x%08x, page = %d, command = %d\n",
		(unsigned int)(FLASHCALW_FSR), (int) page, (int) cmd);
	/* wait for Flash controller ready */
	for (timeout = 0; timeout < FLASH_TIMEOUT; timeout++) {
 8005e62:	2f00      	cmp	r7, #0
 8005e64:	d1f5      	bne.n	8005e52 <sam4l_flash_command+0x16>
		if (status & FLASHCALW_FSR_FRDY) {
			break;
		}
	}
	if (timeout == FLASH_TIMEOUT) {
		DEBUG("\nSAM4L: sam4l_flash_command: Not ready! Status = 0x%08x\n", (unsigned int) status);
 8005e66:	480f      	ldr	r0, [pc, #60]	; (8005ea4 <sam4l_flash_command+0x68>)
 8005e68:	f006 fdf8 	bl	800ca5c <iprintf>
		return -1; /* Failed */
 8005e6c:	2001      	movs	r0, #1
 8005e6e:	4240      	negs	r0, r0
 8005e70:	e011      	b.n	8005e96 <sam4l_flash_command+0x5a>
	}
	/* load up the new command */
	cmd_reg = (cmd & FLASHCALW_FCMD_CMD_MASK) |
 8005e72:	223f      	movs	r2, #63	; 0x3f
 8005e74:	4022      	ands	r2, r4
 8005e76:	24a5      	movs	r4, #165	; 0xa5
			  ((page & FLASHCALW_FCMD_PAGEN_MASK) << FLASHCALW_FCMD_PAGEN_SHIFT) |
 8005e78:	b2ad      	uxth	r5, r5
 8005e7a:	0624      	lsls	r4, r4, #24
 8005e7c:	4314      	orrs	r4, r2
 8005e7e:	022d      	lsls	r5, r5, #8
	if (timeout == FLASH_TIMEOUT) {
		DEBUG("\nSAM4L: sam4l_flash_command: Not ready! Status = 0x%08x\n", (unsigned int) status);
		return -1; /* Failed */
	}
	/* load up the new command */
	cmd_reg = (cmd & FLASHCALW_FCMD_CMD_MASK) |
 8005e80:	432c      	orrs	r4, r5
			  ((page & FLASHCALW_FCMD_PAGEN_MASK) << FLASHCALW_FCMD_PAGEN_SHIFT) |
		  	  (0xA5 << FLASHCALW_FCMD_KEY_SHIFT);
	DEBUG("\nSAM4L: sam4l_flash_command: Wrting command word 0x%08x\n", (unsigned int) cmd_reg);
 8005e82:	1c21      	adds	r1, r4, #0
 8005e84:	4808      	ldr	r0, [pc, #32]	; (8005ea8 <sam4l_flash_command+0x6c>)
 8005e86:	f006 fde9 	bl	800ca5c <iprintf>
	/* and kick it off */
	target_mem_write32(t, FLASHCALW_FCMD, cmd_reg);
 8005e8a:	1c30      	adds	r0, r6, #0
 8005e8c:	4907      	ldr	r1, [pc, #28]	; (8005eac <sam4l_flash_command+0x70>)
 8005e8e:	1c22      	adds	r2, r4, #0
 8005e90:	f002 fb54 	bl	800853c <target_mem_write32>
	/* don't actually wait for it to finish, the next command will stall if it is not done */
	return 0;
 8005e94:	2000      	movs	r0, #0
}
 8005e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005e98:	400a0008 	.word	0x400a0008
 8005e9c:	080129dc 	.word	0x080129dc
 8005ea0:	00002710 	.word	0x00002710
 8005ea4:	08012a1f 	.word	0x08012a1f
 8005ea8:	08012a58 	.word	0x08012a58
 8005eac:	400a0004 	.word	0x400a0004

08005eb0 <sam4l_flash_erase>:
/*
 * Erase flash across the addresses specified by addr and len
 */
static int
sam4l_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8005eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005eb2:	1c15      	adds	r5, r2, #0
	target *t = f->t;
 8005eb4:	6987      	ldr	r7, [r0, #24]
	uint16_t page;

	DEBUG("SAM4L: flash erase address 0x%08x for %d bytes\n",
 8005eb6:	480c      	ldr	r0, [pc, #48]	; (8005ee8 <sam4l_flash_erase+0x38>)
/*
 * Erase flash across the addresses specified by addr and len
 */
static int
sam4l_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8005eb8:	1c0e      	adds	r6, r1, #0
	 *  NB: if addr isn't aligned to a page boundary, or length
	 * is not an even multiple of page sizes, we may end up
	 * erasing data we didn't intend to.
	 */

	while (len) {
 8005eba:	1c2c      	adds	r4, r5, #0
sam4l_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	target *t = f->t;
	uint16_t page;

	DEBUG("SAM4L: flash erase address 0x%08x for %d bytes\n",
 8005ebc:	f006 fdce 	bl	800ca5c <iprintf>
 8005ec0:	1971      	adds	r1, r6, r5
 8005ec2:	1b09      	subs	r1, r1, r4
	 *  NB: if addr isn't aligned to a page boundary, or length
	 * is not an even multiple of page sizes, we may end up
	 * erasing data we didn't intend to.
	 */

	while (len) {
 8005ec4:	2c00      	cmp	r4, #0
 8005ec6:	d00a      	beq.n	8005ede <sam4l_flash_erase+0x2e>
		page = addr / SAM4L_PAGE_SIZE;
 8005ec8:	0a49      	lsrs	r1, r1, #9
		if (sam4l_flash_command(t, page, FLASH_CMD_EP)) {
 8005eca:	b289      	uxth	r1, r1
 8005ecc:	1c38      	adds	r0, r7, #0
 8005ece:	2202      	movs	r2, #2
 8005ed0:	f7ff ffb4 	bl	8005e3c <sam4l_flash_command>
 8005ed4:	2800      	cmp	r0, #0
 8005ed6:	d104      	bne.n	8005ee2 <sam4l_flash_erase+0x32>
			return -1;
		}
		len -= SAM4L_PAGE_SIZE;
 8005ed8:	4b04      	ldr	r3, [pc, #16]	; (8005eec <sam4l_flash_erase+0x3c>)
 8005eda:	18e4      	adds	r4, r4, r3
 8005edc:	e7f0      	b.n	8005ec0 <sam4l_flash_erase+0x10>
		addr += SAM4L_PAGE_SIZE;
	}
	return 0;
 8005ede:	1c20      	adds	r0, r4, #0
 8005ee0:	e001      	b.n	8005ee6 <sam4l_flash_erase+0x36>
	 */

	while (len) {
		page = addr / SAM4L_PAGE_SIZE;
		if (sam4l_flash_command(t, page, FLASH_CMD_EP)) {
			return -1;
 8005ee2:	2001      	movs	r0, #1
 8005ee4:	4240      	negs	r0, r0
		}
		len -= SAM4L_PAGE_SIZE;
		addr += SAM4L_PAGE_SIZE;
	}
	return 0;
}
 8005ee6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005ee8:	08012a91 	.word	0x08012a91
 8005eec:	fffffe00 	.word	0xfffffe00

08005ef0 <sam4l_flash_write_buf>:
 * Write data from 'src' into flash using the algorithim provided by
 * Atmel in their data sheet.
 */
static int
sam4l_flash_write_buf(struct target_flash *f, target_addr addr, const void *src, size_t len)
{
 8005ef0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005ef2:	1c0d      	adds	r5, r1, #0
	target *t = f->t;
 8005ef4:	6986      	ldr	r6, [r0, #24]
 * Write data from 'src' into flash using the algorithim provided by
 * Atmel in their data sheet.
 */
static int
sam4l_flash_write_buf(struct target_flash *f, target_addr addr, const void *src, size_t len)
{
 8005ef6:	1c17      	adds	r7, r2, #0
	target *t = f->t;
	uint32_t *src_data = (uint32_t *)src;
	uint32_t ndx;
	uint16_t page;
	
	DEBUG("\nSAM4L: sam4l_flash_write_buf: addr = 0x%08lx, len %d\n", (long unsigned int) addr, (int) len);
 8005ef8:	4816      	ldr	r0, [pc, #88]	; (8005f54 <sam4l_flash_write_buf+0x64>)
 8005efa:	1c1a      	adds	r2, r3, #0
 * Write data from 'src' into flash using the algorithim provided by
 * Atmel in their data sheet.
 */
static int
sam4l_flash_write_buf(struct target_flash *f, target_addr addr, const void *src, size_t len)
{
 8005efc:	1c1c      	adds	r4, r3, #0
	target *t = f->t;
	uint32_t *src_data = (uint32_t *)src;
	uint32_t ndx;
	uint16_t page;
	
	DEBUG("\nSAM4L: sam4l_flash_write_buf: addr = 0x%08lx, len %d\n", (long unsigned int) addr, (int) len);
 8005efe:	f006 fdad 	bl	800ca5c <iprintf>
	/* This will fail with unaligned writes, the write_buf version */
	page = addr / SAM4L_PAGE_SIZE;
 8005f02:	0a6b      	lsrs	r3, r5, #9
 8005f04:	9300      	str	r3, [sp, #0]

	if (len != SAM4L_PAGE_SIZE) {
 8005f06:	2380      	movs	r3, #128	; 0x80
 8005f08:	009b      	lsls	r3, r3, #2
 8005f0a:	429c      	cmp	r4, r3
 8005f0c:	d001      	beq.n	8005f12 <sam4l_flash_write_buf+0x22>
		return -1;
 8005f0e:	2001      	movs	r0, #1
 8005f10:	e01d      	b.n	8005f4e <sam4l_flash_write_buf+0x5e>
	}

	/* clear the page buffer */
	if (sam4l_flash_command(t, 0, FLASH_CMD_CPB)) {
 8005f12:	1c30      	adds	r0, r6, #0
 8005f14:	2100      	movs	r1, #0
 8005f16:	2203      	movs	r2, #3
 8005f18:	f7ff ff90 	bl	8005e3c <sam4l_flash_command>
 8005f1c:	2800      	cmp	r0, #0
 8005f1e:	d1f6      	bne.n	8005f0e <sam4l_flash_write_buf+0x1e>
 8005f20:	2380      	movs	r3, #128	; 0x80
 8005f22:	1c2c      	adds	r4, r5, #0
 8005f24:	009b      	lsls	r3, r3, #2
 8005f26:	18eb      	adds	r3, r5, r3
 8005f28:	9301      	str	r3, [sp, #4]
 8005f2a:	1b7b      	subs	r3, r7, r5
		 * and no matter where you write it from it goes to the page
		 * you point it to. So we don't need the specific address here
		 * instead we just write 0 - pagelen (512) and that fills our
		 * buffer correctly.
		 */
		target_mem_write32(t, addr+ndx, *src_data);
 8005f2c:	591a      	ldr	r2, [r3, r4]
 8005f2e:	1c21      	adds	r1, r4, #0
 8005f30:	1c30      	adds	r0, r6, #0
 8005f32:	f002 fb03 	bl	800853c <target_mem_write32>

	/* I did try to use target_mem_write however that resulted in the
	 * last 64 bits (8 bytes) to be incorrect on even pages (0, 2, 4, ...)
	 * since it works this way I've not investigated further.
	 */
	for (ndx = 0; ndx < SAM4L_PAGE_SIZE; ndx += 4) {
 8005f36:	9b01      	ldr	r3, [sp, #4]
 8005f38:	3404      	adds	r4, #4
 8005f3a:	429c      	cmp	r4, r3
 8005f3c:	d1f5      	bne.n	8005f2a <sam4l_flash_write_buf+0x3a>
		 */
		target_mem_write32(t, addr+ndx, *src_data);
		src_data++;
	}
	/* write the page */
	if (sam4l_flash_command(t, page, FLASH_CMD_WP)) {
 8005f3e:	466b      	mov	r3, sp
 8005f40:	1c30      	adds	r0, r6, #0
 8005f42:	8819      	ldrh	r1, [r3, #0]
 8005f44:	2201      	movs	r2, #1
 8005f46:	f7ff ff79 	bl	8005e3c <sam4l_flash_command>
 8005f4a:	1e43      	subs	r3, r0, #1
 8005f4c:	4198      	sbcs	r0, r3
 8005f4e:	4240      	negs	r0, r0
		return -1;
	}
	return 0;
}
 8005f50:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8005f52:	46c0      	nop			; (mov r8, r8)
 8005f54:	08012ac1 	.word	0x08012ac1

08005f58 <sam4l_extended_reset>:
/*
 * We've been reset, make sure we take the core out of reset
 */
static void
sam4l_extended_reset(target *t)
{
 8005f58:	b538      	push	{r3, r4, r5, lr}
 8005f5a:	1c04      	adds	r4, r0, #0
	uint32_t	reg;
	int i;

	DEBUG("SAM4L: Extended Reset\n");
 8005f5c:	4813      	ldr	r0, [pc, #76]	; (8005fac <sam4l_extended_reset+0x54>)
 8005f5e:	f006 fe0d 	bl	800cb7c <puts>
	/* enable SMAP in case we're dealing with a non-TCK SRST */
	target_mem_write32(t, SMAP_CR, 0x1); /* enable SMAP */
 8005f62:	2201      	movs	r2, #1
 8005f64:	1c20      	adds	r0, r4, #0
 8005f66:	4912      	ldr	r1, [pc, #72]	; (8005fb0 <sam4l_extended_reset+0x58>)
 8005f68:	f002 fae8 	bl	800853c <target_mem_write32>
	reg = target_mem_read32(t, SMAP_SR);
 8005f6c:	4911      	ldr	r1, [pc, #68]	; (8005fb4 <sam4l_extended_reset+0x5c>)
 8005f6e:	1c20      	adds	r0, r4, #0
 8005f70:	f002 fadc 	bl	800852c <target_mem_read32>
 8005f74:	1c05      	adds	r5, r0, #0
	DEBUG("\nSAM4L: SMAP_SR has 0x%08lx\n", (long unsigned int) reg);
 8005f76:	4810      	ldr	r0, [pc, #64]	; (8005fb8 <sam4l_extended_reset+0x60>)
 8005f78:	1c29      	adds	r1, r5, #0
 8005f7a:	f006 fd6f 	bl	800ca5c <iprintf>
	if ((reg & SMAP_SR_HCR) != 0) {
 8005f7e:	2202      	movs	r2, #2
 8005f80:	4215      	tst	r5, r2
 8005f82:	d00f      	beq.n	8005fa4 <sam4l_extended_reset+0x4c>
		/* write '1' bit to the status clear register */
		target_mem_write32(t, SMAP_SCR, SMAP_SR_HCR);
 8005f84:	1c20      	adds	r0, r4, #0
 8005f86:	490d      	ldr	r1, [pc, #52]	; (8005fbc <sam4l_extended_reset+0x64>)
 8005f88:	f002 fad8 	bl	800853c <target_mem_write32>
 8005f8c:	25fa      	movs	r5, #250	; 0xfa
		/* waiting 250 loops for it to reset is arbitrary, it should happen right away */
		for (i = 0; i < 250; i++) {
			reg = target_mem_read32(t, SMAP_SR);
 8005f8e:	4909      	ldr	r1, [pc, #36]	; (8005fb4 <sam4l_extended_reset+0x5c>)
 8005f90:	1c20      	adds	r0, r4, #0
 8005f92:	f002 facb 	bl	800852c <target_mem_read32>
 8005f96:	3d01      	subs	r5, #1
 8005f98:	1c01      	adds	r1, r0, #0
	DEBUG("\nSAM4L: SMAP_SR has 0x%08lx\n", (long unsigned int) reg);
	if ((reg & SMAP_SR_HCR) != 0) {
		/* write '1' bit to the status clear register */
		target_mem_write32(t, SMAP_SCR, SMAP_SR_HCR);
		/* waiting 250 loops for it to reset is arbitrary, it should happen right away */
		for (i = 0; i < 250; i++) {
 8005f9a:	2d00      	cmp	r5, #0
 8005f9c:	d1f7      	bne.n	8005f8e <sam4l_extended_reset+0x36>
			reg = target_mem_read32(t, SMAP_SR);
		}
		/* not sure what to do if we can't reset that bit */
		if (i > 249) {
			DEBUG("\nSAM4L: Reset failed. SMAP_SR has 0x%08lx\n", (long unsigned int) reg);
 8005f9e:	4808      	ldr	r0, [pc, #32]	; (8005fc0 <sam4l_extended_reset+0x68>)
 8005fa0:	f006 fd5c 	bl	800ca5c <iprintf>
		}
	}
	/* reset bus error if for some reason SMAP was disabled */
	target_check_error(t);
 8005fa4:	1c20      	adds	r0, r4, #0
 8005fa6:	f002 fa37 	bl	8008418 <target_check_error>
}
 8005faa:	bd38      	pop	{r3, r4, r5, pc}
 8005fac:	08012af8 	.word	0x08012af8
 8005fb0:	400a3000 	.word	0x400a3000
 8005fb4:	400a3004 	.word	0x400a3004
 8005fb8:	08012b0e 	.word	0x08012b0e
 8005fbc:	400a3008 	.word	0x400a3008
 8005fc0:	08012b2b 	.word	0x08012b2b

08005fc4 <sam4l_probe>:
 * it matches the SAM4L architecture code.
 *
 * Figure out from the register how much RAM and FLASH this variant has.
 */
bool sam4l_probe(target *t)
{
 8005fc4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8005fc6:	1c04      	adds	r4, r0, #0
	size_t	ram_size, flash_size;

	DEBUG("\nSAM4L: Probe function called\n");
 8005fc8:	482b      	ldr	r0, [pc, #172]	; (8006078 <sam4l_probe+0xb4>)
 8005fca:	f006 fdd7 	bl	800cb7c <puts>
	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
 8005fce:	1c20      	adds	r0, r4, #0
 8005fd0:	492a      	ldr	r1, [pc, #168]	; (800607c <sam4l_probe+0xb8>)
 8005fd2:	f002 faab 	bl	800852c <target_mem_read32>
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
 8005fd6:	22ff      	movs	r2, #255	; 0xff
 8005fd8:	0d03      	lsrs	r3, r0, #20
bool sam4l_probe(target *t)
{
	size_t	ram_size, flash_size;

	DEBUG("\nSAM4L: Probe function called\n");
	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
 8005fda:	6520      	str	r0, [r4, #80]	; 0x50
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
 8005fdc:	4013      	ands	r3, r2
		if (target_check_error(t)) {
			DEBUG("SAM4L: target_check_error returned true\n");
		}
		return true;
	}
	return false;
 8005fde:	2600      	movs	r6, #0
{
	size_t	ram_size, flash_size;

	DEBUG("\nSAM4L: Probe function called\n");
	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
 8005fe0:	2bb0      	cmp	r3, #176	; 0xb0
 8005fe2:	d147      	bne.n	8006074 <sam4l_probe+0xb0>
	target_add_flash(t, f);
}

/* Return size of RAM */
static size_t sam_ram_size(uint32_t idcode) {
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
 8005fe4:	250f      	movs	r5, #15
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
		t->driver = "Atmel SAM4L";
		/* this function says we need to do "extra" stuff after reset */
		t->extended_reset = sam4l_extended_reset;
		ram_size = sam_ram_size(t->idcode);
		target_add_ram(t, 0x20000000, ram_size);
 8005fe6:	2180      	movs	r1, #128	; 0x80
	size_t	ram_size, flash_size;

	DEBUG("\nSAM4L: Probe function called\n");
	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
		t->driver = "Atmel SAM4L";
 8005fe8:	4b25      	ldr	r3, [pc, #148]	; (8006080 <sam4l_probe+0xbc>)
	target_add_flash(t, f);
}

/* Return size of RAM */
static size_t sam_ram_size(uint32_t idcode) {
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
 8005fea:	0c00      	lsrs	r0, r0, #16
	size_t	ram_size, flash_size;

	DEBUG("\nSAM4L: Probe function called\n");
	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
		t->driver = "Atmel SAM4L";
 8005fec:	6623      	str	r3, [r4, #96]	; 0x60
		/* this function says we need to do "extra" stuff after reset */
		t->extended_reset = sam4l_extended_reset;
 8005fee:	4b25      	ldr	r3, [pc, #148]	; (8006084 <sam4l_probe+0xc0>)
	target_add_flash(t, f);
}

/* Return size of RAM */
static size_t sam_ram_size(uint32_t idcode) {
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
 8005ff0:	4028      	ands	r0, r5
	DEBUG("\nSAM4L: Probe function called\n");
	t->idcode = target_mem_read32(t, SAM4L_CHIPID_CIDR);
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
		t->driver = "Atmel SAM4L";
		/* this function says we need to do "extra" stuff after reset */
		t->extended_reset = sam4l_extended_reset;
 8005ff2:	6323      	str	r3, [r4, #48]	; 0x30
	target_add_flash(t, f);
}

/* Return size of RAM */
static size_t sam_ram_size(uint32_t idcode) {
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
 8005ff4:	4b24      	ldr	r3, [pc, #144]	; (8006088 <sam4l_probe+0xc4>)
 8005ff6:	0080      	lsls	r0, r0, #2
 8005ff8:	58c7      	ldr	r7, [r0, r3]
	if (((t->idcode >> CHIPID_CIDR_ARCH_SHIFT) & CHIPID_CIDR_ARCH_MASK) == SAM4L_ARCH) {
		t->driver = "Atmel SAM4L";
		/* this function says we need to do "extra" stuff after reset */
		t->extended_reset = sam4l_extended_reset;
		ram_size = sam_ram_size(t->idcode);
		target_add_ram(t, 0x20000000, ram_size);
 8005ffa:	0589      	lsls	r1, r1, #22
 8005ffc:	1c3a      	adds	r2, r7, #0
 8005ffe:	1c20      	adds	r0, r4, #0
 8006000:	f002 f898 	bl	8008134 <target_add_ram>
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
}

/* Return size of FLASH */
static size_t sam_nvp_size(uint32_t idcode) {
	return __nvp_size[((idcode >> CHIPID_CIDR_NVPSIZ_SHIFT) & CHIPID_CIDR_NVPSIZ_MASK)];
 8006004:	6d23      	ldr	r3, [r4, #80]	; 0x50
 * Populate a target_flash struct with the necessary function pointers
 * and constants to describe our flash.
 */
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
 8006006:	2138      	movs	r1, #56	; 0x38
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
}

/* Return size of FLASH */
static size_t sam_nvp_size(uint32_t idcode) {
	return __nvp_size[((idcode >> CHIPID_CIDR_NVPSIZ_SHIFT) & CHIPID_CIDR_NVPSIZ_MASK)];
 8006008:	0a1b      	lsrs	r3, r3, #8
 800600a:	401d      	ands	r5, r3
 800600c:	4b1e      	ldr	r3, [pc, #120]	; (8006088 <sam4l_probe+0xc4>)
 800600e:	00ad      	lsls	r5, r5, #2
 8006010:	195d      	adds	r5, r3, r5
 * Populate a target_flash struct with the necessary function pointers
 * and constants to describe our flash.
 */
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
 8006012:	2001      	movs	r0, #1
	return __ram_size[((idcode >> CHIPID_CIDR_SRAMSIZ_SHIFT) & CHIPID_CIDR_SRAMSIZ_MASK)];
}

/* Return size of FLASH */
static size_t sam_nvp_size(uint32_t idcode) {
	return __nvp_size[((idcode >> CHIPID_CIDR_NVPSIZ_SHIFT) & CHIPID_CIDR_NVPSIZ_MASK)];
 8006014:	6c2d      	ldr	r5, [r5, #64]	; 0x40
 * Populate a target_flash struct with the necessary function pointers
 * and constants to describe our flash.
 */
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
 8006016:	f006 fc2f 	bl	800c878 <calloc>
	f->start = addr;
	f->length = length;
	f->blocksize = SAM4L_PAGE_SIZE;
	f->erase = sam4l_flash_erase;
 800601a:	4a1c      	ldr	r2, [pc, #112]	; (800608c <sam4l_probe+0xc8>)
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
	f->start = addr;
	f->length = length;
	f->blocksize = SAM4L_PAGE_SIZE;
 800601c:	2380      	movs	r3, #128	; 0x80
	f->erase = sam4l_flash_erase;
 800601e:	60c2      	str	r2, [r0, #12]
	f->write = target_flash_write_buffered;
 8006020:	4a1b      	ldr	r2, [pc, #108]	; (8006090 <sam4l_probe+0xcc>)
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
	f->start = addr;
	f->length = length;
	f->blocksize = SAM4L_PAGE_SIZE;
 8006022:	009b      	lsls	r3, r3, #2
	f->erase = sam4l_flash_erase;
	f->write = target_flash_write_buffered;
 8006024:	6102      	str	r2, [r0, #16]
	f->done = target_flash_done_buffered;
 8006026:	4a1b      	ldr	r2, [pc, #108]	; (8006094 <sam4l_probe+0xd0>)
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
	f->start = addr;
	f->length = length;
	f->blocksize = SAM4L_PAGE_SIZE;
 8006028:	6083      	str	r3, [r0, #8]
	f->erase = sam4l_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 800602a:	6142      	str	r2, [r0, #20]
	f->write_buf = sam4l_flash_write_buf;
 800602c:	4a1a      	ldr	r2, [pc, #104]	; (8006098 <sam4l_probe+0xd4>)
	f->buf_size = SAM4L_PAGE_SIZE;
 800602e:	6283      	str	r3, [r0, #40]	; 0x28
	f->length = length;
	f->blocksize = SAM4L_PAGE_SIZE;
	f->erase = sam4l_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam4l_flash_write_buf;
 8006030:	62c2      	str	r2, [r0, #44]	; 0x2c
	f->buf_size = SAM4L_PAGE_SIZE;
	f->erased = 0xff;
 8006032:	22ff      	movs	r2, #255	; 0xff
 8006034:	1d43      	adds	r3, r0, #5
 * and constants to describe our flash.
 */
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
	f->start = addr;
 8006036:	6006      	str	r6, [r0, #0]
 * Populate a target_flash struct with the necessary function pointers
 * and constants to describe our flash.
 */
static void sam4l_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(struct target_flash));
 8006038:	1c01      	adds	r1, r0, #0
	f->start = addr;
	f->length = length;
 800603a:	6045      	str	r5, [r0, #4]
	f->erase = sam4l_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = sam4l_flash_write_buf;
	f->buf_size = SAM4L_PAGE_SIZE;
	f->erased = 0xff;
 800603c:	77da      	strb	r2, [r3, #31]
	/* add it into the target structures flash chain */
	target_add_flash(t, f);
 800603e:	1c20      	adds	r0, r4, #0
 8006040:	f002 f885 	bl	800814e <target_add_flash>
		t->extended_reset = sam4l_extended_reset;
		ram_size = sam_ram_size(t->idcode);
		target_add_ram(t, 0x20000000, ram_size);
		flash_size = sam_nvp_size(t->idcode);
		sam4l_add_flash(t, 0x0, flash_size);
		DEBUG("\nSAM4L: RAM = 0x%x (%dK), FLASH = 0x%x (%dK)\n",
 8006044:	0aab      	lsrs	r3, r5, #10
 8006046:	0aba      	lsrs	r2, r7, #10
 8006048:	1c39      	adds	r1, r7, #0
 800604a:	9300      	str	r3, [sp, #0]
 800604c:	4813      	ldr	r0, [pc, #76]	; (800609c <sam4l_probe+0xd8>)
 800604e:	1c2b      	adds	r3, r5, #0
 8006050:	f006 fd04 	bl	800ca5c <iprintf>
			(unsigned int) ram_size, (unsigned int) (ram_size / 1024),
					(unsigned int) flash_size, (unsigned int)(flash_size / 1024));
			
		/* enable SMAP if not, check for HCR and reset if set */
		sam4l_extended_reset(t);
 8006054:	1c20      	adds	r0, r4, #0
 8006056:	f7ff ff7f 	bl	8005f58 <sam4l_extended_reset>
		DEBUG("\nSAM4L: SAM4L Selected.\n");
 800605a:	4811      	ldr	r0, [pc, #68]	; (80060a0 <sam4l_probe+0xdc>)
 800605c:	f006 fd8e 	bl	800cb7c <puts>
		if (target_check_error(t)) {
 8006060:	1c20      	adds	r0, r4, #0
 8006062:	f002 f9d9 	bl	8008418 <target_check_error>
 8006066:	1e06      	subs	r6, r0, #0
 8006068:	d003      	beq.n	8006072 <sam4l_probe+0xae>
			DEBUG("SAM4L: target_check_error returned true\n");
 800606a:	480e      	ldr	r0, [pc, #56]	; (80060a4 <sam4l_probe+0xe0>)
 800606c:	f006 fd86 	bl	800cb7c <puts>
 8006070:	e000      	b.n	8006074 <sam4l_probe+0xb0>
		}
		return true;
 8006072:	2601      	movs	r6, #1
	}
	return false;
}
 8006074:	1c30      	adds	r0, r6, #0
 8006076:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8006078:	08012b56 	.word	0x08012b56
 800607c:	400e0740 	.word	0x400e0740
 8006080:	08012b74 	.word	0x08012b74
 8006084:	08005f59 	.word	0x08005f59
 8006088:	0801295c 	.word	0x0801295c
 800608c:	08005eb1 	.word	0x08005eb1
 8006090:	0800834b 	.word	0x0800834b
 8006094:	080083dd 	.word	0x080083dd
 8006098:	08005ef1 	.word	0x08005ef1
 800609c:	08012b80 	.word	0x08012b80
 80060a0:	08012bae 	.word	0x08012bae
 80060a4:	08012bc6 	.word	0x08012bc6

080060a8 <samd_protected_attach>:
	 * they should issue the 'monitor erase_mass' command to
	 * regain access to the chip.
	 */

	/* Patch back in the normal cortexm attach for next time */
	t->attach = cortexm_attach;
 80060a8:	4b01      	ldr	r3, [pc, #4]	; (80060b0 <samd_protected_attach+0x8>)
 80060aa:	6083      	str	r3, [r0, #8]

	/* Allow attach this time */
	return true;
}
 80060ac:	2001      	movs	r0, #1
 80060ae:	4770      	bx	lr
 80060b0:	08001f83 	.word	0x08001f83

080060b4 <samd_set_flashlock>:
 * not take effect until a reset.
 *
 * 0x0000 = Lock, 0xFFFF = Unlock (default)
 */
static bool samd_set_flashlock(target *t, uint16_t value)
{
 80060b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80060b6:	1c0e      	adds	r6, r1, #0
	uint32_t high = target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH);
 80060b8:	4919      	ldr	r1, [pc, #100]	; (8006120 <samd_set_flashlock+0x6c>)
 * not take effect until a reset.
 *
 * 0x0000 = Lock, 0xFFFF = Unlock (default)
 */
static bool samd_set_flashlock(target *t, uint16_t value)
{
 80060ba:	1c04      	adds	r4, r0, #0
	uint32_t high = target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH);
 80060bc:	f002 fa36 	bl	800852c <target_mem_read32>
	uint32_t low = target_mem_read32(t, SAMD_NVM_USER_ROW_LOW);
 80060c0:	4918      	ldr	r1, [pc, #96]	; (8006124 <samd_set_flashlock+0x70>)
 *
 * 0x0000 = Lock, 0xFFFF = Unlock (default)
 */
static bool samd_set_flashlock(target *t, uint16_t value)
{
	uint32_t high = target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH);
 80060c2:	1c05      	adds	r5, r0, #0
	uint32_t low = target_mem_read32(t, SAMD_NVM_USER_ROW_LOW);
 80060c4:	1c20      	adds	r0, r4, #0
 80060c6:	f002 fa31 	bl	800852c <target_mem_read32>

	/* Write address of a word in the row to erase it */
	/* Must be shifted right for 16-bit address, see Datasheet 20.8.8 Address */
	target_mem_write32(t, SAMD_NVMC_ADDRESS, SAMD_NVM_USER_ROW_LOW >> 1);
 80060ca:	4917      	ldr	r1, [pc, #92]	; (8006128 <samd_set_flashlock+0x74>)
 80060cc:	4a17      	ldr	r2, [pc, #92]	; (800612c <samd_set_flashlock+0x78>)
 * 0x0000 = Lock, 0xFFFF = Unlock (default)
 */
static bool samd_set_flashlock(target *t, uint16_t value)
{
	uint32_t high = target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH);
	uint32_t low = target_mem_read32(t, SAMD_NVM_USER_ROW_LOW);
 80060ce:	1c07      	adds	r7, r0, #0

	/* Write address of a word in the row to erase it */
	/* Must be shifted right for 16-bit address, see Datasheet 20.8.8 Address */
	target_mem_write32(t, SAMD_NVMC_ADDRESS, SAMD_NVM_USER_ROW_LOW >> 1);
 80060d0:	1c20      	adds	r0, r4, #0
 80060d2:	f002 fa33 	bl	800853c <target_mem_write32>

	/* Issue the erase command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 80060d6:	1c20      	adds	r0, r4, #0
 80060d8:	4915      	ldr	r1, [pc, #84]	; (8006130 <samd_set_flashlock+0x7c>)
 80060da:	4a16      	ldr	r2, [pc, #88]	; (8006134 <samd_set_flashlock+0x80>)
 80060dc:	f002 fa2e 	bl	800853c <target_mem_write32>
	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_ERASEAUXROW);

	/* Poll for NVM Ready */
	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
 80060e0:	1c20      	adds	r0, r4, #0
 80060e2:	4915      	ldr	r1, [pc, #84]	; (8006138 <samd_set_flashlock+0x84>)
 80060e4:	f002 fa22 	bl	800852c <target_mem_read32>
 80060e8:	07c3      	lsls	r3, r0, #31
 80060ea:	d405      	bmi.n	80060f8 <samd_set_flashlock+0x44>
		if (target_check_error(t))
 80060ec:	1c20      	adds	r0, r4, #0
 80060ee:	f002 f993 	bl	8008418 <target_check_error>
 80060f2:	2800      	cmp	r0, #0
 80060f4:	d0f4      	beq.n	80060e0 <samd_set_flashlock+0x2c>
 80060f6:	e011      	b.n	800611c <samd_set_flashlock+0x68>
			return -1;

	/* Modify the high byte of the user row */
	high = (high & 0x0000FFFF) | ((value << 16) & 0xFFFF0000);
 80060f8:	b2ad      	uxth	r5, r5
 80060fa:	0436      	lsls	r6, r6, #16

	/* Write back */
	target_mem_write32(t, SAMD_NVM_USER_ROW_LOW, low);
 80060fc:	1c20      	adds	r0, r4, #0
 80060fe:	4909      	ldr	r1, [pc, #36]	; (8006124 <samd_set_flashlock+0x70>)
 8006100:	1c3a      	adds	r2, r7, #0
	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
		if (target_check_error(t))
			return -1;

	/* Modify the high byte of the user row */
	high = (high & 0x0000FFFF) | ((value << 16) & 0xFFFF0000);
 8006102:	4335      	orrs	r5, r6

	/* Write back */
	target_mem_write32(t, SAMD_NVM_USER_ROW_LOW, low);
 8006104:	f002 fa1a 	bl	800853c <target_mem_write32>
	target_mem_write32(t, SAMD_NVM_USER_ROW_HIGH, high);
 8006108:	1c20      	adds	r0, r4, #0
 800610a:	4905      	ldr	r1, [pc, #20]	; (8006120 <samd_set_flashlock+0x6c>)
 800610c:	1c2a      	adds	r2, r5, #0
 800610e:	f002 fa15 	bl	800853c <target_mem_write32>

	/* Issue the page write command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 8006112:	1c20      	adds	r0, r4, #0
 8006114:	4906      	ldr	r1, [pc, #24]	; (8006130 <samd_set_flashlock+0x7c>)
 8006116:	4a09      	ldr	r2, [pc, #36]	; (800613c <samd_set_flashlock+0x88>)
 8006118:	f002 fa10 	bl	800853c <target_mem_write32>
	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_WRITEAUXPAGE);

	return true;
}
 800611c:	2001      	movs	r0, #1
 800611e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006120:	00804004 	.word	0x00804004
 8006124:	00804000 	.word	0x00804000
 8006128:	4100401c 	.word	0x4100401c
 800612c:	00402000 	.word	0x00402000
 8006130:	41004000 	.word	0x41004000
 8006134:	0000a505 	.word	0x0000a505
 8006138:	41004014 	.word	0x41004014
 800613c:	0000a506 	.word	0x0000a506

08006140 <samd_cmd_unlock_flash>:
{
	return samd_set_flashlock(t, 0x0000);
}

static bool samd_cmd_unlock_flash(target *t)
{
 8006140:	b508      	push	{r3, lr}
	return samd_set_flashlock(t, 0xFFFF);
 8006142:	4902      	ldr	r1, [pc, #8]	; (800614c <samd_cmd_unlock_flash+0xc>)
 8006144:	f7ff ffb6 	bl	80060b4 <samd_set_flashlock>
}
 8006148:	bd08      	pop	{r3, pc}
 800614a:	46c0      	nop			; (mov r8, r8)
 800614c:	0000ffff 	.word	0x0000ffff

08006150 <samd_cmd_lock_flash>:

	return true;
}

static bool samd_cmd_lock_flash(target *t)
{
 8006150:	b508      	push	{r3, lr}
	return samd_set_flashlock(t, 0x0000);
 8006152:	2100      	movs	r1, #0
 8006154:	f7ff ffae 	bl	80060b4 <samd_set_flashlock>
}
 8006158:	bd08      	pop	{r3, pc}

0800615a <samd_reset>:
 * Overloads the default cortexm reset function with a version that
 * removes the target from extended reset where required.
 */
static void
samd_reset(target *t)
{
 800615a:	b510      	push	{r4, lr}
 800615c:	1c04      	adds	r4, r0, #0
	 * jtagtap_srst(true);
	 * jtagtap_srst(false);
	 */

	/* Read DHCSR here to clear S_RESET_ST bit before reset */
	target_mem_read32(t, CORTEXM_DHCSR);
 800615e:	4911      	ldr	r1, [pc, #68]	; (80061a4 <samd_reset+0x4a>)
 8006160:	f002 f9e4 	bl	800852c <target_mem_read32>

	/* Request system reset from NVIC: SRST doesn't work correctly */
	/* This could be VECTRESET: 0x05FA0001 (reset only core)
	 *          or SYSRESETREQ: 0x05FA0004 (system reset)
	 */
	target_mem_write32(t, CORTEXM_AIRCR,
 8006164:	4a10      	ldr	r2, [pc, #64]	; (80061a8 <samd_reset+0x4e>)
 8006166:	1c20      	adds	r0, r4, #0
 8006168:	4910      	ldr	r1, [pc, #64]	; (80061ac <samd_reset+0x52>)
 800616a:	f002 f9e7 	bl	800853c <target_mem_write32>
	                   CORTEXM_AIRCR_VECTKEY | CORTEXM_AIRCR_SYSRESETREQ);

	/* Exit extended reset */
	if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) &
 800616e:	1c20      	adds	r0, r4, #0
 8006170:	490f      	ldr	r1, [pc, #60]	; (80061b0 <samd_reset+0x56>)
 8006172:	f002 f9db 	bl	800852c <target_mem_read32>
 8006176:	2280      	movs	r2, #128	; 0x80
 8006178:	0092      	lsls	r2, r2, #2
 800617a:	4210      	tst	r0, r2
 800617c:	d003      	beq.n	8006186 <samd_reset+0x2c>
	    SAMD_STATUSA_CRSTEXT) {
		/* Write bit to clear from extended reset */
		target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_STATUSA_CRSTEXT);
 800617e:	1c20      	adds	r0, r4, #0
 8006180:	490b      	ldr	r1, [pc, #44]	; (80061b0 <samd_reset+0x56>)
 8006182:	f002 f9db 	bl	800853c <target_mem_write32>
	}

	/* Poll for release from reset */
	while (target_mem_read32(t, CORTEXM_DHCSR) & CORTEXM_DHCSR_S_RESET_ST);
 8006186:	1c20      	adds	r0, r4, #0
 8006188:	4906      	ldr	r1, [pc, #24]	; (80061a4 <samd_reset+0x4a>)
 800618a:	f002 f9cf 	bl	800852c <target_mem_read32>
 800618e:	0183      	lsls	r3, r0, #6
 8006190:	d4f9      	bmi.n	8006186 <samd_reset+0x2c>

	/* Reset DFSR flags */
	target_mem_write32(t, CORTEXM_DFSR, CORTEXM_DFSR_RESETALL);
 8006192:	1c20      	adds	r0, r4, #0
 8006194:	4907      	ldr	r1, [pc, #28]	; (80061b4 <samd_reset+0x5a>)
 8006196:	221f      	movs	r2, #31
 8006198:	f002 f9d0 	bl	800853c <target_mem_write32>

	/* Clear any target errors */
	target_check_error(t);
 800619c:	1c20      	adds	r0, r4, #0
 800619e:	f002 f93b 	bl	8008418 <target_check_error>
}
 80061a2:	bd10      	pop	{r4, pc}
 80061a4:	e000edf0 	.word	0xe000edf0
 80061a8:	05fa0004 	.word	0x05fa0004
 80061ac:	e000ed0c 	.word	0xe000ed0c
 80061b0:	41002100 	.word	0x41002100
 80061b4:	e000ed30 	.word	0xe000ed30

080061b8 <samd_flash_erase>:

/**
 * Erase flash row by row
 */
static int samd_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 80061b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80061ba:	1c07      	adds	r7, r0, #0
 80061bc:	1c0e      	adds	r6, r1, #0
 80061be:	1c14      	adds	r4, r2, #0
	target *t = f->t;
 80061c0:	6985      	ldr	r5, [r0, #24]
	while (len) {
 80061c2:	2c00      	cmp	r4, #0
 80061c4:	d025      	beq.n	8006212 <samd_flash_erase+0x5a>
		/* Write address of first word in row to erase it */
		/* Must be shifted right for 16-bit address, see Datasheet 20.8.8 Address */
		target_mem_write32(t, SAMD_NVMC_ADDRESS, addr >> 1);
 80061c6:	0872      	lsrs	r2, r6, #1
 80061c8:	1c28      	adds	r0, r5, #0
 80061ca:	4913      	ldr	r1, [pc, #76]	; (8006218 <samd_flash_erase+0x60>)
 80061cc:	f002 f9b6 	bl	800853c <target_mem_write32>
	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_LOCK);
}
static void samd_unlock_current_address(target *t)
{
	/* Issue the unlock command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 80061d0:	1c28      	adds	r0, r5, #0
 80061d2:	4912      	ldr	r1, [pc, #72]	; (800621c <samd_flash_erase+0x64>)
 80061d4:	4a12      	ldr	r2, [pc, #72]	; (8006220 <samd_flash_erase+0x68>)
 80061d6:	f002 f9b1 	bl	800853c <target_mem_write32>

		/* Unlock */
		samd_unlock_current_address(t);

		/* Issue the erase command */
		target_mem_write32(t, SAMD_NVMC_CTRLA,
 80061da:	1c28      	adds	r0, r5, #0
 80061dc:	490f      	ldr	r1, [pc, #60]	; (800621c <samd_flash_erase+0x64>)
 80061de:	4a11      	ldr	r2, [pc, #68]	; (8006224 <samd_flash_erase+0x6c>)
 80061e0:	f002 f9ac 	bl	800853c <target_mem_write32>
		                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_ERASEROW);
		/* Poll for NVM Ready */
		while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
 80061e4:	1c28      	adds	r0, r5, #0
 80061e6:	4910      	ldr	r1, [pc, #64]	; (8006228 <samd_flash_erase+0x70>)
 80061e8:	f002 f9a0 	bl	800852c <target_mem_read32>
 80061ec:	07c3      	lsls	r3, r0, #31
 80061ee:	d407      	bmi.n	8006200 <samd_flash_erase+0x48>
			if (target_check_error(t))
 80061f0:	1c28      	adds	r0, r5, #0
 80061f2:	f002 f911 	bl	8008418 <target_check_error>
 80061f6:	2800      	cmp	r0, #0
 80061f8:	d0f4      	beq.n	80061e4 <samd_flash_erase+0x2c>
				return -1;
 80061fa:	2001      	movs	r0, #1
 80061fc:	4240      	negs	r0, r0
 80061fe:	e009      	b.n	8006214 <samd_flash_erase+0x5c>
 * Temporary (until next reset) flash memory locking / unlocking
 */
static void samd_lock_current_address(target *t)
{
	/* Issue the unlock command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 8006200:	1c28      	adds	r0, r5, #0
 8006202:	4906      	ldr	r1, [pc, #24]	; (800621c <samd_flash_erase+0x64>)
 8006204:	4a09      	ldr	r2, [pc, #36]	; (800622c <samd_flash_erase+0x74>)
 8006206:	f002 f999 	bl	800853c <target_mem_write32>
				return -1;

		/* Lock */
		samd_lock_current_address(t);

		addr += f->blocksize;
 800620a:	68bb      	ldr	r3, [r7, #8]
 800620c:	18f6      	adds	r6, r6, r3
		len -= f->blocksize;
 800620e:	1ae4      	subs	r4, r4, r3
 8006210:	e7d7      	b.n	80061c2 <samd_flash_erase+0xa>
	}

	return 0;
 8006212:	1c20      	adds	r0, r4, #0
}
 8006214:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006216:	46c0      	nop			; (mov r8, r8)
 8006218:	4100401c 	.word	0x4100401c
 800621c:	41004000 	.word	0x41004000
 8006220:	0000a541 	.word	0x0000a541
 8006224:	0000a502 	.word	0x0000a502
 8006228:	41004014 	.word	0x41004014
 800622c:	0000a540 	.word	0x0000a540

08006230 <samd_cmd_ssb>:
}
/**
 * Sets the security bit
 */
static bool samd_cmd_ssb(target *t)
{
 8006230:	b510      	push	{r4, lr}
	/* Issue the ssb command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 8006232:	490b      	ldr	r1, [pc, #44]	; (8006260 <samd_cmd_ssb+0x30>)
 8006234:	4a0b      	ldr	r2, [pc, #44]	; (8006264 <samd_cmd_ssb+0x34>)
}
/**
 * Sets the security bit
 */
static bool samd_cmd_ssb(target *t)
{
 8006236:	1c04      	adds	r4, r0, #0
	/* Issue the ssb command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 8006238:	f002 f980 	bl	800853c <target_mem_write32>
	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_SSB);

	/* Poll for NVM Ready */
	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
 800623c:	1c20      	adds	r0, r4, #0
 800623e:	490a      	ldr	r1, [pc, #40]	; (8006268 <samd_cmd_ssb+0x38>)
 8006240:	f002 f974 	bl	800852c <target_mem_read32>
 8006244:	07c3      	lsls	r3, r0, #31
 8006246:	d405      	bmi.n	8006254 <samd_cmd_ssb+0x24>
		if (target_check_error(t))
 8006248:	1c20      	adds	r0, r4, #0
 800624a:	f002 f8e5 	bl	8008418 <target_check_error>
 800624e:	2800      	cmp	r0, #0
 8006250:	d0f4      	beq.n	800623c <samd_cmd_ssb+0xc>
 8006252:	e003      	b.n	800625c <samd_cmd_ssb+0x2c>
			return -1;

	tc_printf(t, "Set the security bit! "
 8006254:	1c20      	adds	r0, r4, #0
 8006256:	4905      	ldr	r1, [pc, #20]	; (800626c <samd_cmd_ssb+0x3c>)
 8006258:	f002 f9c7 	bl	80085ea <tc_printf>
		  "You will need to issue 'monitor erase_mass' to clear this.\n");

	return true;
}
 800625c:	2001      	movs	r0, #1
 800625e:	bd10      	pop	{r4, pc}
 8006260:	41004000 	.word	0x41004000
 8006264:	0000a545 	.word	0x0000a545
 8006268:	41004014 	.word	0x41004014
 800626c:	08012c50 	.word	0x08012c50

08006270 <samd_cmd_mbist>:

/**
 * Runs the Memory Built In Self Test (MBIST)
 */
static bool samd_cmd_mbist(target *t)
{
 8006270:	b538      	push	{r3, r4, r5, lr}
 8006272:	1c04      	adds	r4, r0, #0
	/* Write the memory parameters to the DSU */
	target_mem_write32(t, SAMD_DSU_ADDRESS, 0);
 8006274:	2200      	movs	r2, #0
 8006276:	4923      	ldr	r1, [pc, #140]	; (8006304 <samd_cmd_mbist+0x94>)
 8006278:	f002 f960 	bl	800853c <target_mem_write32>
 * Returns the size (in bytes) of the current SAM D20's flash memory.
 */
static uint32_t samd_flash_size(target *t)
{
	/* Read the Device ID */
	uint32_t did = target_mem_read32(t, SAMD_DSU_DID);
 800627c:	4922      	ldr	r1, [pc, #136]	; (8006308 <samd_cmd_mbist+0x98>)
 800627e:	1c20      	adds	r0, r4, #0
 8006280:	f002 f954 	bl	800852c <target_mem_read32>

	/* Mask off the device select bits */
	uint8_t devsel = did & SAMD_DID_DEVSEL_MASK;

	/* Shift the maximum flash size (256KB) down as appropriate */
	return (0x40000 >> (devsel % 5));
 8006284:	230f      	movs	r3, #15
 8006286:	2105      	movs	r1, #5
 8006288:	4018      	ands	r0, r3
 800628a:	f008 fc07 	bl	800ea9c <__aeabi_uidivmod>
 800628e:	2380      	movs	r3, #128	; 0x80
 8006290:	b2ca      	uxtb	r2, r1
 8006292:	02db      	lsls	r3, r3, #11
 8006294:	4113      	asrs	r3, r2
 */
static bool samd_cmd_mbist(target *t)
{
	/* Write the memory parameters to the DSU */
	target_mem_write32(t, SAMD_DSU_ADDRESS, 0);
	target_mem_write32(t, SAMD_DSU_LENGTH, samd_flash_size(t));
 8006296:	1c20      	adds	r0, r4, #0

	/* Mask off the device select bits */
	uint8_t devsel = did & SAMD_DID_DEVSEL_MASK;

	/* Shift the maximum flash size (256KB) down as appropriate */
	return (0x40000 >> (devsel % 5));
 8006298:	1c1a      	adds	r2, r3, #0
 */
static bool samd_cmd_mbist(target *t)
{
	/* Write the memory parameters to the DSU */
	target_mem_write32(t, SAMD_DSU_ADDRESS, 0);
	target_mem_write32(t, SAMD_DSU_LENGTH, samd_flash_size(t));
 800629a:	491c      	ldr	r1, [pc, #112]	; (800630c <samd_cmd_mbist+0x9c>)
 800629c:	f002 f94e 	bl	800853c <target_mem_write32>

	/* Clear the fail bit */
	target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_STATUSA_FAIL);
 80062a0:	2280      	movs	r2, #128	; 0x80
 80062a2:	1c20      	adds	r0, r4, #0
 80062a4:	491a      	ldr	r1, [pc, #104]	; (8006310 <samd_cmd_mbist+0xa0>)
 80062a6:	0112      	lsls	r2, r2, #4
 80062a8:	f002 f948 	bl	800853c <target_mem_write32>

	/* Write the MBIST command */
	target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_CTRL_MBIST);
 80062ac:	1c20      	adds	r0, r4, #0
 80062ae:	4918      	ldr	r1, [pc, #96]	; (8006310 <samd_cmd_mbist+0xa0>)
 80062b0:	2208      	movs	r2, #8
 80062b2:	f002 f943 	bl	800853c <target_mem_write32>

	/* Poll for DSU Ready */
	uint32_t status;
	while (((status = target_mem_read32(t, SAMD_DSU_CTRLSTAT)) &
 80062b6:	1c20      	adds	r0, r4, #0
 80062b8:	4915      	ldr	r1, [pc, #84]	; (8006310 <samd_cmd_mbist+0xa0>)
 80062ba:	25c8      	movs	r5, #200	; 0xc8
 80062bc:	f002 f936 	bl	800852c <target_mem_read32>
 80062c0:	016d      	lsls	r5, r5, #5
 80062c2:	4005      	ands	r5, r0
 80062c4:	d106      	bne.n	80062d4 <samd_cmd_mbist+0x64>
		(SAMD_STATUSA_DONE | SAMD_STATUSA_PERR | SAMD_STATUSA_FAIL)) == 0)
		if (target_check_error(t))
 80062c6:	1c20      	adds	r0, r4, #0
 80062c8:	f002 f8a6 	bl	8008418 <target_check_error>
 80062cc:	2800      	cmp	r0, #0
 80062ce:	d0f2      	beq.n	80062b6 <samd_cmd_mbist+0x46>
			return false;
 80062d0:	1c28      	adds	r0, r5, #0
 80062d2:	e015      	b.n	8006300 <samd_cmd_mbist+0x90>

	/* Test the protection error bit in Status A */
	if (status & SAMD_STATUSA_PERR) {
 80062d4:	04c3      	lsls	r3, r0, #19
 80062d6:	d502      	bpl.n	80062de <samd_cmd_mbist+0x6e>
		tc_printf(t, "MBIST not run due to protection error.\n");
 80062d8:	1c20      	adds	r0, r4, #0
 80062da:	490e      	ldr	r1, [pc, #56]	; (8006314 <samd_cmd_mbist+0xa4>)
 80062dc:	e00d      	b.n	80062fa <samd_cmd_mbist+0x8a>
		return true;
	}

	/* Test the fail bit in Status A */
	if (status & SAMD_STATUSA_FAIL) {
 80062de:	0503      	lsls	r3, r0, #20
 80062e0:	d509      	bpl.n	80062f6 <samd_cmd_mbist+0x86>
		tc_printf(t, "MBIST Fail @ 0x%08x\n",
 80062e2:	1c20      	adds	r0, r4, #0
 80062e4:	4907      	ldr	r1, [pc, #28]	; (8006304 <samd_cmd_mbist+0x94>)
 80062e6:	f002 f921 	bl	800852c <target_mem_read32>
 80062ea:	490b      	ldr	r1, [pc, #44]	; (8006318 <samd_cmd_mbist+0xa8>)
 80062ec:	1c02      	adds	r2, r0, #0
 80062ee:	1c20      	adds	r0, r4, #0
 80062f0:	f002 f97b 	bl	80085ea <tc_printf>
 80062f4:	e003      	b.n	80062fe <samd_cmd_mbist+0x8e>
		          target_mem_read32(t, SAMD_DSU_ADDRESS));
	} else {
		tc_printf(t, "MBIST Passed!\n");
 80062f6:	1c20      	adds	r0, r4, #0
 80062f8:	4908      	ldr	r1, [pc, #32]	; (800631c <samd_cmd_mbist+0xac>)
 80062fa:	f002 f976 	bl	80085ea <tc_printf>
	}

	return true;
 80062fe:	2001      	movs	r0, #1
}
 8006300:	bd38      	pop	{r3, r4, r5, pc}
 8006302:	46c0      	nop			; (mov r8, r8)
 8006304:	41002104 	.word	0x41002104
 8006308:	41002118 	.word	0x41002118
 800630c:	41002108 	.word	0x41002108
 8006310:	41002100 	.word	0x41002100
 8006314:	08012ca2 	.word	0x08012ca2
 8006318:	08012cca 	.word	0x08012cca
 800631c:	08012cdf 	.word	0x08012cdf

08006320 <samd_cmd_serial>:

/**
 * Reads the 128-bit serial number from the NVM
 */
static bool samd_cmd_serial(target *t)
{
 8006320:	b538      	push	{r3, r4, r5, lr}
	tc_printf(t, "Serial Number: 0x");
 8006322:	490e      	ldr	r1, [pc, #56]	; (800635c <samd_cmd_serial+0x3c>)

/**
 * Reads the 128-bit serial number from the NVM
 */
static bool samd_cmd_serial(target *t)
{
 8006324:	1c05      	adds	r5, r0, #0
	tc_printf(t, "Serial Number: 0x");
 8006326:	2403      	movs	r4, #3
 8006328:	f002 f95f 	bl	80085ea <tc_printf>
 800632c:	4b0c      	ldr	r3, [pc, #48]	; (8006360 <samd_cmd_serial+0x40>)

	for (uint32_t i = 0; i < 4; i++) {
		tc_printf(t, "%08x", target_mem_read32(t, SAMD_NVM_SERIAL(i)));
 800632e:	08a1      	lsrs	r1, r4, #2
 8006330:	18e2      	adds	r2, r4, r3
 8006332:	230c      	movs	r3, #12
 8006334:	4359      	muls	r1, r3
 8006336:	1851      	adds	r1, r2, r1
 8006338:	0089      	lsls	r1, r1, #2
 800633a:	1c28      	adds	r0, r5, #0
 800633c:	f002 f8f6 	bl	800852c <target_mem_read32>
 8006340:	3401      	adds	r4, #1
 8006342:	1c02      	adds	r2, r0, #0
 8006344:	4907      	ldr	r1, [pc, #28]	; (8006364 <samd_cmd_serial+0x44>)
 8006346:	1c28      	adds	r0, r5, #0
 8006348:	f002 f94f 	bl	80085ea <tc_printf>
 */
static bool samd_cmd_serial(target *t)
{
	tc_printf(t, "Serial Number: 0x");

	for (uint32_t i = 0; i < 4; i++) {
 800634c:	2c07      	cmp	r4, #7
 800634e:	d1ed      	bne.n	800632c <samd_cmd_serial+0xc>
		tc_printf(t, "%08x", target_mem_read32(t, SAMD_NVM_SERIAL(i)));
	}

	tc_printf(t, "\n");
 8006350:	1c28      	adds	r0, r5, #0
 8006352:	4905      	ldr	r1, [pc, #20]	; (8006368 <samd_cmd_serial+0x48>)
 8006354:	f002 f949 	bl	80085ea <tc_printf>

	return true;
}
 8006358:	2001      	movs	r0, #1
 800635a:	bd38      	pop	{r3, r4, r5, pc}
 800635c:	08012cee 	.word	0x08012cee
 8006360:	00202800 	.word	0x00202800
 8006364:	08012d00 	.word	0x08012d00
 8006368:	0800fc8c 	.word	0x0800fc8c

0800636c <samd_cmd_read_userrow>:
{
	return samd_set_flashlock(t, 0xFFFF);
}

static bool samd_cmd_read_userrow(target *t)
{
 800636c:	b538      	push	{r3, r4, r5, lr}
	tc_printf(t, "User Row: 0x%08x%08x\n",
 800636e:	4908      	ldr	r1, [pc, #32]	; (8006390 <samd_cmd_read_userrow+0x24>)
{
	return samd_set_flashlock(t, 0xFFFF);
}

static bool samd_cmd_read_userrow(target *t)
{
 8006370:	1c04      	adds	r4, r0, #0
	tc_printf(t, "User Row: 0x%08x%08x\n",
 8006372:	f002 f8db 	bl	800852c <target_mem_read32>
 8006376:	4907      	ldr	r1, [pc, #28]	; (8006394 <samd_cmd_read_userrow+0x28>)
 8006378:	1c05      	adds	r5, r0, #0
 800637a:	1c20      	adds	r0, r4, #0
 800637c:	f002 f8d6 	bl	800852c <target_mem_read32>
 8006380:	1c2a      	adds	r2, r5, #0
 8006382:	1c03      	adds	r3, r0, #0
 8006384:	4904      	ldr	r1, [pc, #16]	; (8006398 <samd_cmd_read_userrow+0x2c>)
 8006386:	1c20      	adds	r0, r4, #0
 8006388:	f002 f92f 	bl	80085ea <tc_printf>
		target_mem_read32(t, SAMD_NVM_USER_ROW_HIGH),
		target_mem_read32(t, SAMD_NVM_USER_ROW_LOW));

	return true;
}
 800638c:	2001      	movs	r0, #1
 800638e:	bd38      	pop	{r3, r4, r5, pc}
 8006390:	00804004 	.word	0x00804004
 8006394:	00804000 	.word	0x00804000
 8006398:	08012d05 	.word	0x08012d05

0800639c <samd_cmd_erase_all>:
 * Uses the Device Service Unit to erase the entire flash
 */
static bool samd_cmd_erase_all(target *t)
{
	/* Clear the DSU status bits */
	target_mem_write32(t, SAMD_DSU_CTRLSTAT,
 800639c:	22c8      	movs	r2, #200	; 0xc8

/**
 * Uses the Device Service Unit to erase the entire flash
 */
static bool samd_cmd_erase_all(target *t)
{
 800639e:	b538      	push	{r3, r4, r5, lr}
 80063a0:	1c05      	adds	r5, r0, #0
	/* Clear the DSU status bits */
	target_mem_write32(t, SAMD_DSU_CTRLSTAT,
 80063a2:	4914      	ldr	r1, [pc, #80]	; (80063f4 <samd_cmd_erase_all+0x58>)
 80063a4:	0152      	lsls	r2, r2, #5
 80063a6:	f002 f8c9 	bl	800853c <target_mem_write32>
	                   SAMD_STATUSA_DONE | SAMD_STATUSA_PERR |
	                   SAMD_STATUSA_FAIL);

	/* Erase all */
	target_mem_write32(t, SAMD_DSU_CTRLSTAT, SAMD_CTRL_CHIP_ERASE);
 80063aa:	1c28      	adds	r0, r5, #0
 80063ac:	4911      	ldr	r1, [pc, #68]	; (80063f4 <samd_cmd_erase_all+0x58>)
 80063ae:	2210      	movs	r2, #16
 80063b0:	f002 f8c4 	bl	800853c <target_mem_write32>

	/* Poll for DSU Ready */
	uint32_t status;
	while (((status = target_mem_read32(t, SAMD_DSU_CTRLSTAT)) &
 80063b4:	1c28      	adds	r0, r5, #0
 80063b6:	490f      	ldr	r1, [pc, #60]	; (80063f4 <samd_cmd_erase_all+0x58>)
 80063b8:	24c8      	movs	r4, #200	; 0xc8
 80063ba:	f002 f8b7 	bl	800852c <target_mem_read32>
 80063be:	0164      	lsls	r4, r4, #5
 80063c0:	4004      	ands	r4, r0
 80063c2:	d106      	bne.n	80063d2 <samd_cmd_erase_all+0x36>
		(SAMD_STATUSA_DONE | SAMD_STATUSA_PERR | SAMD_STATUSA_FAIL)) == 0)
		if (target_check_error(t))
 80063c4:	1c28      	adds	r0, r5, #0
 80063c6:	f002 f827 	bl	8008418 <target_check_error>
 80063ca:	2800      	cmp	r0, #0
 80063cc:	d0f2      	beq.n	80063b4 <samd_cmd_erase_all+0x18>
			return false;
 80063ce:	1c20      	adds	r0, r4, #0
 80063d0:	e00e      	b.n	80063f0 <samd_cmd_erase_all+0x54>

	/* Test the protection error bit in Status A */
	if (status & SAMD_STATUSA_PERR) {
 80063d2:	04c3      	lsls	r3, r0, #19
 80063d4:	d502      	bpl.n	80063dc <samd_cmd_erase_all+0x40>
		tc_printf(t, "Erase failed due to a protection error.\n");
 80063d6:	1c28      	adds	r0, r5, #0
 80063d8:	4907      	ldr	r1, [pc, #28]	; (80063f8 <samd_cmd_erase_all+0x5c>)
 80063da:	e006      	b.n	80063ea <samd_cmd_erase_all+0x4e>
		return true;
	}

	/* Test the fail bit in Status A */
	if (status & SAMD_STATUSA_FAIL) {
 80063dc:	0503      	lsls	r3, r0, #20
 80063de:	d502      	bpl.n	80063e6 <samd_cmd_erase_all+0x4a>
		tc_printf(t, "Erase failed.\n");
 80063e0:	1c28      	adds	r0, r5, #0
 80063e2:	4906      	ldr	r1, [pc, #24]	; (80063fc <samd_cmd_erase_all+0x60>)
 80063e4:	e001      	b.n	80063ea <samd_cmd_erase_all+0x4e>
		return true;
	}

	tc_printf(t, "Erase successful!\n");
 80063e6:	1c28      	adds	r0, r5, #0
 80063e8:	4905      	ldr	r1, [pc, #20]	; (8006400 <samd_cmd_erase_all+0x64>)
 80063ea:	f002 f8fe 	bl	80085ea <tc_printf>

	return true;
 80063ee:	2001      	movs	r0, #1
}
 80063f0:	bd38      	pop	{r3, r4, r5, pc}
 80063f2:	46c0      	nop			; (mov r8, r8)
 80063f4:	41002100 	.word	0x41002100
 80063f8:	08012d1b 	.word	0x08012d1b
 80063fc:	08012d44 	.word	0x08012d44
 8006400:	080117b8 	.word	0x080117b8

08006404 <samd20_revB_halt_resume>:
 *
 * Only required for SAM D20 _Revision B_ Silicon
 */
static void
samd20_revB_halt_resume(target *t, bool step)
{
 8006404:	b510      	push	{r4, lr}
 8006406:	1c04      	adds	r4, r0, #0
	cortexm_halt_resume(t, step);
 8006408:	f7fb fb1e 	bl	8001a48 <cortexm_halt_resume>

	/* ---- Additional ---- */
	/* Exit extended reset */
	if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) & SAMD_STATUSA_CRSTEXT) {
 800640c:	1c20      	adds	r0, r4, #0
 800640e:	4906      	ldr	r1, [pc, #24]	; (8006428 <samd20_revB_halt_resume+0x24>)
 8006410:	f002 f88c 	bl	800852c <target_mem_read32>
 8006414:	2280      	movs	r2, #128	; 0x80
 8006416:	0092      	lsls	r2, r2, #2
 8006418:	4210      	tst	r0, r2
 800641a:	d003      	beq.n	8006424 <samd20_revB_halt_resume+0x20>
		/* Write bit to clear from extended reset */
		target_mem_write32(t, SAMD_DSU_CTRLSTAT,
 800641c:	1c20      	adds	r0, r4, #0
 800641e:	4902      	ldr	r1, [pc, #8]	; (8006428 <samd20_revB_halt_resume+0x24>)
 8006420:	f002 f88c 	bl	800853c <target_mem_write32>
		                   SAMD_STATUSA_CRSTEXT);
	}
}
 8006424:	bd10      	pop	{r4, pc}
 8006426:	46c0      	nop			; (mov r8, r8)
 8006428:	41002100 	.word	0x41002100

0800642c <samd20_revB_detach>:
 *
 * Only required for SAM D20 _Revision B_ Silicon
 */
static void
samd20_revB_detach(target *t)
{
 800642c:	b510      	push	{r4, lr}
 800642e:	1c04      	adds	r4, r0, #0
	cortexm_detach(t);
 8006430:	f7fb fa9e 	bl	8001970 <cortexm_detach>

	/* ---- Additional ---- */
	/* Exit extended reset */
	if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) &
 8006434:	1c20      	adds	r0, r4, #0
 8006436:	4906      	ldr	r1, [pc, #24]	; (8006450 <samd20_revB_detach+0x24>)
 8006438:	f002 f878 	bl	800852c <target_mem_read32>
 800643c:	2280      	movs	r2, #128	; 0x80
 800643e:	0092      	lsls	r2, r2, #2
 8006440:	4210      	tst	r0, r2
 8006442:	d003      	beq.n	800644c <samd20_revB_detach+0x20>
	    SAMD_STATUSA_CRSTEXT) {
		/* Write bit to clear from extended reset */
		target_mem_write32(t, SAMD_DSU_CTRLSTAT,
 8006444:	1c20      	adds	r0, r4, #0
 8006446:	4902      	ldr	r1, [pc, #8]	; (8006450 <samd20_revB_detach+0x24>)
 8006448:	f002 f878 	bl	800853c <target_mem_write32>
		                   SAMD_STATUSA_CRSTEXT);
	}
}
 800644c:	bd10      	pop	{r4, pc}
 800644e:	46c0      	nop			; (mov r8, r8)
 8006450:	41002100 	.word	0x41002100

08006454 <samd_flash_write>:
/**
 * Write flash page by page
 */
static int samd_flash_write(struct target_flash *f,
                            target_addr dest, const void *src, size_t len)
{
 8006454:	b510      	push	{r4, lr}
	target *t = f->t;
 8006456:	6984      	ldr	r4, [r0, #24]

	/* Write within a single page. This may be part or all of the page */
	target_mem_write(t, dest, src, len);
 8006458:	1c20      	adds	r0, r4, #0
 800645a:	f001 ffeb 	bl	8008434 <target_mem_write>
	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_LOCK);
}
static void samd_unlock_current_address(target *t)
{
	/* Issue the unlock command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 800645e:	1c20      	adds	r0, r4, #0
 8006460:	490e      	ldr	r1, [pc, #56]	; (800649c <samd_flash_write+0x48>)
 8006462:	4a0f      	ldr	r2, [pc, #60]	; (80064a0 <samd_flash_write+0x4c>)
 8006464:	f002 f86a 	bl	800853c <target_mem_write32>

	/* Unlock */
	samd_unlock_current_address(t);

	/* Issue the write page command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 8006468:	1c20      	adds	r0, r4, #0
 800646a:	490c      	ldr	r1, [pc, #48]	; (800649c <samd_flash_write+0x48>)
 800646c:	4a0d      	ldr	r2, [pc, #52]	; (80064a4 <samd_flash_write+0x50>)
 800646e:	f002 f865 	bl	800853c <target_mem_write32>
	                   SAMD_CTRLA_CMD_KEY | SAMD_CTRLA_CMD_WRITEPAGE);

	/* Poll for NVM Ready */
	while ((target_mem_read32(t, SAMD_NVMC_INTFLAG) & SAMD_NVMC_READY) == 0)
 8006472:	1c20      	adds	r0, r4, #0
 8006474:	490c      	ldr	r1, [pc, #48]	; (80064a8 <samd_flash_write+0x54>)
 8006476:	f002 f859 	bl	800852c <target_mem_read32>
 800647a:	07c3      	lsls	r3, r0, #31
 800647c:	d407      	bmi.n	800648e <samd_flash_write+0x3a>
		if (target_check_error(t))
 800647e:	1c20      	adds	r0, r4, #0
 8006480:	f001 ffca 	bl	8008418 <target_check_error>
 8006484:	2800      	cmp	r0, #0
 8006486:	d0f4      	beq.n	8006472 <samd_flash_write+0x1e>
			return -1;
 8006488:	2001      	movs	r0, #1
 800648a:	4240      	negs	r0, r0
 800648c:	e005      	b.n	800649a <samd_flash_write+0x46>
 * Temporary (until next reset) flash memory locking / unlocking
 */
static void samd_lock_current_address(target *t)
{
	/* Issue the unlock command */
	target_mem_write32(t, SAMD_NVMC_CTRLA,
 800648e:	1c20      	adds	r0, r4, #0
 8006490:	4902      	ldr	r1, [pc, #8]	; (800649c <samd_flash_write+0x48>)
 8006492:	4a06      	ldr	r2, [pc, #24]	; (80064ac <samd_flash_write+0x58>)
 8006494:	f002 f852 	bl	800853c <target_mem_write32>
			return -1;

	/* Lock */
	samd_lock_current_address(t);

	return 0;
 8006498:	2000      	movs	r0, #0
}
 800649a:	bd10      	pop	{r4, pc}
 800649c:	41004000 	.word	0x41004000
 80064a0:	0000a541 	.word	0x0000a541
 80064a4:	0000a504 	.word	0x0000a504
 80064a8:	41004014 	.word	0x41004014
 80064ac:	0000a540 	.word	0x0000a540

080064b0 <samd_read_pid>:

/**
 * Reads the SAM D20 Peripheral ID
 */
uint64_t samd_read_pid(target *t)
{
 80064b0:	b570      	push	{r4, r5, r6, lr}
 80064b2:	2400      	movs	r4, #0
 80064b4:	1c06      	adds	r6, r0, #0
	uint64_t pid = 0;
 80064b6:	1c25      	adds	r5, r4, #0
	uint8_t i, j;

	/* Five PID registers to read LSB first */
	for (i = 0, j = 0; i < 5; i++, j += 8)
		pid |= (target_mem_read32(t, SAMD_DSU_PID(i)) & 0xFF) << j;
 80064b8:	2303      	movs	r3, #3
 80064ba:	b2e1      	uxtb	r1, r4
 80064bc:	4a09      	ldr	r2, [pc, #36]	; (80064e4 <samd_read_pid+0x34>)
 80064be:	400b      	ands	r3, r1
 80064c0:	0889      	lsrs	r1, r1, #2
 80064c2:	189b      	adds	r3, r3, r2
 80064c4:	0089      	lsls	r1, r1, #2
 80064c6:	1a59      	subs	r1, r3, r1
 80064c8:	0089      	lsls	r1, r1, #2
 80064ca:	1c30      	adds	r0, r6, #0
 80064cc:	f002 f82e 	bl	800852c <target_mem_read32>
 80064d0:	00e3      	lsls	r3, r4, #3
 80064d2:	b2c0      	uxtb	r0, r0
 80064d4:	4098      	lsls	r0, r3
 80064d6:	3401      	adds	r4, #1
 80064d8:	4305      	orrs	r5, r0
{
	uint64_t pid = 0;
	uint8_t i, j;

	/* Five PID registers to read LSB first */
	for (i = 0, j = 0; i < 5; i++, j += 8)
 80064da:	2c05      	cmp	r4, #5
 80064dc:	d1ec      	bne.n	80064b8 <samd_read_pid+0x8>
		pid |= (target_mem_read32(t, SAMD_DSU_PID(i)) & 0xFF) << j;

	return pid;
}
 80064de:	1c28      	adds	r0, r5, #0
 80064e0:	2100      	movs	r1, #0
 80064e2:	bd70      	pop	{r4, r5, r6, pc}
 80064e4:	10400ff8 	.word	0x10400ff8

080064e8 <samd_read_cid>:
/**
 * Reads the SAM D20 Component ID
 */
uint32_t samd_read_cid(target *t)
{
 80064e8:	b570      	push	{r4, r5, r6, lr}
 80064ea:	2400      	movs	r4, #0
 80064ec:	1c06      	adds	r6, r0, #0
	uint64_t cid = 0;
 80064ee:	1c25      	adds	r5, r4, #0
 80064f0:	4b06      	ldr	r3, [pc, #24]	; (800650c <samd_read_cid+0x24>)
	uint8_t i, j;

	/* Four CID registers to read LSB first */
	for (i = 0, j = 0; i < 4; i++, j += 8)
		cid |= (target_mem_read32(t, SAMD_DSU_CID(i)) & 0xFF) << j;
 80064f2:	1c30      	adds	r0, r6, #0
 80064f4:	18e1      	adds	r1, r4, r3
 80064f6:	f002 f819 	bl	800852c <target_mem_read32>
 80064fa:	0063      	lsls	r3, r4, #1
 80064fc:	b2c0      	uxtb	r0, r0
 80064fe:	4098      	lsls	r0, r3
 8006500:	3404      	adds	r4, #4
 8006502:	4305      	orrs	r5, r0
{
	uint64_t cid = 0;
	uint8_t i, j;

	/* Four CID registers to read LSB first */
	for (i = 0, j = 0; i < 4; i++, j += 8)
 8006504:	2c10      	cmp	r4, #16
 8006506:	d1f3      	bne.n	80064f0 <samd_read_cid+0x8>
		cid |= (target_mem_read32(t, SAMD_DSU_CID(i)) & 0xFF) << j;

	return cid;
}
 8006508:	1c28      	adds	r0, r5, #0
 800650a:	bd70      	pop	{r4, r5, r6, pc}
 800650c:	41003ff0 	.word	0x41003ff0

08006510 <samd_parse_device_id>:
	char pin;
	uint8_t mem;
	char package[3];
};
struct samd_descr samd_parse_device_id(uint32_t did)
{
 8006510:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct samd_descr samd;
	memset(samd.package, 0, 3);
 8006512:	2200      	movs	r2, #0

	uint8_t series = (did >> SAMD_DID_SERIES_POS)
	  & SAMD_DID_SERIES_MASK;
	uint8_t revision = (did >> SAMD_DID_REVISION_POS)
 8006514:	240f      	movs	r4, #15
	char package[3];
};
struct samd_descr samd_parse_device_id(uint32_t did)
{
	struct samd_descr samd;
	memset(samd.package, 0, 3);
 8006516:	ab01      	add	r3, sp, #4
 8006518:	801a      	strh	r2, [r3, #0]
 800651a:	709a      	strb	r2, [r3, #2]

	uint8_t series = (did >> SAMD_DID_SERIES_POS)
	  & SAMD_DID_SERIES_MASK;
	uint8_t revision = (did >> SAMD_DID_REVISION_POS)
 800651c:	0a0b      	lsrs	r3, r1, #8
 800651e:	4023      	ands	r3, r4
	  & SAMD_DID_REVISION_MASK;
	uint8_t devsel = (did >> SAMD_DID_DEVSEL_POS)
 8006520:	400c      	ands	r4, r1
struct samd_descr samd_parse_device_id(uint32_t did)
{
	struct samd_descr samd;
	memset(samd.package, 0, 3);

	uint8_t series = (did >> SAMD_DID_SERIES_POS)
 8006522:	0389      	lsls	r1, r1, #14
	char pin;
	uint8_t mem;
	char package[3];
};
struct samd_descr samd_parse_device_id(uint32_t did)
{
 8006524:	1c05      	adds	r5, r0, #0
	  & SAMD_DID_REVISION_MASK;
	uint8_t devsel = (did >> SAMD_DID_DEVSEL_POS)
	  & SAMD_DID_DEVSEL_MASK;

	/* Series */
	switch (series) {
 8006526:	0f89      	lsrs	r1, r1, #30
 8006528:	2902      	cmp	r1, #2
 800652a:	d006      	beq.n	800653a <samd_parse_device_id+0x2a>
 800652c:	2903      	cmp	r1, #3
 800652e:	d006      	beq.n	800653e <samd_parse_device_id+0x2e>
		case 0: samd.series = 20; break;
 8006530:	3214      	adds	r2, #20
	  & SAMD_DID_REVISION_MASK;
	uint8_t devsel = (did >> SAMD_DID_DEVSEL_POS)
	  & SAMD_DID_DEVSEL_MASK;

	/* Series */
	switch (series) {
 8006532:	2901      	cmp	r1, #1
 8006534:	d104      	bne.n	8006540 <samd_parse_device_id+0x30>
		case 0: samd.series = 20; break;
		case 1: samd.series = 21; break;
 8006536:	2215      	movs	r2, #21
 8006538:	e002      	b.n	8006540 <samd_parse_device_id+0x30>
		case 2: samd.series = 10; break;
 800653a:	220a      	movs	r2, #10
 800653c:	e000      	b.n	8006540 <samd_parse_device_id+0x30>
		case 3: samd.series = 11; break;
 800653e:	220b      	movs	r2, #11
 8006540:	4669      	mov	r1, sp
 8006542:	700a      	strb	r2, [r1, #0]
	}
	/* Revision */
	samd.revision = 'A' + revision;

	switch (samd.series) {
 8006544:	7808      	ldrb	r0, [r1, #0]
		case 1: samd.series = 21; break;
		case 2: samd.series = 10; break;
		case 3: samd.series = 11; break;
	}
	/* Revision */
	samd.revision = 'A' + revision;
 8006546:	3341      	adds	r3, #65	; 0x41

	switch (samd.series) {
 8006548:	380a      	subs	r0, #10
		case 1: samd.series = 21; break;
		case 2: samd.series = 10; break;
		case 3: samd.series = 11; break;
	}
	/* Revision */
	samd.revision = 'A' + revision;
 800654a:	704b      	strb	r3, [r1, #1]

	switch (samd.series) {
 800654c:	280b      	cmp	r0, #11
 800654e:	d83a      	bhi.n	80065c6 <samd_parse_device_id+0xb6>
 8006550:	f008 fa14 	bl	800e97c <__gnu_thumb1_case_uqi>
 8006554:	39391d1d 	.word	0x39391d1d
 8006558:	39393939 	.word	0x39393939
 800655c:	06063939 	.word	0x06063939
	case 20: /* SAM D20 */
	case 21: /* SAM D21 */
		switch (devsel / 5) {
 8006560:	1c20      	adds	r0, r4, #0
 8006562:	2105      	movs	r1, #5
 8006564:	f008 fa14 	bl	800e990 <__aeabi_uidiv>
 8006568:	b2c0      	uxtb	r0, r0
			case 0: samd.pin = 'J'; break;
			case 1: samd.pin = 'G'; break;
 800656a:	2347      	movs	r3, #71	; 0x47
	samd.revision = 'A' + revision;

	switch (samd.series) {
	case 20: /* SAM D20 */
	case 21: /* SAM D21 */
		switch (devsel / 5) {
 800656c:	2801      	cmp	r0, #1
 800656e:	d006      	beq.n	800657e <samd_parse_device_id+0x6e>
			case 0: samd.pin = 'J'; break;
 8006570:	234a      	movs	r3, #74	; 0x4a
	samd.revision = 'A' + revision;

	switch (samd.series) {
	case 20: /* SAM D20 */
	case 21: /* SAM D21 */
		switch (devsel / 5) {
 8006572:	2800      	cmp	r0, #0
 8006574:	d003      	beq.n	800657e <samd_parse_device_id+0x6e>
			case 0: samd.pin = 'J'; break;
			case 1: samd.pin = 'G'; break;
			case 2: samd.pin = 'E'; break;
 8006576:	2345      	movs	r3, #69	; 0x45
	samd.revision = 'A' + revision;

	switch (samd.series) {
	case 20: /* SAM D20 */
	case 21: /* SAM D21 */
		switch (devsel / 5) {
 8006578:	2802      	cmp	r0, #2
 800657a:	d000      	beq.n	800657e <samd_parse_device_id+0x6e>
			case 0: samd.pin = 'J'; break;
			case 1: samd.pin = 'G'; break;
			case 2: samd.pin = 'E'; break;
			default: samd.pin = 'u'; break;
 800657c:	2375      	movs	r3, #117	; 0x75
 800657e:	466a      	mov	r2, sp
		}
		samd.mem = 18 - (devsel % 5);
 8006580:	1c20      	adds	r0, r4, #0
	case 21: /* SAM D21 */
		switch (devsel / 5) {
			case 0: samd.pin = 'J'; break;
			case 1: samd.pin = 'G'; break;
			case 2: samd.pin = 'E'; break;
			default: samd.pin = 'u'; break;
 8006582:	7093      	strb	r3, [r2, #2]
		}
		samd.mem = 18 - (devsel % 5);
 8006584:	2105      	movs	r1, #5
 8006586:	f008 fa89 	bl	800ea9c <__aeabi_uidivmod>
 800658a:	2312      	movs	r3, #18
 800658c:	e018      	b.n	80065c0 <samd_parse_device_id+0xb0>
		break;
	case 10: /* SAM D10 */
	case 11: /* SAM D11 */
		switch (devsel / 3) {
 800658e:	1c20      	adds	r0, r4, #0
 8006590:	2103      	movs	r1, #3
 8006592:	f008 f9fd 	bl	800e990 <__aeabi_uidiv>
 8006596:	b2c0      	uxtb	r0, r0
 8006598:	2800      	cmp	r0, #0
 800659a:	d006      	beq.n	80065aa <samd_parse_device_id+0x9a>
 800659c:	2801      	cmp	r0, #1
 800659e:	d107      	bne.n	80065b0 <samd_parse_device_id+0xa0>
			case 0: samd.package[0] = 'M'; break;
			case 1: samd.package[0] = 'S'; samd.package[1] = 'S'; break;
 80065a0:	2353      	movs	r3, #83	; 0x53
 80065a2:	466a      	mov	r2, sp
 80065a4:	7113      	strb	r3, [r2, #4]
 80065a6:	7153      	strb	r3, [r2, #5]
 80065a8:	e002      	b.n	80065b0 <samd_parse_device_id+0xa0>
		samd.mem = 18 - (devsel % 5);
		break;
	case 10: /* SAM D10 */
	case 11: /* SAM D11 */
		switch (devsel / 3) {
			case 0: samd.package[0] = 'M'; break;
 80065aa:	234d      	movs	r3, #77	; 0x4d
 80065ac:	466a      	mov	r2, sp
 80065ae:	7113      	strb	r3, [r2, #4]
			case 1: samd.package[0] = 'S'; samd.package[1] = 'S'; break;
		}
		samd.pin = 'D';
 80065b0:	2344      	movs	r3, #68	; 0x44
 80065b2:	466a      	mov	r2, sp
		samd.mem = 14 - (devsel % 3);
 80065b4:	1c20      	adds	r0, r4, #0
	case 11: /* SAM D11 */
		switch (devsel / 3) {
			case 0: samd.package[0] = 'M'; break;
			case 1: samd.package[0] = 'S'; samd.package[1] = 'S'; break;
		}
		samd.pin = 'D';
 80065b6:	7093      	strb	r3, [r2, #2]
		samd.mem = 14 - (devsel % 3);
 80065b8:	2103      	movs	r1, #3
 80065ba:	f008 fa6f 	bl	800ea9c <__aeabi_uidivmod>
 80065be:	230e      	movs	r3, #14
 80065c0:	1a59      	subs	r1, r3, r1
 80065c2:	466b      	mov	r3, sp
 80065c4:	70d9      	strb	r1, [r3, #3]
		break;
	}

	return samd;
 80065c6:	1c28      	adds	r0, r5, #0
 80065c8:	4669      	mov	r1, sp
 80065ca:	2207      	movs	r2, #7
 80065cc:	f006 f974 	bl	800c8b8 <memcpy>
}
 80065d0:	1c28      	adds	r0, r5, #0
 80065d2:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

080065d4 <samd_probe>:
	target_add_flash(t, f);
}

char variant_string[40];
bool samd_probe(target *t)
{
 80065d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80065d6:	b087      	sub	sp, #28
 80065d8:	1c04      	adds	r4, r0, #0
	uint32_t cid = samd_read_cid(t);
 80065da:	f7ff ff85 	bl	80064e8 <samd_read_cid>
 80065de:	1c05      	adds	r5, r0, #0
	uint32_t pid = samd_read_pid(t);
 80065e0:	1c20      	adds	r0, r4, #0
 80065e2:	f7ff ff65 	bl	80064b0 <samd_read_pid>

	/* Check the ARM Coresight Component and Perhiperal IDs */
	if ((cid != SAMD_CID_VALUE) ||
 80065e6:	4b3d      	ldr	r3, [pc, #244]	; (80066dc <samd_probe+0x108>)
 80065e8:	429d      	cmp	r5, r3
 80065ea:	d001      	beq.n	80065f0 <samd_probe+0x1c>
	    ((pid & SAMD_PID_MASK) != SAMD_PID_CONST_VALUE))
		return false;
 80065ec:	2000      	movs	r0, #0
 80065ee:	e072      	b.n	80066d6 <samd_probe+0x102>
	uint32_t cid = samd_read_cid(t);
	uint32_t pid = samd_read_pid(t);

	/* Check the ARM Coresight Component and Perhiperal IDs */
	if ((cid != SAMD_CID_VALUE) ||
	    ((pid & SAMD_PID_MASK) != SAMD_PID_CONST_VALUE))
 80065f0:	4b3b      	ldr	r3, [pc, #236]	; (80066e0 <samd_probe+0x10c>)
 80065f2:	4018      	ands	r0, r3
{
	uint32_t cid = samd_read_cid(t);
	uint32_t pid = samd_read_pid(t);

	/* Check the ARM Coresight Component and Perhiperal IDs */
	if ((cid != SAMD_CID_VALUE) ||
 80065f4:	4b3b      	ldr	r3, [pc, #236]	; (80066e4 <samd_probe+0x110>)
 80065f6:	4298      	cmp	r0, r3
 80065f8:	d1f8      	bne.n	80065ec <samd_probe+0x18>
	    ((pid & SAMD_PID_MASK) != SAMD_PID_CONST_VALUE))
		return false;

	/* Read the Device ID */
	uint32_t did = target_mem_read32(t, SAMD_DSU_DID);
 80065fa:	1c20      	adds	r0, r4, #0
 80065fc:	493a      	ldr	r1, [pc, #232]	; (80066e8 <samd_probe+0x114>)
 80065fe:	f001 ff95 	bl	800852c <target_mem_read32>

	/* If the Device ID matches */
	if ((did & SAMD_DID_MASK) != SAMD_DID_CONST_VALUE)
 8006602:	2280      	movs	r2, #128	; 0x80
 8006604:	4b39      	ldr	r3, [pc, #228]	; (80066ec <samd_probe+0x118>)
	if ((cid != SAMD_CID_VALUE) ||
	    ((pid & SAMD_PID_MASK) != SAMD_PID_CONST_VALUE))
		return false;

	/* Read the Device ID */
	uint32_t did = target_mem_read32(t, SAMD_DSU_DID);
 8006606:	1c07      	adds	r7, r0, #0

	/* If the Device ID matches */
	if ((did & SAMD_DID_MASK) != SAMD_DID_CONST_VALUE)
 8006608:	4003      	ands	r3, r0
 800660a:	0552      	lsls	r2, r2, #21
 800660c:	4293      	cmp	r3, r2
 800660e:	d1ed      	bne.n	80065ec <samd_probe+0x18>
		return false;

	uint32_t ctrlstat = target_mem_read32(t, SAMD_DSU_CTRLSTAT);
 8006610:	4937      	ldr	r1, [pc, #220]	; (80066f0 <samd_probe+0x11c>)
 8006612:	1c20      	adds	r0, r4, #0
 8006614:	f001 ff8a 	bl	800852c <target_mem_read32>
 8006618:	1c06      	adds	r6, r0, #0
	struct samd_descr samd = samd_parse_device_id(did);
 800661a:	ad04      	add	r5, sp, #16
 800661c:	1c39      	adds	r1, r7, #0
 800661e:	1c28      	adds	r0, r5, #0
 8006620:	f7ff ff76 	bl	8006510 <samd_parse_device_id>
 8006624:	78ef      	ldrb	r7, [r5, #3]
 8006626:	7869      	ldrb	r1, [r5, #1]
 8006628:	782a      	ldrb	r2, [r5, #0]
 800662a:	78ab      	ldrb	r3, [r5, #2]

	/* Protected? */
	bool protected = (ctrlstat & SAMD_STATUSB_PROT);
 800662c:	03f6      	lsls	r6, r6, #15

	/* Part String */
	if (protected) {
		sprintf(variant_string,
 800662e:	9700      	str	r7, [sp, #0]
 8006630:	af05      	add	r7, sp, #20
 8006632:	9102      	str	r1, [sp, #8]

	uint32_t ctrlstat = target_mem_read32(t, SAMD_DSU_CTRLSTAT);
	struct samd_descr samd = samd_parse_device_id(did);

	/* Protected? */
	bool protected = (ctrlstat & SAMD_STATUSB_PROT);
 8006634:	0ff6      	lsrs	r6, r6, #31
 8006636:	482f      	ldr	r0, [pc, #188]	; (80066f4 <samd_probe+0x120>)

	/* Part String */
	if (protected) {
		sprintf(variant_string,
 8006638:	9701      	str	r7, [sp, #4]
 800663a:	492f      	ldr	r1, [pc, #188]	; (80066f8 <samd_probe+0x124>)

	/* Protected? */
	bool protected = (ctrlstat & SAMD_STATUSB_PROT);

	/* Part String */
	if (protected) {
 800663c:	d100      	bne.n	8006640 <samd_probe+0x6c>
		sprintf(variant_string,
		        "Atmel SAMD%d%c%dA%s (rev %c) (PROT=1)",
		        samd.series, samd.pin, samd.mem,
		        samd.package, samd.revision);
	} else {
		sprintf(variant_string,
 800663e:	492f      	ldr	r1, [pc, #188]	; (80066fc <samd_probe+0x128>)
 8006640:	f006 fb50 	bl	800cce4 <siprintf>
		        samd.series, samd.pin, samd.mem,
		        samd.package, samd.revision);
	}

	/* Setup Target */
	t->driver = variant_string;
 8006644:	4b2b      	ldr	r3, [pc, #172]	; (80066f4 <samd_probe+0x120>)
 8006646:	6623      	str	r3, [r4, #96]	; 0x60
	t->reset = samd_reset;
 8006648:	4b2d      	ldr	r3, [pc, #180]	; (8006700 <samd_probe+0x12c>)
 800664a:	62e3      	str	r3, [r4, #44]	; 0x2c

	if (samd.series == 20 && samd.revision == 'B') {
 800664c:	782b      	ldrb	r3, [r5, #0]
 800664e:	2b14      	cmp	r3, #20
 8006650:	d106      	bne.n	8006660 <samd_probe+0x8c>
 8006652:	786b      	ldrb	r3, [r5, #1]
 8006654:	2b42      	cmp	r3, #66	; 0x42
 8006656:	d103      	bne.n	8006660 <samd_probe+0x8c>
		/**
		 * These functions check for and
		 * extended reset. Appears to be
		 * related to Errata 35.4.1 ref 12015
		 */
		t->detach      = samd20_revB_detach;
 8006658:	4b2a      	ldr	r3, [pc, #168]	; (8006704 <samd_probe+0x130>)
 800665a:	60e3      	str	r3, [r4, #12]
		t->halt_resume = samd20_revB_halt_resume;
 800665c:	4b2a      	ldr	r3, [pc, #168]	; (8006708 <samd_probe+0x134>)
 800665e:	63e3      	str	r3, [r4, #60]	; 0x3c
	}
	if (protected) {
 8006660:	2e00      	cmp	r6, #0
 8006662:	d001      	beq.n	8006668 <samd_probe+0x94>
		 * for when the samd is protected.
		 * This function allows users to
		 * attach on a temporary basis so they
		 * can rescue the device.
		 */
		t->attach = samd_protected_attach;
 8006664:	4b29      	ldr	r3, [pc, #164]	; (800670c <samd_probe+0x138>)
 8006666:	60a3      	str	r3, [r4, #8]
	}

	target_add_ram(t, 0x20000000, 0x8000);
 8006668:	2180      	movs	r1, #128	; 0x80
 800666a:	2280      	movs	r2, #128	; 0x80
 800666c:	1c20      	adds	r0, r4, #0
 800666e:	0212      	lsls	r2, r2, #8
 8006670:	0589      	lsls	r1, r1, #22
 8006672:	f001 fd5f 	bl	8008134 <target_add_ram>
	return samd;
}

static void samd_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8006676:	2138      	movs	r1, #56	; 0x38
 8006678:	2001      	movs	r0, #1
 800667a:	f006 f8fd 	bl	800c878 <calloc>
	f->start = addr;
 800667e:	2300      	movs	r3, #0
 8006680:	6003      	str	r3, [r0, #0]
	f->length = length;
 8006682:	2380      	movs	r3, #128	; 0x80
 8006684:	02db      	lsls	r3, r3, #11
 8006686:	6043      	str	r3, [r0, #4]
	f->blocksize = SAMD_ROW_SIZE;
 8006688:	2380      	movs	r3, #128	; 0x80
 800668a:	005b      	lsls	r3, r3, #1
 800668c:	6083      	str	r3, [r0, #8]
	f->erase = samd_flash_erase;
 800668e:	4b20      	ldr	r3, [pc, #128]	; (8006710 <samd_probe+0x13c>)
	return samd;
}

static void samd_add_flash(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8006690:	1c01      	adds	r1, r0, #0
	f->start = addr;
	f->length = length;
	f->blocksize = SAMD_ROW_SIZE;
	f->erase = samd_flash_erase;
 8006692:	60c3      	str	r3, [r0, #12]
	f->write = target_flash_write_buffered;
 8006694:	4b1f      	ldr	r3, [pc, #124]	; (8006714 <samd_probe+0x140>)
 8006696:	6103      	str	r3, [r0, #16]
	f->done = target_flash_done_buffered;
 8006698:	4b1f      	ldr	r3, [pc, #124]	; (8006718 <samd_probe+0x144>)
 800669a:	6143      	str	r3, [r0, #20]
	f->write_buf = samd_flash_write;
 800669c:	4b1f      	ldr	r3, [pc, #124]	; (800671c <samd_probe+0x148>)
 800669e:	62c3      	str	r3, [r0, #44]	; 0x2c
	f->buf_size = SAMD_PAGE_SIZE;
 80066a0:	2340      	movs	r3, #64	; 0x40
 80066a2:	6283      	str	r3, [r0, #40]	; 0x28
	target_add_flash(t, f);
 80066a4:	1c20      	adds	r0, r4, #0
 80066a6:	f001 fd52 	bl	800814e <target_add_flash>
		t->attach = samd_protected_attach;
	}

	target_add_ram(t, 0x20000000, 0x8000);
	samd_add_flash(t, 0x00000000, 0x40000);
	target_add_commands(t, samd_cmd_list, "SAMD");
 80066aa:	1c20      	adds	r0, r4, #0
 80066ac:	491c      	ldr	r1, [pc, #112]	; (8006720 <samd_probe+0x14c>)
 80066ae:	4a1d      	ldr	r2, [pc, #116]	; (8006724 <samd_probe+0x150>)
 80066b0:	f001 fd00 	bl	80080b4 <target_add_commands>

	/* If we're not in reset here */
	if (!platform_srst_get_val()) {
 80066b4:	f7fe fffd 	bl	80056b2 <platform_srst_get_val>
 80066b8:	2800      	cmp	r0, #0
 80066ba:	d10b      	bne.n	80066d4 <samd_probe+0x100>
		/* We'll have to release the target from
		 * extended reset to make attach possible */
		if (target_mem_read32(t, SAMD_DSU_CTRLSTAT) &
 80066bc:	1c20      	adds	r0, r4, #0
 80066be:	490c      	ldr	r1, [pc, #48]	; (80066f0 <samd_probe+0x11c>)
 80066c0:	f001 ff34 	bl	800852c <target_mem_read32>
 80066c4:	2280      	movs	r2, #128	; 0x80
 80066c6:	0092      	lsls	r2, r2, #2
 80066c8:	4210      	tst	r0, r2
 80066ca:	d003      	beq.n	80066d4 <samd_probe+0x100>
		    SAMD_STATUSA_CRSTEXT) {

			/* Write bit to clear from extended reset */
			target_mem_write32(t, SAMD_DSU_CTRLSTAT,
 80066cc:	1c20      	adds	r0, r4, #0
 80066ce:	4908      	ldr	r1, [pc, #32]	; (80066f0 <samd_probe+0x11c>)
 80066d0:	f001 ff34 	bl	800853c <target_mem_write32>
			                   SAMD_STATUSA_CRSTEXT);
		}
	}

	return true;
 80066d4:	2001      	movs	r0, #1
}
 80066d6:	b007      	add	sp, #28
 80066d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80066da:	46c0      	nop			; (mov r8, r8)
 80066dc:	b105100d 	.word	0xb105100d
 80066e0:	00f7ffff 	.word	0x00f7ffff
 80066e4:	0001fcd0 	.word	0x0001fcd0
 80066e8:	41002118 	.word	0x41002118
 80066ec:	ffbc0000 	.word	0xffbc0000
 80066f0:	41002100 	.word	0x41002100
 80066f4:	20001d99 	.word	0x20001d99
 80066f8:	08012d53 	.word	0x08012d53
 80066fc:	08012d79 	.word	0x08012d79
 8006700:	0800615b 	.word	0x0800615b
 8006704:	0800642d 	.word	0x0800642d
 8006708:	08006405 	.word	0x08006405
 800670c:	080060a9 	.word	0x080060a9
 8006710:	080061b9 	.word	0x080061b9
 8006714:	0800834b 	.word	0x0800834b
 8006718:	080083dd 	.word	0x080083dd
 800671c:	08006455 	.word	0x08006455
 8006720:	08012bf0 	.word	0x08012bf0
 8006724:	08012d96 	.word	0x08012d96

08006728 <stm32f1_flash_unlock>:
	target_add_commands(t, stm32f1_cmd_list, "STM32F0");
	return true;
}

static void stm32f1_flash_unlock(target *t)
{
 8006728:	b538      	push	{r3, r4, r5, lr}
 800672a:	1c05      	adds	r5, r0, #0
	target_mem_write32(t, FLASH_KEYR, KEY1);
 800672c:	4c05      	ldr	r4, [pc, #20]	; (8006744 <stm32f1_flash_unlock+0x1c>)
 800672e:	4a06      	ldr	r2, [pc, #24]	; (8006748 <stm32f1_flash_unlock+0x20>)
 8006730:	1c21      	adds	r1, r4, #0
 8006732:	f001 ff03 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_KEYR, KEY2);
 8006736:	1c28      	adds	r0, r5, #0
 8006738:	1c21      	adds	r1, r4, #0
 800673a:	4a04      	ldr	r2, [pc, #16]	; (800674c <stm32f1_flash_unlock+0x24>)
 800673c:	f001 fefe 	bl	800853c <target_mem_write32>
}
 8006740:	bd38      	pop	{r3, r4, r5, pc}
 8006742:	46c0      	nop			; (mov r8, r8)
 8006744:	40022004 	.word	0x40022004
 8006748:	45670123 	.word	0x45670123
 800674c:	cdef89ab 	.word	0xcdef89ab

08006750 <stm32f1_option_erase>:
}

static bool stm32f1_option_erase(target *t)
{
	/* Erase option bytes instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTER | FLASH_CR_OPTWRE);
 8006750:	2288      	movs	r2, #136	; 0x88

	return true;
}

static bool stm32f1_option_erase(target *t)
{
 8006752:	b510      	push	{r4, lr}
	/* Erase option bytes instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTER | FLASH_CR_OPTWRE);
 8006754:	490d      	ldr	r1, [pc, #52]	; (800678c <stm32f1_option_erase+0x3c>)
 8006756:	0092      	lsls	r2, r2, #2

	return true;
}

static bool stm32f1_option_erase(target *t)
{
 8006758:	1c04      	adds	r4, r0, #0
	/* Erase option bytes instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTER | FLASH_CR_OPTWRE);
 800675a:	f001 feef 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_CR,
 800675e:	2298      	movs	r2, #152	; 0x98
 8006760:	1c20      	adds	r0, r4, #0
 8006762:	490a      	ldr	r1, [pc, #40]	; (800678c <stm32f1_option_erase+0x3c>)
 8006764:	0092      	lsls	r2, r2, #2
 8006766:	f001 fee9 	bl	800853c <target_mem_write32>
			   FLASH_CR_STRT | FLASH_CR_OPTER | FLASH_CR_OPTWRE);
	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 800676a:	1c20      	adds	r0, r4, #0
 800676c:	4908      	ldr	r1, [pc, #32]	; (8006790 <stm32f1_option_erase+0x40>)
 800676e:	f001 fedd 	bl	800852c <target_mem_read32>
 8006772:	2301      	movs	r3, #1
 8006774:	4218      	tst	r0, r3
 8006776:	d006      	beq.n	8006786 <stm32f1_option_erase+0x36>
		if(target_check_error(t))
 8006778:	1c20      	adds	r0, r4, #0
 800677a:	f001 fe4d 	bl	8008418 <target_check_error>
 800677e:	2800      	cmp	r0, #0
 8006780:	d0f3      	beq.n	800676a <stm32f1_option_erase+0x1a>
			return false;
 8006782:	2000      	movs	r0, #0
 8006784:	e000      	b.n	8006788 <stm32f1_option_erase+0x38>
	return true;
 8006786:	1c18      	adds	r0, r3, #0
}
 8006788:	bd10      	pop	{r4, pc}
 800678a:	46c0      	nop			; (mov r8, r8)
 800678c:	40022010 	.word	0x40022010
 8006790:	4002200c 	.word	0x4002200c

08006794 <stm32f1_flash_erase>:
	target_mem_write32(t, FLASH_KEYR, KEY2);
}

static int stm32f1_flash_erase(struct target_flash *f,
                               target_addr addr, size_t len)
{
 8006794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	target *t = f->t;
 8006796:	6984      	ldr	r4, [r0, #24]
	target_mem_write32(t, FLASH_KEYR, KEY2);
}

static int stm32f1_flash_erase(struct target_flash *f,
                               target_addr addr, size_t len)
{
 8006798:	1c07      	adds	r7, r0, #0
	target *t = f->t;
	uint16_t sr;

	stm32f1_flash_unlock(t);
 800679a:	1c20      	adds	r0, r4, #0
	target_mem_write32(t, FLASH_KEYR, KEY2);
}

static int stm32f1_flash_erase(struct target_flash *f,
                               target_addr addr, size_t len)
{
 800679c:	1c0e      	adds	r6, r1, #0
 800679e:	1c15      	adds	r5, r2, #0
	target *t = f->t;
	uint16_t sr;

	stm32f1_flash_unlock(t);
 80067a0:	f7ff ffc2 	bl	8006728 <stm32f1_flash_unlock>

	while(len) {
		/* Flash page erase instruction */
		target_mem_write32(t, FLASH_CR, FLASH_CR_PER);
 80067a4:	1c20      	adds	r0, r4, #0
	target *t = f->t;
	uint16_t sr;

	stm32f1_flash_unlock(t);

	while(len) {
 80067a6:	2d00      	cmp	r5, #0
 80067a8:	d01e      	beq.n	80067e8 <stm32f1_flash_erase+0x54>
		/* Flash page erase instruction */
		target_mem_write32(t, FLASH_CR, FLASH_CR_PER);
 80067aa:	4914      	ldr	r1, [pc, #80]	; (80067fc <stm32f1_flash_erase+0x68>)
 80067ac:	2202      	movs	r2, #2
 80067ae:	f001 fec5 	bl	800853c <target_mem_write32>
		/* write address to FMA */
		target_mem_write32(t, FLASH_AR, addr);
 80067b2:	1c20      	adds	r0, r4, #0
 80067b4:	4912      	ldr	r1, [pc, #72]	; (8006800 <stm32f1_flash_erase+0x6c>)
 80067b6:	1c32      	adds	r2, r6, #0
 80067b8:	f001 fec0 	bl	800853c <target_mem_write32>
		/* Flash page erase start instruction */
		target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_PER);
 80067bc:	1c20      	adds	r0, r4, #0
 80067be:	490f      	ldr	r1, [pc, #60]	; (80067fc <stm32f1_flash_erase+0x68>)
 80067c0:	2242      	movs	r2, #66	; 0x42
 80067c2:	f001 febb 	bl	800853c <target_mem_write32>

		/* Read FLASH_SR to poll for BSY bit */
		while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 80067c6:	1c20      	adds	r0, r4, #0
 80067c8:	490e      	ldr	r1, [pc, #56]	; (8006804 <stm32f1_flash_erase+0x70>)
 80067ca:	f001 feaf 	bl	800852c <target_mem_read32>
 80067ce:	07c3      	lsls	r3, r0, #31
 80067d0:	d506      	bpl.n	80067e0 <stm32f1_flash_erase+0x4c>
			if(target_check_error(t))
 80067d2:	1c20      	adds	r0, r4, #0
 80067d4:	f001 fe20 	bl	8008418 <target_check_error>
 80067d8:	2800      	cmp	r0, #0
 80067da:	d0f4      	beq.n	80067c6 <stm32f1_flash_erase+0x32>
				return -1;
 80067dc:	2001      	movs	r0, #1
 80067de:	e00b      	b.n	80067f8 <stm32f1_flash_erase+0x64>

		len -= f->blocksize;
 80067e0:	68bb      	ldr	r3, [r7, #8]
 80067e2:	1aed      	subs	r5, r5, r3
		addr += f->blocksize;
 80067e4:	18f6      	adds	r6, r6, r3
 80067e6:	e7dd      	b.n	80067a4 <stm32f1_flash_erase+0x10>
	}

	/* Check for error */
	sr = target_mem_read32(t, FLASH_SR);
 80067e8:	4906      	ldr	r1, [pc, #24]	; (8006804 <stm32f1_flash_erase+0x70>)
 80067ea:	f001 fe9f 	bl	800852c <target_mem_read32>
	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
 80067ee:	2334      	movs	r3, #52	; 0x34
 80067f0:	4018      	ands	r0, r3
 80067f2:	3820      	subs	r0, #32
 80067f4:	1e43      	subs	r3, r0, #1
 80067f6:	4198      	sbcs	r0, r3
		target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_PER);

		/* Read FLASH_SR to poll for BSY bit */
		while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
			if(target_check_error(t))
				return -1;
 80067f8:	4240      	negs	r0, r0
	sr = target_mem_read32(t, FLASH_SR);
	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
		return -1;

	return 0;
}
 80067fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80067fc:	40022010 	.word	0x40022010
 8006800:	40022014 	.word	0x40022014
 8006804:	4002200c 	.word	0x4002200c

08006808 <stm32f1_flash_write>:

static int stm32f1_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8006808:	b5f0      	push	{r4, r5, r6, r7, lr}
	target *t = f->t;
	/* Write stub and data to target ram and set PC */
	target_mem_write(t, SRAM_BASE, stm32f1_flash_write_stub,
 800680a:	2580      	movs	r5, #128	; 0x80
	return 0;
}

static int stm32f1_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 800680c:	1c1e      	adds	r6, r3, #0
	target *t = f->t;
 800680e:	6984      	ldr	r4, [r0, #24]
	return 0;
}

static int stm32f1_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8006810:	b085      	sub	sp, #20
	target *t = f->t;
	/* Write stub and data to target ram and set PC */
	target_mem_write(t, SRAM_BASE, stm32f1_flash_write_stub,
 8006812:	05ad      	lsls	r5, r5, #22
	                 sizeof(stm32f1_flash_write_stub));
	target_mem_write(t, STUB_BUFFER_BASE, src, len);
 8006814:	4f0c      	ldr	r7, [pc, #48]	; (8006848 <stm32f1_flash_write+0x40>)
	return 0;
}

static int stm32f1_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8006816:	9102      	str	r1, [sp, #8]
 8006818:	9203      	str	r2, [sp, #12]
	target *t = f->t;
	/* Write stub and data to target ram and set PC */
	target_mem_write(t, SRAM_BASE, stm32f1_flash_write_stub,
 800681a:	1c29      	adds	r1, r5, #0
 800681c:	1c20      	adds	r0, r4, #0
 800681e:	4a0b      	ldr	r2, [pc, #44]	; (800684c <stm32f1_flash_write+0x44>)
 8006820:	2330      	movs	r3, #48	; 0x30
 8006822:	f001 fe07 	bl	8008434 <target_mem_write>
	                 sizeof(stm32f1_flash_write_stub));
	target_mem_write(t, STUB_BUFFER_BASE, src, len);
 8006826:	1c39      	adds	r1, r7, #0
 8006828:	9a03      	ldr	r2, [sp, #12]
 800682a:	1c33      	adds	r3, r6, #0
 800682c:	1c20      	adds	r0, r4, #0
 800682e:	f001 fe01 	bl	8008434 <target_mem_write>
	return cortexm_run_stub(t, SRAM_BASE, dest, STUB_BUFFER_BASE, len, 0);
 8006832:	2300      	movs	r3, #0
 8006834:	9600      	str	r6, [sp, #0]
 8006836:	9301      	str	r3, [sp, #4]
 8006838:	1c20      	adds	r0, r4, #0
 800683a:	1c29      	adds	r1, r5, #0
 800683c:	9a02      	ldr	r2, [sp, #8]
 800683e:	1c3b      	adds	r3, r7, #0
 8006840:	f7fb fe32 	bl	80024a8 <cortexm_run_stub>
}
 8006844:	b005      	add	sp, #20
 8006846:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006848:	20000030 	.word	0x20000030
 800684c:	08012e60 	.word	0x08012e60

08006850 <stm32f1_cmd_erase_mass>:

static bool stm32f1_cmd_erase_mass(target *t)
{
 8006850:	b510      	push	{r4, lr}
 8006852:	1c04      	adds	r4, r0, #0
	stm32f1_flash_unlock(t);
 8006854:	f7ff ff68 	bl	8006728 <stm32f1_flash_unlock>

	/* Flash mass erase start instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_MER);
 8006858:	1c20      	adds	r0, r4, #0
 800685a:	4910      	ldr	r1, [pc, #64]	; (800689c <stm32f1_cmd_erase_mass+0x4c>)
 800685c:	2204      	movs	r2, #4
 800685e:	f001 fe6d 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_MER);
 8006862:	1c20      	adds	r0, r4, #0
 8006864:	490d      	ldr	r1, [pc, #52]	; (800689c <stm32f1_cmd_erase_mass+0x4c>)
 8006866:	2244      	movs	r2, #68	; 0x44
 8006868:	f001 fe68 	bl	800853c <target_mem_write32>

	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 800686c:	1c20      	adds	r0, r4, #0
 800686e:	490c      	ldr	r1, [pc, #48]	; (80068a0 <stm32f1_cmd_erase_mass+0x50>)
 8006870:	f001 fe5c 	bl	800852c <target_mem_read32>
 8006874:	07c3      	lsls	r3, r0, #31
 8006876:	d506      	bpl.n	8006886 <stm32f1_cmd_erase_mass+0x36>
		if(target_check_error(t))
 8006878:	1c20      	adds	r0, r4, #0
 800687a:	f001 fdcd 	bl	8008418 <target_check_error>
 800687e:	2800      	cmp	r0, #0
 8006880:	d0f4      	beq.n	800686c <stm32f1_cmd_erase_mass+0x1c>
			return false;
 8006882:	2000      	movs	r0, #0
 8006884:	e009      	b.n	800689a <stm32f1_cmd_erase_mass+0x4a>

	/* Check for error */
	uint16_t sr = target_mem_read32(t, FLASH_SR);
 8006886:	1c20      	adds	r0, r4, #0
 8006888:	4905      	ldr	r1, [pc, #20]	; (80068a0 <stm32f1_cmd_erase_mass+0x50>)
 800688a:	f001 fe4f 	bl	800852c <target_mem_read32>
	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
 800688e:	2334      	movs	r3, #52	; 0x34
 8006890:	4018      	ands	r0, r3
 8006892:	3820      	subs	r0, #32
 8006894:	4243      	negs	r3, r0
 8006896:	4158      	adcs	r0, r3
 8006898:	b2c0      	uxtb	r0, r0
		return false;

	return true;
}
 800689a:	bd10      	pop	{r4, pc}
 800689c:	40022010 	.word	0x40022010
 80068a0:	4002200c 	.word	0x4002200c

080068a4 <stm32f1_option_write_erased.part.1>:
		if(target_check_error(t))
			return false;
	return true;
}

static bool stm32f1_option_write_erased(target *t, uint32_t addr, uint16_t value)
 80068a4:	b570      	push	{r4, r5, r6, lr}
 80068a6:	1c15      	adds	r5, r2, #0
{
	if (value == 0xffff)
		return true;
	/* Erase option bytes instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTPG | FLASH_CR_OPTWRE);
 80068a8:	2284      	movs	r2, #132	; 0x84
		if(target_check_error(t))
			return false;
	return true;
}

static bool stm32f1_option_write_erased(target *t, uint32_t addr, uint16_t value)
 80068aa:	1c04      	adds	r4, r0, #0
 80068ac:	1c0e      	adds	r6, r1, #0
{
	if (value == 0xffff)
		return true;
	/* Erase option bytes instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_OPTPG | FLASH_CR_OPTWRE);
 80068ae:	0092      	lsls	r2, r2, #2
 80068b0:	490b      	ldr	r1, [pc, #44]	; (80068e0 <stm32f1_option_write_erased.part.1+0x3c>)
 80068b2:	f001 fe43 	bl	800853c <target_mem_write32>
	target_mem_write16(t, addr, value);
 80068b6:	1c20      	adds	r0, r4, #0
 80068b8:	1c31      	adds	r1, r6, #0
 80068ba:	1c2a      	adds	r2, r5, #0
 80068bc:	f001 fe4f 	bl	800855e <target_mem_write16>
	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 80068c0:	1c20      	adds	r0, r4, #0
 80068c2:	4908      	ldr	r1, [pc, #32]	; (80068e4 <stm32f1_option_write_erased.part.1+0x40>)
 80068c4:	f001 fe32 	bl	800852c <target_mem_read32>
 80068c8:	2301      	movs	r3, #1
 80068ca:	4218      	tst	r0, r3
 80068cc:	d006      	beq.n	80068dc <stm32f1_option_write_erased.part.1+0x38>
		if(target_check_error(t))
 80068ce:	1c20      	adds	r0, r4, #0
 80068d0:	f001 fda2 	bl	8008418 <target_check_error>
 80068d4:	2800      	cmp	r0, #0
 80068d6:	d0f3      	beq.n	80068c0 <stm32f1_option_write_erased.part.1+0x1c>
			return false;
 80068d8:	2000      	movs	r0, #0
 80068da:	e000      	b.n	80068de <stm32f1_option_write_erased.part.1+0x3a>
	return true;
 80068dc:	1c18      	adds	r0, r3, #0
}
 80068de:	bd70      	pop	{r4, r5, r6, pc}
 80068e0:	40022010 	.word	0x40022010
 80068e4:	4002200c 	.word	0x4002200c

080068e8 <stm32f1_add_flash.constprop.2>:
};

#define SRAM_BASE 0x20000000
#define STUB_BUFFER_BASE ALIGN(SRAM_BASE + sizeof(stm32f1_flash_write_stub), 4)

static void stm32f1_add_flash(target *t,
 80068e8:	b570      	push	{r4, r5, r6, lr}
 80068ea:	1c0e      	adds	r6, r1, #0
 80068ec:	1c04      	adds	r4, r0, #0
                              uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 80068ee:	2138      	movs	r1, #56	; 0x38
 80068f0:	2001      	movs	r0, #1
};

#define SRAM_BASE 0x20000000
#define STUB_BUFFER_BASE ALIGN(SRAM_BASE + sizeof(stm32f1_flash_write_stub), 4)

static void stm32f1_add_flash(target *t,
 80068f2:	1c15      	adds	r5, r2, #0
                              uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 80068f4:	f005 ffc0 	bl	800c878 <calloc>
	f->start = addr;
 80068f8:	2380      	movs	r3, #128	; 0x80
 80068fa:	051b      	lsls	r3, r3, #20
 80068fc:	6003      	str	r3, [r0, #0]
	f->length = length;
	f->blocksize = erasesize;
	f->erase = stm32f1_flash_erase;
 80068fe:	4b08      	ldr	r3, [pc, #32]	; (8006920 <stm32f1_add_flash.constprop.2+0x38>)
	f->write = stm32f1_flash_write;
	f->align = 2;
	f->erased = 0xff;
 8006900:	22ff      	movs	r2, #255	; 0xff
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
	f->erase = stm32f1_flash_erase;
 8006902:	60c3      	str	r3, [r0, #12]
	f->write = stm32f1_flash_write;
 8006904:	4b07      	ldr	r3, [pc, #28]	; (8006924 <stm32f1_add_flash.constprop.2+0x3c>)
static void stm32f1_add_flash(target *t,
                              uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
 8006906:	6046      	str	r6, [r0, #4]
	f->blocksize = erasesize;
	f->erase = stm32f1_flash_erase;
	f->write = stm32f1_flash_write;
 8006908:	6103      	str	r3, [r0, #16]
	f->align = 2;
 800690a:	2302      	movs	r3, #2
 800690c:	6203      	str	r3, [r0, #32]
	f->erased = 0xff;
 800690e:	1d43      	adds	r3, r0, #5
                              uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
 8006910:	6085      	str	r5, [r0, #8]
#define STUB_BUFFER_BASE ALIGN(SRAM_BASE + sizeof(stm32f1_flash_write_stub), 4)

static void stm32f1_add_flash(target *t,
                              uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8006912:	1c01      	adds	r1, r0, #0
	f->length = length;
	f->blocksize = erasesize;
	f->erase = stm32f1_flash_erase;
	f->write = stm32f1_flash_write;
	f->align = 2;
	f->erased = 0xff;
 8006914:	77da      	strb	r2, [r3, #31]
	target_add_flash(t, f);
 8006916:	1c20      	adds	r0, r4, #0
 8006918:	f001 fc19 	bl	800814e <target_add_flash>
}
 800691c:	bd70      	pop	{r4, r5, r6, pc}
 800691e:	46c0      	nop			; (mov r8, r8)
 8006920:	08006795 	.word	0x08006795
 8006924:	08006809 	.word	0x08006809

08006928 <stm32f1_cmd_option>:
			return false;
	return true;
}

static bool stm32f1_cmd_option(target *t, int argc, char *argv[])
{
 8006928:	b5f0      	push	{r4, r5, r6, r7, lr}
 800692a:	1c16      	adds	r6, r2, #0
	uint32_t addr, val;
	uint32_t flash_obp_rdp_key;
	uint32_t rdprt;

	switch(t->idcode) {
 800692c:	2287      	movs	r2, #135	; 0x87
 800692e:	6d03      	ldr	r3, [r0, #80]	; 0x50
			return false;
	return true;
}

static bool stm32f1_cmd_option(target *t, int argc, char *argv[])
{
 8006930:	b087      	sub	sp, #28
 8006932:	1c04      	adds	r4, r0, #0
 8006934:	1c0f      	adds	r7, r1, #0
	uint32_t addr, val;
	uint32_t flash_obp_rdp_key;
	uint32_t rdprt;

	switch(t->idcode) {
 8006936:	00d2      	lsls	r2, r2, #3
 8006938:	4293      	cmp	r3, r2
 800693a:	d00e      	beq.n	800695a <stm32f1_cmd_option+0x32>
 800693c:	d804      	bhi.n	8006948 <stm32f1_cmd_option+0x20>
 800693e:	4a55      	ldr	r2, [pc, #340]	; (8006a94 <stm32f1_cmd_option+0x16c>)
 8006940:	4293      	cmp	r3, r2
 8006942:	d00a      	beq.n	800695a <stm32f1_cmd_option+0x32>
 8006944:	4a54      	ldr	r2, [pc, #336]	; (8006a98 <stm32f1_cmd_option+0x170>)
 8006946:	e004      	b.n	8006952 <stm32f1_cmd_option+0x2a>
 8006948:	2288      	movs	r2, #136	; 0x88
 800694a:	00d2      	lsls	r2, r2, #3
 800694c:	4293      	cmp	r3, r2
 800694e:	d004      	beq.n	800695a <stm32f1_cmd_option+0x32>
 8006950:	4a52      	ldr	r2, [pc, #328]	; (8006a9c <stm32f1_cmd_option+0x174>)
 8006952:	4293      	cmp	r3, r2
 8006954:	d001      	beq.n	800695a <stm32f1_cmd_option+0x32>
	case 0x438:  /* STM32F303x6/8 and STM32F328 */
	case 0x440:  /* STM32F0 */
	case 0x446:  /* STM32F303xD/E and STM32F398xE */
		flash_obp_rdp_key = FLASH_OBP_RDP_KEY_F3;
		break;
	default: flash_obp_rdp_key = FLASH_OBP_RDP_KEY;
 8006956:	4b52      	ldr	r3, [pc, #328]	; (8006aa0 <stm32f1_cmd_option+0x178>)
 8006958:	e000      	b.n	800695c <stm32f1_cmd_option+0x34>
	case 0x422:  /* STM32F30x */
	case 0x432:  /* STM32F37x */
	case 0x438:  /* STM32F303x6/8 and STM32F328 */
	case 0x440:  /* STM32F0 */
	case 0x446:  /* STM32F303xD/E and STM32F398xE */
		flash_obp_rdp_key = FLASH_OBP_RDP_KEY_F3;
 800695a:	4b52      	ldr	r3, [pc, #328]	; (8006aa4 <stm32f1_cmd_option+0x17c>)
		break;
	default: flash_obp_rdp_key = FLASH_OBP_RDP_KEY;
	}
	rdprt = target_mem_read32(t, FLASH_OBR) & FLASH_OBR_RDPRT;
 800695c:	4952      	ldr	r1, [pc, #328]	; (8006aa8 <stm32f1_cmd_option+0x180>)
 800695e:	1c20      	adds	r0, r4, #0
	case 0x422:  /* STM32F30x */
	case 0x432:  /* STM32F37x */
	case 0x438:  /* STM32F303x6/8 and STM32F328 */
	case 0x440:  /* STM32F0 */
	case 0x446:  /* STM32F303xD/E and STM32F398xE */
		flash_obp_rdp_key = FLASH_OBP_RDP_KEY_F3;
 8006960:	9301      	str	r3, [sp, #4]
		break;
	default: flash_obp_rdp_key = FLASH_OBP_RDP_KEY;
	}
	rdprt = target_mem_read32(t, FLASH_OBR) & FLASH_OBR_RDPRT;
 8006962:	f001 fde3 	bl	800852c <target_mem_read32>
 8006966:	2302      	movs	r3, #2
 8006968:	4018      	ands	r0, r3
 800696a:	1c05      	adds	r5, r0, #0
	stm32f1_flash_unlock(t);
 800696c:	1c20      	adds	r0, r4, #0
 800696e:	f7ff fedb 	bl	8006728 <stm32f1_flash_unlock>
	target_mem_write32(t, FLASH_OPTKEYR, KEY1);
 8006972:	1c20      	adds	r0, r4, #0
 8006974:	494d      	ldr	r1, [pc, #308]	; (8006aac <stm32f1_cmd_option+0x184>)
 8006976:	4a4e      	ldr	r2, [pc, #312]	; (8006ab0 <stm32f1_cmd_option+0x188>)
 8006978:	f001 fde0 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_OPTKEYR, KEY2);
 800697c:	1c20      	adds	r0, r4, #0
 800697e:	494b      	ldr	r1, [pc, #300]	; (8006aac <stm32f1_cmd_option+0x184>)
 8006980:	4a4c      	ldr	r2, [pc, #304]	; (8006ab4 <stm32f1_cmd_option+0x18c>)
 8006982:	f001 fddb 	bl	800853c <target_mem_write32>

	if ((argc == 2) && !strcmp(argv[1], "erase")) {
 8006986:	2f02      	cmp	r7, #2
 8006988:	d10f      	bne.n	80069aa <stm32f1_cmd_option+0x82>
 800698a:	6870      	ldr	r0, [r6, #4]
 800698c:	494a      	ldr	r1, [pc, #296]	; (8006ab8 <stm32f1_cmd_option+0x190>)
 800698e:	f006 fa41 	bl	800ce14 <strcmp>
 8006992:	2800      	cmp	r0, #0
 8006994:	d15a      	bne.n	8006a4c <stm32f1_cmd_option+0x124>
		stm32f1_option_erase(t);
 8006996:	1c20      	adds	r0, r4, #0
 8006998:	f7ff feda 	bl	8006750 <stm32f1_option_erase>
 800699c:	466b      	mov	r3, sp
 800699e:	1c20      	adds	r0, r4, #0
 80069a0:	889a      	ldrh	r2, [r3, #4]
 80069a2:	4946      	ldr	r1, [pc, #280]	; (8006abc <stm32f1_cmd_option+0x194>)
 80069a4:	f7ff ff7e 	bl	80068a4 <stm32f1_option_write_erased.part.1>
 80069a8:	e05a      	b.n	8006a60 <stm32f1_cmd_option+0x138>
		stm32f1_option_write_erased(t, FLASH_OBP_RDP, flash_obp_rdp_key);
	} else if (rdprt) {
 80069aa:	2d00      	cmp	r5, #0
 80069ac:	d008      	beq.n	80069c0 <stm32f1_cmd_option+0x98>
		tc_printf(t, "Device is Read Protected\n");
 80069ae:	1c20      	adds	r0, r4, #0
 80069b0:	4943      	ldr	r1, [pc, #268]	; (8006ac0 <stm32f1_cmd_option+0x198>)
 80069b2:	f001 fe1a 	bl	80085ea <tc_printf>
		tc_printf(t, "Use \"monitor option erase\" to unprotect, erasing device\n");
 80069b6:	1c20      	adds	r0, r4, #0
 80069b8:	4942      	ldr	r1, [pc, #264]	; (8006ac4 <stm32f1_cmd_option+0x19c>)
 80069ba:	f001 fe16 	bl	80085ea <tc_printf>
		return true;
 80069be:	e066      	b.n	8006a8e <stm32f1_cmd_option+0x166>
	} else if (argc == 3) {
 80069c0:	2f03      	cmp	r7, #3
 80069c2:	d145      	bne.n	8006a50 <stm32f1_cmd_option+0x128>
		addr = strtol(argv[1], NULL, 0);
 80069c4:	6870      	ldr	r0, [r6, #4]
 80069c6:	1c29      	adds	r1, r5, #0
 80069c8:	1c2a      	adds	r2, r5, #0
 80069ca:	f006 fb75 	bl	800d0b8 <strtol>
		val = strtol(argv[2], NULL, 0);
 80069ce:	1c29      	adds	r1, r5, #0
	} else if (rdprt) {
		tc_printf(t, "Device is Read Protected\n");
		tc_printf(t, "Use \"monitor option erase\" to unprotect, erasing device\n");
		return true;
	} else if (argc == 3) {
		addr = strtol(argv[1], NULL, 0);
 80069d0:	1c07      	adds	r7, r0, #0
		val = strtol(argv[2], NULL, 0);
 80069d2:	1c2a      	adds	r2, r5, #0
 80069d4:	68b0      	ldr	r0, [r6, #8]
 80069d6:	f006 fb6f 	bl	800d0b8 <strtol>
static bool stm32f1_option_write(target *t, uint32_t addr, uint16_t value)
{
	uint16_t opt_val[8];
	int i, index;

	index = (addr - FLASH_OBP_RDP) / 2;
 80069da:	4b3b      	ldr	r3, [pc, #236]	; (8006ac8 <stm32f1_cmd_option+0x1a0>)
		tc_printf(t, "Device is Read Protected\n");
		tc_printf(t, "Use \"monitor option erase\" to unprotect, erasing device\n");
		return true;
	} else if (argc == 3) {
		addr = strtol(argv[1], NULL, 0);
		val = strtol(argv[2], NULL, 0);
 80069dc:	1c06      	adds	r6, r0, #0
static bool stm32f1_option_write(target *t, uint32_t addr, uint16_t value)
{
	uint16_t opt_val[8];
	int i, index;

	index = (addr - FLASH_OBP_RDP) / 2;
 80069de:	18ff      	adds	r7, r7, r3
 80069e0:	087f      	lsrs	r7, r7, #1
	if ((index < 0) || (index > 7))
 80069e2:	2f07      	cmp	r7, #7
 80069e4:	d83c      	bhi.n	8006a60 <stm32f1_cmd_option+0x138>
 80069e6:	4b35      	ldr	r3, [pc, #212]	; (8006abc <stm32f1_cmd_option+0x194>)
		 return false;
	/* Retrieve old values */
	for (i = 0; i < 16; i = i +4) {
		 uint32_t val = target_mem_read32(t, FLASH_OBP_RDP + i);
 80069e8:	1c20      	adds	r0, r4, #0
 80069ea:	18e9      	adds	r1, r5, r3
 80069ec:	f001 fd9e 	bl	800852c <target_mem_read32>
		 opt_val[i/2] = val & 0xffff;
 80069f0:	106b      	asrs	r3, r5, #1
 80069f2:	005a      	lsls	r2, r3, #1
 80069f4:	a902      	add	r1, sp, #8
		 opt_val[i/2 +1] = val >> 16;
 80069f6:	3301      	adds	r3, #1
	if ((index < 0) || (index > 7))
		 return false;
	/* Retrieve old values */
	for (i = 0; i < 16; i = i +4) {
		 uint32_t val = target_mem_read32(t, FLASH_OBP_RDP + i);
		 opt_val[i/2] = val & 0xffff;
 80069f8:	5250      	strh	r0, [r2, r1]
		 opt_val[i/2 +1] = val >> 16;
 80069fa:	005b      	lsls	r3, r3, #1
 80069fc:	0c00      	lsrs	r0, r0, #16

	index = (addr - FLASH_OBP_RDP) / 2;
	if ((index < 0) || (index > 7))
		 return false;
	/* Retrieve old values */
	for (i = 0; i < 16; i = i +4) {
 80069fe:	3504      	adds	r5, #4
		 uint32_t val = target_mem_read32(t, FLASH_OBP_RDP + i);
		 opt_val[i/2] = val & 0xffff;
		 opt_val[i/2 +1] = val >> 16;
 8006a00:	5258      	strh	r0, [r3, r1]

	index = (addr - FLASH_OBP_RDP) / 2;
	if ((index < 0) || (index > 7))
		 return false;
	/* Retrieve old values */
	for (i = 0; i < 16; i = i +4) {
 8006a02:	2d10      	cmp	r5, #16
 8006a04:	d1ef      	bne.n	80069e6 <stm32f1_cmd_option+0xbe>
		 uint32_t val = target_mem_read32(t, FLASH_OBP_RDP + i);
		 opt_val[i/2] = val & 0xffff;
		 opt_val[i/2 +1] = val >> 16;
	}
	if (opt_val[index] == value)
 8006a06:	007f      	lsls	r7, r7, #1
 8006a08:	5a7b      	ldrh	r3, [r7, r1]
		tc_printf(t, "Use \"monitor option erase\" to unprotect, erasing device\n");
		return true;
	} else if (argc == 3) {
		addr = strtol(argv[1], NULL, 0);
		val = strtol(argv[2], NULL, 0);
		stm32f1_option_write(t, addr, val);
 8006a0a:	b2b5      	uxth	r5, r6
	for (i = 0; i < 16; i = i +4) {
		 uint32_t val = target_mem_read32(t, FLASH_OBP_RDP + i);
		 opt_val[i/2] = val & 0xffff;
		 opt_val[i/2 +1] = val >> 16;
	}
	if (opt_val[index] == value)
 8006a0c:	42ab      	cmp	r3, r5
 8006a0e:	d027      	beq.n	8006a60 <stm32f1_cmd_option+0x138>
		return true;
	/* Check for erased value */
	if (opt_val[index] != 0xffff)
 8006a10:	4e2e      	ldr	r6, [pc, #184]	; (8006acc <stm32f1_cmd_option+0x1a4>)
 8006a12:	42b3      	cmp	r3, r6
 8006a14:	d103      	bne.n	8006a1e <stm32f1_cmd_option+0xf6>
		if (!(stm32f1_option_erase(t)))
			return false;
	opt_val[index] = value;
 8006a16:	ab02      	add	r3, sp, #8
 8006a18:	53dd      	strh	r5, [r3, r7]
 8006a1a:	4d28      	ldr	r5, [pc, #160]	; (8006abc <stm32f1_cmd_option+0x194>)
 8006a1c:	e00f      	b.n	8006a3e <stm32f1_cmd_option+0x116>
	}
	if (opt_val[index] == value)
		return true;
	/* Check for erased value */
	if (opt_val[index] != 0xffff)
		if (!(stm32f1_option_erase(t)))
 8006a1e:	1c20      	adds	r0, r4, #0
 8006a20:	f7ff fe96 	bl	8006750 <stm32f1_option_erase>
 8006a24:	2800      	cmp	r0, #0
 8006a26:	d1f6      	bne.n	8006a16 <stm32f1_cmd_option+0xee>
 8006a28:	e01a      	b.n	8006a60 <stm32f1_cmd_option+0x138>
 8006a2a:	1c20      	adds	r0, r4, #0
 8006a2c:	1c29      	adds	r1, r5, #0
 8006a2e:	f7ff ff39 	bl	80068a4 <stm32f1_option_write_erased.part.1>
			return false;
	opt_val[index] = value;
	/* Write changed values*/
	for (i = 0; i < 8; i++)
		if (!(stm32f1_option_write_erased
 8006a32:	2800      	cmp	r0, #0
 8006a34:	d014      	beq.n	8006a60 <stm32f1_cmd_option+0x138>
	if (opt_val[index] != 0xffff)
		if (!(stm32f1_option_erase(t)))
			return false;
	opt_val[index] = value;
	/* Write changed values*/
	for (i = 0; i < 8; i++)
 8006a36:	4b26      	ldr	r3, [pc, #152]	; (8006ad0 <stm32f1_cmd_option+0x1a8>)
 8006a38:	3502      	adds	r5, #2
 8006a3a:	429d      	cmp	r5, r3
 8006a3c:	d010      	beq.n	8006a60 <stm32f1_cmd_option+0x138>
 8006a3e:	4b22      	ldr	r3, [pc, #136]	; (8006ac8 <stm32f1_cmd_option+0x1a0>)
		if (!(stm32f1_option_write_erased
 8006a40:	aa02      	add	r2, sp, #8
 8006a42:	18eb      	adds	r3, r5, r3
 8006a44:	5ad2      	ldrh	r2, [r2, r3]
	return true;
}

static bool stm32f1_option_write_erased(target *t, uint32_t addr, uint16_t value)
{
	if (value == 0xffff)
 8006a46:	42b2      	cmp	r2, r6
 8006a48:	d1ef      	bne.n	8006a2a <stm32f1_cmd_option+0x102>
 8006a4a:	e7f4      	b.n	8006a36 <stm32f1_cmd_option+0x10e>
	target_mem_write32(t, FLASH_OPTKEYR, KEY2);

	if ((argc == 2) && !strcmp(argv[1], "erase")) {
		stm32f1_option_erase(t);
		stm32f1_option_write_erased(t, FLASH_OBP_RDP, flash_obp_rdp_key);
	} else if (rdprt) {
 8006a4c:	2d00      	cmp	r5, #0
 8006a4e:	d1ae      	bne.n	80069ae <stm32f1_cmd_option+0x86>
	} else if (argc == 3) {
		addr = strtol(argv[1], NULL, 0);
		val = strtol(argv[2], NULL, 0);
		stm32f1_option_write(t, addr, val);
	} else {
		tc_printf(t, "usage: monitor option erase\n");
 8006a50:	1c20      	adds	r0, r4, #0
 8006a52:	4920      	ldr	r1, [pc, #128]	; (8006ad4 <stm32f1_cmd_option+0x1ac>)
 8006a54:	f001 fdc9 	bl	80085ea <tc_printf>
		tc_printf(t, "usage: monitor option <addr> <value>\n");
 8006a58:	1c20      	adds	r0, r4, #0
 8006a5a:	491f      	ldr	r1, [pc, #124]	; (8006ad8 <stm32f1_cmd_option+0x1b0>)
 8006a5c:	f001 fdc5 	bl	80085ea <tc_printf>
		return true;
	/* Check for erased value */
	if (opt_val[index] != 0xffff)
		if (!(stm32f1_option_erase(t)))
			return false;
	opt_val[index] = value;
 8006a60:	4d16      	ldr	r5, [pc, #88]	; (8006abc <stm32f1_cmd_option+0x194>)
		stm32f1_option_write(t, FLASH_CR, val);
	}

	for (int i = 0; i < 0xf; i += 4) {
		addr = 0x1ffff800 + i;
		val = target_mem_read32(t, addr);
 8006a62:	1c29      	adds	r1, r5, #0
 8006a64:	1c20      	adds	r0, r4, #0
 8006a66:	f001 fd61 	bl	800852c <target_mem_read32>
 8006a6a:	1c06      	adds	r6, r0, #0
		tc_printf(t, "0x%08X: 0x%04X\n", addr, val & 0xFFFF);
 8006a6c:	4f1b      	ldr	r7, [pc, #108]	; (8006adc <stm32f1_cmd_option+0x1b4>)
 8006a6e:	b283      	uxth	r3, r0
 8006a70:	1c2a      	adds	r2, r5, #0
 8006a72:	1c20      	adds	r0, r4, #0
 8006a74:	1c39      	adds	r1, r7, #0
 8006a76:	f001 fdb8 	bl	80085ea <tc_printf>
 8006a7a:	1caa      	adds	r2, r5, #2
		tc_printf(t, "0x%08X: 0x%04X\n", addr + 2, val >> 16);
 8006a7c:	0c33      	lsrs	r3, r6, #16
 8006a7e:	1c20      	adds	r0, r4, #0
 8006a80:	1c39      	adds	r1, r7, #0
 8006a82:	f001 fdb2 	bl	80085ea <tc_printf>
		stm32f1_option_write(t, FLASH_CR, val);
		val &= ~FLASH_CR_OBL_LAUNCH;
		stm32f1_option_write(t, FLASH_CR, val);
	}

	for (int i = 0; i < 0xf; i += 4) {
 8006a86:	4b12      	ldr	r3, [pc, #72]	; (8006ad0 <stm32f1_cmd_option+0x1a8>)
 8006a88:	3504      	adds	r5, #4
 8006a8a:	429d      	cmp	r5, r3
 8006a8c:	d1e9      	bne.n	8006a62 <stm32f1_cmd_option+0x13a>
		val = target_mem_read32(t, addr);
		tc_printf(t, "0x%08X: 0x%04X\n", addr, val & 0xFFFF);
		tc_printf(t, "0x%08X: 0x%04X\n", addr + 2, val >> 16);
	}
	return true;
}
 8006a8e:	2001      	movs	r0, #1
 8006a90:	b007      	add	sp, #28
 8006a92:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006a94:	00000422 	.word	0x00000422
 8006a98:	00000432 	.word	0x00000432
 8006a9c:	00000446 	.word	0x00000446
 8006aa0:	00005aa5 	.word	0x00005aa5
 8006aa4:	000055aa 	.word	0x000055aa
 8006aa8:	4002201c 	.word	0x4002201c
 8006aac:	40022008 	.word	0x40022008
 8006ab0:	45670123 	.word	0x45670123
 8006ab4:	cdef89ab 	.word	0xcdef89ab
 8006ab8:	08012eb4 	.word	0x08012eb4
 8006abc:	1ffff800 	.word	0x1ffff800
 8006ac0:	08012eba 	.word	0x08012eba
 8006ac4:	08012ed4 	.word	0x08012ed4
 8006ac8:	e0000800 	.word	0xe0000800
 8006acc:	0000ffff 	.word	0x0000ffff
 8006ad0:	1ffff810 	.word	0x1ffff810
 8006ad4:	08012f0d 	.word	0x08012f0d
 8006ad8:	08012f2a 	.word	0x08012f2a
 8006adc:	08012f50 	.word	0x08012f50

08006ae0 <stm32f1_probe>:
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool stm32f1_probe(target *t)
{
 8006ae0:	b570      	push	{r4, r5, r6, lr}
	size_t flash_size;
	size_t block_size = 0x400;
	t->idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xfff;
 8006ae2:	4953      	ldr	r1, [pc, #332]	; (8006c30 <stm32f1_probe+0x150>)
	f->erased = 0xff;
	target_add_flash(t, f);
}

bool stm32f1_probe(target *t)
{
 8006ae4:	1c04      	adds	r4, r0, #0
	size_t flash_size;
	size_t block_size = 0x400;
	t->idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xfff;
 8006ae6:	f001 fd21 	bl	800852c <target_mem_read32>
	switch(t->idcode) {
 8006aea:	4b52      	ldr	r3, [pc, #328]	; (8006c34 <stm32f1_probe+0x154>)

bool stm32f1_probe(target *t)
{
	size_t flash_size;
	size_t block_size = 0x400;
	t->idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xfff;
 8006aec:	0500      	lsls	r0, r0, #20
 8006aee:	0d00      	lsrs	r0, r0, #20
 8006af0:	6520      	str	r0, [r4, #80]	; 0x50
	switch(t->idcode) {
 8006af2:	4298      	cmp	r0, r3
 8006af4:	d04a      	beq.n	8006b8c <stm32f1_probe+0xac>
 8006af6:	d810      	bhi.n	8006b1a <stm32f1_probe+0x3a>
 8006af8:	4b4f      	ldr	r3, [pc, #316]	; (8006c38 <stm32f1_probe+0x158>)
 8006afa:	4298      	cmp	r0, r3
 8006afc:	d031      	beq.n	8006b62 <stm32f1_probe+0x82>
 8006afe:	d804      	bhi.n	8006b0a <stm32f1_probe+0x2a>
 8006b00:	3b04      	subs	r3, #4
 8006b02:	4298      	cmp	r0, r3
 8006b04:	d018      	beq.n	8006b38 <stm32f1_probe+0x58>
 8006b06:	4b4d      	ldr	r3, [pc, #308]	; (8006c3c <stm32f1_probe+0x15c>)
 8006b08:	e004      	b.n	8006b14 <stm32f1_probe+0x34>
 8006b0a:	2383      	movs	r3, #131	; 0x83
 8006b0c:	00db      	lsls	r3, r3, #3
 8006b0e:	4298      	cmp	r0, r3
 8006b10:	d027      	beq.n	8006b62 <stm32f1_probe+0x82>
 8006b12:	3308      	adds	r3, #8
 8006b14:	4298      	cmp	r0, r3
 8006b16:	d00f      	beq.n	8006b38 <stm32f1_probe+0x58>
 8006b18:	e04d      	b.n	8006bb6 <stm32f1_probe+0xd6>
 8006b1a:	4b49      	ldr	r3, [pc, #292]	; (8006c40 <stm32f1_probe+0x160>)
 8006b1c:	4298      	cmp	r0, r3
 8006b1e:	d807      	bhi.n	8006b30 <stm32f1_probe+0x50>
 8006b20:	3b01      	subs	r3, #1
 8006b22:	4298      	cmp	r0, r3
 8006b24:	d232      	bcs.n	8006b8c <stm32f1_probe+0xac>
 8006b26:	3b10      	subs	r3, #16
 8006b28:	4298      	cmp	r0, r3
 8006b2a:	d01a      	beq.n	8006b62 <stm32f1_probe+0x82>
 8006b2c:	4b45      	ldr	r3, [pc, #276]	; (8006c44 <stm32f1_probe+0x164>)
 8006b2e:	e000      	b.n	8006b32 <stm32f1_probe+0x52>
 8006b30:	4b45      	ldr	r3, [pc, #276]	; (8006c48 <stm32f1_probe+0x168>)
 8006b32:	4298      	cmp	r0, r3
 8006b34:	d02a      	beq.n	8006b8c <stm32f1_probe+0xac>
 8006b36:	e03e      	b.n	8006bb6 <stm32f1_probe+0xd6>
	case 0x410:  /* Medium density */
	case 0x412:  /* Low denisty */
	case 0x420:  /* Value Line, Low-/Medium density */
		t->driver = "STM32F1 medium density";
		target_add_ram(t, 0x20000000, 0x5000);
 8006b38:	2180      	movs	r1, #128	; 0x80
 8006b3a:	22a0      	movs	r2, #160	; 0xa0
	t->idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xfff;
	switch(t->idcode) {
	case 0x410:  /* Medium density */
	case 0x412:  /* Low denisty */
	case 0x420:  /* Value Line, Low-/Medium density */
		t->driver = "STM32F1 medium density";
 8006b3c:	4b43      	ldr	r3, [pc, #268]	; (8006c4c <stm32f1_probe+0x16c>)
		target_add_ram(t, 0x20000000, 0x5000);
 8006b3e:	1c20      	adds	r0, r4, #0
	t->idcode = target_mem_read32(t, DBGMCU_IDCODE) & 0xfff;
	switch(t->idcode) {
	case 0x410:  /* Medium density */
	case 0x412:  /* Low denisty */
	case 0x420:  /* Value Line, Low-/Medium density */
		t->driver = "STM32F1 medium density";
 8006b40:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x5000);
 8006b42:	0589      	lsls	r1, r1, #22
 8006b44:	01d2      	lsls	r2, r2, #7
 8006b46:	f001 faf5 	bl	8008134 <target_add_ram>
		stm32f1_add_flash(t, 0x8000000, 0x20000, 0x400);
 8006b4a:	2180      	movs	r1, #128	; 0x80
 8006b4c:	2280      	movs	r2, #128	; 0x80
 8006b4e:	1c20      	adds	r0, r4, #0
 8006b50:	0289      	lsls	r1, r1, #10
 8006b52:	00d2      	lsls	r2, r2, #3
 8006b54:	f7ff fec8 	bl	80068e8 <stm32f1_add_flash.constprop.2>
		target_add_commands(t, stm32f1_cmd_list, "STM32 LD/MD");
 8006b58:	493d      	ldr	r1, [pc, #244]	; (8006c50 <stm32f1_probe+0x170>)
 8006b5a:	1c20      	adds	r0, r4, #0
 8006b5c:	3130      	adds	r1, #48	; 0x30
 8006b5e:	4a3d      	ldr	r2, [pc, #244]	; (8006c54 <stm32f1_probe+0x174>)
 8006b60:	e060      	b.n	8006c24 <stm32f1_probe+0x144>
		return true;
	case 0x414:	 /* High density */
	case 0x418:  /* Connectivity Line */
	case 0x428:	 /* Value Line, High Density */
		t->driver = "STM32F1 high density";
		target_add_ram(t, 0x20000000, 0x10000);
 8006b62:	2180      	movs	r1, #128	; 0x80
 8006b64:	2280      	movs	r2, #128	; 0x80
		target_add_commands(t, stm32f1_cmd_list, "STM32 LD/MD");
		return true;
	case 0x414:	 /* High density */
	case 0x418:  /* Connectivity Line */
	case 0x428:	 /* Value Line, High Density */
		t->driver = "STM32F1 high density";
 8006b66:	4b3c      	ldr	r3, [pc, #240]	; (8006c58 <stm32f1_probe+0x178>)
		target_add_ram(t, 0x20000000, 0x10000);
 8006b68:	1c20      	adds	r0, r4, #0
		target_add_commands(t, stm32f1_cmd_list, "STM32 LD/MD");
		return true;
	case 0x414:	 /* High density */
	case 0x418:  /* Connectivity Line */
	case 0x428:	 /* Value Line, High Density */
		t->driver = "STM32F1 high density";
 8006b6a:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x10000);
 8006b6c:	0589      	lsls	r1, r1, #22
 8006b6e:	0252      	lsls	r2, r2, #9
 8006b70:	f001 fae0 	bl	8008134 <target_add_ram>
		stm32f1_add_flash(t, 0x8000000, 0x80000, 0x800);
 8006b74:	2180      	movs	r1, #128	; 0x80
 8006b76:	2280      	movs	r2, #128	; 0x80
 8006b78:	1c20      	adds	r0, r4, #0
 8006b7a:	0309      	lsls	r1, r1, #12
 8006b7c:	0112      	lsls	r2, r2, #4
 8006b7e:	f7ff feb3 	bl	80068e8 <stm32f1_add_flash.constprop.2>
		target_add_commands(t, stm32f1_cmd_list, "STM32 HD/CL");
 8006b82:	4933      	ldr	r1, [pc, #204]	; (8006c50 <stm32f1_probe+0x170>)
 8006b84:	1c20      	adds	r0, r4, #0
 8006b86:	3130      	adds	r1, #48	; 0x30
 8006b88:	4a34      	ldr	r2, [pc, #208]	; (8006c5c <stm32f1_probe+0x17c>)
 8006b8a:	e04b      	b.n	8006c24 <stm32f1_probe+0x144>
	case 0x432:  /* STM32F37x */
	case 0x438:  /* STM32F303x6/8 and STM32F328 */
	case 0x439:  /* STM32F302C8 */
	case 0x446:  /* STM32F303xD/E and STM32F398xE */
		t->driver = "STM32F3";
		target_add_ram(t, 0x20000000, 0x10000);
 8006b8c:	2180      	movs	r1, #128	; 0x80
 8006b8e:	2280      	movs	r2, #128	; 0x80
	case 0x422:  /* STM32F30x */
	case 0x432:  /* STM32F37x */
	case 0x438:  /* STM32F303x6/8 and STM32F328 */
	case 0x439:  /* STM32F302C8 */
	case 0x446:  /* STM32F303xD/E and STM32F398xE */
		t->driver = "STM32F3";
 8006b90:	4d33      	ldr	r5, [pc, #204]	; (8006c60 <stm32f1_probe+0x180>)
		target_add_ram(t, 0x20000000, 0x10000);
 8006b92:	1c20      	adds	r0, r4, #0
 8006b94:	0589      	lsls	r1, r1, #22
 8006b96:	0252      	lsls	r2, r2, #9
	case 0x422:  /* STM32F30x */
	case 0x432:  /* STM32F37x */
	case 0x438:  /* STM32F303x6/8 and STM32F328 */
	case 0x439:  /* STM32F302C8 */
	case 0x446:  /* STM32F303xD/E and STM32F398xE */
		t->driver = "STM32F3";
 8006b98:	6625      	str	r5, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x10000);
 8006b9a:	f001 facb 	bl	8008134 <target_add_ram>
		stm32f1_add_flash(t, 0x8000000, 0x80000, 0x800);
 8006b9e:	2180      	movs	r1, #128	; 0x80
 8006ba0:	2280      	movs	r2, #128	; 0x80
 8006ba2:	1c20      	adds	r0, r4, #0
 8006ba4:	0309      	lsls	r1, r1, #12
 8006ba6:	0112      	lsls	r2, r2, #4
 8006ba8:	f7ff fe9e 	bl	80068e8 <stm32f1_add_flash.constprop.2>
		target_add_commands(t, stm32f1_cmd_list, "STM32F3");
 8006bac:	4928      	ldr	r1, [pc, #160]	; (8006c50 <stm32f1_probe+0x170>)
 8006bae:	1c20      	adds	r0, r4, #0
 8006bb0:	3130      	adds	r1, #48	; 0x30
 8006bb2:	1c2a      	adds	r2, r5, #0
 8006bb4:	e036      	b.n	8006c24 <stm32f1_probe+0x144>
		return true;
	}

	t->idcode = target_mem_read32(t, DBGMCU_IDCODE_F0) & 0xfff;
 8006bb6:	1c20      	adds	r0, r4, #0
 8006bb8:	492a      	ldr	r1, [pc, #168]	; (8006c64 <stm32f1_probe+0x184>)
 8006bba:	f001 fcb7 	bl	800852c <target_mem_read32>
	switch(t->idcode) {
 8006bbe:	4b2a      	ldr	r3, [pc, #168]	; (8006c68 <stm32f1_probe+0x188>)
		stm32f1_add_flash(t, 0x8000000, 0x80000, 0x800);
		target_add_commands(t, stm32f1_cmd_list, "STM32F3");
		return true;
	}

	t->idcode = target_mem_read32(t, DBGMCU_IDCODE_F0) & 0xfff;
 8006bc0:	0500      	lsls	r0, r0, #20
 8006bc2:	0d00      	lsrs	r0, r0, #20
 8006bc4:	6520      	str	r0, [r4, #80]	; 0x50
	switch(t->idcode) {
 8006bc6:	18c0      	adds	r0, r0, r3
 8006bc8:	2808      	cmp	r0, #8
 8006bca:	d82f      	bhi.n	8006c2c <stm32f1_probe+0x14c>
 8006bcc:	f007 fed6 	bl	800e97c <__gnu_thumb1_case_uqi>
 8006bd0:	2e102e0c 	.word	0x2e102e0c
 8006bd4:	2e2e0705 	.word	0x2e2e0705
 8006bd8:	0e          	.byte	0x0e
 8006bd9:	00          	.byte	0x00
	case 0x444:  /* STM32F03 RM0091 Rev.7 */
		t->driver = "STM32F03";
 8006bda:	4b24      	ldr	r3, [pc, #144]	; (8006c6c <stm32f1_probe+0x18c>)
 8006bdc:	e000      	b.n	8006be0 <stm32f1_probe+0x100>
		break;
	case 0x445:  /* STM32F04 RM0091 Rev.7 */
		t->driver = "STM32F04";
 8006bde:	4b24      	ldr	r3, [pc, #144]	; (8006c70 <stm32f1_probe+0x190>)
}

bool stm32f1_probe(target *t)
{
	size_t flash_size;
	size_t block_size = 0x400;
 8006be0:	2580      	movs	r5, #128	; 0x80
	switch(t->idcode) {
	case 0x444:  /* STM32F03 RM0091 Rev.7 */
		t->driver = "STM32F03";
		break;
	case 0x445:  /* STM32F04 RM0091 Rev.7 */
		t->driver = "STM32F04";
 8006be2:	6623      	str	r3, [r4, #96]	; 0x60
}

bool stm32f1_probe(target *t)
{
	size_t flash_size;
	size_t block_size = 0x400;
 8006be4:	00ed      	lsls	r5, r5, #3
	case 0x444:  /* STM32F03 RM0091 Rev.7 */
		t->driver = "STM32F03";
		break;
	case 0x445:  /* STM32F04 RM0091 Rev.7 */
		t->driver = "STM32F04";
		break;
 8006be6:	e007      	b.n	8006bf8 <stm32f1_probe+0x118>
	case 0x440:  /* STM32F05 RM0091 Rev.7 */
		t->driver = "STM32F05";
 8006be8:	4b22      	ldr	r3, [pc, #136]	; (8006c74 <stm32f1_probe+0x194>)
 8006bea:	e7f9      	b.n	8006be0 <stm32f1_probe+0x100>
		break;
	case 0x448:  /* STM32F07 RM0091 Rev.7 */
		t->driver = "STM32F07";
 8006bec:	4b22      	ldr	r3, [pc, #136]	; (8006c78 <stm32f1_probe+0x198>)
 8006bee:	e000      	b.n	8006bf2 <stm32f1_probe+0x112>
		block_size = 0x800;
		break;
	case 0x442:  /* STM32F09 RM0091 Rev.7 */
		t->driver = "STM32F09";
 8006bf0:	4b22      	ldr	r3, [pc, #136]	; (8006c7c <stm32f1_probe+0x19c>)
		block_size = 0x800;
 8006bf2:	2580      	movs	r5, #128	; 0x80
	case 0x448:  /* STM32F07 RM0091 Rev.7 */
		t->driver = "STM32F07";
		block_size = 0x800;
		break;
	case 0x442:  /* STM32F09 RM0091 Rev.7 */
		t->driver = "STM32F09";
 8006bf4:	6623      	str	r3, [r4, #96]	; 0x60
		block_size = 0x800;
 8006bf6:	012d      	lsls	r5, r5, #4
		break;
	default:     /* NONE */
		return false;
	}

	flash_size = (target_mem_read32(t, FLASHSIZE_F0) & 0xffff) *0x400;
 8006bf8:	4921      	ldr	r1, [pc, #132]	; (8006c80 <stm32f1_probe+0x1a0>)
 8006bfa:	1c20      	adds	r0, r4, #0
 8006bfc:	f001 fc96 	bl	800852c <target_mem_read32>
	target_add_ram(t, 0x20000000, 0x5000);
 8006c00:	2180      	movs	r1, #128	; 0x80
 8006c02:	22a0      	movs	r2, #160	; 0xa0
		break;
	default:     /* NONE */
		return false;
	}

	flash_size = (target_mem_read32(t, FLASHSIZE_F0) & 0xffff) *0x400;
 8006c04:	1c06      	adds	r6, r0, #0
	target_add_ram(t, 0x20000000, 0x5000);
 8006c06:	0589      	lsls	r1, r1, #22
 8006c08:	1c20      	adds	r0, r4, #0
 8006c0a:	01d2      	lsls	r2, r2, #7
 8006c0c:	f001 fa92 	bl	8008134 <target_add_ram>
		break;
	default:     /* NONE */
		return false;
	}

	flash_size = (target_mem_read32(t, FLASHSIZE_F0) & 0xffff) *0x400;
 8006c10:	b2b1      	uxth	r1, r6
 8006c12:	0289      	lsls	r1, r1, #10
	target_add_ram(t, 0x20000000, 0x5000);
	stm32f1_add_flash(t, 0x8000000, flash_size, block_size);
 8006c14:	1c20      	adds	r0, r4, #0
 8006c16:	1c2a      	adds	r2, r5, #0
 8006c18:	f7ff fe66 	bl	80068e8 <stm32f1_add_flash.constprop.2>
	target_add_commands(t, stm32f1_cmd_list, "STM32F0");
 8006c1c:	1c20      	adds	r0, r4, #0
 8006c1e:	490c      	ldr	r1, [pc, #48]	; (8006c50 <stm32f1_probe+0x170>)
 8006c20:	4a18      	ldr	r2, [pc, #96]	; (8006c84 <stm32f1_probe+0x1a4>)
 8006c22:	3130      	adds	r1, #48	; 0x30
 8006c24:	f001 fa46 	bl	80080b4 <target_add_commands>
	return true;
 8006c28:	2001      	movs	r0, #1
 8006c2a:	e000      	b.n	8006c2e <stm32f1_probe+0x14e>
	case 0x442:  /* STM32F09 RM0091 Rev.7 */
		t->driver = "STM32F09";
		block_size = 0x800;
		break;
	default:     /* NONE */
		return false;
 8006c2c:	2000      	movs	r0, #0
	flash_size = (target_mem_read32(t, FLASHSIZE_F0) & 0xffff) *0x400;
	target_add_ram(t, 0x20000000, 0x5000);
	stm32f1_add_flash(t, 0x8000000, flash_size, block_size);
	target_add_commands(t, stm32f1_cmd_list, "STM32F0");
	return true;
}
 8006c2e:	bd70      	pop	{r4, r5, r6, pc}
 8006c30:	e0042000 	.word	0xe0042000
 8006c34:	00000422 	.word	0x00000422
 8006c38:	00000414 	.word	0x00000414
 8006c3c:	00000412 	.word	0x00000412
 8006c40:	00000439 	.word	0x00000439
 8006c44:	00000432 	.word	0x00000432
 8006c48:	00000446 	.word	0x00000446
 8006c4c:	08012f60 	.word	0x08012f60
 8006c50:	08012e60 	.word	0x08012e60
 8006c54:	08012f77 	.word	0x08012f77
 8006c58:	08012f83 	.word	0x08012f83
 8006c5c:	08012f98 	.word	0x08012f98
 8006c60:	08012fa4 	.word	0x08012fa4
 8006c64:	40015800 	.word	0x40015800
 8006c68:	fffffbc0 	.word	0xfffffbc0
 8006c6c:	08012fac 	.word	0x08012fac
 8006c70:	08012fb5 	.word	0x08012fb5
 8006c74:	08012fbe 	.word	0x08012fbe
 8006c78:	08012fc7 	.word	0x08012fc7
 8006c7c:	08012fd0 	.word	0x08012fd0
 8006c80:	1ffff7cc 	.word	0x1ffff7cc
 8006c84:	08012fd9 	.word	0x08012fd9

08006c88 <stm32f4_option_write>:

	return true;
}

static bool stm32f4_option_write(target *t, uint32_t value)
{
 8006c88:	b570      	push	{r4, r5, r6, lr}
 8006c8a:	1c04      	adds	r4, r0, #0
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY1);
 8006c8c:	4a1c      	ldr	r2, [pc, #112]	; (8006d00 <stm32f4_option_write+0x78>)

	return true;
}

static bool stm32f4_option_write(target *t, uint32_t value)
{
 8006c8e:	1c0e      	adds	r6, r1, #0
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY1);
 8006c90:	491c      	ldr	r1, [pc, #112]	; (8006d04 <stm32f4_option_write+0x7c>)
 8006c92:	f001 fc53 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY2);
 8006c96:	1c20      	adds	r0, r4, #0
 8006c98:	491a      	ldr	r1, [pc, #104]	; (8006d04 <stm32f4_option_write+0x7c>)
 8006c9a:	4a1b      	ldr	r2, [pc, #108]	; (8006d08 <stm32f4_option_write+0x80>)
 8006c9c:	f001 fc4e 	bl	800853c <target_mem_write32>
	value &= ~FLASH_OPTCR_RESERVED;
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 8006ca0:	1c20      	adds	r0, r4, #0
 8006ca2:	491a      	ldr	r1, [pc, #104]	; (8006d0c <stm32f4_option_write+0x84>)
 8006ca4:	f001 fc42 	bl	800852c <target_mem_read32>
 8006ca8:	03c3      	lsls	r3, r0, #15
 8006caa:	d505      	bpl.n	8006cb8 <stm32f4_option_write+0x30>
		if(target_check_error(t))
 8006cac:	1c20      	adds	r0, r4, #0
 8006cae:	f001 fbb3 	bl	8008418 <target_check_error>
 8006cb2:	2800      	cmp	r0, #0
 8006cb4:	d0f4      	beq.n	8006ca0 <stm32f4_option_write+0x18>
 8006cb6:	e021      	b.n	8006cfc <stm32f4_option_write+0x74>

static bool stm32f4_option_write(target *t, uint32_t value)
{
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY1);
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY2);
	value &= ~FLASH_OPTCR_RESERVED;
 8006cb8:	4a15      	ldr	r2, [pc, #84]	; (8006d10 <stm32f4_option_write+0x88>)
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
		if(target_check_error(t))
			return -1;

	/* WRITE option bytes instruction */
	target_mem_write32(t, FLASH_OPTCR, value);
 8006cba:	1c20      	adds	r0, r4, #0

static bool stm32f4_option_write(target *t, uint32_t value)
{
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY1);
	target_mem_write32(t, FLASH_OPTKEYR, OPTKEY2);
	value &= ~FLASH_OPTCR_RESERVED;
 8006cbc:	4016      	ands	r6, r2
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
		if(target_check_error(t))
			return -1;

	/* WRITE option bytes instruction */
	target_mem_write32(t, FLASH_OPTCR, value);
 8006cbe:	4915      	ldr	r1, [pc, #84]	; (8006d14 <stm32f4_option_write+0x8c>)
 8006cc0:	1c32      	adds	r2, r6, #0
 8006cc2:	f001 fc3b 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_OPTCR, value | FLASH_OPTCR_OPTSTRT);
 8006cc6:	2202      	movs	r2, #2
 8006cc8:	1c20      	adds	r0, r4, #0
 8006cca:	4332      	orrs	r2, r6
 8006ccc:	4911      	ldr	r1, [pc, #68]	; (8006d14 <stm32f4_option_write+0x8c>)
 8006cce:	f001 fc35 	bl	800853c <target_mem_write32>
	/* Read FLASH_SR to poll for BSY bit */
	while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 8006cd2:	1c20      	adds	r0, r4, #0
 8006cd4:	490d      	ldr	r1, [pc, #52]	; (8006d0c <stm32f4_option_write+0x84>)
 8006cd6:	f001 fc29 	bl	800852c <target_mem_read32>
 8006cda:	03c3      	lsls	r3, r0, #15
 8006cdc:	d506      	bpl.n	8006cec <stm32f4_option_write+0x64>
		if(target_check_error(t))
 8006cde:	1c20      	adds	r0, r4, #0
 8006ce0:	f001 fb9a 	bl	8008418 <target_check_error>
 8006ce4:	2800      	cmp	r0, #0
 8006ce6:	d0f4      	beq.n	8006cd2 <stm32f4_option_write+0x4a>
			return false;
 8006ce8:	2000      	movs	r0, #0
 8006cea:	e007      	b.n	8006cfc <stm32f4_option_write+0x74>
	target_mem_write32(t, FLASH_OPTCR, value | FLASH_OPTCR_OPTLOCK);
 8006cec:	2501      	movs	r5, #1
 8006cee:	1c32      	adds	r2, r6, #0
 8006cf0:	1c20      	adds	r0, r4, #0
 8006cf2:	432a      	orrs	r2, r5
 8006cf4:	4907      	ldr	r1, [pc, #28]	; (8006d14 <stm32f4_option_write+0x8c>)
 8006cf6:	f001 fc21 	bl	800853c <target_mem_write32>
	return true;
 8006cfa:	1c28      	adds	r0, r5, #0
}
 8006cfc:	bd70      	pop	{r4, r5, r6, pc}
 8006cfe:	46c0      	nop			; (mov r8, r8)
 8006d00:	08192a3b 	.word	0x08192a3b
 8006d04:	40023c08 	.word	0x40023c08
 8006d08:	4c5d6e7f 	.word	0x4c5d6e7f
 8006d0c:	40023c0c 	.word	0x40023c0c
 8006d10:	0fffffec 	.word	0x0fffffec
 8006d14:	40023c14 	.word	0x40023c14

08006d18 <stm32f4_cmd_option>:

static bool stm32f4_cmd_option(target *t, int argc, char *argv[])
{
 8006d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006d1a:	1c15      	adds	r5, r2, #0
	uint32_t start, val;
	int len;

	if (t->idcode == 0x449) {
 8006d1c:	4b1f      	ldr	r3, [pc, #124]	; (8006d9c <stm32f4_cmd_option+0x84>)
 8006d1e:	6d02      	ldr	r2, [r0, #80]	; 0x50
	target_mem_write32(t, FLASH_OPTCR, value | FLASH_OPTCR_OPTLOCK);
	return true;
}

static bool stm32f4_cmd_option(target *t, int argc, char *argv[])
{
 8006d20:	1c04      	adds	r4, r0, #0
	uint32_t start, val;
	int len;

	if (t->idcode == 0x449) {
 8006d22:	429a      	cmp	r2, r3
 8006d24:	d002      	beq.n	8006d2c <stm32f4_cmd_option+0x14>
		start = 0x1FFF0000;
		len = 0x20;
	}
	else {
		start = 0x1FFFC000;
		len = 0x10;
 8006d26:	2710      	movs	r7, #16
	if (t->idcode == 0x449) {
		start = 0x1FFF0000;
		len = 0x20;
	}
	else {
		start = 0x1FFFC000;
 8006d28:	4e1d      	ldr	r6, [pc, #116]	; (8006da0 <stm32f4_cmd_option+0x88>)
 8006d2a:	e001      	b.n	8006d30 <stm32f4_cmd_option+0x18>
	uint32_t start, val;
	int len;

	if (t->idcode == 0x449) {
		start = 0x1FFF0000;
		len = 0x20;
 8006d2c:	2720      	movs	r7, #32
{
	uint32_t start, val;
	int len;

	if (t->idcode == 0x449) {
		start = 0x1FFF0000;
 8006d2e:	4e1d      	ldr	r6, [pc, #116]	; (8006da4 <stm32f4_cmd_option+0x8c>)
	else {
		start = 0x1FFFC000;
		len = 0x10;
	}

	if ((argc == 2) && !strcmp(argv[1], "erase")) {
 8006d30:	2902      	cmp	r1, #2
 8006d32:	d10b      	bne.n	8006d4c <stm32f4_cmd_option+0x34>
 8006d34:	6868      	ldr	r0, [r5, #4]
 8006d36:	491c      	ldr	r1, [pc, #112]	; (8006da8 <stm32f4_cmd_option+0x90>)
 8006d38:	f006 f86c 	bl	800ce14 <strcmp>
 8006d3c:	2800      	cmp	r0, #0
 8006d3e:	d114      	bne.n	8006d6a <stm32f4_cmd_option+0x52>
		stm32f4_option_write(t, 0x0fffaaed);
 8006d40:	1c20      	adds	r0, r4, #0
 8006d42:	491a      	ldr	r1, [pc, #104]	; (8006dac <stm32f4_cmd_option+0x94>)
 8006d44:	f7ff ffa0 	bl	8006c88 <stm32f4_option_write>
	if (t->idcode == 0x449) {
		start = 0x1FFF0000;
		len = 0x20;
	}
	else {
		start = 0x1FFFC000;
 8006d48:	1c35      	adds	r5, r6, #0
 8006d4a:	e017      	b.n	8006d7c <stm32f4_cmd_option+0x64>
	}

	if ((argc == 2) && !strcmp(argv[1], "erase")) {
		stm32f4_option_write(t, 0x0fffaaed);
	}
	else if ((argc == 3) && !strcmp(argv[1], "write")) {
 8006d4c:	2903      	cmp	r1, #3
 8006d4e:	d10c      	bne.n	8006d6a <stm32f4_cmd_option+0x52>
 8006d50:	6868      	ldr	r0, [r5, #4]
 8006d52:	4917      	ldr	r1, [pc, #92]	; (8006db0 <stm32f4_cmd_option+0x98>)
 8006d54:	f006 f85e 	bl	800ce14 <strcmp>
 8006d58:	1e02      	subs	r2, r0, #0
 8006d5a:	d106      	bne.n	8006d6a <stm32f4_cmd_option+0x52>
		val = strtoul(argv[2], NULL, 0);
 8006d5c:	1c11      	adds	r1, r2, #0
 8006d5e:	68a8      	ldr	r0, [r5, #8]
 8006d60:	f006 fa3a 	bl	800d1d8 <strtoul>
 8006d64:	1c01      	adds	r1, r0, #0
		stm32f4_option_write(t, val);
 8006d66:	1c20      	adds	r0, r4, #0
 8006d68:	e7ec      	b.n	8006d44 <stm32f4_cmd_option+0x2c>
	} else {
		tc_printf(t, "usage: monitor option erase\n");
 8006d6a:	1c20      	adds	r0, r4, #0
 8006d6c:	4911      	ldr	r1, [pc, #68]	; (8006db4 <stm32f4_cmd_option+0x9c>)
 8006d6e:	f001 fc3c 	bl	80085ea <tc_printf>
		tc_printf(t, "usage: monitor option write <value>\n");
 8006d72:	1c20      	adds	r0, r4, #0
 8006d74:	4910      	ldr	r1, [pc, #64]	; (8006db8 <stm32f4_cmd_option+0xa0>)
 8006d76:	f001 fc38 	bl	80085ea <tc_printf>
 8006d7a:	e7e5      	b.n	8006d48 <stm32f4_cmd_option+0x30>
	}

	for (int i = 0; i < len; i += 8) {
		uint32_t addr =  start + i;
		val = target_mem_read32(t, addr);
 8006d7c:	1c29      	adds	r1, r5, #0
 8006d7e:	1c20      	adds	r0, r4, #0
 8006d80:	f001 fbd4 	bl	800852c <target_mem_read32>
		tc_printf(t, "0x%08X: 0x%04X\n", addr, val & 0xFFFF);
 8006d84:	1c2a      	adds	r2, r5, #0
 8006d86:	b283      	uxth	r3, r0
 8006d88:	490c      	ldr	r1, [pc, #48]	; (8006dbc <stm32f4_cmd_option+0xa4>)
 8006d8a:	1c20      	adds	r0, r4, #0
 8006d8c:	3508      	adds	r5, #8
 8006d8e:	f001 fc2c 	bl	80085ea <tc_printf>
 8006d92:	1bab      	subs	r3, r5, r6
	} else {
		tc_printf(t, "usage: monitor option erase\n");
		tc_printf(t, "usage: monitor option write <value>\n");
	}

	for (int i = 0; i < len; i += 8) {
 8006d94:	42bb      	cmp	r3, r7
 8006d96:	dbf1      	blt.n	8006d7c <stm32f4_cmd_option+0x64>
		uint32_t addr =  start + i;
		val = target_mem_read32(t, addr);
		tc_printf(t, "0x%08X: 0x%04X\n", addr, val & 0xFFFF);
	}
	return true;
}
 8006d98:	2001      	movs	r0, #1
 8006d9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d9c:	00000449 	.word	0x00000449
 8006da0:	1fffc000 	.word	0x1fffc000
 8006da4:	1fff0000 	.word	0x1fff0000
 8006da8:	08012eb4 	.word	0x08012eb4
 8006dac:	0fffaaed 	.word	0x0fffaaed
 8006db0:	0801307c 	.word	0x0801307c
 8006db4:	08012f0d 	.word	0x08012f0d
 8006db8:	08013082 	.word	0x08013082
 8006dbc:	08012f50 	.word	0x08012f50

08006dc0 <stm32f4_add_flash>:
};

static void stm32f4_add_flash(target *t,
                              uint32_t addr, size_t length, size_t blocksize,
                              uint8_t base_sector)
{
 8006dc0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8006dc2:	1c1d      	adds	r5, r3, #0
 8006dc4:	ab08      	add	r3, sp, #32
 8006dc6:	781b      	ldrb	r3, [r3, #0]
 8006dc8:	1c0f      	adds	r7, r1, #0
 8006dca:	1c04      	adds	r4, r0, #0
	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
 8006dcc:	213c      	movs	r1, #60	; 0x3c
 8006dce:	2001      	movs	r0, #1
};

static void stm32f4_add_flash(target *t,
                              uint32_t addr, size_t length, size_t blocksize,
                              uint8_t base_sector)
{
 8006dd0:	1c16      	adds	r6, r2, #0
 8006dd2:	9301      	str	r3, [sp, #4]
	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
 8006dd4:	f005 fd50 	bl	800c878 <calloc>
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = blocksize;
	f->erase = stm32f4_flash_erase;
 8006dd8:	4b0a      	ldr	r3, [pc, #40]	; (8006e04 <stm32f4_add_flash+0x44>)
	f->write = stm32f4_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8006dda:	22ff      	movs	r2, #255	; 0xff
	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = blocksize;
	f->erase = stm32f4_flash_erase;
 8006ddc:	60c3      	str	r3, [r0, #12]
	f->write = stm32f4_flash_write;
 8006dde:	4b0a      	ldr	r3, [pc, #40]	; (8006e08 <stm32f4_add_flash+0x48>)
                              uint32_t addr, size_t length, size_t blocksize,
                              uint8_t base_sector)
{
	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
 8006de0:	6007      	str	r7, [r0, #0]
	f->length = length;
	f->blocksize = blocksize;
	f->erase = stm32f4_flash_erase;
	f->write = stm32f4_flash_write;
 8006de2:	6103      	str	r3, [r0, #16]
	f->align = 4;
 8006de4:	2304      	movs	r3, #4
 8006de6:	6203      	str	r3, [r0, #32]
	f->erased = 0xff;
 8006de8:	1d43      	adds	r3, r0, #5
                              uint8_t base_sector)
{
	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
 8006dea:	6046      	str	r6, [r0, #4]
	f->blocksize = blocksize;
 8006dec:	6085      	str	r5, [r0, #8]
	f->erase = stm32f4_flash_erase;
	f->write = stm32f4_flash_write;
	f->align = 4;
	f->erased = 0xff;
 8006dee:	77da      	strb	r2, [r3, #31]
	sf->base_sector = base_sector;
 8006df0:	466a      	mov	r2, sp
 8006df2:	7912      	ldrb	r2, [r2, #4]
 8006df4:	3333      	adds	r3, #51	; 0x33

static void stm32f4_add_flash(target *t,
                              uint32_t addr, size_t length, size_t blocksize,
                              uint8_t base_sector)
{
	struct stm32f4_flash *sf = calloc(1, sizeof(*sf));
 8006df6:	1c01      	adds	r1, r0, #0
	f->blocksize = blocksize;
	f->erase = stm32f4_flash_erase;
	f->write = stm32f4_flash_write;
	f->align = 4;
	f->erased = 0xff;
	sf->base_sector = base_sector;
 8006df8:	701a      	strb	r2, [r3, #0]
	target_add_flash(t, f);
 8006dfa:	1c20      	adds	r0, r4, #0
 8006dfc:	f001 f9a7 	bl	800814e <target_add_flash>
}
 8006e00:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8006e02:	46c0      	nop			; (mov r8, r8)
 8006e04:	08006f2d 	.word	0x08006f2d
 8006e08:	08006e0d 	.word	0x08006e0d

08006e0c <stm32f4_flash_write>:
	return 0;
}

static int stm32f4_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8006e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Write buffer to target ram call stub */
	target_mem_write(f->t, SRAM_BASE, stm32f4_flash_write_stub,
 8006e0e:	2580      	movs	r5, #128	; 0x80
	return 0;
}

static int stm32f4_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8006e10:	1c04      	adds	r4, r0, #0
 8006e12:	1c1e      	adds	r6, r3, #0
 8006e14:	b085      	sub	sp, #20
	/* Write buffer to target ram call stub */
	target_mem_write(f->t, SRAM_BASE, stm32f4_flash_write_stub,
 8006e16:	05ad      	lsls	r5, r5, #22
	                 sizeof(stm32f4_flash_write_stub));
	target_mem_write(f->t, STUB_BUFFER_BASE, src, len);
 8006e18:	4f0c      	ldr	r7, [pc, #48]	; (8006e4c <stm32f4_flash_write+0x40>)
	return 0;
}

static int stm32f4_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8006e1a:	9102      	str	r1, [sp, #8]
 8006e1c:	9203      	str	r2, [sp, #12]
	/* Write buffer to target ram call stub */
	target_mem_write(f->t, SRAM_BASE, stm32f4_flash_write_stub,
 8006e1e:	1c29      	adds	r1, r5, #0
 8006e20:	4a0b      	ldr	r2, [pc, #44]	; (8006e50 <stm32f4_flash_write+0x44>)
 8006e22:	2338      	movs	r3, #56	; 0x38
 8006e24:	6980      	ldr	r0, [r0, #24]
 8006e26:	f001 fb05 	bl	8008434 <target_mem_write>
	                 sizeof(stm32f4_flash_write_stub));
	target_mem_write(f->t, STUB_BUFFER_BASE, src, len);
 8006e2a:	1c39      	adds	r1, r7, #0
 8006e2c:	9a03      	ldr	r2, [sp, #12]
 8006e2e:	1c33      	adds	r3, r6, #0
 8006e30:	69a0      	ldr	r0, [r4, #24]
 8006e32:	f001 faff 	bl	8008434 <target_mem_write>
	return cortexm_run_stub(f->t, SRAM_BASE, dest,
 8006e36:	2300      	movs	r3, #0
 8006e38:	9600      	str	r6, [sp, #0]
 8006e3a:	9301      	str	r3, [sp, #4]
 8006e3c:	69a0      	ldr	r0, [r4, #24]
 8006e3e:	1c29      	adds	r1, r5, #0
 8006e40:	9a02      	ldr	r2, [sp, #8]
 8006e42:	1c3b      	adds	r3, r7, #0
 8006e44:	f7fb fb30 	bl	80024a8 <cortexm_run_stub>
	                        STUB_BUFFER_BASE, len, 0);
}
 8006e48:	b005      	add	sp, #20
 8006e4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006e4c:	20000038 	.word	0x20000038
 8006e50:	08013000 	.word	0x08013000

08006e54 <stm32f4_flash_unlock>:
	t->idcode = idcode;
	return true;
}

static void stm32f4_flash_unlock(target *t)
{
 8006e54:	b510      	push	{r4, lr}
	if (target_mem_read32(t, FLASH_CR) & FLASH_CR_LOCK) {
 8006e56:	4908      	ldr	r1, [pc, #32]	; (8006e78 <stm32f4_flash_unlock+0x24>)
	t->idcode = idcode;
	return true;
}

static void stm32f4_flash_unlock(target *t)
{
 8006e58:	1c04      	adds	r4, r0, #0
	if (target_mem_read32(t, FLASH_CR) & FLASH_CR_LOCK) {
 8006e5a:	f001 fb67 	bl	800852c <target_mem_read32>
 8006e5e:	2800      	cmp	r0, #0
 8006e60:	da09      	bge.n	8006e76 <stm32f4_flash_unlock+0x22>
		/* Enable FPEC controller access */
		target_mem_write32(t, FLASH_KEYR, KEY1);
 8006e62:	1c20      	adds	r0, r4, #0
 8006e64:	4905      	ldr	r1, [pc, #20]	; (8006e7c <stm32f4_flash_unlock+0x28>)
 8006e66:	4a06      	ldr	r2, [pc, #24]	; (8006e80 <stm32f4_flash_unlock+0x2c>)
 8006e68:	f001 fb68 	bl	800853c <target_mem_write32>
		target_mem_write32(t, FLASH_KEYR, KEY2);
 8006e6c:	1c20      	adds	r0, r4, #0
 8006e6e:	4903      	ldr	r1, [pc, #12]	; (8006e7c <stm32f4_flash_unlock+0x28>)
 8006e70:	4a04      	ldr	r2, [pc, #16]	; (8006e84 <stm32f4_flash_unlock+0x30>)
 8006e72:	f001 fb63 	bl	800853c <target_mem_write32>
	}
}
 8006e76:	bd10      	pop	{r4, pc}
 8006e78:	40023c10 	.word	0x40023c10
 8006e7c:	40023c04 	.word	0x40023c04
 8006e80:	45670123 	.word	0x45670123
 8006e84:	cdef89ab 	.word	0xcdef89ab

08006e88 <stm32f4_cmd_erase_mass>:
	return cortexm_run_stub(f->t, SRAM_BASE, dest,
	                        STUB_BUFFER_BASE, len, 0);
}

static bool stm32f4_cmd_erase_mass(target *t)
{
 8006e88:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006e8a:	1c04      	adds	r4, r0, #0
	const char spinner[] = "|/-\\";
 8006e8c:	2205      	movs	r2, #5
 8006e8e:	4920      	ldr	r1, [pc, #128]	; (8006f10 <stm32f4_cmd_erase_mass+0x88>)
 8006e90:	4668      	mov	r0, sp
 8006e92:	f005 fd11 	bl	800c8b8 <memcpy>
	int spinindex = 0;

	tc_printf(t, "Erasing flash... This may take a few seconds.  ");
 8006e96:	491f      	ldr	r1, [pc, #124]	; (8006f14 <stm32f4_cmd_erase_mass+0x8c>)
 8006e98:	1c20      	adds	r0, r4, #0
 8006e9a:	f001 fba6 	bl	80085ea <tc_printf>
	stm32f4_flash_unlock(t);
 8006e9e:	1c20      	adds	r0, r4, #0
 8006ea0:	f7ff ffd8 	bl	8006e54 <stm32f4_flash_unlock>

	/* Flash mass erase start instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_MER);
 8006ea4:	1c20      	adds	r0, r4, #0
 8006ea6:	491c      	ldr	r1, [pc, #112]	; (8006f18 <stm32f4_cmd_erase_mass+0x90>)
 8006ea8:	2204      	movs	r2, #4
 8006eaa:	f001 fb47 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_MER);
 8006eae:	1c20      	adds	r0, r4, #0
 8006eb0:	4919      	ldr	r1, [pc, #100]	; (8006f18 <stm32f4_cmd_erase_mass+0x90>)
 8006eb2:	4a1a      	ldr	r2, [pc, #104]	; (8006f1c <stm32f4_cmd_erase_mass+0x94>)
 8006eb4:	f001 fb42 	bl	800853c <target_mem_write32>
}

static bool stm32f4_cmd_erase_mass(target *t)
{
	const char spinner[] = "|/-\\";
	int spinindex = 0;
 8006eb8:	2500      	movs	r5, #0
	/* Flash mass erase start instruction */
	target_mem_write32(t, FLASH_CR, FLASH_CR_MER);
	target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_MER);

	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY) {
 8006eba:	1c20      	adds	r0, r4, #0
 8006ebc:	4918      	ldr	r1, [pc, #96]	; (8006f20 <stm32f4_cmd_erase_mass+0x98>)
 8006ebe:	f001 fb35 	bl	800852c <target_mem_read32>
 8006ec2:	03c3      	lsls	r3, r0, #15
 8006ec4:	d515      	bpl.n	8006ef2 <stm32f4_cmd_erase_mass+0x6a>
		tc_printf(t, "\b%c", spinner[spinindex++ % 4]);
 8006ec6:	2303      	movs	r3, #3
 8006ec8:	1c6e      	adds	r6, r5, #1
 8006eca:	401d      	ands	r5, r3
 8006ecc:	466b      	mov	r3, sp
 8006ece:	1c20      	adds	r0, r4, #0
 8006ed0:	5d5a      	ldrb	r2, [r3, r5]
 8006ed2:	4914      	ldr	r1, [pc, #80]	; (8006f24 <stm32f4_cmd_erase_mass+0x9c>)
 8006ed4:	f001 fb89 	bl	80085ea <tc_printf>
		if(target_check_error(t)) {
 8006ed8:	1c20      	adds	r0, r4, #0
 8006eda:	f001 fa9d 	bl	8008418 <target_check_error>
 8006ede:	2800      	cmp	r0, #0
 8006ee0:	d005      	beq.n	8006eee <stm32f4_cmd_erase_mass+0x66>
			tc_printf(t, "\n");
 8006ee2:	1c20      	adds	r0, r4, #0
 8006ee4:	4910      	ldr	r1, [pc, #64]	; (8006f28 <stm32f4_cmd_erase_mass+0xa0>)
 8006ee6:	f001 fb80 	bl	80085ea <tc_printf>
			return false;
 8006eea:	2000      	movs	r0, #0
 8006eec:	e00f      	b.n	8006f0e <stm32f4_cmd_erase_mass+0x86>
	target_mem_write32(t, FLASH_CR, FLASH_CR_MER);
	target_mem_write32(t, FLASH_CR, FLASH_CR_STRT | FLASH_CR_MER);

	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY) {
		tc_printf(t, "\b%c", spinner[spinindex++ % 4]);
 8006eee:	1c35      	adds	r5, r6, #0
 8006ef0:	e7e3      	b.n	8006eba <stm32f4_cmd_erase_mass+0x32>
		if(target_check_error(t)) {
			tc_printf(t, "\n");
			return false;
		}
	}
	tc_printf(t, "\n");
 8006ef2:	1c20      	adds	r0, r4, #0
 8006ef4:	490c      	ldr	r1, [pc, #48]	; (8006f28 <stm32f4_cmd_erase_mass+0xa0>)
 8006ef6:	f001 fb78 	bl	80085ea <tc_printf>

	/* Check for error */
	uint16_t sr = target_mem_read32(t, FLASH_SR);
 8006efa:	1c20      	adds	r0, r4, #0
 8006efc:	4908      	ldr	r1, [pc, #32]	; (8006f20 <stm32f4_cmd_erase_mass+0x98>)
 8006efe:	f001 fb15 	bl	800852c <target_mem_read32>
	if ((sr & SR_ERROR_MASK) || !(sr & SR_EOP))
 8006f02:	23f3      	movs	r3, #243	; 0xf3
 8006f04:	4018      	ands	r0, r3
 8006f06:	3801      	subs	r0, #1
 8006f08:	4243      	negs	r3, r0
 8006f0a:	4158      	adcs	r0, r3
 8006f0c:	b2c0      	uxtb	r0, r0
		return false;

	return true;
}
 8006f0e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8006f10:	080130db 	.word	0x080130db
 8006f14:	080130a7 	.word	0x080130a7
 8006f18:	40023c10 	.word	0x40023c10
 8006f1c:	00010004 	.word	0x00010004
 8006f20:	40023c0c 	.word	0x40023c0c
 8006f24:	080130d7 	.word	0x080130d7
 8006f28:	0800fc8c 	.word	0x0800fc8c

08006f2c <stm32f4_flash_erase>:
		target_mem_write32(t, FLASH_KEYR, KEY2);
	}
}

static int stm32f4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8006f2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8006f2e:	1c06      	adds	r6, r0, #0
	target *t = f->t;
	uint16_t sr;
	uint8_t sector = ((struct stm32f4_flash *)f)->base_sector +
	                  (addr - f->start)/f->blocksize;
 8006f30:	6803      	ldr	r3, [r0, #0]
	}
}

static int stm32f4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	target *t = f->t;
 8006f32:	6984      	ldr	r4, [r0, #24]
	uint16_t sr;
	uint8_t sector = ((struct stm32f4_flash *)f)->base_sector +
	                  (addr - f->start)/f->blocksize;
 8006f34:	1ac8      	subs	r0, r1, r3
 8006f36:	68b1      	ldr	r1, [r6, #8]
		target_mem_write32(t, FLASH_KEYR, KEY2);
	}
}

static int stm32f4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8006f38:	1c17      	adds	r7, r2, #0
	target *t = f->t;
	uint16_t sr;
	uint8_t sector = ((struct stm32f4_flash *)f)->base_sector +
	                  (addr - f->start)/f->blocksize;
 8006f3a:	f007 fd29 	bl	800e990 <__aeabi_uidiv>

static int stm32f4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	target *t = f->t;
	uint16_t sr;
	uint8_t sector = ((struct stm32f4_flash *)f)->base_sector +
 8006f3e:	1c33      	adds	r3, r6, #0
 8006f40:	3338      	adds	r3, #56	; 0x38
 8006f42:	781b      	ldrb	r3, [r3, #0]
 8006f44:	18c0      	adds	r0, r0, r3
 8006f46:	b2c3      	uxtb	r3, r0
	                  (addr - f->start)/f->blocksize;

	stm32f4_flash_unlock(t);
 8006f48:	1c20      	adds	r0, r4, #0

static int stm32f4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
	target *t = f->t;
	uint16_t sr;
	uint8_t sector = ((struct stm32f4_flash *)f)->base_sector +
 8006f4a:	9301      	str	r3, [sp, #4]
	                  (addr - f->start)/f->blocksize;

	stm32f4_flash_unlock(t);
 8006f4c:	f7ff ff82 	bl	8006e54 <stm32f4_flash_unlock>

	while(len) {
 8006f50:	2f00      	cmp	r7, #0
 8006f52:	d023      	beq.n	8006f9c <stm32f4_flash_erase+0x70>
		uint32_t cr = FLASH_CR_EOPIE | FLASH_CR_ERRIE | FLASH_CR_SER |
		              (sector << 3);
 8006f54:	9b01      	ldr	r3, [sp, #4]
	                  (addr - f->start)/f->blocksize;

	stm32f4_flash_unlock(t);

	while(len) {
		uint32_t cr = FLASH_CR_EOPIE | FLASH_CR_ERRIE | FLASH_CR_SER |
 8006f56:	4d16      	ldr	r5, [pc, #88]	; (8006fb0 <stm32f4_flash_erase+0x84>)
		              (sector << 3);
 8006f58:	00db      	lsls	r3, r3, #3
	                  (addr - f->start)/f->blocksize;

	stm32f4_flash_unlock(t);

	while(len) {
		uint32_t cr = FLASH_CR_EOPIE | FLASH_CR_ERRIE | FLASH_CR_SER |
 8006f5a:	431d      	orrs	r5, r3
		              (sector << 3);
		/* Flash page erase instruction */
		target_mem_write32(t, FLASH_CR, cr);
 8006f5c:	1c20      	adds	r0, r4, #0
 8006f5e:	4915      	ldr	r1, [pc, #84]	; (8006fb4 <stm32f4_flash_erase+0x88>)
 8006f60:	1c2a      	adds	r2, r5, #0
 8006f62:	f001 faeb 	bl	800853c <target_mem_write32>
		/* write address to FMA */
		target_mem_write32(t, FLASH_CR, cr | FLASH_CR_STRT);
 8006f66:	2280      	movs	r2, #128	; 0x80
 8006f68:	0252      	lsls	r2, r2, #9
 8006f6a:	432a      	orrs	r2, r5
 8006f6c:	1c20      	adds	r0, r4, #0
 8006f6e:	4911      	ldr	r1, [pc, #68]	; (8006fb4 <stm32f4_flash_erase+0x88>)
 8006f70:	f001 fae4 	bl	800853c <target_mem_write32>

		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 8006f74:	1c20      	adds	r0, r4, #0
 8006f76:	4910      	ldr	r1, [pc, #64]	; (8006fb8 <stm32f4_flash_erase+0x8c>)
 8006f78:	f001 fad8 	bl	800852c <target_mem_read32>
 8006f7c:	03c3      	lsls	r3, r0, #15
 8006f7e:	d506      	bpl.n	8006f8e <stm32f4_flash_erase+0x62>
			if(target_check_error(t))
 8006f80:	1c20      	adds	r0, r4, #0
 8006f82:	f001 fa49 	bl	8008418 <target_check_error>
 8006f86:	2800      	cmp	r0, #0
 8006f88:	d0f4      	beq.n	8006f74 <stm32f4_flash_erase+0x48>
				return -1;
 8006f8a:	2001      	movs	r0, #1
 8006f8c:	e00e      	b.n	8006fac <stm32f4_flash_erase+0x80>

		len -= f->blocksize;
		sector++;
 8006f8e:	9801      	ldr	r0, [sp, #4]
		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
			if(target_check_error(t))
				return -1;

		len -= f->blocksize;
 8006f90:	68b3      	ldr	r3, [r6, #8]
		sector++;
 8006f92:	3001      	adds	r0, #1
		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
			if(target_check_error(t))
				return -1;

		len -= f->blocksize;
 8006f94:	1aff      	subs	r7, r7, r3
		sector++;
 8006f96:	b2c3      	uxtb	r3, r0
 8006f98:	9301      	str	r3, [sp, #4]
 8006f9a:	e7d9      	b.n	8006f50 <stm32f4_flash_erase+0x24>
	}

	/* Check for error */
	sr = target_mem_read32(t, FLASH_SR);
 8006f9c:	1c20      	adds	r0, r4, #0
 8006f9e:	4906      	ldr	r1, [pc, #24]	; (8006fb8 <stm32f4_flash_erase+0x8c>)
 8006fa0:	f001 fac4 	bl	800852c <target_mem_read32>
	if(sr & SR_ERROR_MASK)
 8006fa4:	23f2      	movs	r3, #242	; 0xf2
 8006fa6:	4018      	ands	r0, r3
 8006fa8:	1e43      	subs	r3, r0, #1
 8006faa:	4198      	sbcs	r0, r3
		target_mem_write32(t, FLASH_CR, cr | FLASH_CR_STRT);

		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
			if(target_check_error(t))
				return -1;
 8006fac:	4240      	negs	r0, r0
	sr = target_mem_read32(t, FLASH_SR);
	if(sr & SR_ERROR_MASK)
		return -1;

	return 0;
}
 8006fae:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8006fb0:	03000002 	.word	0x03000002
 8006fb4:	40023c10 	.word	0x40023c10
 8006fb8:	40023c0c 	.word	0x40023c0c

08006fbc <stm32f4_probe>:
	sf->base_sector = base_sector;
	target_add_flash(t, f);
}

bool stm32f4_probe(target *t)
{
 8006fbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	bool f2 = false;
	uint32_t idcode;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
 8006fbe:	4999      	ldr	r1, [pc, #612]	; (8007224 <stm32f4_probe+0x268>)
	sf->base_sector = base_sector;
	target_add_flash(t, f);
}

bool stm32f4_probe(target *t)
{
 8006fc0:	1c04      	adds	r4, r0, #0
	bool f2 = false;
	uint32_t idcode;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
 8006fc2:	f001 fab3 	bl	800852c <target_mem_read32>
	idcode &= 0xFFF;

	if (idcode == 0x411)
 8006fc6:	4b98      	ldr	r3, [pc, #608]	; (8007228 <stm32f4_probe+0x26c>)
{
	bool f2 = false;
	uint32_t idcode;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
	idcode &= 0xFFF;
 8006fc8:	0505      	lsls	r5, r0, #20
 8006fca:	0d2d      	lsrs	r5, r5, #20

	if (idcode == 0x411)
 8006fcc:	429d      	cmp	r5, r3
 8006fce:	d10d      	bne.n	8006fec <stm32f4_probe+0x30>
	{
		/* F405 revision A have a wrong IDCODE, use ARM_CPUID to make the
		 * distinction with F205. Revision is also wrong (0x2000 instead
		 * of 0x1000). See F40x/F41x errata. */
		uint32_t cpuid = target_mem_read32(t, ARM_CPUID);
 8006fd0:	1c20      	adds	r0, r4, #0
 8006fd2:	4996      	ldr	r1, [pc, #600]	; (800722c <stm32f4_probe+0x270>)
 8006fd4:	f001 faaa 	bl	800852c <target_mem_read32>
		if ((cpuid & 0xFFF0) == 0xC240)
 8006fd8:	4b95      	ldr	r3, [pc, #596]	; (8007230 <stm32f4_probe+0x274>)
 8006fda:	4a96      	ldr	r2, [pc, #600]	; (8007234 <stm32f4_probe+0x278>)
 8006fdc:	4018      	ands	r0, r3
 8006fde:	4b96      	ldr	r3, [pc, #600]	; (8007238 <stm32f4_probe+0x27c>)
 8006fe0:	4290      	cmp	r0, r2
 8006fe2:	d100      	bne.n	8006fe6 <stm32f4_probe+0x2a>
 8006fe4:	e119      	b.n	800721a <stm32f4_probe+0x25e>
			idcode = 0x413;
		else
			f2 = true;
 8006fe6:	2601      	movs	r6, #1
	case 0x413: /* F405 */
	case 0x421: /* F446 */
	case 0x423: /* F401 B/C RM0368 Rev.3 */
	case 0x431: /* F411     RM0383 Rev.4 */
	case 0x433: /* F401 D/E RM0368 Rev.3 */
		t->driver = f2 ? stm32f2_driver_str : stm32f4_driver_str;
 8006fe8:	3338      	adds	r3, #56	; 0x38
 8006fea:	e088      	b.n	80070fe <stm32f4_probe+0x142>
			idcode = 0x413;
		else
			f2 = true;
	}

	switch(idcode) {
 8006fec:	4a93      	ldr	r2, [pc, #588]	; (800723c <stm32f4_probe+0x280>)
 8006fee:	4295      	cmp	r5, r2
 8006ff0:	d100      	bne.n	8006ff4 <stm32f4_probe+0x38>
 8006ff2:	e081      	b.n	80070f8 <stm32f4_probe+0x13c>
 8006ff4:	d808      	bhi.n	8007008 <stm32f4_probe+0x4c>
 8006ff6:	4a92      	ldr	r2, [pc, #584]	; (8007240 <stm32f4_probe+0x284>)
 8006ff8:	4295      	cmp	r5, r2
 8006ffa:	d07d      	beq.n	80070f8 <stm32f4_probe+0x13c>
 8006ffc:	d909      	bls.n	8007012 <stm32f4_probe+0x56>
 8006ffe:	4b91      	ldr	r3, [pc, #580]	; (8007244 <stm32f4_probe+0x288>)
 8007000:	429d      	cmp	r5, r3
 8007002:	d05b      	beq.n	80070bc <stm32f4_probe+0x100>
 8007004:	4b90      	ldr	r3, [pc, #576]	; (8007248 <stm32f4_probe+0x28c>)
 8007006:	e004      	b.n	8007012 <stm32f4_probe+0x56>
 8007008:	4b90      	ldr	r3, [pc, #576]	; (800724c <stm32f4_probe+0x290>)
 800700a:	429d      	cmp	r5, r3
 800700c:	d074      	beq.n	80070f8 <stm32f4_probe+0x13c>
 800700e:	d804      	bhi.n	800701a <stm32f4_probe+0x5e>
 8007010:	4b8f      	ldr	r3, [pc, #572]	; (8007250 <stm32f4_probe+0x294>)
 8007012:	429d      	cmp	r5, r3
 8007014:	d000      	beq.n	8007018 <stm32f4_probe+0x5c>
 8007016:	e0fe      	b.n	8007216 <stm32f4_probe+0x25a>
 8007018:	e06e      	b.n	80070f8 <stm32f4_probe+0x13c>
 800701a:	4b8e      	ldr	r3, [pc, #568]	; (8007254 <stm32f4_probe+0x298>)
 800701c:	429d      	cmp	r5, r3
 800701e:	d100      	bne.n	8007022 <stm32f4_probe+0x66>
 8007020:	e0a4      	b.n	800716c <stm32f4_probe+0x1b0>
 8007022:	4b8d      	ldr	r3, [pc, #564]	; (8007258 <stm32f4_probe+0x29c>)
 8007024:	429d      	cmp	r5, r3
 8007026:	d000      	beq.n	800702a <stm32f4_probe+0x6e>
 8007028:	e0f5      	b.n	8007216 <stm32f4_probe+0x25a>
		stm32f4_add_flash(t, 0x0240000, 0xC0000, 0x40000, 5);
		target_add_commands(t, stm32f4_cmd_list, "STM32F7");
		break;
	case 0x451: /* F76x F77x RM0410 */
		t->driver = stm32f7_driver_str;
		target_add_ram(t, 0x00000000, 0x4000);
 800702a:	2280      	movs	r2, #128	; 0x80
		stm32f4_add_flash(t, 0x0220000, 0x20000, 0x20000, 4);
		stm32f4_add_flash(t, 0x0240000, 0xC0000, 0x40000, 5);
		target_add_commands(t, stm32f4_cmd_list, "STM32F7");
		break;
	case 0x451: /* F76x F77x RM0410 */
		t->driver = stm32f7_driver_str;
 800702c:	4b82      	ldr	r3, [pc, #520]	; (8007238 <stm32f4_probe+0x27c>)
		target_add_ram(t, 0x00000000, 0x4000);
 800702e:	1c20      	adds	r0, r4, #0
		stm32f4_add_flash(t, 0x0220000, 0x20000, 0x20000, 4);
		stm32f4_add_flash(t, 0x0240000, 0xC0000, 0x40000, 5);
		target_add_commands(t, stm32f4_cmd_list, "STM32F7");
		break;
	case 0x451: /* F76x F77x RM0410 */
		t->driver = stm32f7_driver_str;
 8007030:	3370      	adds	r3, #112	; 0x70
 8007032:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x00000000, 0x4000);
 8007034:	2100      	movs	r1, #0
 8007036:	01d2      	lsls	r2, r2, #7
 8007038:	f001 f87c 	bl	8008134 <target_add_ram>
		target_add_ram(t, 0x20000000, 0x80000);
 800703c:	2180      	movs	r1, #128	; 0x80
 800703e:	2280      	movs	r2, #128	; 0x80
 8007040:	1c20      	adds	r0, r4, #0
 8007042:	0589      	lsls	r1, r1, #22
 8007044:	0312      	lsls	r2, r2, #12
 8007046:	f001 f875 	bl	8008134 <target_add_ram>
		/* DTCM */
		stm32f4_add_flash(t, 0x8000000, 0x020000, 0x8000, 0);
 800704a:	2700      	movs	r7, #0
 800704c:	2180      	movs	r1, #128	; 0x80
 800704e:	2280      	movs	r2, #128	; 0x80
 8007050:	2380      	movs	r3, #128	; 0x80
 8007052:	1c20      	adds	r0, r4, #0
 8007054:	0509      	lsls	r1, r1, #20
 8007056:	0292      	lsls	r2, r2, #10
 8007058:	021b      	lsls	r3, r3, #8
 800705a:	9700      	str	r7, [sp, #0]
 800705c:	f7ff feb0 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8020000, 0x020000, 0x20000, 4);
 8007060:	2280      	movs	r2, #128	; 0x80
 8007062:	2604      	movs	r6, #4
 8007064:	0292      	lsls	r2, r2, #10
 8007066:	1c13      	adds	r3, r2, #0
 8007068:	1c20      	adds	r0, r4, #0
 800706a:	497c      	ldr	r1, [pc, #496]	; (800725c <stm32f4_probe+0x2a0>)
 800706c:	9600      	str	r6, [sp, #0]
 800706e:	f7ff fea7 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8040000, 0x1C0000, 0x40000, 5);
 8007072:	2305      	movs	r3, #5
 8007074:	22e0      	movs	r2, #224	; 0xe0
 8007076:	9300      	str	r3, [sp, #0]
 8007078:	2380      	movs	r3, #128	; 0x80
 800707a:	1c20      	adds	r0, r4, #0
 800707c:	4978      	ldr	r1, [pc, #480]	; (8007260 <stm32f4_probe+0x2a4>)
 800707e:	0352      	lsls	r2, r2, #13
 8007080:	02db      	lsls	r3, r3, #11
 8007082:	f7ff fe9d 	bl	8006dc0 <stm32f4_add_flash>
		/* ITCM */
		stm32f4_add_flash(t, 0x200000, 0x020000, 0x8000, 0);
 8007086:	2180      	movs	r1, #128	; 0x80
 8007088:	2280      	movs	r2, #128	; 0x80
 800708a:	2380      	movs	r3, #128	; 0x80
 800708c:	1c20      	adds	r0, r4, #0
 800708e:	0389      	lsls	r1, r1, #14
 8007090:	0292      	lsls	r2, r2, #10
 8007092:	021b      	lsls	r3, r3, #8
 8007094:	9700      	str	r7, [sp, #0]
 8007096:	f7ff fe93 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x220000, 0x020000, 0x20000, 4);
 800709a:	2280      	movs	r2, #128	; 0x80
 800709c:	2188      	movs	r1, #136	; 0x88
 800709e:	0292      	lsls	r2, r2, #10
 80070a0:	1c13      	adds	r3, r2, #0
 80070a2:	1c20      	adds	r0, r4, #0
 80070a4:	0389      	lsls	r1, r1, #14
 80070a6:	9600      	str	r6, [sp, #0]
 80070a8:	f7ff fe8a 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x240000, 0x1C0000, 0x40000, 5);
 80070ac:	2305      	movs	r3, #5
 80070ae:	2190      	movs	r1, #144	; 0x90
 80070b0:	22e0      	movs	r2, #224	; 0xe0
 80070b2:	9300      	str	r3, [sp, #0]
 80070b4:	1c20      	adds	r0, r4, #0
 80070b6:	0389      	lsls	r1, r1, #14
 80070b8:	0352      	lsls	r2, r2, #13
 80070ba:	e09f      	b.n	80071fc <stm32f4_probe+0x240>
	}

	switch(idcode) {
	case 0x419: /* 427/437 */
		/* Second bank for 2M parts. */
		stm32f4_add_flash(t, 0x8100000, 0x10000, 0x4000, 12);
 80070bc:	230c      	movs	r3, #12
 80070be:	2181      	movs	r1, #129	; 0x81
 80070c0:	9300      	str	r3, [sp, #0]
 80070c2:	2280      	movs	r2, #128	; 0x80
 80070c4:	2380      	movs	r3, #128	; 0x80
 80070c6:	1c20      	adds	r0, r4, #0
 80070c8:	0509      	lsls	r1, r1, #20
 80070ca:	0252      	lsls	r2, r2, #9
 80070cc:	01db      	lsls	r3, r3, #7
 80070ce:	f7ff fe77 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8110000, 0x10000, 0x10000, 16);
 80070d2:	2280      	movs	r2, #128	; 0x80
 80070d4:	2310      	movs	r3, #16
 80070d6:	0252      	lsls	r2, r2, #9
 80070d8:	9300      	str	r3, [sp, #0]
 80070da:	1c20      	adds	r0, r4, #0
 80070dc:	1c13      	adds	r3, r2, #0
 80070de:	4961      	ldr	r1, [pc, #388]	; (8007264 <stm32f4_probe+0x2a8>)
 80070e0:	f7ff fe6e 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8120000, 0xE0000, 0x20000, 17);
 80070e4:	2311      	movs	r3, #17
 80070e6:	22e0      	movs	r2, #224	; 0xe0
 80070e8:	9300      	str	r3, [sp, #0]
 80070ea:	2380      	movs	r3, #128	; 0x80
 80070ec:	1c20      	adds	r0, r4, #0
 80070ee:	495e      	ldr	r1, [pc, #376]	; (8007268 <stm32f4_probe+0x2ac>)
 80070f0:	0312      	lsls	r2, r2, #12
 80070f2:	029b      	lsls	r3, r3, #10
 80070f4:	f7ff fe64 	bl	8006dc0 <stm32f4_add_flash>
	target_add_flash(t, f);
}

bool stm32f4_probe(target *t)
{
	bool f2 = false;
 80070f8:	2600      	movs	r6, #0
	case 0x413: /* F405 */
	case 0x421: /* F446 */
	case 0x423: /* F401 B/C RM0368 Rev.3 */
	case 0x431: /* F411     RM0383 Rev.4 */
	case 0x433: /* F401 D/E RM0368 Rev.3 */
		t->driver = f2 ? stm32f2_driver_str : stm32f4_driver_str;
 80070fa:	4b4f      	ldr	r3, [pc, #316]	; (8007238 <stm32f4_probe+0x27c>)
 80070fc:	3342      	adds	r3, #66	; 0x42
 80070fe:	6623      	str	r3, [r4, #96]	; 0x60
		if (!f2)
 8007100:	2e00      	cmp	r6, #0
 8007102:	d106      	bne.n	8007112 <stm32f4_probe+0x156>
			target_add_ram(t, 0x10000000, 0x10000);
 8007104:	2180      	movs	r1, #128	; 0x80
 8007106:	2280      	movs	r2, #128	; 0x80
 8007108:	1c20      	adds	r0, r4, #0
 800710a:	0549      	lsls	r1, r1, #21
 800710c:	0252      	lsls	r2, r2, #9
 800710e:	f001 f811 	bl	8008134 <target_add_ram>
		target_add_ram(t, 0x20000000, 0x30000);
 8007112:	2180      	movs	r1, #128	; 0x80
 8007114:	22c0      	movs	r2, #192	; 0xc0
 8007116:	1c20      	adds	r0, r4, #0
 8007118:	0589      	lsls	r1, r1, #22
 800711a:	0292      	lsls	r2, r2, #10
 800711c:	f001 f80a 	bl	8008134 <target_add_ram>
		stm32f4_add_flash(t, 0x8000000, 0x10000, 0x4000, 0);
 8007120:	2300      	movs	r3, #0
 8007122:	2180      	movs	r1, #128	; 0x80
 8007124:	9300      	str	r3, [sp, #0]
 8007126:	2280      	movs	r2, #128	; 0x80
 8007128:	2380      	movs	r3, #128	; 0x80
 800712a:	1c20      	adds	r0, r4, #0
 800712c:	0509      	lsls	r1, r1, #20
 800712e:	0252      	lsls	r2, r2, #9
 8007130:	01db      	lsls	r3, r3, #7
 8007132:	f7ff fe45 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8010000, 0x10000, 0x10000, 4);
 8007136:	2280      	movs	r2, #128	; 0x80
 8007138:	2304      	movs	r3, #4
 800713a:	0252      	lsls	r2, r2, #9
 800713c:	9300      	str	r3, [sp, #0]
 800713e:	1c20      	adds	r0, r4, #0
 8007140:	1c13      	adds	r3, r2, #0
 8007142:	494a      	ldr	r1, [pc, #296]	; (800726c <stm32f4_probe+0x2b0>)
 8007144:	f7ff fe3c 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8020000, 0xE0000, 0x20000, 5);
 8007148:	2305      	movs	r3, #5
 800714a:	22e0      	movs	r2, #224	; 0xe0
 800714c:	9300      	str	r3, [sp, #0]
 800714e:	2380      	movs	r3, #128	; 0x80
 8007150:	0312      	lsls	r2, r2, #12
 8007152:	1c20      	adds	r0, r4, #0
 8007154:	4941      	ldr	r1, [pc, #260]	; (800725c <stm32f4_probe+0x2a0>)
 8007156:	029b      	lsls	r3, r3, #10
 8007158:	f7ff fe32 	bl	8006dc0 <stm32f4_add_flash>
		target_add_commands(t, stm32f4_cmd_list, f2 ? "STM32F2" :
 800715c:	4a44      	ldr	r2, [pc, #272]	; (8007270 <stm32f4_probe+0x2b4>)
 800715e:	2e00      	cmp	r6, #0
 8007160:	d100      	bne.n	8007164 <stm32f4_probe+0x1a8>
 8007162:	4a44      	ldr	r2, [pc, #272]	; (8007274 <stm32f4_probe+0x2b8>)
 8007164:	4934      	ldr	r1, [pc, #208]	; (8007238 <stm32f4_probe+0x27c>)
 8007166:	1c20      	adds	r0, r4, #0
 8007168:	314c      	adds	r1, #76	; 0x4c
 800716a:	e04f      	b.n	800720c <stm32f4_probe+0x250>
		                    "STM32F4");
		break;
	case 0x449: /* F7x6 RM0385 Rev.2 */
		t->driver = stm32f7_driver_str;
		target_add_ram(t, 0x00000000, 0x4000);
 800716c:	2280      	movs	r2, #128	; 0x80
		stm32f4_add_flash(t, 0x8020000, 0xE0000, 0x20000, 5);
		target_add_commands(t, stm32f4_cmd_list, f2 ? "STM32F2" :
		                    "STM32F4");
		break;
	case 0x449: /* F7x6 RM0385 Rev.2 */
		t->driver = stm32f7_driver_str;
 800716e:	4b32      	ldr	r3, [pc, #200]	; (8007238 <stm32f4_probe+0x27c>)
		target_add_ram(t, 0x00000000, 0x4000);
 8007170:	1c20      	adds	r0, r4, #0
		stm32f4_add_flash(t, 0x8020000, 0xE0000, 0x20000, 5);
		target_add_commands(t, stm32f4_cmd_list, f2 ? "STM32F2" :
		                    "STM32F4");
		break;
	case 0x449: /* F7x6 RM0385 Rev.2 */
		t->driver = stm32f7_driver_str;
 8007172:	3370      	adds	r3, #112	; 0x70
 8007174:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x00000000, 0x4000);
 8007176:	2100      	movs	r1, #0
 8007178:	01d2      	lsls	r2, r2, #7
 800717a:	f000 ffdb 	bl	8008134 <target_add_ram>
		target_add_ram(t, 0x20000000, 0x50000);
 800717e:	2180      	movs	r1, #128	; 0x80
 8007180:	22a0      	movs	r2, #160	; 0xa0
 8007182:	1c20      	adds	r0, r4, #0
 8007184:	0589      	lsls	r1, r1, #22
 8007186:	02d2      	lsls	r2, r2, #11
 8007188:	f000 ffd4 	bl	8008134 <target_add_ram>
		/* DTCM */
		stm32f4_add_flash(t, 0x8000000, 0x20000, 0x8000, 0);
 800718c:	2700      	movs	r7, #0
 800718e:	2180      	movs	r1, #128	; 0x80
 8007190:	2280      	movs	r2, #128	; 0x80
 8007192:	2380      	movs	r3, #128	; 0x80
 8007194:	1c20      	adds	r0, r4, #0
 8007196:	0509      	lsls	r1, r1, #20
 8007198:	0292      	lsls	r2, r2, #10
 800719a:	021b      	lsls	r3, r3, #8
 800719c:	9700      	str	r7, [sp, #0]
 800719e:	f7ff fe0f 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8020000, 0x20000, 0x20000, 4);
 80071a2:	2280      	movs	r2, #128	; 0x80
 80071a4:	2604      	movs	r6, #4
 80071a6:	0292      	lsls	r2, r2, #10
 80071a8:	1c13      	adds	r3, r2, #0
 80071aa:	1c20      	adds	r0, r4, #0
 80071ac:	492b      	ldr	r1, [pc, #172]	; (800725c <stm32f4_probe+0x2a0>)
 80071ae:	9600      	str	r6, [sp, #0]
 80071b0:	f7ff fe06 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x8040000, 0xC0000, 0x40000, 5);
 80071b4:	2305      	movs	r3, #5
 80071b6:	22c0      	movs	r2, #192	; 0xc0
 80071b8:	9300      	str	r3, [sp, #0]
 80071ba:	2380      	movs	r3, #128	; 0x80
 80071bc:	1c20      	adds	r0, r4, #0
 80071be:	4928      	ldr	r1, [pc, #160]	; (8007260 <stm32f4_probe+0x2a4>)
 80071c0:	0312      	lsls	r2, r2, #12
 80071c2:	02db      	lsls	r3, r3, #11
 80071c4:	f7ff fdfc 	bl	8006dc0 <stm32f4_add_flash>
		/* ITCM */
		stm32f4_add_flash(t, 0x0200000, 0x20000, 0x8000, 0);
 80071c8:	2180      	movs	r1, #128	; 0x80
 80071ca:	2280      	movs	r2, #128	; 0x80
 80071cc:	2380      	movs	r3, #128	; 0x80
 80071ce:	1c20      	adds	r0, r4, #0
 80071d0:	0389      	lsls	r1, r1, #14
 80071d2:	0292      	lsls	r2, r2, #10
 80071d4:	021b      	lsls	r3, r3, #8
 80071d6:	9700      	str	r7, [sp, #0]
 80071d8:	f7ff fdf2 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x0220000, 0x20000, 0x20000, 4);
 80071dc:	2280      	movs	r2, #128	; 0x80
 80071de:	2188      	movs	r1, #136	; 0x88
 80071e0:	0292      	lsls	r2, r2, #10
 80071e2:	1c13      	adds	r3, r2, #0
 80071e4:	1c20      	adds	r0, r4, #0
 80071e6:	0389      	lsls	r1, r1, #14
 80071e8:	9600      	str	r6, [sp, #0]
 80071ea:	f7ff fde9 	bl	8006dc0 <stm32f4_add_flash>
		stm32f4_add_flash(t, 0x0240000, 0xC0000, 0x40000, 5);
 80071ee:	2305      	movs	r3, #5
 80071f0:	2190      	movs	r1, #144	; 0x90
 80071f2:	22c0      	movs	r2, #192	; 0xc0
 80071f4:	1c20      	adds	r0, r4, #0
 80071f6:	9300      	str	r3, [sp, #0]
 80071f8:	0389      	lsls	r1, r1, #14
 80071fa:	0312      	lsls	r2, r2, #12
		stm32f4_add_flash(t, 0x8020000, 0x020000, 0x20000, 4);
		stm32f4_add_flash(t, 0x8040000, 0x1C0000, 0x40000, 5);
		/* ITCM */
		stm32f4_add_flash(t, 0x200000, 0x020000, 0x8000, 0);
		stm32f4_add_flash(t, 0x220000, 0x020000, 0x20000, 4);
		stm32f4_add_flash(t, 0x240000, 0x1C0000, 0x40000, 5);
 80071fc:	2380      	movs	r3, #128	; 0x80
 80071fe:	02db      	lsls	r3, r3, #11
 8007200:	f7ff fdde 	bl	8006dc0 <stm32f4_add_flash>
		target_add_commands(t, stm32f4_cmd_list, "STM32F7");
 8007204:	1c20      	adds	r0, r4, #0
 8007206:	490c      	ldr	r1, [pc, #48]	; (8007238 <stm32f4_probe+0x27c>)
 8007208:	4a1b      	ldr	r2, [pc, #108]	; (8007278 <stm32f4_probe+0x2bc>)
 800720a:	314c      	adds	r1, #76	; 0x4c
 800720c:	f000 ff52 	bl	80080b4 <target_add_commands>
		break;
	default:
		return false;
	}
	t->idcode = idcode;
 8007210:	6525      	str	r5, [r4, #80]	; 0x50
	return true;
 8007212:	2001      	movs	r0, #1
 8007214:	e004      	b.n	8007220 <stm32f4_probe+0x264>
		stm32f4_add_flash(t, 0x220000, 0x020000, 0x20000, 4);
		stm32f4_add_flash(t, 0x240000, 0x1C0000, 0x40000, 5);
		target_add_commands(t, stm32f4_cmd_list, "STM32F7");
		break;
	default:
		return false;
 8007216:	2000      	movs	r0, #0
 8007218:	e002      	b.n	8007220 <stm32f4_probe+0x264>
		/* F405 revision A have a wrong IDCODE, use ARM_CPUID to make the
		 * distinction with F205. Revision is also wrong (0x2000 instead
		 * of 0x1000). See F40x/F41x errata. */
		uint32_t cpuid = target_mem_read32(t, ARM_CPUID);
		if ((cpuid & 0xFFF0) == 0xC240)
			idcode = 0x413;
 800721a:	4d09      	ldr	r5, [pc, #36]	; (8007240 <stm32f4_probe+0x284>)
	target_add_flash(t, f);
}

bool stm32f4_probe(target *t)
{
	bool f2 = false;
 800721c:	2600      	movs	r6, #0
 800721e:	e76d      	b.n	80070fc <stm32f4_probe+0x140>
	default:
		return false;
	}
	t->idcode = idcode;
	return true;
}
 8007220:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007222:	46c0      	nop			; (mov r8, r8)
 8007224:	e0042000 	.word	0xe0042000
 8007228:	00000411 	.word	0x00000411
 800722c:	e000ed00 	.word	0xe000ed00
 8007230:	0000fff0 	.word	0x0000fff0
 8007234:	0000c240 	.word	0x0000c240
 8007238:	08013000 	.word	0x08013000
 800723c:	00000423 	.word	0x00000423
 8007240:	00000413 	.word	0x00000413
 8007244:	00000419 	.word	0x00000419
 8007248:	00000421 	.word	0x00000421
 800724c:	00000433 	.word	0x00000433
 8007250:	00000431 	.word	0x00000431
 8007254:	00000449 	.word	0x00000449
 8007258:	00000451 	.word	0x00000451
 800725c:	08020000 	.word	0x08020000
 8007260:	08040000 	.word	0x08040000
 8007264:	08110000 	.word	0x08110000
 8007268:	08120000 	.word	0x08120000
 800726c:	08010000 	.word	0x08010000
 8007270:	080130e0 	.word	0x080130e0
 8007274:	080130e8 	.word	0x080130e8
 8007278:	080130f0 	.word	0x080130f0

0800727c <stm32lx_nvm_prog_data_unlock>:


/** Unlock the NVM control registers for modifying program or
    data flash.  Returns true if the unlock succeeds. */
static bool stm32lx_nvm_prog_data_unlock(target* t, uint32_t nvm)
{
 800727c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800727e:	1c0d      	adds	r5, r1, #0
        /* Always lock first because that's the only way to know that the
           unlock can succeed on the STM32L0's. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
 8007280:	1c2f      	adds	r7, r5, #0


/** Unlock the NVM control registers for modifying program or
    data flash.  Returns true if the unlock succeeds. */
static bool stm32lx_nvm_prog_data_unlock(target* t, uint32_t nvm)
{
 8007282:	1c04      	adds	r4, r0, #0
        /* Always lock first because that's the only way to know that the
           unlock can succeed on the STM32L0's. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
 8007284:	1d0e      	adds	r6, r1, #4
 8007286:	1c31      	adds	r1, r6, #0
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
 8007288:	370c      	adds	r7, #12
    data flash.  Returns true if the unlock succeeds. */
static bool stm32lx_nvm_prog_data_unlock(target* t, uint32_t nvm)
{
        /* Always lock first because that's the only way to know that the
           unlock can succeed on the STM32L0's. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
 800728a:	2201      	movs	r2, #1
 800728c:	f001 f956 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
 8007290:	1c39      	adds	r1, r7, #0
 8007292:	1c20      	adds	r0, r4, #0
 8007294:	4a0d      	ldr	r2, [pc, #52]	; (80072cc <stm32lx_nvm_prog_data_unlock+0x50>)
 8007296:	f001 f951 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY2);
        target_mem_write32(t, STM32Lx_NVM_PRGKEYR(nvm), STM32Lx_NVM_PRGKEY1);
 800729a:	3510      	adds	r5, #16
{
        /* Always lock first because that's the only way to know that the
           unlock can succeed on the STM32L0's. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY2);
 800729c:	1c39      	adds	r1, r7, #0
 800729e:	1c20      	adds	r0, r4, #0
 80072a0:	4a0b      	ldr	r2, [pc, #44]	; (80072d0 <stm32lx_nvm_prog_data_unlock+0x54>)
 80072a2:	f001 f94b 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_PRGKEYR(nvm), STM32Lx_NVM_PRGKEY1);
 80072a6:	1c29      	adds	r1, r5, #0
 80072a8:	1c20      	adds	r0, r4, #0
 80072aa:	4a0a      	ldr	r2, [pc, #40]	; (80072d4 <stm32lx_nvm_prog_data_unlock+0x58>)
 80072ac:	f001 f946 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_PRGKEYR(nvm), STM32Lx_NVM_PRGKEY2);
 80072b0:	1c29      	adds	r1, r5, #0
 80072b2:	1c20      	adds	r0, r4, #0
 80072b4:	4a08      	ldr	r2, [pc, #32]	; (80072d8 <stm32lx_nvm_prog_data_unlock+0x5c>)
 80072b6:	f001 f941 	bl	800853c <target_mem_write32>

        return !(target_mem_read32(t, STM32Lx_NVM_PECR(nvm))
 80072ba:	1c31      	adds	r1, r6, #0
 80072bc:	1c20      	adds	r0, r4, #0
 80072be:	f001 f935 	bl	800852c <target_mem_read32>
 80072c2:	0843      	lsrs	r3, r0, #1
 80072c4:	2001      	movs	r0, #1
 80072c6:	4398      	bics	r0, r3
                 & STM32Lx_NVM_PECR_PRGLOCK);
}
 80072c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80072ca:	46c0      	nop			; (mov r8, r8)
 80072cc:	89abcdef 	.word	0x89abcdef
 80072d0:	02030405 	.word	0x02030405
 80072d4:	8c9daebf 	.word	0x8c9daebf
 80072d8:	13141516 	.word	0x13141516

080072dc <stm32lx_nvm_lock>:
}


/** Lock the NVM control registers preventing writes or erases. */
static void stm32lx_nvm_lock(target *t, uint32_t nvm)
{
 80072dc:	b508      	push	{r3, lr}
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm), STM32Lx_NVM_PECR_PELOCK);
 80072de:	3104      	adds	r1, #4
 80072e0:	2201      	movs	r2, #1
 80072e2:	f001 f92b 	bl	800853c <target_mem_write32>
}
 80072e6:	bd08      	pop	{r3, pc}

080072e8 <stm32lx_nvm_phys.isra.2>:
        }
}

static uint32_t stm32lx_nvm_phys(target *t)
{
        switch (t->idcode) {
 80072e8:	4b03      	ldr	r3, [pc, #12]	; (80072f8 <stm32lx_nvm_phys.isra.2+0x10>)
 80072ea:	4298      	cmp	r0, r3
 80072ec:	d001      	beq.n	80072f2 <stm32lx_nvm_phys.isra.2+0xa>
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_PHYS;
        default:                      /* STM32L1xx */
                return STM32L1_NVM_PHYS;
 80072ee:	4803      	ldr	r0, [pc, #12]	; (80072fc <stm32lx_nvm_phys.isra.2+0x14>)
 80072f0:	e000      	b.n	80072f4 <stm32lx_nvm_phys.isra.2+0xc>

static uint32_t stm32lx_nvm_phys(target *t)
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_PHYS;
 80072f2:	4803      	ldr	r0, [pc, #12]	; (8007300 <stm32lx_nvm_phys.isra.2+0x18>)
        default:                      /* STM32L1xx */
                return STM32L1_NVM_PHYS;
        }
}
 80072f4:	4770      	bx	lr
 80072f6:	46c0      	nop			; (mov r8, r8)
 80072f8:	00000417 	.word	0x00000417
 80072fc:	40023c00 	.word	0x40023c00
 8007300:	40022000 	.word	0x40022000

08007304 <stm32lx_option_write>:
    responsible for making sure that the value satisfies the proper
    format where the upper 16 bits are the 1s complement of the lower
    16 bits.  The funtion returns when the operation is complete.
    The return value is true if the write succeeded. */
static bool stm32lx_option_write(target *t, uint32_t address, uint32_t value)
{
 8007304:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007306:	1c04      	adds	r4, r0, #0
        const uint32_t nvm = stm32lx_nvm_phys(t);
 8007308:	6d00      	ldr	r0, [r0, #80]	; 0x50
    responsible for making sure that the value satisfies the proper
    format where the upper 16 bits are the 1s complement of the lower
    16 bits.  The funtion returns when the operation is complete.
    The return value is true if the write succeeded. */
static bool stm32lx_option_write(target *t, uint32_t address, uint32_t value)
{
 800730a:	1c0f      	adds	r7, r1, #0
 800730c:	1c16      	adds	r6, r2, #0
        const uint32_t nvm = stm32lx_nvm_phys(t);
 800730e:	f7ff ffeb 	bl	80072e8 <stm32lx_nvm_phys.isra.2>

        /* Erase and program option in one go. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm), STM32Lx_NVM_PECR_FIX);
 8007312:	2280      	movs	r2, #128	; 0x80
 8007314:	1d01      	adds	r1, r0, #4
 8007316:	0052      	lsls	r2, r2, #1
    format where the upper 16 bits are the 1s complement of the lower
    16 bits.  The funtion returns when the operation is complete.
    The return value is true if the write succeeded. */
static bool stm32lx_option_write(target *t, uint32_t address, uint32_t value)
{
        const uint32_t nvm = stm32lx_nvm_phys(t);
 8007318:	1c05      	adds	r5, r0, #0

        /* Erase and program option in one go. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm), STM32Lx_NVM_PECR_FIX);
 800731a:	1c20      	adds	r0, r4, #0
 800731c:	f001 f90e 	bl	800853c <target_mem_write32>
        target_mem_write32(t, address, value);
 8007320:	1c20      	adds	r0, r4, #0
 8007322:	1c39      	adds	r1, r7, #0
 8007324:	1c32      	adds	r2, r6, #0
 8007326:	f001 f909 	bl	800853c <target_mem_write32>

        uint32_t sr;
        do {
                sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
 800732a:	1c29      	adds	r1, r5, #0
 800732c:	1c20      	adds	r0, r4, #0
 800732e:	3118      	adds	r1, #24
 8007330:	f001 f8fc 	bl	800852c <target_mem_read32>
        } while (sr & STM32Lx_NVM_SR_BSY);
 8007334:	07c3      	lsls	r3, r0, #31
 8007336:	d4f8      	bmi.n	800732a <stm32lx_option_write+0x26>

        return !(sr & STM32Lx_NVM_SR_ERR_M);
 8007338:	4b02      	ldr	r3, [pc, #8]	; (8007344 <stm32lx_option_write+0x40>)
 800733a:	4018      	ands	r0, r3
 800733c:	4243      	negs	r3, r0
 800733e:	4158      	adcs	r0, r3
 8007340:	b2c0      	uxtb	r0, r0
}
 8007342:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007344:	00010700 	.word	0x00010700

08007348 <stm32lx_nvm_prog_erase>:
    interface.  This is slower than stubbed versions(see NOTES).  The
    flash array is erased for all pages from addr to addr+len
    inclusive.  NVM register file address chosen from target. */
static int stm32lx_nvm_prog_erase(struct target_flash* f,
                                  target_addr addr, size_t len)
{
 8007348:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	target *t = f->t;
 800734a:	6984      	ldr	r4, [r0, #24]
	const size_t page_size = f->blocksize;
 800734c:	6883      	ldr	r3, [r0, #8]
	const uint32_t nvm = stm32lx_nvm_phys(t);
 800734e:	6d20      	ldr	r0, [r4, #80]	; 0x50
    interface.  This is slower than stubbed versions(see NOTES).  The
    flash array is erased for all pages from addr to addr+len
    inclusive.  NVM register file address chosen from target. */
static int stm32lx_nvm_prog_erase(struct target_flash* f,
                                  target_addr addr, size_t len)
{
 8007350:	1c0e      	adds	r6, r1, #0
 8007352:	9200      	str	r2, [sp, #0]
	target *t = f->t;
	const size_t page_size = f->blocksize;
 8007354:	9301      	str	r3, [sp, #4]
	const uint32_t nvm = stm32lx_nvm_phys(t);
 8007356:	f7ff ffc7 	bl	80072e8 <stm32lx_nvm_phys.isra.2>
 800735a:	1c05      	adds	r5, r0, #0

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 800735c:	1c20      	adds	r0, r4, #0
 800735e:	1c29      	adds	r1, r5, #0
 8007360:	f7ff ff8c 	bl	800727c <stm32lx_nvm_prog_data_unlock>
 8007364:	2800      	cmp	r0, #0
 8007366:	d101      	bne.n	800736c <stm32lx_nvm_prog_erase+0x24>
	        return -1;
 8007368:	2001      	movs	r0, #1
 800736a:	e033      	b.n	80073d4 <stm32lx_nvm_prog_erase+0x8c>

	/* Flash page erase instruction */
	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
 800736c:	2282      	movs	r2, #130	; 0x82
 800736e:	1d2f      	adds	r7, r5, #4
 8007370:	1c20      	adds	r0, r4, #0
 8007372:	1c39      	adds	r1, r7, #0
 8007374:	0092      	lsls	r2, r2, #2
 8007376:	f001 f8e1 	bl	800853c <target_mem_write32>
	                   STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_PROG);

	uint32_t pecr = target_mem_read32(t, STM32Lx_NVM_PECR(nvm));
 800737a:	1c20      	adds	r0, r4, #0
 800737c:	1c39      	adds	r1, r7, #0
 800737e:	f001 f8d5 	bl	800852c <target_mem_read32>
	if ((pecr & (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
 8007382:	2382      	movs	r3, #130	; 0x82
 8007384:	009b      	lsls	r3, r3, #2
 8007386:	4018      	ands	r0, r3
 8007388:	4298      	cmp	r0, r3
 800738a:	d1ed      	bne.n	8007368 <stm32lx_nvm_prog_erase+0x20>
	   != (STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_ERASE))
		return -1;

	/* Clear errors.  Note that this only works when we wait for the NVM
	   block to complete the last operation. */
	target_mem_write32(t, STM32Lx_NVM_SR(nvm), STM32Lx_NVM_SR_ERR_M);
 800738c:	3714      	adds	r7, #20
 800738e:	1c20      	adds	r0, r4, #0
 8007390:	1c39      	adds	r1, r7, #0
 8007392:	4a11      	ldr	r2, [pc, #68]	; (80073d8 <stm32lx_nvm_prog_erase+0x90>)
 8007394:	f001 f8d2 	bl	800853c <target_mem_write32>

	while (len > 0) {
 8007398:	9b00      	ldr	r3, [sp, #0]
		/* Write first word of page to 0 */
		target_mem_write32(t, addr, 0);
 800739a:	1c20      	adds	r0, r4, #0

	/* Clear errors.  Note that this only works when we wait for the NVM
	   block to complete the last operation. */
	target_mem_write32(t, STM32Lx_NVM_SR(nvm), STM32Lx_NVM_SR_ERR_M);

	while (len > 0) {
 800739c:	2b00      	cmp	r3, #0
 800739e:	d009      	beq.n	80073b4 <stm32lx_nvm_prog_erase+0x6c>
		/* Write first word of page to 0 */
		target_mem_write32(t, addr, 0);
 80073a0:	1c31      	adds	r1, r6, #0
 80073a2:	2200      	movs	r2, #0
 80073a4:	f001 f8ca 	bl	800853c <target_mem_write32>

		len  -= page_size;
 80073a8:	9b00      	ldr	r3, [sp, #0]
 80073aa:	9a01      	ldr	r2, [sp, #4]
 80073ac:	1a9b      	subs	r3, r3, r2
 80073ae:	9300      	str	r3, [sp, #0]
		addr += page_size;
 80073b0:	18b6      	adds	r6, r6, r2
 80073b2:	e7f1      	b.n	8007398 <stm32lx_nvm_prog_erase+0x50>
	}

	/* Disable further programming by locking PECR */
	stm32lx_nvm_lock(t, nvm);
 80073b4:	1c29      	adds	r1, r5, #0
 80073b6:	f7ff ff91 	bl	80072dc <stm32lx_nvm_lock>

	/* Wait for completion or an error */
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
 80073ba:	1c20      	adds	r0, r4, #0
 80073bc:	1c39      	adds	r1, r7, #0
 80073be:	f001 f8b5 	bl	800852c <target_mem_read32>
	} while (sr & STM32Lx_NVM_SR_BSY);
 80073c2:	07c3      	lsls	r3, r0, #31
 80073c4:	d4f9      	bmi.n	80073ba <stm32lx_nvm_prog_erase+0x72>

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 80073c6:	4b05      	ldr	r3, [pc, #20]	; (80073dc <stm32lx_nvm_prog_erase+0x94>)
 80073c8:	4018      	ands	r0, r3
 80073ca:	2802      	cmp	r0, #2
 80073cc:	d1cc      	bne.n	8007368 <stm32lx_nvm_prog_erase+0x20>
	    target_check_error(t))
 80073ce:	1c20      	adds	r0, r4, #0
 80073d0:	f001 f822 	bl	8008418 <target_check_error>
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
	} while (sr & STM32Lx_NVM_SR_BSY);

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 80073d4:	4240      	negs	r0, r0
	    target_check_error(t))
			return -1;

	return 0;
}
 80073d6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80073d8:	00010700 	.word	0x00010700
 80073dc:	00010702 	.word	0x00010702

080073e0 <stm32lx_nvm_data_erase>:
    interface .  The flash is erased for all pages from addr to
    addr+len, inclusive, on a word boundary.  NVM register file
    address chosen from target. */
static int stm32lx_nvm_data_erase(struct target_flash *f,
                                  target_addr addr, size_t len)
{
 80073e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	target *t = f->t;
 80073e2:	6984      	ldr	r4, [r0, #24]
	const size_t page_size = f->blocksize;
 80073e4:	6883      	ldr	r3, [r0, #8]
    interface .  The flash is erased for all pages from addr to
    addr+len, inclusive, on a word boundary.  NVM register file
    address chosen from target. */
static int stm32lx_nvm_data_erase(struct target_flash *f,
                                  target_addr addr, size_t len)
{
 80073e6:	b085      	sub	sp, #20
 80073e8:	1c0e      	adds	r6, r1, #0
	target *t = f->t;
	const size_t page_size = f->blocksize;
	const uint32_t nvm = stm32lx_nvm_phys(t);
 80073ea:	6d20      	ldr	r0, [r4, #80]	; 0x50
    interface .  The flash is erased for all pages from addr to
    addr+len, inclusive, on a word boundary.  NVM register file
    address chosen from target. */
static int stm32lx_nvm_data_erase(struct target_flash *f,
                                  target_addr addr, size_t len)
{
 80073ec:	1c17      	adds	r7, r2, #0
	target *t = f->t;
	const size_t page_size = f->blocksize;
 80073ee:	9303      	str	r3, [sp, #12]
	const uint32_t nvm = stm32lx_nvm_phys(t);
 80073f0:	f7ff ff7a 	bl	80072e8 <stm32lx_nvm_phys.isra.2>

	/* Word align */
	len += (addr & 3);
 80073f4:	2303      	movs	r3, #3
 80073f6:	1c32      	adds	r2, r6, #0
static int stm32lx_nvm_data_erase(struct target_flash *f,
                                  target_addr addr, size_t len)
{
	target *t = f->t;
	const size_t page_size = f->blocksize;
	const uint32_t nvm = stm32lx_nvm_phys(t);
 80073f8:	1c05      	adds	r5, r0, #0

	/* Word align */
	len += (addr & 3);
 80073fa:	401a      	ands	r2, r3
 80073fc:	19d2      	adds	r2, r2, r7
	addr &= ~3;
 80073fe:	439e      	bics	r6, r3

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 8007400:	1c20      	adds	r0, r4, #0
 8007402:	1c29      	adds	r1, r5, #0
	target *t = f->t;
	const size_t page_size = f->blocksize;
	const uint32_t nvm = stm32lx_nvm_phys(t);

	/* Word align */
	len += (addr & 3);
 8007404:	9202      	str	r2, [sp, #8]
	addr &= ~3;
 8007406:	9601      	str	r6, [sp, #4]

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 8007408:	f7ff ff38 	bl	800727c <stm32lx_nvm_prog_data_unlock>
 800740c:	2800      	cmp	r0, #0
 800740e:	d101      	bne.n	8007414 <stm32lx_nvm_data_erase+0x34>
		return -1;
 8007410:	2001      	movs	r0, #1
 8007412:	e030      	b.n	8007476 <stm32lx_nvm_data_erase+0x96>

	/* Flash data erase instruction */
	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
 8007414:	2784      	movs	r7, #132	; 0x84
 8007416:	1d2e      	adds	r6, r5, #4
 8007418:	00bf      	lsls	r7, r7, #2
 800741a:	1c20      	adds	r0, r4, #0
 800741c:	1c31      	adds	r1, r6, #0
 800741e:	1c3a      	adds	r2, r7, #0
 8007420:	f001 f88c 	bl	800853c <target_mem_write32>
	                   STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA);

	uint32_t pecr = target_mem_read32(t, STM32Lx_NVM_PECR(nvm));
 8007424:	1c20      	adds	r0, r4, #0
 8007426:	1c31      	adds	r1, r6, #0
 8007428:	f001 f880 	bl	800852c <target_mem_read32>
	if ((pecr & (STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA))
 800742c:	4038      	ands	r0, r7
 800742e:	42b8      	cmp	r0, r7
 8007430:	d1ee      	bne.n	8007410 <stm32lx_nvm_data_erase+0x30>
	   != (STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA))
		return -1;

	while (len > 0) {
 8007432:	9b02      	ldr	r3, [sp, #8]
		/* Write first word of page to 0 */
		target_mem_write32(t, addr, 0);
 8007434:	1c20      	adds	r0, r4, #0
	uint32_t pecr = target_mem_read32(t, STM32Lx_NVM_PECR(nvm));
	if ((pecr & (STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA))
	   != (STM32Lx_NVM_PECR_ERASE | STM32Lx_NVM_PECR_DATA))
		return -1;

	while (len > 0) {
 8007436:	2b00      	cmp	r3, #0
 8007438:	d00c      	beq.n	8007454 <stm32lx_nvm_data_erase+0x74>
		/* Write first word of page to 0 */
		target_mem_write32(t, addr, 0);
 800743a:	2200      	movs	r2, #0
 800743c:	9901      	ldr	r1, [sp, #4]
 800743e:	f001 f87d 	bl	800853c <target_mem_write32>

		len  -= page_size;
 8007442:	9a03      	ldr	r2, [sp, #12]
 8007444:	9b02      	ldr	r3, [sp, #8]
		addr += page_size;
 8007446:	4694      	mov	ip, r2

	while (len > 0) {
		/* Write first word of page to 0 */
		target_mem_write32(t, addr, 0);

		len  -= page_size;
 8007448:	1a9b      	subs	r3, r3, r2
 800744a:	9302      	str	r3, [sp, #8]
		addr += page_size;
 800744c:	9b01      	ldr	r3, [sp, #4]
 800744e:	4463      	add	r3, ip
 8007450:	9301      	str	r3, [sp, #4]
 8007452:	e7ee      	b.n	8007432 <stm32lx_nvm_data_erase+0x52>
	}

	/* Disable further programming by locking PECR */
	stm32lx_nvm_lock(t, nvm);
 8007454:	1c29      	adds	r1, r5, #0
 8007456:	f7ff ff41 	bl	80072dc <stm32lx_nvm_lock>

	/* Wait for completion or an error */
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
 800745a:	1c29      	adds	r1, r5, #0
 800745c:	1c20      	adds	r0, r4, #0
 800745e:	3118      	adds	r1, #24
 8007460:	f001 f864 	bl	800852c <target_mem_read32>
	} while (sr & STM32Lx_NVM_SR_BSY);
 8007464:	07c3      	lsls	r3, r0, #31
 8007466:	d4f8      	bmi.n	800745a <stm32lx_nvm_data_erase+0x7a>

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 8007468:	4b04      	ldr	r3, [pc, #16]	; (800747c <stm32lx_nvm_data_erase+0x9c>)
 800746a:	4018      	ands	r0, r3
 800746c:	2802      	cmp	r0, #2
 800746e:	d1cf      	bne.n	8007410 <stm32lx_nvm_data_erase+0x30>
	    target_check_error(t))
 8007470:	1c20      	adds	r0, r4, #0
 8007472:	f000 ffd1 	bl	8008418 <target_check_error>
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
	} while (sr & STM32Lx_NVM_SR_BSY);

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 8007476:	4240      	negs	r0, r0
	    target_check_error(t))
			return -1;

	return 0;
}
 8007478:	b005      	add	sp, #20
 800747a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800747c:	00010702 	.word	0x00010702

08007480 <stm32lx_nvm_prog_write>:
    interface. */
static int stm32lx_nvm_prog_write(struct target_flash *f,
                                  target_addr dest,
                                  const void* src,
                                  size_t size)
{
 8007480:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	target *t = f->t;
 8007482:	6984      	ldr	r4, [r0, #24]
    interface. */
static int stm32lx_nvm_prog_write(struct target_flash *f,
                                  target_addr dest,
                                  const void* src,
                                  size_t size)
{
 8007484:	1c0f      	adds	r7, r1, #0
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
 8007486:	6d20      	ldr	r0, [r4, #80]	; 0x50
    interface. */
static int stm32lx_nvm_prog_write(struct target_flash *f,
                                  target_addr dest,
                                  const void* src,
                                  size_t size)
{
 8007488:	9200      	str	r2, [sp, #0]
 800748a:	9301      	str	r3, [sp, #4]
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
 800748c:	f7ff ff2c 	bl	80072e8 <stm32lx_nvm_phys.isra.2>
 8007490:	1c05      	adds	r5, r0, #0

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 8007492:	1c20      	adds	r0, r4, #0
 8007494:	1c29      	adds	r1, r5, #0
 8007496:	f7ff fef1 	bl	800727c <stm32lx_nvm_prog_data_unlock>
 800749a:	2800      	cmp	r0, #0
 800749c:	d106      	bne.n	80074ac <stm32lx_nvm_prog_write+0x2c>
	        return -1;
 800749e:	2001      	movs	r0, #1
 80074a0:	e029      	b.n	80074f6 <stm32lx_nvm_prog_write+0x76>

	/* Wait for BSY to clear because we cannot write the PECR until
	   the previous operation completes on STM32Lxxx. */
	while (target_mem_read32(t, STM32Lx_NVM_SR(nvm))
	       & STM32Lx_NVM_SR_BSY)
		if (target_check_error(t))
 80074a2:	1c20      	adds	r0, r4, #0
 80074a4:	f000 ffb8 	bl	8008418 <target_check_error>
 80074a8:	2800      	cmp	r0, #0
 80074aa:	d1f8      	bne.n	800749e <stm32lx_nvm_prog_write+0x1e>
	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
	        return -1;

	/* Wait for BSY to clear because we cannot write the PECR until
	   the previous operation completes on STM32Lxxx. */
	while (target_mem_read32(t, STM32Lx_NVM_SR(nvm))
 80074ac:	1c2e      	adds	r6, r5, #0
 80074ae:	3618      	adds	r6, #24
 80074b0:	1c20      	adds	r0, r4, #0
 80074b2:	1c31      	adds	r1, r6, #0
 80074b4:	f001 f83a 	bl	800852c <target_mem_read32>
 80074b8:	07c3      	lsls	r3, r0, #31
 80074ba:	d4f2      	bmi.n	80074a2 <stm32lx_nvm_prog_write+0x22>
	       & STM32Lx_NVM_SR_BSY)
		if (target_check_error(t))
			return -1;

	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
 80074bc:	2281      	movs	r2, #129	; 0x81
 80074be:	1d29      	adds	r1, r5, #4
 80074c0:	1c20      	adds	r0, r4, #0
 80074c2:	00d2      	lsls	r2, r2, #3
 80074c4:	f001 f83a 	bl	800853c <target_mem_write32>
	                   STM32Lx_NVM_PECR_PROG | STM32Lx_NVM_PECR_FPRG);
	target_mem_write(t, dest, src, size);
 80074c8:	1c39      	adds	r1, r7, #0
 80074ca:	1c20      	adds	r0, r4, #0
 80074cc:	9a00      	ldr	r2, [sp, #0]
 80074ce:	9b01      	ldr	r3, [sp, #4]
 80074d0:	f000 ffb0 	bl	8008434 <target_mem_write>

	/* Disable further programming by locking PECR */
	stm32lx_nvm_lock(t, nvm);
 80074d4:	1c20      	adds	r0, r4, #0
 80074d6:	1c29      	adds	r1, r5, #0
 80074d8:	f7ff ff00 	bl	80072dc <stm32lx_nvm_lock>

	/* Wait for completion or an error */
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
 80074dc:	1c20      	adds	r0, r4, #0
 80074de:	1c31      	adds	r1, r6, #0
 80074e0:	f001 f824 	bl	800852c <target_mem_read32>
	} while (sr & STM32Lx_NVM_SR_BSY);
 80074e4:	07c3      	lsls	r3, r0, #31
 80074e6:	d4f9      	bmi.n	80074dc <stm32lx_nvm_prog_write+0x5c>

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 80074e8:	4b04      	ldr	r3, [pc, #16]	; (80074fc <stm32lx_nvm_prog_write+0x7c>)
 80074ea:	4018      	ands	r0, r3
 80074ec:	2802      	cmp	r0, #2
 80074ee:	d1d6      	bne.n	800749e <stm32lx_nvm_prog_write+0x1e>
	    target_check_error(t))
 80074f0:	1c20      	adds	r0, r4, #0
 80074f2:	f000 ff91 	bl	8008418 <target_check_error>
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
	} while (sr & STM32Lx_NVM_SR_BSY);

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 80074f6:	4240      	negs	r0, r0
	    target_check_error(t))
			return -1;

	return 0;
}
 80074f8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80074fa:	46c0      	nop			; (mov r8, r8)
 80074fc:	00010702 	.word	0x00010702

08007500 <stm32lx_cmd_option>:

        return !(sr & STM32Lx_NVM_SR_ERR_M);
}

static bool stm32lx_cmd_option(target* t, int argc, char** argv)
{
 8007500:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007502:	6d05      	ldr	r5, [r0, #80]	; 0x50
 8007504:	b08b      	sub	sp, #44	; 0x2c
 8007506:	1c04      	adds	r4, r0, #0
        const uint32_t nvm      = stm32lx_nvm_phys(t);
 8007508:	1c28      	adds	r0, r5, #0

        return !(sr & STM32Lx_NVM_SR_ERR_M);
}

static bool stm32lx_cmd_option(target* t, int argc, char** argv)
{
 800750a:	9109      	str	r1, [sp, #36]	; 0x24
 800750c:	1c17      	adds	r7, r2, #0
        const uint32_t nvm      = stm32lx_nvm_phys(t);
 800750e:	f7ff feeb 	bl	80072e8 <stm32lx_nvm_phys.isra.2>

static uint32_t stm32lx_nvm_option_size(target *t)
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_OPT_SIZE;
 8007512:	230c      	movs	r3, #12
 8007514:	9307      	str	r3, [sp, #28]
        }
}

static uint32_t stm32lx_nvm_option_size(target *t)
{
        switch (t->idcode) {
 8007516:	4b90      	ldr	r3, [pc, #576]	; (8007758 <stm32lx_cmd_option+0x258>)
        return !(sr & STM32Lx_NVM_SR_ERR_M);
}

static bool stm32lx_cmd_option(target* t, int argc, char** argv)
{
        const uint32_t nvm      = stm32lx_nvm_phys(t);
 8007518:	9006      	str	r0, [sp, #24]
        }
}

static uint32_t stm32lx_nvm_option_size(target *t)
{
        switch (t->idcode) {
 800751a:	429d      	cmp	r5, r3
 800751c:	d001      	beq.n	8007522 <stm32lx_cmd_option+0x22>
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_OPT_SIZE;
        default:                      /* STM32L1xx */
                return STM32L1_NVM_OPT_SIZE;
 800751e:	2320      	movs	r3, #32
 8007520:	9307      	str	r3, [sp, #28]
    Returns true if the unlock succeeds. */
static bool stm32lx_nvm_opt_unlock(target *t, uint32_t nvm)
{
        /* Always lock first because that's the only way to know that the
           unlock can succeed on the STM32L0's. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),  STM32Lx_NVM_PECR_PELOCK);
 8007522:	9b06      	ldr	r3, [sp, #24]
 8007524:	1c20      	adds	r0, r4, #0
 8007526:	1d1e      	adds	r6, r3, #4
 8007528:	1c31      	adds	r1, r6, #0
 800752a:	2201      	movs	r2, #1
 800752c:	f001 f806 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY1);
 8007530:	9d06      	ldr	r5, [sp, #24]
 8007532:	1c20      	adds	r0, r4, #0
 8007534:	350c      	adds	r5, #12
 8007536:	1c29      	adds	r1, r5, #0
 8007538:	4a88      	ldr	r2, [pc, #544]	; (800775c <stm32lx_cmd_option+0x25c>)
 800753a:	f000 ffff 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_PEKEYR(nvm),  STM32Lx_NVM_PEKEY2);
 800753e:	1c29      	adds	r1, r5, #0
 8007540:	1c20      	adds	r0, r4, #0
 8007542:	4a87      	ldr	r2, [pc, #540]	; (8007760 <stm32lx_cmd_option+0x260>)
 8007544:	f000 fffa 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_OPTKEYR(nvm), STM32Lx_NVM_OPTKEY1);
 8007548:	9d06      	ldr	r5, [sp, #24]
 800754a:	1c20      	adds	r0, r4, #0
 800754c:	3514      	adds	r5, #20
 800754e:	1c29      	adds	r1, r5, #0
 8007550:	4a84      	ldr	r2, [pc, #528]	; (8007764 <stm32lx_cmd_option+0x264>)
 8007552:	f000 fff3 	bl	800853c <target_mem_write32>
        target_mem_write32(t, STM32Lx_NVM_OPTKEYR(nvm), STM32Lx_NVM_OPTKEY2);
 8007556:	1c20      	adds	r0, r4, #0
 8007558:	1c29      	adds	r1, r5, #0
 800755a:	4a83      	ldr	r2, [pc, #524]	; (8007768 <stm32lx_cmd_option+0x268>)
 800755c:	f000 ffee 	bl	800853c <target_mem_write32>

        return !(target_mem_read32(t, STM32Lx_NVM_PECR(nvm))
 8007560:	1c20      	adds	r0, r4, #0
 8007562:	1c31      	adds	r1, r6, #0
 8007564:	f000 ffe2 	bl	800852c <target_mem_read32>
static bool stm32lx_cmd_option(target* t, int argc, char** argv)
{
        const uint32_t nvm      = stm32lx_nvm_phys(t);
        const size_t   opt_size = stm32lx_nvm_option_size(t);

        if (!stm32lx_nvm_opt_unlock(t, nvm)) {
 8007568:	0743      	lsls	r3, r0, #29
 800756a:	d504      	bpl.n	8007576 <stm32lx_cmd_option+0x76>
                tc_printf(t, "unable to unlock NVM option bytes\n");
 800756c:	1c20      	adds	r0, r4, #0
 800756e:	497f      	ldr	r1, [pc, #508]	; (800776c <stm32lx_cmd_option+0x26c>)
 8007570:	f001 f83b 	bl	80085ea <tc_printf>
                return true;
 8007574:	e0ed      	b.n	8007752 <stm32lx_cmd_option+0x252>
        }

        size_t cb = strlen(argv[1]);
 8007576:	687d      	ldr	r5, [r7, #4]
 8007578:	1c28      	adds	r0, r5, #0
 800757a:	f005 fc55 	bl	800ce28 <strlen>

        if (argc == 2 && !strncasecmp(argv[1], "obl_launch", cb)) {
 800757e:	9b09      	ldr	r3, [sp, #36]	; 0x24
        if (!stm32lx_nvm_opt_unlock(t, nvm)) {
                tc_printf(t, "unable to unlock NVM option bytes\n");
                return true;
        }

        size_t cb = strlen(argv[1]);
 8007580:	9008      	str	r0, [sp, #32]

        if (argc == 2 && !strncasecmp(argv[1], "obl_launch", cb)) {
 8007582:	2b02      	cmp	r3, #2
 8007584:	d10e      	bne.n	80075a4 <stm32lx_cmd_option+0xa4>
 8007586:	1c28      	adds	r0, r5, #0
 8007588:	4979      	ldr	r1, [pc, #484]	; (8007770 <stm32lx_cmd_option+0x270>)
 800758a:	9a08      	ldr	r2, [sp, #32]
 800758c:	f005 fc54 	bl	800ce38 <strncasecmp>
 8007590:	2800      	cmp	r0, #0
 8007592:	d152      	bne.n	800763a <stm32lx_cmd_option+0x13a>
                target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
 8007594:	2280      	movs	r2, #128	; 0x80
 8007596:	1c20      	adds	r0, r4, #0
 8007598:	1c31      	adds	r1, r6, #0
 800759a:	02d2      	lsls	r2, r2, #11
 800759c:	f000 ffce 	bl	800853c <target_mem_write32>
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_OPT_SIZE;
        default:                      /* STM32L1xx */
                return STM32L1_NVM_OPT_SIZE;
 80075a0:	2500      	movs	r5, #0
 80075a2:	e05d      	b.n	8007660 <stm32lx_cmd_option+0x160>

        if (argc == 2 && !strncasecmp(argv[1], "obl_launch", cb)) {
                target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
                                   STM32Lx_NVM_PECR_OBL_LAUNCH);
        }
        else if (argc == 4 && !strncasecmp(argv[1], "raw", cb)) {
 80075a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80075a6:	2b04      	cmp	r3, #4
 80075a8:	d171      	bne.n	800768e <stm32lx_cmd_option+0x18e>
 80075aa:	1c28      	adds	r0, r5, #0
 80075ac:	4971      	ldr	r1, [pc, #452]	; (8007774 <stm32lx_cmd_option+0x274>)
 80075ae:	9a08      	ldr	r2, [sp, #32]
 80075b0:	f005 fc42 	bl	800ce38 <strncasecmp>
 80075b4:	1e06      	subs	r6, r0, #0
 80075b6:	d10e      	bne.n	80075d6 <stm32lx_cmd_option+0xd6>
                uint32_t addr = strtoul(argv[2], NULL, 0);
 80075b8:	1c31      	adds	r1, r6, #0
 80075ba:	1c32      	adds	r2, r6, #0
 80075bc:	68b8      	ldr	r0, [r7, #8]
 80075be:	f005 fe0b 	bl	800d1d8 <strtoul>
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80075c2:	1c31      	adds	r1, r6, #0
 80075c4:	1c32      	adds	r2, r6, #0
        if (argc == 2 && !strncasecmp(argv[1], "obl_launch", cb)) {
                target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
                                   STM32Lx_NVM_PECR_OBL_LAUNCH);
        }
        else if (argc == 4 && !strncasecmp(argv[1], "raw", cb)) {
                uint32_t addr = strtoul(argv[2], NULL, 0);
 80075c6:	1c05      	adds	r5, r0, #0
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80075c8:	68f8      	ldr	r0, [r7, #12]
 80075ca:	f005 fe05 	bl	800d1d8 <strtoul>
                tc_printf(t, "raw %08x <- %08x\n", addr, val);
 80075ce:	496a      	ldr	r1, [pc, #424]	; (8007778 <stm32lx_cmd_option+0x278>)
                target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
                                   STM32Lx_NVM_PECR_OBL_LAUNCH);
        }
        else if (argc == 4 && !strncasecmp(argv[1], "raw", cb)) {
                uint32_t addr = strtoul(argv[2], NULL, 0);
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80075d0:	1c06      	adds	r6, r0, #0
                tc_printf(t, "raw %08x <- %08x\n", addr, val);
 80075d2:	1c20      	adds	r0, r4, #0
 80075d4:	e017      	b.n	8007606 <stm32lx_cmd_option+0x106>
                    || (addr & 3))
                        goto usage;
                if (!stm32lx_option_write(t, addr, val))
                        tc_printf(t, "option write failed\n");
        }
        else if (argc == 4 && !strncasecmp(argv[1], "write", cb)) {
 80075d6:	1c28      	adds	r0, r5, #0
 80075d8:	4968      	ldr	r1, [pc, #416]	; (800777c <stm32lx_cmd_option+0x27c>)
 80075da:	9a08      	ldr	r2, [sp, #32]
 80075dc:	f005 fc2c 	bl	800ce38 <strncasecmp>
 80075e0:	1e06      	subs	r6, r0, #0
 80075e2:	d154      	bne.n	800768e <stm32lx_cmd_option+0x18e>
                uint32_t addr = strtoul(argv[2], NULL, 0);
 80075e4:	1c31      	adds	r1, r6, #0
 80075e6:	1c32      	adds	r2, r6, #0
 80075e8:	68b8      	ldr	r0, [r7, #8]
 80075ea:	f005 fdf5 	bl	800d1d8 <strtoul>
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80075ee:	1c31      	adds	r1, r6, #0
 80075f0:	1c32      	adds	r2, r6, #0
                        goto usage;
                if (!stm32lx_option_write(t, addr, val))
                        tc_printf(t, "option write failed\n");
        }
        else if (argc == 4 && !strncasecmp(argv[1], "write", cb)) {
                uint32_t addr = strtoul(argv[2], NULL, 0);
 80075f2:	1c05      	adds	r5, r0, #0
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80075f4:	68f8      	ldr	r0, [r7, #12]
 80075f6:	f005 fdef 	bl	800d1d8 <strtoul>
                val = (val & 0xffff) | ((~val & 0xffff) << 16);
 80075fa:	b286      	uxth	r6, r0
 80075fc:	43c0      	mvns	r0, r0
 80075fe:	0400      	lsls	r0, r0, #16
 8007600:	4306      	orrs	r6, r0
                tc_printf(t, "write %08x <- %08x\n", addr, val);
 8007602:	1c20      	adds	r0, r4, #0
 8007604:	495e      	ldr	r1, [pc, #376]	; (8007780 <stm32lx_cmd_option+0x280>)
 8007606:	1c33      	adds	r3, r6, #0
 8007608:	1c2a      	adds	r2, r5, #0
 800760a:	f000 ffee 	bl	80085ea <tc_printf>
                if (   addr <  STM32Lx_NVM_OPT_PHYS
 800760e:	4b5d      	ldr	r3, [pc, #372]	; (8007784 <stm32lx_cmd_option+0x284>)
 8007610:	429d      	cmp	r5, r3
 8007612:	d93c      	bls.n	800768e <stm32lx_cmd_option+0x18e>
                    || addr >= STM32Lx_NVM_OPT_PHYS + opt_size
 8007614:	9b07      	ldr	r3, [sp, #28]
 8007616:	4a5c      	ldr	r2, [pc, #368]	; (8007788 <stm32lx_cmd_option+0x288>)
 8007618:	189b      	adds	r3, r3, r2
 800761a:	429d      	cmp	r5, r3
 800761c:	d237      	bcs.n	800768e <stm32lx_cmd_option+0x18e>
                    || (addr & 3))
 800761e:	07ab      	lsls	r3, r5, #30
 8007620:	d135      	bne.n	800768e <stm32lx_cmd_option+0x18e>
                tc_printf(t, "raw %08x <- %08x\n", addr, val);
                if (   addr <  STM32Lx_NVM_OPT_PHYS
                    || addr >= STM32Lx_NVM_OPT_PHYS + opt_size
                    || (addr & 3))
                        goto usage;
                if (!stm32lx_option_write(t, addr, val))
 8007622:	1c20      	adds	r0, r4, #0
 8007624:	1c29      	adds	r1, r5, #0
 8007626:	1c32      	adds	r2, r6, #0
 8007628:	f7ff fe6c 	bl	8007304 <stm32lx_option_write>
 800762c:	2800      	cmp	r0, #0
 800762e:	d1b7      	bne.n	80075a0 <stm32lx_cmd_option+0xa0>
                        tc_printf(t, "option write failed\n");
 8007630:	1c20      	adds	r0, r4, #0
 8007632:	4956      	ldr	r1, [pc, #344]	; (800778c <stm32lx_cmd_option+0x28c>)
 8007634:	f000 ffd9 	bl	80085ea <tc_printf>
 8007638:	e7b2      	b.n	80075a0 <stm32lx_cmd_option+0xa0>
                    || (addr & 3))
                        goto usage;
                if (!stm32lx_option_write(t, addr, val))
                        tc_printf(t, "option write failed\n");
        }
        else if (argc == 2 && !strncasecmp(argv[1], "show", cb))
 800763a:	1c28      	adds	r0, r5, #0
 800763c:	4954      	ldr	r1, [pc, #336]	; (8007790 <stm32lx_cmd_option+0x290>)
 800763e:	9a08      	ldr	r2, [sp, #32]
 8007640:	f005 fbfa 	bl	800ce38 <strncasecmp>
 8007644:	2800      	cmp	r0, #0
 8007646:	d0ab      	beq.n	80075a0 <stm32lx_cmd_option+0xa0>
 8007648:	e021      	b.n	800768e <stm32lx_cmd_option+0x18e>

        /* Report the current option values */
        for(unsigned i = 0; i < opt_size; i += sizeof(uint32_t)) {
                uint32_t addr = STM32Lx_NVM_OPT_PHYS + i;
                uint32_t val = target_mem_read32(t, addr);
                tc_printf(t, "0x%08x: 0x%04x 0x%04x %s\n",
 800764a:	9200      	str	r2, [sp, #0]
 800764c:	9101      	str	r1, [sp, #4]
 800764e:	1c20      	adds	r0, r4, #0
 8007650:	4950      	ldr	r1, [pc, #320]	; (8007794 <stm32lx_cmd_option+0x294>)
 8007652:	1c32      	adds	r2, r6, #0
 8007654:	f000 ffc9 	bl	80085ea <tc_printf>
                ;
        else
                goto usage;

        /* Report the current option values */
        for(unsigned i = 0; i < opt_size; i += sizeof(uint32_t)) {
 8007658:	9b07      	ldr	r3, [sp, #28]
 800765a:	3504      	adds	r5, #4
 800765c:	429d      	cmp	r5, r3
 800765e:	d20e      	bcs.n	800767e <stm32lx_cmd_option+0x17e>
 8007660:	4b49      	ldr	r3, [pc, #292]	; (8007788 <stm32lx_cmd_option+0x288>)
                uint32_t addr = STM32Lx_NVM_OPT_PHYS + i;
                uint32_t val = target_mem_read32(t, addr);
 8007662:	1c20      	adds	r0, r4, #0
 8007664:	18ee      	adds	r6, r5, r3
 8007666:	1c31      	adds	r1, r6, #0
 8007668:	f000 ff60 	bl	800852c <target_mem_read32>
                tc_printf(t, "0x%08x: 0x%04x 0x%04x %s\n",
                          addr, val & 0xffff, (val >> 16) & 0xffff,
 800766c:	0c02      	lsrs	r2, r0, #16
                          ((val & 0xffff) == ((~val >> 16) & 0xffff))
 800766e:	b283      	uxth	r3, r0
 8007670:	43c0      	mvns	r0, r0

        /* Report the current option values */
        for(unsigned i = 0; i < opt_size; i += sizeof(uint32_t)) {
                uint32_t addr = STM32Lx_NVM_OPT_PHYS + i;
                uint32_t val = target_mem_read32(t, addr);
                tc_printf(t, "0x%08x: 0x%04x 0x%04x %s\n",
 8007672:	4949      	ldr	r1, [pc, #292]	; (8007798 <stm32lx_cmd_option+0x298>)
                          addr, val & 0xffff, (val >> 16) & 0xffff,
                          ((val & 0xffff) == ((~val >> 16) & 0xffff))
 8007674:	0c00      	lsrs	r0, r0, #16

        /* Report the current option values */
        for(unsigned i = 0; i < opt_size; i += sizeof(uint32_t)) {
                uint32_t addr = STM32Lx_NVM_OPT_PHYS + i;
                uint32_t val = target_mem_read32(t, addr);
                tc_printf(t, "0x%08x: 0x%04x 0x%04x %s\n",
 8007676:	4283      	cmp	r3, r0
 8007678:	d0e7      	beq.n	800764a <stm32lx_cmd_option+0x14a>
 800767a:	4948      	ldr	r1, [pc, #288]	; (800779c <stm32lx_cmd_option+0x29c>)
 800767c:	e7e5      	b.n	800764a <stm32lx_cmd_option+0x14a>
        STM32L1_DBGMCU_IDCODE_PHYS = 0xe0042000,
};

static bool stm32lx_is_stm32l1(target* t)
{
        switch (t->idcode) {
 800767e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8007680:	9906      	ldr	r1, [sp, #24]
 8007682:	1c1a      	adds	r2, r3, #0
 8007684:	4b34      	ldr	r3, [pc, #208]	; (8007758 <stm32lx_cmd_option+0x258>)
 8007686:	311c      	adds	r1, #28
 8007688:	429a      	cmp	r2, r3
 800768a:	d13d      	bne.n	8007708 <stm32lx_cmd_option+0x208>
 800768c:	e021      	b.n	80076d2 <stm32lx_cmd_option+0x1d2>
        }

        goto done;

usage:
        tc_printf(t, "usage: monitor option [ARGS]\n");
 800768e:	1c20      	adds	r0, r4, #0
 8007690:	4943      	ldr	r1, [pc, #268]	; (80077a0 <stm32lx_cmd_option+0x2a0>)
 8007692:	f000 ffaa 	bl	80085ea <tc_printf>
        tc_printf(t, "  show                   - Show options in NVM and as"
 8007696:	1c20      	adds	r0, r4, #0
 8007698:	4942      	ldr	r1, [pc, #264]	; (80077a4 <stm32lx_cmd_option+0x2a4>)
 800769a:	f000 ffa6 	bl	80085ea <tc_printf>
                  " loaded\n");
        tc_printf(t, "  obl_launch             - Reload options from NVM\n");
 800769e:	1c20      	adds	r0, r4, #0
 80076a0:	4941      	ldr	r1, [pc, #260]	; (80077a8 <stm32lx_cmd_option+0x2a8>)
 80076a2:	f000 ffa2 	bl	80085ea <tc_printf>
        tc_printf(t, "  write <addr> <value16> - Set option half-word; "
 80076a6:	1c20      	adds	r0, r4, #0
 80076a8:	4940      	ldr	r1, [pc, #256]	; (80077ac <stm32lx_cmd_option+0x2ac>)
 80076aa:	f000 ff9e 	bl	80085ea <tc_printf>
                  "complement computed\n");
        tc_printf(t, "  raw <addr> <value32>   - Set option word\n");
 80076ae:	1c20      	adds	r0, r4, #0
 80076b0:	493f      	ldr	r1, [pc, #252]	; (80077b0 <stm32lx_cmd_option+0x2b0>)
 80076b2:	f000 ff9a 	bl	80085ea <tc_printf>
        tc_printf(t, "The value of <addr> must be word aligned and from 0x%08x "
 80076b6:	4a3f      	ldr	r2, [pc, #252]	; (80077b4 <stm32lx_cmd_option+0x2b4>)
 80076b8:	9b07      	ldr	r3, [sp, #28]
 80076ba:	4694      	mov	ip, r2
 80076bc:	1c20      	adds	r0, r4, #0
 80076be:	4463      	add	r3, ip
 80076c0:	493d      	ldr	r1, [pc, #244]	; (80077b8 <stm32lx_cmd_option+0x2b8>)
 80076c2:	4a31      	ldr	r2, [pc, #196]	; (8007788 <stm32lx_cmd_option+0x288>)
 80076c4:	f000 ff91 	bl	80085ea <tc_printf>
                  "to +0x%x\n",
                  STM32Lx_NVM_OPT_PHYS,
                  STM32Lx_NVM_OPT_PHYS + opt_size - sizeof(uint32_t));

done:
        stm32lx_nvm_lock(t, nvm);
 80076c8:	1c20      	adds	r0, r4, #0
 80076ca:	9906      	ldr	r1, [sp, #24]
 80076cc:	f7ff fe06 	bl	80072dc <stm32lx_nvm_lock>
        return true;
 80076d0:	e03f      	b.n	8007752 <stm32lx_cmd_option+0x252>
                          (optr &  STM32L1_NVM_OPTR_nRST_STOP)  ? 1 : 0,
                          (optr &  STM32L1_NVM_OPTR_nRST_STDBY) ? 1 : 0,
                          (optr &  STM32L1_NVM_OPTR_nBFB2)      ? 1 : 0);
        }
        else {
                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
 80076d2:	1c20      	adds	r0, r4, #0
 80076d4:	f000 ff2a 	bl	800852c <target_mem_read32>
                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
 80076d8:	b2c1      	uxtb	r1, r0
                          (optr &  STM32L1_NVM_OPTR_nRST_STOP)  ? 1 : 0,
                          (optr &  STM32L1_NVM_OPTR_nRST_STDBY) ? 1 : 0,
                          (optr &  STM32L1_NVM_OPTR_nBFB2)      ? 1 : 0);
        }
        else {
                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
 80076da:	1c02      	adds	r2, r0, #0
                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
                        & STM32Lx_NVM_OPTR_RDPROT_M;
                if (rdprot == STM32Lx_NVM_OPTR_RDPROT_0)
                        rdprot = 0;
 80076dc:	2300      	movs	r3, #0
        }
        else {
                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
                        & STM32Lx_NVM_OPTR_RDPROT_M;
                if (rdprot == STM32Lx_NVM_OPTR_RDPROT_0)
 80076de:	29aa      	cmp	r1, #170	; 0xaa
 80076e0:	d004      	beq.n	80076ec <stm32lx_cmd_option+0x1ec>
                        rdprot = 0;
                else if (rdprot == STM32Lx_NVM_OPTR_RDPROT_2)
                        rdprot = 2;
                else
                        rdprot = 1;
 80076e2:	1c0b      	adds	r3, r1, #0
 80076e4:	3bcc      	subs	r3, #204	; 0xcc
 80076e6:	4258      	negs	r0, r3
 80076e8:	4158      	adcs	r0, r3
 80076ea:	1c43      	adds	r3, r0, #1
                tc_printf(t, "OPTR: 0x%08x, RDPROT %d, WPRMOD %d, WDG_SW %d, "
 80076ec:	2101      	movs	r1, #1
 80076ee:	0a10      	lsrs	r0, r2, #8
 80076f0:	4008      	ands	r0, r1
 80076f2:	9000      	str	r0, [sp, #0]
 80076f4:	0d10      	lsrs	r0, r2, #20
 80076f6:	4001      	ands	r1, r0
 80076f8:	9101      	str	r1, [sp, #4]
 80076fa:	0fd1      	lsrs	r1, r2, #31
 80076fc:	9102      	str	r1, [sp, #8]
 80076fe:	1c20      	adds	r0, r4, #0
 8007700:	492e      	ldr	r1, [pc, #184]	; (80077bc <stm32lx_cmd_option+0x2bc>)
 8007702:	f000 ff72 	bl	80085ea <tc_printf>
 8007706:	e7df      	b.n	80076c8 <stm32lx_cmd_option+0x1c8>
                          ((val & 0xffff) == ((~val >> 16) & 0xffff))
                          ? "OK" : "ERR");
        }

        if (stm32lx_is_stm32l1(t)) {
                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
 8007708:	1c20      	adds	r0, r4, #0
 800770a:	f000 ff0f 	bl	800852c <target_mem_read32>
                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
 800770e:	b2c1      	uxtb	r1, r0
                          ((val & 0xffff) == ((~val >> 16) & 0xffff))
                          ? "OK" : "ERR");
        }

        if (stm32lx_is_stm32l1(t)) {
                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
 8007710:	1c02      	adds	r2, r0, #0
                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
                        & STM32Lx_NVM_OPTR_RDPROT_M;
                if (rdprot == STM32Lx_NVM_OPTR_RDPROT_0)
                        rdprot = 0;
 8007712:	2300      	movs	r3, #0

        if (stm32lx_is_stm32l1(t)) {
                uint32_t optr   = target_mem_read32(t, STM32Lx_NVM_OPTR(nvm));
                uint8_t  rdprot = (optr >> STM32Lx_NVM_OPTR_RDPROT_S)
                        & STM32Lx_NVM_OPTR_RDPROT_M;
                if (rdprot == STM32Lx_NVM_OPTR_RDPROT_0)
 8007714:	29aa      	cmp	r1, #170	; 0xaa
 8007716:	d004      	beq.n	8007722 <stm32lx_cmd_option+0x222>
                        rdprot = 0;
                else if (rdprot == STM32Lx_NVM_OPTR_RDPROT_2)
                        rdprot = 2;
                else
                        rdprot = 1;
 8007718:	1c0b      	adds	r3, r1, #0
 800771a:	3bcc      	subs	r3, #204	; 0xcc
 800771c:	4258      	negs	r0, r3
 800771e:	4158      	adcs	r0, r3
 8007720:	1c43      	adds	r3, r0, #1
                tc_printf(t, "OPTR: 0x%08x, RDPRT %d, SPRMD %d, "
 8007722:	2101      	movs	r1, #1
 8007724:	0a10      	lsrs	r0, r2, #8
 8007726:	4008      	ands	r0, r1
 8007728:	9000      	str	r0, [sp, #0]
 800772a:	0310      	lsls	r0, r2, #12
 800772c:	0f00      	lsrs	r0, r0, #28
 800772e:	9001      	str	r0, [sp, #4]
 8007730:	0d10      	lsrs	r0, r2, #20
 8007732:	4008      	ands	r0, r1
 8007734:	9002      	str	r0, [sp, #8]
 8007736:	0d50      	lsrs	r0, r2, #21
 8007738:	4008      	ands	r0, r1
 800773a:	9003      	str	r0, [sp, #12]
 800773c:	0d90      	lsrs	r0, r2, #22
 800773e:	4008      	ands	r0, r1
 8007740:	9004      	str	r0, [sp, #16]
 8007742:	0dd0      	lsrs	r0, r2, #23
 8007744:	4001      	ands	r1, r0
 8007746:	9105      	str	r1, [sp, #20]
 8007748:	1c20      	adds	r0, r4, #0
 800774a:	491d      	ldr	r1, [pc, #116]	; (80077c0 <stm32lx_cmd_option+0x2c0>)
 800774c:	f000 ff4d 	bl	80085ea <tc_printf>
 8007750:	e7ba      	b.n	80076c8 <stm32lx_cmd_option+0x1c8>
                  STM32Lx_NVM_OPT_PHYS + opt_size - sizeof(uint32_t));

done:
        stm32lx_nvm_lock(t, nvm);
        return true;
}
 8007752:	2001      	movs	r0, #1
 8007754:	b00b      	add	sp, #44	; 0x2c
 8007756:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007758:	00000417 	.word	0x00000417
 800775c:	89abcdef 	.word	0x89abcdef
 8007760:	02030405 	.word	0x02030405
 8007764:	fbead9c8 	.word	0xfbead9c8
 8007768:	24252627 	.word	0x24252627
 800776c:	08013120 	.word	0x08013120
 8007770:	08013143 	.word	0x08013143
 8007774:	0801314e 	.word	0x0801314e
 8007778:	08013152 	.word	0x08013152
 800777c:	0801307c 	.word	0x0801307c
 8007780:	08013179 	.word	0x08013179
 8007784:	1ff7ffff 	.word	0x1ff7ffff
 8007788:	1ff80000 	.word	0x1ff80000
 800778c:	08013164 	.word	0x08013164
 8007790:	0801318d 	.word	0x0801318d
 8007794:	08013192 	.word	0x08013192
 8007798:	08011c22 	.word	0x08011c22
 800779c:	0801311c 	.word	0x0801311c
 80077a0:	0801323f 	.word	0x0801323f
 80077a4:	0801325d 	.word	0x0801325d
 80077a8:	0801329b 	.word	0x0801329b
 80077ac:	080132cf 	.word	0x080132cf
 80077b0:	08013315 	.word	0x08013315
 80077b4:	1ff7fffc 	.word	0x1ff7fffc
 80077b8:	08013341 	.word	0x08013341
 80077bc:	08013206 	.word	0x08013206
 80077c0:	080131ac 	.word	0x080131ac

080077c4 <stm32l_add_flash.constprop.5>:
        default:                      /* STM32L1xx */
                return STM32L1_NVM_OPT_SIZE;
        }
}

static void stm32l_add_flash(target *t,
 80077c4:	b570      	push	{r4, r5, r6, lr}
 80077c6:	1c05      	adds	r5, r0, #0
 80077c8:	1c0e      	adds	r6, r1, #0
                             uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 80077ca:	2001      	movs	r0, #1
 80077cc:	2138      	movs	r1, #56	; 0x38
        default:                      /* STM32L1xx */
                return STM32L1_NVM_OPT_SIZE;
        }
}

static void stm32l_add_flash(target *t,
 80077ce:	1c14      	adds	r4, r2, #0
                             uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 80077d0:	f005 f852 	bl	800c878 <calloc>
	f->start = addr;
 80077d4:	2380      	movs	r3, #128	; 0x80
 80077d6:	051b      	lsls	r3, r3, #20
 80077d8:	6003      	str	r3, [r0, #0]
	f->length = length;
	f->blocksize = erasesize;
	f->erase = stm32lx_nvm_prog_erase;
 80077da:	4b08      	ldr	r3, [pc, #32]	; (80077fc <stm32l_add_flash.constprop.5+0x38>)
                             uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
 80077dc:	6084      	str	r4, [r0, #8]
	f->erase = stm32lx_nvm_prog_erase;
 80077de:	60c3      	str	r3, [r0, #12]
	f->write = target_flash_write_buffered;
 80077e0:	4b07      	ldr	r3, [pc, #28]	; (8007800 <stm32l_add_flash.constprop.5+0x3c>)
	f->done = target_flash_done_buffered;
	f->write_buf = stm32lx_nvm_prog_write;
	f->buf_size = erasesize/2;
 80077e2:	0864      	lsrs	r4, r4, #1
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = erasesize;
	f->erase = stm32lx_nvm_prog_erase;
	f->write = target_flash_write_buffered;
 80077e4:	6103      	str	r3, [r0, #16]
	f->done = target_flash_done_buffered;
 80077e6:	4b07      	ldr	r3, [pc, #28]	; (8007804 <stm32l_add_flash.constprop.5+0x40>)
static void stm32l_add_flash(target *t,
                             uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
 80077e8:	6046      	str	r6, [r0, #4]
	f->blocksize = erasesize;
	f->erase = stm32lx_nvm_prog_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 80077ea:	6143      	str	r3, [r0, #20]
	f->write_buf = stm32lx_nvm_prog_write;
 80077ec:	4b06      	ldr	r3, [pc, #24]	; (8007808 <stm32l_add_flash.constprop.5+0x44>)
}

static void stm32l_add_flash(target *t,
                             uint32_t addr, size_t length, size_t erasesize)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 80077ee:	1c01      	adds	r1, r0, #0
	f->length = length;
	f->blocksize = erasesize;
	f->erase = stm32lx_nvm_prog_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = stm32lx_nvm_prog_write;
 80077f0:	62c3      	str	r3, [r0, #44]	; 0x2c
	f->buf_size = erasesize/2;
 80077f2:	6284      	str	r4, [r0, #40]	; 0x28
	target_add_flash(t, f);
 80077f4:	1c28      	adds	r0, r5, #0
 80077f6:	f000 fcaa 	bl	800814e <target_add_flash>
}
 80077fa:	bd70      	pop	{r4, r5, r6, pc}
 80077fc:	08007349 	.word	0x08007349
 8007800:	0800834b 	.word	0x0800834b
 8007804:	080083dd 	.word	0x080083dd
 8007808:	08007481 	.word	0x08007481

0800780c <stm32lx_eeprom_write>:
    complete.  The return value is true if the write succeeded.
    FWIW, byte writing isn't supported because the adiv5 layer
    doesn't support byte-level operations. */
static bool stm32lx_eeprom_write(target *t, uint32_t address,
                                 size_t cb, uint32_t value)
{
 800780c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800780e:	6d05      	ldr	r5, [r0, #80]	; 0x50
 8007810:	b085      	sub	sp, #20
 8007812:	1c04      	adds	r4, r0, #0
        const uint32_t nvm        = stm32lx_nvm_phys(t);
 8007814:	1c28      	adds	r0, r5, #0
    complete.  The return value is true if the write succeeded.
    FWIW, byte writing isn't supported because the adiv5 layer
    doesn't support byte-level operations. */
static bool stm32lx_eeprom_write(target *t, uint32_t address,
                                 size_t cb, uint32_t value)
{
 8007816:	1c0e      	adds	r6, r1, #0
 8007818:	1c17      	adds	r7, r2, #0
 800781a:	9301      	str	r3, [sp, #4]
        const uint32_t nvm        = stm32lx_nvm_phys(t);
 800781c:	f7ff fd64 	bl	80072e8 <stm32lx_nvm_phys.isra.2>
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return false;
        default:                      /* STM32L1xx */
                return true;
 8007820:	4b1f      	ldr	r3, [pc, #124]	; (80078a0 <stm32lx_eeprom_write+0x94>)
    FWIW, byte writing isn't supported because the adiv5 layer
    doesn't support byte-level operations. */
static bool stm32lx_eeprom_write(target *t, uint32_t address,
                                 size_t cb, uint32_t value)
{
        const uint32_t nvm        = stm32lx_nvm_phys(t);
 8007822:	9002      	str	r0, [sp, #8]
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return false;
        default:                      /* STM32L1xx */
                return true;
 8007824:	18ed      	adds	r5, r5, r3
 8007826:	1c2b      	adds	r3, r5, #0
 8007828:	1e5d      	subs	r5, r3, #1
 800782a:	41ab      	sbcs	r3, r5
{
        const uint32_t nvm        = stm32lx_nvm_phys(t);
        const bool     is_stm32l1 = stm32lx_is_stm32l1(t);

        /* Clear errors. */
        target_mem_write32(t, STM32Lx_NVM_SR(nvm), STM32Lx_NVM_SR_ERR_M);
 800782c:	1c05      	adds	r5, r0, #0
 800782e:	3518      	adds	r5, #24
 8007830:	1c29      	adds	r1, r5, #0
 8007832:	4a1c      	ldr	r2, [pc, #112]	; (80078a4 <stm32lx_eeprom_write+0x98>)
 8007834:	1c20      	adds	r0, r4, #0
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return false;
        default:                      /* STM32L1xx */
                return true;
 8007836:	9303      	str	r3, [sp, #12]
{
        const uint32_t nvm        = stm32lx_nvm_phys(t);
        const bool     is_stm32l1 = stm32lx_is_stm32l1(t);

        /* Clear errors. */
        target_mem_write32(t, STM32Lx_NVM_SR(nvm), STM32Lx_NVM_SR_ERR_M);
 8007838:	f000 fe80 	bl	800853c <target_mem_write32>

        /* Erase and program option in one go. */
        target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
 800783c:	9902      	ldr	r1, [sp, #8]
 800783e:	9b03      	ldr	r3, [sp, #12]
 8007840:	3104      	adds	r1, #4
 8007842:	2288      	movs	r2, #136	; 0x88
 8007844:	2b00      	cmp	r3, #0
 8007846:	d000      	beq.n	800784a <stm32lx_eeprom_write+0x3e>
 8007848:	2280      	movs	r2, #128	; 0x80
 800784a:	0052      	lsls	r2, r2, #1
 800784c:	1c20      	adds	r0, r4, #0
 800784e:	f000 fe75 	bl	800853c <target_mem_write32>
                           (is_stm32l1 ? 0 : STM32Lx_NVM_PECR_DATA)
                           | STM32Lx_NVM_PECR_FIX);
        if (cb == 4)
 8007852:	2f04      	cmp	r7, #4
 8007854:	d105      	bne.n	8007862 <stm32lx_eeprom_write+0x56>
                target_mem_write32(t, address, value);
 8007856:	1c20      	adds	r0, r4, #0
 8007858:	1c31      	adds	r1, r6, #0
 800785a:	9a01      	ldr	r2, [sp, #4]
 800785c:	f000 fe6e 	bl	800853c <target_mem_write32>
 8007860:	e011      	b.n	8007886 <stm32lx_eeprom_write+0x7a>
        else if (cb == 2)
 8007862:	2f02      	cmp	r7, #2
 8007864:	d106      	bne.n	8007874 <stm32lx_eeprom_write+0x68>
                target_mem_write16(t, address, value);
 8007866:	466b      	mov	r3, sp
 8007868:	1c20      	adds	r0, r4, #0
 800786a:	889a      	ldrh	r2, [r3, #4]
 800786c:	1c31      	adds	r1, r6, #0
 800786e:	f000 fe76 	bl	800855e <target_mem_write16>
 8007872:	e008      	b.n	8007886 <stm32lx_eeprom_write+0x7a>
        else if (cb == 1)
                target_mem_write8(t, address, value);
        else
                return false;
 8007874:	2000      	movs	r0, #0
                           | STM32Lx_NVM_PECR_FIX);
        if (cb == 4)
                target_mem_write32(t, address, value);
        else if (cb == 2)
                target_mem_write16(t, address, value);
        else if (cb == 1)
 8007876:	2f01      	cmp	r7, #1
 8007878:	d110      	bne.n	800789c <stm32lx_eeprom_write+0x90>
                target_mem_write8(t, address, value);
 800787a:	466b      	mov	r3, sp
 800787c:	1c20      	adds	r0, r4, #0
 800787e:	791a      	ldrb	r2, [r3, #4]
 8007880:	1c31      	adds	r1, r6, #0
 8007882:	f000 fe7f 	bl	8008584 <target_mem_write8>
        else
                return false;

        uint32_t sr;
        do {
                sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
 8007886:	1c20      	adds	r0, r4, #0
 8007888:	1c29      	adds	r1, r5, #0
 800788a:	f000 fe4f 	bl	800852c <target_mem_read32>
        } while (sr & STM32Lx_NVM_SR_BSY);
 800788e:	07c3      	lsls	r3, r0, #31
 8007890:	d4f9      	bmi.n	8007886 <stm32lx_eeprom_write+0x7a>

        return !(sr & STM32Lx_NVM_SR_ERR_M);
 8007892:	4b04      	ldr	r3, [pc, #16]	; (80078a4 <stm32lx_eeprom_write+0x98>)
 8007894:	4018      	ands	r0, r3
 8007896:	4243      	negs	r3, r0
 8007898:	4158      	adcs	r0, r3
 800789a:	b2c0      	uxtb	r0, r0
}
 800789c:	b005      	add	sp, #20
 800789e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80078a0:	fffffbe9 	.word	0xfffffbe9
 80078a4:	00010700 	.word	0x00010700

080078a8 <stm32lx_cmd_eeprom>:
        return true;
}


static bool stm32lx_cmd_eeprom(target* t, int argc, char** argv)
{
 80078a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80078aa:	1c04      	adds	r4, r0, #0
        const uint32_t nvm = stm32lx_nvm_phys(t);
 80078ac:	6d00      	ldr	r0, [r0, #80]	; 0x50
        return true;
}


static bool stm32lx_cmd_eeprom(target* t, int argc, char** argv)
{
 80078ae:	1c0d      	adds	r5, r1, #0
 80078b0:	1c17      	adds	r7, r2, #0
        const uint32_t nvm = stm32lx_nvm_phys(t);
 80078b2:	f7ff fd19 	bl	80072e8 <stm32lx_nvm_phys.isra.2>
 80078b6:	9001      	str	r0, [sp, #4]

        if (!stm32lx_nvm_prog_data_unlock(t, nvm)) {
 80078b8:	9901      	ldr	r1, [sp, #4]
 80078ba:	1c20      	adds	r0, r4, #0
 80078bc:	f7ff fcde 	bl	800727c <stm32lx_nvm_prog_data_unlock>
 80078c0:	2800      	cmp	r0, #0
 80078c2:	d104      	bne.n	80078ce <stm32lx_cmd_eeprom+0x26>
                tc_printf(t, "unable to unlock EEPROM\n");
 80078c4:	1c20      	adds	r0, r4, #0
 80078c6:	4947      	ldr	r1, [pc, #284]	; (80079e4 <stm32lx_cmd_eeprom+0x13c>)
 80078c8:	f000 fe8f 	bl	80085ea <tc_printf>
                return true;
 80078cc:	e088      	b.n	80079e0 <stm32lx_cmd_eeprom+0x138>
        }

        size_t cb = strlen(argv[1]);
 80078ce:	6878      	ldr	r0, [r7, #4]
 80078d0:	f005 faaa 	bl	800ce28 <strlen>
 80078d4:	9000      	str	r0, [sp, #0]

        if (argc == 4) {
 80078d6:	2d04      	cmp	r5, #4
 80078d8:	d15e      	bne.n	8007998 <stm32lx_cmd_eeprom+0xf0>
                uint32_t addr = strtoul(argv[2], NULL, 0);
 80078da:	2100      	movs	r1, #0
 80078dc:	68b8      	ldr	r0, [r7, #8]
 80078de:	1c0a      	adds	r2, r1, #0
 80078e0:	f005 fc7a 	bl	800d1d8 <strtoul>
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80078e4:	2100      	movs	r1, #0
        }

        size_t cb = strlen(argv[1]);

        if (argc == 4) {
                uint32_t addr = strtoul(argv[2], NULL, 0);
 80078e6:	1c05      	adds	r5, r0, #0
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80078e8:	1c0a      	adds	r2, r1, #0
 80078ea:	68f8      	ldr	r0, [r7, #12]
 80078ec:	f005 fc74 	bl	800d1d8 <strtoul>

                if (   addr <  STM32Lx_NVM_EEPROM_PHYS
 80078f0:	4b3d      	ldr	r3, [pc, #244]	; (80079e8 <stm32lx_cmd_eeprom+0x140>)

        size_t cb = strlen(argv[1]);

        if (argc == 4) {
                uint32_t addr = strtoul(argv[2], NULL, 0);
                uint32_t val  = strtoul(argv[3], NULL, 0);
 80078f2:	1c06      	adds	r6, r0, #0

                if (   addr <  STM32Lx_NVM_EEPROM_PHYS
 80078f4:	429d      	cmp	r5, r3
 80078f6:	d94f      	bls.n	8007998 <stm32lx_cmd_eeprom+0xf0>
        }
}

static uint32_t stm32lx_nvm_eeprom_size(target *t)
{
        switch (t->idcode) {
 80078f8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80078fa:	1e1a      	subs	r2, r3, #0
 80078fc:	4b3b      	ldr	r3, [pc, #236]	; (80079ec <stm32lx_cmd_eeprom+0x144>)
 80078fe:	429a      	cmp	r2, r3
 8007900:	d002      	beq.n	8007908 <stm32lx_cmd_eeprom+0x60>
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_EEPROM_SIZE;
        default:                      /* STM32L1xx */
                return STM32L1_NVM_EEPROM_SIZE;
 8007902:	2380      	movs	r3, #128	; 0x80
 8007904:	01db      	lsls	r3, r3, #7
 8007906:	e001      	b.n	800790c <stm32lx_cmd_eeprom+0x64>

static uint32_t stm32lx_nvm_eeprom_size(target *t)
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_EEPROM_SIZE;
 8007908:	2380      	movs	r3, #128	; 0x80
 800790a:	011b      	lsls	r3, r3, #4
                uint32_t addr = strtoul(argv[2], NULL, 0);
                uint32_t val  = strtoul(argv[3], NULL, 0);

                if (   addr <  STM32Lx_NVM_EEPROM_PHYS
                    || addr >= STM32Lx_NVM_EEPROM_PHYS
                       	        + stm32lx_nvm_eeprom_size(t))
 800790c:	4a38      	ldr	r2, [pc, #224]	; (80079f0 <stm32lx_cmd_eeprom+0x148>)
 800790e:	189b      	adds	r3, r3, r2
        if (argc == 4) {
                uint32_t addr = strtoul(argv[2], NULL, 0);
                uint32_t val  = strtoul(argv[3], NULL, 0);

                if (   addr <  STM32Lx_NVM_EEPROM_PHYS
                    || addr >= STM32Lx_NVM_EEPROM_PHYS
 8007910:	429d      	cmp	r5, r3
 8007912:	d241      	bcs.n	8007998 <stm32lx_cmd_eeprom+0xf0>
                       	        + stm32lx_nvm_eeprom_size(t))
                        goto usage;

                if (!strncasecmp(argv[1], "byte", cb)) {
 8007914:	687f      	ldr	r7, [r7, #4]
 8007916:	4937      	ldr	r1, [pc, #220]	; (80079f4 <stm32lx_cmd_eeprom+0x14c>)
 8007918:	1c38      	adds	r0, r7, #0
 800791a:	9a00      	ldr	r2, [sp, #0]
 800791c:	f005 fa8c 	bl	800ce38 <strncasecmp>
 8007920:	2800      	cmp	r0, #0
 8007922:	d112      	bne.n	800794a <stm32lx_cmd_eeprom+0xa2>
                        tc_printf(t, "write byte 0x%08x <- 0x%08x\n", addr, val);
 8007924:	1c20      	adds	r0, r4, #0
 8007926:	4934      	ldr	r1, [pc, #208]	; (80079f8 <stm32lx_cmd_eeprom+0x150>)
 8007928:	1c2a      	adds	r2, r5, #0
 800792a:	1c33      	adds	r3, r6, #0
 800792c:	f000 fe5d 	bl	80085ea <tc_printf>
                        if (!stm32lx_eeprom_write(t, addr, 1, val))
 8007930:	1c20      	adds	r0, r4, #0
 8007932:	1c29      	adds	r1, r5, #0
 8007934:	2201      	movs	r2, #1
 8007936:	1c33      	adds	r3, r6, #0
 8007938:	f7ff ff68 	bl	800780c <stm32lx_eeprom_write>
 800793c:	2800      	cmp	r0, #0
 800793e:	d14b      	bne.n	80079d8 <stm32lx_cmd_eeprom+0x130>
                                tc_printf(t, "eeprom write failed\n");
 8007940:	1c20      	adds	r0, r4, #0
 8007942:	492e      	ldr	r1, [pc, #184]	; (80079fc <stm32lx_cmd_eeprom+0x154>)
 8007944:	f000 fe51 	bl	80085ea <tc_printf>
 8007948:	e046      	b.n	80079d8 <stm32lx_cmd_eeprom+0x130>
                } else if (!strncasecmp(argv[1], "halfword", cb)) {
 800794a:	1c38      	adds	r0, r7, #0
 800794c:	492c      	ldr	r1, [pc, #176]	; (8007a00 <stm32lx_cmd_eeprom+0x158>)
 800794e:	9a00      	ldr	r2, [sp, #0]
 8007950:	f005 fa72 	bl	800ce38 <strncasecmp>
 8007954:	2800      	cmp	r0, #0
 8007956:	d10c      	bne.n	8007972 <stm32lx_cmd_eeprom+0xca>
                        val &= 0xffff;
 8007958:	b2b6      	uxth	r6, r6
                        tc_printf(t, "write halfword 0x%08x <- 0x%04x\n",
 800795a:	1c33      	adds	r3, r6, #0
 800795c:	1c20      	adds	r0, r4, #0
 800795e:	4929      	ldr	r1, [pc, #164]	; (8007a04 <stm32lx_cmd_eeprom+0x15c>)
 8007960:	1c2a      	adds	r2, r5, #0
 8007962:	f000 fe42 	bl	80085ea <tc_printf>
                                 addr, val);
                        if (addr & 1)
 8007966:	07eb      	lsls	r3, r5, #31
 8007968:	d416      	bmi.n	8007998 <stm32lx_cmd_eeprom+0xf0>
                                goto usage;
                        if (!stm32lx_eeprom_write(t, addr, 2, val))
 800796a:	1c20      	adds	r0, r4, #0
 800796c:	1c29      	adds	r1, r5, #0
 800796e:	2202      	movs	r2, #2
 8007970:	e7e1      	b.n	8007936 <stm32lx_cmd_eeprom+0x8e>
                                tc_printf(t, "eeprom write failed\n");
                } else if (!strncasecmp(argv[1], "word", cb)) {
 8007972:	1c38      	adds	r0, r7, #0
 8007974:	4924      	ldr	r1, [pc, #144]	; (8007a08 <stm32lx_cmd_eeprom+0x160>)
 8007976:	9a00      	ldr	r2, [sp, #0]
 8007978:	f005 fa5e 	bl	800ce38 <strncasecmp>
 800797c:	2800      	cmp	r0, #0
 800797e:	d10b      	bne.n	8007998 <stm32lx_cmd_eeprom+0xf0>
                        tc_printf(t, "write word 0x%08x <- 0x%08x\n", addr, val);
 8007980:	1c33      	adds	r3, r6, #0
 8007982:	1c20      	adds	r0, r4, #0
 8007984:	4921      	ldr	r1, [pc, #132]	; (8007a0c <stm32lx_cmd_eeprom+0x164>)
 8007986:	1c2a      	adds	r2, r5, #0
 8007988:	f000 fe2f 	bl	80085ea <tc_printf>
                        if (addr & 3)
 800798c:	07ab      	lsls	r3, r5, #30
 800798e:	d103      	bne.n	8007998 <stm32lx_cmd_eeprom+0xf0>
                                goto usage;
                        if (!stm32lx_eeprom_write(t, addr, 4, val))
 8007990:	1c20      	adds	r0, r4, #0
 8007992:	1c29      	adds	r1, r5, #0
 8007994:	2204      	movs	r2, #4
 8007996:	e7ce      	b.n	8007936 <stm32lx_cmd_eeprom+0x8e>
                goto usage;

        goto done;

usage:
        tc_printf(t, "usage: monitor eeprom [ARGS]\n");
 8007998:	1c20      	adds	r0, r4, #0
 800799a:	491d      	ldr	r1, [pc, #116]	; (8007a10 <stm32lx_cmd_eeprom+0x168>)
 800799c:	f000 fe25 	bl	80085ea <tc_printf>
        tc_printf(t, "  byte     <addr> <value8>  - Write a byte\n");
 80079a0:	1c20      	adds	r0, r4, #0
 80079a2:	491c      	ldr	r1, [pc, #112]	; (8007a14 <stm32lx_cmd_eeprom+0x16c>)
 80079a4:	f000 fe21 	bl	80085ea <tc_printf>
        tc_printf(t, "  halfword <addr> <value16> - Write a half-word\n");
 80079a8:	1c20      	adds	r0, r4, #0
 80079aa:	491b      	ldr	r1, [pc, #108]	; (8007a18 <stm32lx_cmd_eeprom+0x170>)
 80079ac:	f000 fe1d 	bl	80085ea <tc_printf>
        tc_printf(t, "  word     <addr> <value32> - Write a word\n");
 80079b0:	1c20      	adds	r0, r4, #0
 80079b2:	491a      	ldr	r1, [pc, #104]	; (8007a1c <stm32lx_cmd_eeprom+0x174>)
 80079b4:	f000 fe19 	bl	80085ea <tc_printf>
        }
}

static uint32_t stm32lx_nvm_eeprom_size(target *t)
{
        switch (t->idcode) {
 80079b8:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80079ba:	1e1a      	subs	r2, r3, #0
 80079bc:	4b0b      	ldr	r3, [pc, #44]	; (80079ec <stm32lx_cmd_eeprom+0x144>)
 80079be:	429a      	cmp	r2, r3
 80079c0:	d002      	beq.n	80079c8 <stm32lx_cmd_eeprom+0x120>
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_EEPROM_SIZE;
        default:                      /* STM32L1xx */
                return STM32L1_NVM_EEPROM_SIZE;
 80079c2:	2380      	movs	r3, #128	; 0x80
 80079c4:	01db      	lsls	r3, r3, #7
 80079c6:	e001      	b.n	80079cc <stm32lx_cmd_eeprom+0x124>

static uint32_t stm32lx_nvm_eeprom_size(target *t)
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return STM32L0_NVM_EEPROM_SIZE;
 80079c8:	2380      	movs	r3, #128	; 0x80
 80079ca:	011b      	lsls	r3, r3, #4
usage:
        tc_printf(t, "usage: monitor eeprom [ARGS]\n");
        tc_printf(t, "  byte     <addr> <value8>  - Write a byte\n");
        tc_printf(t, "  halfword <addr> <value16> - Write a half-word\n");
        tc_printf(t, "  word     <addr> <value32> - Write a word\n");
        tc_printf(t, "The value of <addr> must in the interval [0x%08x, 0x%x)\n",
 80079cc:	4a08      	ldr	r2, [pc, #32]	; (80079f0 <stm32lx_cmd_eeprom+0x148>)
 80079ce:	1c20      	adds	r0, r4, #0
 80079d0:	189b      	adds	r3, r3, r2
 80079d2:	4913      	ldr	r1, [pc, #76]	; (8007a20 <stm32lx_cmd_eeprom+0x178>)
 80079d4:	f000 fe09 	bl	80085ea <tc_printf>
                  STM32Lx_NVM_EEPROM_PHYS,
                  STM32Lx_NVM_EEPROM_PHYS + stm32lx_nvm_eeprom_size(t));

done:
        stm32lx_nvm_lock(t, nvm);
 80079d8:	1c20      	adds	r0, r4, #0
 80079da:	9901      	ldr	r1, [sp, #4]
 80079dc:	f7ff fc7e 	bl	80072dc <stm32lx_nvm_lock>
        return true;
}
 80079e0:	2001      	movs	r0, #1
 80079e2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80079e4:	08013384 	.word	0x08013384
 80079e8:	0807ffff 	.word	0x0807ffff
 80079ec:	00000417 	.word	0x00000417
 80079f0:	08080000 	.word	0x08080000
 80079f4:	0801339d 	.word	0x0801339d
 80079f8:	080133a2 	.word	0x080133a2
 80079fc:	080133bf 	.word	0x080133bf
 8007a00:	080133d4 	.word	0x080133d4
 8007a04:	080133dd 	.word	0x080133dd
 8007a08:	080133d8 	.word	0x080133d8
 8007a0c:	080133fe 	.word	0x080133fe
 8007a10:	0801341b 	.word	0x0801341b
 8007a14:	08013439 	.word	0x08013439
 8007a18:	08013465 	.word	0x08013465
 8007a1c:	08013496 	.word	0x08013496
 8007a20:	080134c2 	.word	0x080134c2

08007a24 <stm32lx_nvm_data_write>:
    not). */
static int stm32lx_nvm_data_write(struct target_flash *f,
                                  target_addr destination,
                                  const void* src,
                                  size_t size)
{
 8007a24:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	target *t = f->t;
 8007a26:	6984      	ldr	r4, [r0, #24]
    not). */
static int stm32lx_nvm_data_write(struct target_flash *f,
                                  target_addr destination,
                                  const void* src,
                                  size_t size)
{
 8007a28:	1c0f      	adds	r7, r1, #0
 8007a2a:	6d25      	ldr	r5, [r4, #80]	; 0x50
 8007a2c:	9200      	str	r2, [sp, #0]
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
 8007a2e:	1c28      	adds	r0, r5, #0
    not). */
static int stm32lx_nvm_data_write(struct target_flash *f,
                                  target_addr destination,
                                  const void* src,
                                  size_t size)
{
 8007a30:	9301      	str	r3, [sp, #4]
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
 8007a32:	f7ff fc59 	bl	80072e8 <stm32lx_nvm_phys.isra.2>
 8007a36:	1c06      	adds	r6, r0, #0
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return false;
        default:                      /* STM32L1xx */
                return true;
 8007a38:	4b1c      	ldr	r3, [pc, #112]	; (8007aac <stm32lx_nvm_data_write+0x88>)
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
	const bool is_stm32l1 = stm32lx_is_stm32l1(t);
	uint32_t* source = (uint32_t*) src;

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 8007a3a:	1c20      	adds	r0, r4, #0
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return false;
        default:                      /* STM32L1xx */
                return true;
 8007a3c:	18ed      	adds	r5, r5, r3
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
	const bool is_stm32l1 = stm32lx_is_stm32l1(t);
	uint32_t* source = (uint32_t*) src;

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 8007a3e:	1c31      	adds	r1, r6, #0
{
        switch (t->idcode) {
        case 0x417:                   /* STM32L0xx */
                return false;
        default:                      /* STM32L1xx */
                return true;
 8007a40:	1e6a      	subs	r2, r5, #1
 8007a42:	4195      	sbcs	r5, r2
	target *t = f->t;
	const uint32_t nvm = stm32lx_nvm_phys(t);
	const bool is_stm32l1 = stm32lx_is_stm32l1(t);
	uint32_t* source = (uint32_t*) src;

	if (!stm32lx_nvm_prog_data_unlock(t, nvm))
 8007a44:	f7ff fc1a 	bl	800727c <stm32lx_nvm_prog_data_unlock>
 8007a48:	2800      	cmp	r0, #0
 8007a4a:	d101      	bne.n	8007a50 <stm32lx_nvm_data_write+0x2c>
		return -1;
 8007a4c:	2001      	movs	r0, #1
 8007a4e:	e02b      	b.n	8007aa8 <stm32lx_nvm_data_write+0x84>

	target_mem_write32(t, STM32Lx_NVM_PECR(nvm),
 8007a50:	426a      	negs	r2, r5
 8007a52:	416a      	adcs	r2, r5
 8007a54:	1d31      	adds	r1, r6, #4
 8007a56:	0112      	lsls	r2, r2, #4
 8007a58:	1c20      	adds	r0, r4, #0
 8007a5a:	f000 fd6f 	bl	800853c <target_mem_write32>
	                   is_stm32l1 ? 0 : STM32Lx_NVM_PECR_DATA);

	while (size) {
 8007a5e:	1c3d      	adds	r5, r7, #0
 8007a60:	9b01      	ldr	r3, [sp, #4]
 8007a62:	18fb      	adds	r3, r7, r3
 8007a64:	42ab      	cmp	r3, r5
 8007a66:	d00d      	beq.n	8007a84 <stm32lx_nvm_data_write+0x60>
 8007a68:	9b00      	ldr	r3, [sp, #0]
		size -= 4;
		uint32_t v = *source++;
		target_mem_write32(t, destination, v);
 8007a6a:	1c20      	adds	r0, r4, #0
 8007a6c:	1bdb      	subs	r3, r3, r7
 8007a6e:	1c29      	adds	r1, r5, #0
 8007a70:	595a      	ldr	r2, [r3, r5]
 8007a72:	f000 fd63 	bl	800853c <target_mem_write32>
		destination += 4;

		if (target_check_error(t))
 8007a76:	1c20      	adds	r0, r4, #0

	while (size) {
		size -= 4;
		uint32_t v = *source++;
		target_mem_write32(t, destination, v);
		destination += 4;
 8007a78:	3504      	adds	r5, #4

		if (target_check_error(t))
 8007a7a:	f000 fccd 	bl	8008418 <target_check_error>
 8007a7e:	2800      	cmp	r0, #0
 8007a80:	d0ee      	beq.n	8007a60 <stm32lx_nvm_data_write+0x3c>
 8007a82:	e7e3      	b.n	8007a4c <stm32lx_nvm_data_write+0x28>
			return -1;
	}

	/* Disable further programming by locking PECR */
	stm32lx_nvm_lock(t, nvm);
 8007a84:	1c20      	adds	r0, r4, #0
 8007a86:	1c31      	adds	r1, r6, #0
 8007a88:	f7ff fc28 	bl	80072dc <stm32lx_nvm_lock>

	/* Wait for completion or an error */
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
 8007a8c:	1c31      	adds	r1, r6, #0
 8007a8e:	1c20      	adds	r0, r4, #0
 8007a90:	3118      	adds	r1, #24
 8007a92:	f000 fd4b 	bl	800852c <target_mem_read32>
	} while (sr & STM32Lx_NVM_SR_BSY);
 8007a96:	07c3      	lsls	r3, r0, #31
 8007a98:	d4f8      	bmi.n	8007a8c <stm32lx_nvm_data_write+0x68>

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 8007a9a:	4b05      	ldr	r3, [pc, #20]	; (8007ab0 <stm32lx_nvm_data_write+0x8c>)
 8007a9c:	4018      	ands	r0, r3
 8007a9e:	2802      	cmp	r0, #2
 8007aa0:	d1d4      	bne.n	8007a4c <stm32lx_nvm_data_write+0x28>
	    target_check_error(t))
 8007aa2:	1c20      	adds	r0, r4, #0
 8007aa4:	f000 fcb8 	bl	8008418 <target_check_error>
	uint32_t sr;
	do {
		sr = target_mem_read32(t, STM32Lx_NVM_SR(nvm));
	} while (sr & STM32Lx_NVM_SR_BSY);

	if ((sr & STM32Lx_NVM_SR_ERR_M) || !(sr & STM32Lx_NVM_SR_EOP) ||
 8007aa8:	4240      	negs	r0, r0
	    target_check_error(t))
			return -1;

	return 0;
}
 8007aaa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8007aac:	fffffbe9 	.word	0xfffffbe9
 8007ab0:	00010702 	.word	0x00010702

08007ab4 <stm32l0_probe>:

/** Query MCU memory for an indication as to whether or not the
    currently attached target is served by this module.  We detect the
    STM32L0xx parts as well as the STM32L1xx's. */
bool stm32l0_probe(target* t)
{
 8007ab4:	b570      	push	{r4, r5, r6, lr}
	uint32_t idcode;

	idcode = target_mem_read32(t, STM32L1_DBGMCU_IDCODE_PHYS) & 0xfff;
 8007ab6:	4930      	ldr	r1, [pc, #192]	; (8007b78 <stm32l0_probe+0xc4>)

/** Query MCU memory for an indication as to whether or not the
    currently attached target is served by this module.  We detect the
    STM32L0xx parts as well as the STM32L1xx's. */
bool stm32l0_probe(target* t)
{
 8007ab8:	1c04      	adds	r4, r0, #0
	uint32_t idcode;

	idcode = target_mem_read32(t, STM32L1_DBGMCU_IDCODE_PHYS) & 0xfff;
 8007aba:	f000 fd37 	bl	800852c <target_mem_read32>
	switch (idcode) {
 8007abe:	4b2f      	ldr	r3, [pc, #188]	; (8007b7c <stm32l0_probe+0xc8>)
    STM32L0xx parts as well as the STM32L1xx's. */
bool stm32l0_probe(target* t)
{
	uint32_t idcode;

	idcode = target_mem_read32(t, STM32L1_DBGMCU_IDCODE_PHYS) & 0xfff;
 8007ac0:	0500      	lsls	r0, r0, #20
 8007ac2:	0d00      	lsrs	r0, r0, #20
	switch (idcode) {
 8007ac4:	4298      	cmp	r0, r3
 8007ac6:	d00b      	beq.n	8007ae0 <stm32l0_probe+0x2c>
 8007ac8:	d806      	bhi.n	8007ad8 <stm32l0_probe+0x24>
 8007aca:	4b2d      	ldr	r3, [pc, #180]	; (8007b80 <stm32l0_probe+0xcc>)
 8007acc:	4298      	cmp	r0, r3
 8007ace:	d007      	beq.n	8007ae0 <stm32l0_probe+0x2c>
 8007ad0:	4b2c      	ldr	r3, [pc, #176]	; (8007b84 <stm32l0_probe+0xd0>)
 8007ad2:	4298      	cmp	r0, r3
 8007ad4:	d11c      	bne.n	8007b10 <stm32l0_probe+0x5c>
 8007ad6:	e003      	b.n	8007ae0 <stm32l0_probe+0x2c>
 8007ad8:	4b2b      	ldr	r3, [pc, #172]	; (8007b88 <stm32l0_probe+0xd4>)
 8007ada:	18c3      	adds	r3, r0, r3
 8007adc:	2b01      	cmp	r3, #1
 8007ade:	d817      	bhi.n	8007b10 <stm32l0_probe+0x5c>
	case 0x427:                   /* CAT. 3 device */
	case 0x436:                   /* CAT. 4 device */
	case 0x437:                   /* CAT. 5 device  */
		t->idcode = idcode;
		t->driver = "STM32L1x";
		target_add_ram(t, 0x20000000, 0x14000);
 8007ae0:	2180      	movs	r1, #128	; 0x80
 8007ae2:	22a0      	movs	r2, #160	; 0xa0
	case 0x429:                   /* CAT. 2 device */
	case 0x427:                   /* CAT. 3 device */
	case 0x436:                   /* CAT. 4 device */
	case 0x437:                   /* CAT. 5 device  */
		t->idcode = idcode;
		t->driver = "STM32L1x";
 8007ae4:	4d29      	ldr	r5, [pc, #164]	; (8007b8c <stm32l0_probe+0xd8>)
	case 0x416:                   /* CAT. 1 device */
	case 0x429:                   /* CAT. 2 device */
	case 0x427:                   /* CAT. 3 device */
	case 0x436:                   /* CAT. 4 device */
	case 0x437:                   /* CAT. 5 device  */
		t->idcode = idcode;
 8007ae6:	6520      	str	r0, [r4, #80]	; 0x50
		t->driver = "STM32L1x";
		target_add_ram(t, 0x20000000, 0x14000);
 8007ae8:	0589      	lsls	r1, r1, #22
 8007aea:	1c20      	adds	r0, r4, #0
 8007aec:	0252      	lsls	r2, r2, #9
	case 0x429:                   /* CAT. 2 device */
	case 0x427:                   /* CAT. 3 device */
	case 0x436:                   /* CAT. 4 device */
	case 0x437:                   /* CAT. 5 device  */
		t->idcode = idcode;
		t->driver = "STM32L1x";
 8007aee:	6625      	str	r5, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x14000);
 8007af0:	f000 fb20 	bl	8008134 <target_add_ram>
		stm32l_add_flash(t, 0x8000000, 0x80000, 0x100);
 8007af4:	2180      	movs	r1, #128	; 0x80
 8007af6:	2280      	movs	r2, #128	; 0x80
 8007af8:	1c20      	adds	r0, r4, #0
 8007afa:	0309      	lsls	r1, r1, #12
 8007afc:	0052      	lsls	r2, r2, #1
 8007afe:	f7ff fe61 	bl	80077c4 <stm32l_add_flash.constprop.5>
		//stm32l_add_eeprom(t, 0x8080000, 0x4000);
		target_add_commands(t, stm32lx_cmd_list, "STM32L1x");
 8007b02:	1c20      	adds	r0, r4, #0
 8007b04:	1c2a      	adds	r2, r5, #0
 8007b06:	4922      	ldr	r1, [pc, #136]	; (8007b90 <stm32l0_probe+0xdc>)
 8007b08:	f000 fad4 	bl	80080b4 <target_add_commands>
		return true;
 8007b0c:	2001      	movs	r0, #1
 8007b0e:	e032      	b.n	8007b76 <stm32l0_probe+0xc2>
	}

	idcode = target_mem_read32(t, STM32L0_DBGMCU_IDCODE_PHYS) & 0xfff;
 8007b10:	1c20      	adds	r0, r4, #0
 8007b12:	4920      	ldr	r1, [pc, #128]	; (8007b94 <stm32l0_probe+0xe0>)
 8007b14:	f000 fd0a 	bl	800852c <target_mem_read32>
	switch (idcode) {
 8007b18:	4b1f      	ldr	r3, [pc, #124]	; (8007b98 <stm32l0_probe+0xe4>)
		//stm32l_add_eeprom(t, 0x8080000, 0x4000);
		target_add_commands(t, stm32lx_cmd_list, "STM32L1x");
		return true;
	}

	idcode = target_mem_read32(t, STM32L0_DBGMCU_IDCODE_PHYS) & 0xfff;
 8007b1a:	0500      	lsls	r0, r0, #20
 8007b1c:	0d00      	lsrs	r0, r0, #20
	switch (idcode) {
 8007b1e:	4298      	cmp	r0, r3
 8007b20:	d128      	bne.n	8007b74 <stm32l0_probe+0xc0>
	case 0x417:                   /* STM32L0x[123] & probably others */
		t->idcode = idcode;
		t->driver = "STM32L0x";
		target_add_ram(t, 0x20000000, 0x2000);
 8007b22:	2180      	movs	r1, #128	; 0x80
 8007b24:	2280      	movs	r2, #128	; 0x80

	idcode = target_mem_read32(t, STM32L0_DBGMCU_IDCODE_PHYS) & 0xfff;
	switch (idcode) {
	case 0x417:                   /* STM32L0x[123] & probably others */
		t->idcode = idcode;
		t->driver = "STM32L0x";
 8007b26:	4e1d      	ldr	r6, [pc, #116]	; (8007b9c <stm32l0_probe+0xe8>)
	}

	idcode = target_mem_read32(t, STM32L0_DBGMCU_IDCODE_PHYS) & 0xfff;
	switch (idcode) {
	case 0x417:                   /* STM32L0x[123] & probably others */
		t->idcode = idcode;
 8007b28:	6520      	str	r0, [r4, #80]	; 0x50
		t->driver = "STM32L0x";
		target_add_ram(t, 0x20000000, 0x2000);
 8007b2a:	0589      	lsls	r1, r1, #22
 8007b2c:	1c20      	adds	r0, r4, #0
 8007b2e:	0192      	lsls	r2, r2, #6

	idcode = target_mem_read32(t, STM32L0_DBGMCU_IDCODE_PHYS) & 0xfff;
	switch (idcode) {
	case 0x417:                   /* STM32L0x[123] & probably others */
		t->idcode = idcode;
		t->driver = "STM32L0x";
 8007b30:	6626      	str	r6, [r4, #96]	; 0x60
		target_add_ram(t, 0x20000000, 0x2000);
 8007b32:	f000 faff 	bl	8008134 <target_add_ram>
		stm32l_add_flash(t, 0x8000000, 0x10000, 0x80);
 8007b36:	2180      	movs	r1, #128	; 0x80
 8007b38:	2280      	movs	r2, #128	; 0x80
 8007b3a:	1c20      	adds	r0, r4, #0
 8007b3c:	0249      	lsls	r1, r1, #9
 8007b3e:	f7ff fe41 	bl	80077c4 <stm32l_add_flash.constprop.5>
	target_add_flash(t, f);
}

static void stm32l_add_eeprom(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8007b42:	2138      	movs	r1, #56	; 0x38
 8007b44:	2001      	movs	r0, #1
 8007b46:	f004 fe97 	bl	800c878 <calloc>
	f->start = addr;
 8007b4a:	4b15      	ldr	r3, [pc, #84]	; (8007ba0 <stm32l0_probe+0xec>)
	f->length = length;
	f->blocksize = 4;
	f->erase = stm32lx_nvm_data_erase;
	f->write = stm32lx_nvm_data_write;
	f->align = 1;
 8007b4c:	2501      	movs	r5, #1
}

static void stm32l_add_eeprom(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
 8007b4e:	6003      	str	r3, [r0, #0]
	f->length = length;
 8007b50:	2380      	movs	r3, #128	; 0x80
 8007b52:	011b      	lsls	r3, r3, #4
 8007b54:	6043      	str	r3, [r0, #4]
	f->blocksize = 4;
 8007b56:	2304      	movs	r3, #4
 8007b58:	6083      	str	r3, [r0, #8]
	f->erase = stm32lx_nvm_data_erase;
 8007b5a:	4b12      	ldr	r3, [pc, #72]	; (8007ba4 <stm32l0_probe+0xf0>)
	target_add_flash(t, f);
}

static void stm32l_add_eeprom(target *t, uint32_t addr, size_t length)
{
	struct target_flash *f = calloc(1, sizeof(*f));
 8007b5c:	1c01      	adds	r1, r0, #0
	f->start = addr;
	f->length = length;
	f->blocksize = 4;
	f->erase = stm32lx_nvm_data_erase;
 8007b5e:	60c3      	str	r3, [r0, #12]
	f->write = stm32lx_nvm_data_write;
 8007b60:	4b11      	ldr	r3, [pc, #68]	; (8007ba8 <stm32l0_probe+0xf4>)
	f->align = 1;
 8007b62:	6205      	str	r5, [r0, #32]
	struct target_flash *f = calloc(1, sizeof(*f));
	f->start = addr;
	f->length = length;
	f->blocksize = 4;
	f->erase = stm32lx_nvm_data_erase;
	f->write = stm32lx_nvm_data_write;
 8007b64:	6103      	str	r3, [r0, #16]
	f->align = 1;
	target_add_flash(t, f);
 8007b66:	1c20      	adds	r0, r4, #0
 8007b68:	f000 faf1 	bl	800814e <target_add_flash>
		t->idcode = idcode;
		t->driver = "STM32L0x";
		target_add_ram(t, 0x20000000, 0x2000);
		stm32l_add_flash(t, 0x8000000, 0x10000, 0x80);
		stm32l_add_eeprom(t, 0x8080000, 0x800);
		target_add_commands(t, stm32lx_cmd_list, "STM32L0x");
 8007b6c:	1c20      	adds	r0, r4, #0
 8007b6e:	4908      	ldr	r1, [pc, #32]	; (8007b90 <stm32l0_probe+0xdc>)
 8007b70:	1c32      	adds	r2, r6, #0
 8007b72:	e7c9      	b.n	8007b08 <stm32l0_probe+0x54>
		return true;
	}

	return false;
 8007b74:	2000      	movs	r0, #0
}
 8007b76:	bd70      	pop	{r4, r5, r6, pc}
 8007b78:	e0042000 	.word	0xe0042000
 8007b7c:	00000429 	.word	0x00000429
 8007b80:	00000416 	.word	0x00000416
 8007b84:	00000427 	.word	0x00000427
 8007b88:	fffffbca 	.word	0xfffffbca
 8007b8c:	080134fb 	.word	0x080134fb
 8007b90:	080130f8 	.word	0x080130f8
 8007b94:	40015800 	.word	0x40015800
 8007b98:	00000417 	.word	0x00000417
 8007b9c:	08013504 	.word	0x08013504
 8007ba0:	08080000 	.word	0x08080000
 8007ba4:	080073e1 	.word	0x080073e1
 8007ba8:	08007a25 	.word	0x08007a25

08007bac <stm32l4_cmd_option>:
{
	return stm32l4_cmd_erase(t, FLASH_CR_MER2);
}

static bool stm32l4_cmd_option(target *t, int argc, char *argv[])
{
 8007bac:	b538      	push	{r3, r4, r5, lr}
 8007bae:	1c05      	adds	r5, r0, #0
 8007bb0:	4c0f      	ldr	r4, [pc, #60]	; (8007bf0 <stm32l4_cmd_option+0x44>)

	(void) argc;
	(void) argv;
	for (int i = 0; i < 0x23; i += 8) {
		addr = 0x1fff7800 + i;
		val = target_mem_read32(t, addr);
 8007bb2:	1c21      	adds	r1, r4, #0
 8007bb4:	1c28      	adds	r0, r5, #0
 8007bb6:	f000 fcb9 	bl	800852c <target_mem_read32>
		tc_printf(t, "0x%08X: 0x%08x\n", addr, val);
 8007bba:	1c22      	adds	r2, r4, #0

	(void) argc;
	(void) argv;
	for (int i = 0; i < 0x23; i += 8) {
		addr = 0x1fff7800 + i;
		val = target_mem_read32(t, addr);
 8007bbc:	1c03      	adds	r3, r0, #0
		tc_printf(t, "0x%08X: 0x%08x\n", addr, val);
 8007bbe:	490d      	ldr	r1, [pc, #52]	; (8007bf4 <stm32l4_cmd_option+0x48>)
 8007bc0:	1c28      	adds	r0, r5, #0
 8007bc2:	f000 fd12 	bl	80085ea <tc_printf>
{
	uint32_t addr, val;

	(void) argc;
	(void) argv;
	for (int i = 0; i < 0x23; i += 8) {
 8007bc6:	4b0c      	ldr	r3, [pc, #48]	; (8007bf8 <stm32l4_cmd_option+0x4c>)
 8007bc8:	3408      	adds	r4, #8
 8007bca:	429c      	cmp	r4, r3
 8007bcc:	d1f1      	bne.n	8007bb2 <stm32l4_cmd_option+0x6>
 8007bce:	4c0b      	ldr	r4, [pc, #44]	; (8007bfc <stm32l4_cmd_option+0x50>)
		val = target_mem_read32(t, addr);
		tc_printf(t, "0x%08X: 0x%08x\n", addr, val);
	}
	for (int i = 8; i < 0x23; i += 8) {
		addr = 0x1ffff800 + i;
		val = target_mem_read32(t, addr);
 8007bd0:	1c21      	adds	r1, r4, #0
 8007bd2:	1c28      	adds	r0, r5, #0
 8007bd4:	f000 fcaa 	bl	800852c <target_mem_read32>
		tc_printf(t, "0x%08X: 0x%08X\n", addr, val);
 8007bd8:	1c22      	adds	r2, r4, #0
		val = target_mem_read32(t, addr);
		tc_printf(t, "0x%08X: 0x%08x\n", addr, val);
	}
	for (int i = 8; i < 0x23; i += 8) {
		addr = 0x1ffff800 + i;
		val = target_mem_read32(t, addr);
 8007bda:	1c03      	adds	r3, r0, #0
		tc_printf(t, "0x%08X: 0x%08X\n", addr, val);
 8007bdc:	4908      	ldr	r1, [pc, #32]	; (8007c00 <stm32l4_cmd_option+0x54>)
 8007bde:	1c28      	adds	r0, r5, #0
 8007be0:	f000 fd03 	bl	80085ea <tc_printf>
	for (int i = 0; i < 0x23; i += 8) {
		addr = 0x1fff7800 + i;
		val = target_mem_read32(t, addr);
		tc_printf(t, "0x%08X: 0x%08x\n", addr, val);
	}
	for (int i = 8; i < 0x23; i += 8) {
 8007be4:	4b07      	ldr	r3, [pc, #28]	; (8007c04 <stm32l4_cmd_option+0x58>)
 8007be6:	3408      	adds	r4, #8
 8007be8:	429c      	cmp	r4, r3
 8007bea:	d1f1      	bne.n	8007bd0 <stm32l4_cmd_option+0x24>
		addr = 0x1ffff800 + i;
		val = target_mem_read32(t, addr);
		tc_printf(t, "0x%08X: 0x%08X\n", addr, val);
	}
	return true;
}
 8007bec:	2001      	movs	r0, #1
 8007bee:	bd38      	pop	{r3, r4, r5, pc}
 8007bf0:	1fff7800 	.word	0x1fff7800
 8007bf4:	080135e4 	.word	0x080135e4
 8007bf8:	1fff7828 	.word	0x1fff7828
 8007bfc:	1ffff808 	.word	0x1ffff808
 8007c00:	080135f4 	.word	0x080135f4
 8007c04:	1ffff828 	.word	0x1ffff828

08007c08 <stm32l4_flash_write>:
	return 0;
}

static int stm32l4_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8007c08:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Write buffer to target ram call stub */
	target_mem_write(f->t, SRAM_BASE, stm32l4_flash_write_stub,
 8007c0a:	2580      	movs	r5, #128	; 0x80
	return 0;
}

static int stm32l4_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8007c0c:	1c04      	adds	r4, r0, #0
 8007c0e:	1c1e      	adds	r6, r3, #0
 8007c10:	b085      	sub	sp, #20
	/* Write buffer to target ram call stub */
	target_mem_write(f->t, SRAM_BASE, stm32l4_flash_write_stub,
 8007c12:	05ad      	lsls	r5, r5, #22
	                 sizeof(stm32l4_flash_write_stub));
	target_mem_write(f->t, STUB_BUFFER_BASE, src, len);
 8007c14:	4f0c      	ldr	r7, [pc, #48]	; (8007c48 <stm32l4_flash_write+0x40>)
	return 0;
}

static int stm32l4_flash_write(struct target_flash *f,
                               target_addr dest, const void *src, size_t len)
{
 8007c16:	9102      	str	r1, [sp, #8]
 8007c18:	9203      	str	r2, [sp, #12]
	/* Write buffer to target ram call stub */
	target_mem_write(f->t, SRAM_BASE, stm32l4_flash_write_stub,
 8007c1a:	1c29      	adds	r1, r5, #0
 8007c1c:	4a0b      	ldr	r2, [pc, #44]	; (8007c4c <stm32l4_flash_write+0x44>)
 8007c1e:	2364      	movs	r3, #100	; 0x64
 8007c20:	6980      	ldr	r0, [r0, #24]
 8007c22:	f000 fc07 	bl	8008434 <target_mem_write>
	                 sizeof(stm32l4_flash_write_stub));
	target_mem_write(f->t, STUB_BUFFER_BASE, src, len);
 8007c26:	1c39      	adds	r1, r7, #0
 8007c28:	9a03      	ldr	r2, [sp, #12]
 8007c2a:	1c33      	adds	r3, r6, #0
 8007c2c:	69a0      	ldr	r0, [r4, #24]
 8007c2e:	f000 fc01 	bl	8008434 <target_mem_write>
	return cortexm_run_stub(f->t, SRAM_BASE, dest,
 8007c32:	2300      	movs	r3, #0
 8007c34:	9600      	str	r6, [sp, #0]
 8007c36:	9301      	str	r3, [sp, #4]
 8007c38:	69a0      	ldr	r0, [r4, #24]
 8007c3a:	1c29      	adds	r1, r5, #0
 8007c3c:	9a02      	ldr	r2, [sp, #8]
 8007c3e:	1c3b      	adds	r3, r7, #0
 8007c40:	f7fa fc32 	bl	80024a8 <cortexm_run_stub>
	                        STUB_BUFFER_BASE, len, 0);
}
 8007c44:	b005      	add	sp, #20
 8007c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007c48:	20000068 	.word	0x20000068
 8007c4c:	08013538 	.word	0x08013538

08007c50 <stm32l4_flash_unlock>:
	}
	return false;
}

static void stm32l4_flash_unlock(target *t)
{
 8007c50:	b510      	push	{r4, lr}
	if (target_mem_read32(t, FLASH_CR) & FLASH_CR_LOCK) {
 8007c52:	4908      	ldr	r1, [pc, #32]	; (8007c74 <stm32l4_flash_unlock+0x24>)
	}
	return false;
}

static void stm32l4_flash_unlock(target *t)
{
 8007c54:	1c04      	adds	r4, r0, #0
	if (target_mem_read32(t, FLASH_CR) & FLASH_CR_LOCK) {
 8007c56:	f000 fc69 	bl	800852c <target_mem_read32>
 8007c5a:	2800      	cmp	r0, #0
 8007c5c:	da09      	bge.n	8007c72 <stm32l4_flash_unlock+0x22>
		/* Enable FPEC controller access */
		target_mem_write32(t, FLASH_KEYR, KEY1);
 8007c5e:	1c20      	adds	r0, r4, #0
 8007c60:	4905      	ldr	r1, [pc, #20]	; (8007c78 <stm32l4_flash_unlock+0x28>)
 8007c62:	4a06      	ldr	r2, [pc, #24]	; (8007c7c <stm32l4_flash_unlock+0x2c>)
 8007c64:	f000 fc6a 	bl	800853c <target_mem_write32>
		target_mem_write32(t, FLASH_KEYR, KEY2);
 8007c68:	1c20      	adds	r0, r4, #0
 8007c6a:	4903      	ldr	r1, [pc, #12]	; (8007c78 <stm32l4_flash_unlock+0x28>)
 8007c6c:	4a04      	ldr	r2, [pc, #16]	; (8007c80 <stm32l4_flash_unlock+0x30>)
 8007c6e:	f000 fc65 	bl	800853c <target_mem_write32>
	}
}
 8007c72:	bd10      	pop	{r4, pc}
 8007c74:	40022014 	.word	0x40022014
 8007c78:	40022008 	.word	0x40022008
 8007c7c:	45670123 	.word	0x45670123
 8007c80:	cdef89ab 	.word	0xcdef89ab

08007c84 <stm32l4_cmd_erase>:
	return cortexm_run_stub(f->t, SRAM_BASE, dest,
	                        STUB_BUFFER_BASE, len, 0);
}

static bool stm32l4_cmd_erase(target *t, uint32_t action)
{
 8007c84:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007c86:	1c04      	adds	r4, r0, #0
 8007c88:	1c0d      	adds	r5, r1, #0
	const char spinner[] = "|/-\\";
 8007c8a:	2205      	movs	r2, #5
 8007c8c:	4920      	ldr	r1, [pc, #128]	; (8007d10 <stm32l4_cmd_erase+0x8c>)
 8007c8e:	4668      	mov	r0, sp
 8007c90:	f004 fe12 	bl	800c8b8 <memcpy>
	int spinindex = 0;

	tc_printf(t, "Erasing flash... This may take a few seconds.  ");
 8007c94:	491f      	ldr	r1, [pc, #124]	; (8007d14 <stm32l4_cmd_erase+0x90>)
 8007c96:	1c20      	adds	r0, r4, #0
 8007c98:	f000 fca7 	bl	80085ea <tc_printf>
	stm32l4_flash_unlock(t);
 8007c9c:	1c20      	adds	r0, r4, #0
 8007c9e:	f7ff ffd7 	bl	8007c50 <stm32l4_flash_unlock>

	/* Flash erase action start instruction */
	target_mem_write32(t, FLASH_CR, action);
 8007ca2:	1c2a      	adds	r2, r5, #0
 8007ca4:	1c20      	adds	r0, r4, #0
 8007ca6:	491c      	ldr	r1, [pc, #112]	; (8007d18 <stm32l4_cmd_erase+0x94>)
 8007ca8:	f000 fc48 	bl	800853c <target_mem_write32>
	target_mem_write32(t, FLASH_CR, action | FLASH_CR_STRT);
 8007cac:	2280      	movs	r2, #128	; 0x80
 8007cae:	0252      	lsls	r2, r2, #9
 8007cb0:	432a      	orrs	r2, r5
 8007cb2:	1c20      	adds	r0, r4, #0
 8007cb4:	4918      	ldr	r1, [pc, #96]	; (8007d18 <stm32l4_cmd_erase+0x94>)
 8007cb6:	f000 fc41 	bl	800853c <target_mem_write32>
}

static bool stm32l4_cmd_erase(target *t, uint32_t action)
{
	const char spinner[] = "|/-\\";
	int spinindex = 0;
 8007cba:	2500      	movs	r5, #0
	/* Flash erase action start instruction */
	target_mem_write32(t, FLASH_CR, action);
	target_mem_write32(t, FLASH_CR, action | FLASH_CR_STRT);

	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY) {
 8007cbc:	1c20      	adds	r0, r4, #0
 8007cbe:	4917      	ldr	r1, [pc, #92]	; (8007d1c <stm32l4_cmd_erase+0x98>)
 8007cc0:	f000 fc34 	bl	800852c <target_mem_read32>
 8007cc4:	03c3      	lsls	r3, r0, #15
 8007cc6:	d515      	bpl.n	8007cf4 <stm32l4_cmd_erase+0x70>
		tc_printf(t, "\b%c", spinner[spinindex++ % 4]);
 8007cc8:	2303      	movs	r3, #3
 8007cca:	1c6e      	adds	r6, r5, #1
 8007ccc:	401d      	ands	r5, r3
 8007cce:	466b      	mov	r3, sp
 8007cd0:	1c20      	adds	r0, r4, #0
 8007cd2:	5d5a      	ldrb	r2, [r3, r5]
 8007cd4:	4912      	ldr	r1, [pc, #72]	; (8007d20 <stm32l4_cmd_erase+0x9c>)
 8007cd6:	f000 fc88 	bl	80085ea <tc_printf>
		if(target_check_error(t)) {
 8007cda:	1c20      	adds	r0, r4, #0
 8007cdc:	f000 fb9c 	bl	8008418 <target_check_error>
 8007ce0:	2800      	cmp	r0, #0
 8007ce2:	d005      	beq.n	8007cf0 <stm32l4_cmd_erase+0x6c>
			tc_printf(t, "\n");
 8007ce4:	1c20      	adds	r0, r4, #0
 8007ce6:	490f      	ldr	r1, [pc, #60]	; (8007d24 <stm32l4_cmd_erase+0xa0>)
 8007ce8:	f000 fc7f 	bl	80085ea <tc_printf>
			return false;
 8007cec:	2000      	movs	r0, #0
 8007cee:	e00e      	b.n	8007d0e <stm32l4_cmd_erase+0x8a>
	target_mem_write32(t, FLASH_CR, action);
	target_mem_write32(t, FLASH_CR, action | FLASH_CR_STRT);

	/* Read FLASH_SR to poll for BSY bit */
	while (target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY) {
		tc_printf(t, "\b%c", spinner[spinindex++ % 4]);
 8007cf0:	1c35      	adds	r5, r6, #0
 8007cf2:	e7e3      	b.n	8007cbc <stm32l4_cmd_erase+0x38>
		if(target_check_error(t)) {
			tc_printf(t, "\n");
			return false;
		}
	}
	tc_printf(t, "\n");
 8007cf4:	1c20      	adds	r0, r4, #0
 8007cf6:	490b      	ldr	r1, [pc, #44]	; (8007d24 <stm32l4_cmd_erase+0xa0>)
 8007cf8:	f000 fc77 	bl	80085ea <tc_printf>

	/* Check for error */
	uint16_t sr = target_mem_read32(t, FLASH_SR);
 8007cfc:	1c20      	adds	r0, r4, #0
 8007cfe:	4907      	ldr	r1, [pc, #28]	; (8007d1c <stm32l4_cmd_erase+0x98>)
 8007d00:	f000 fc14 	bl	800852c <target_mem_read32>
	if (sr & FLASH_SR_ERROR_MASK)
 8007d04:	4b08      	ldr	r3, [pc, #32]	; (8007d28 <stm32l4_cmd_erase+0xa4>)
 8007d06:	4018      	ands	r0, r3
 8007d08:	4243      	negs	r3, r0
 8007d0a:	4158      	adcs	r0, r3
 8007d0c:	b2c0      	uxtb	r0, r0
		return false;
	return true;
}
 8007d0e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007d10:	080130db 	.word	0x080130db
 8007d14:	080130a7 	.word	0x080130a7
 8007d18:	40022014 	.word	0x40022014
 8007d1c:	40022010 	.word	0x40022010
 8007d20:	080130d7 	.word	0x080130d7
 8007d24:	0800fc8c 	.word	0x0800fc8c
 8007d28:	0000c3fa 	.word	0x0000c3fa

08007d2c <stm32l4_cmd_erase_bank2>:
	return stm32l4_cmd_erase(t, FLASH_CR_MER1);
}

static bool stm32l4_cmd_erase_bank2(target *t)
{
	return stm32l4_cmd_erase(t, FLASH_CR_MER2);
 8007d2c:	2180      	movs	r1, #128	; 0x80
{
	return stm32l4_cmd_erase(t, FLASH_CR_MER1);
}

static bool stm32l4_cmd_erase_bank2(target *t)
{
 8007d2e:	b508      	push	{r3, lr}
	return stm32l4_cmd_erase(t, FLASH_CR_MER2);
 8007d30:	0209      	lsls	r1, r1, #8
 8007d32:	f7ff ffa7 	bl	8007c84 <stm32l4_cmd_erase>
}
 8007d36:	bd08      	pop	{r3, pc}

08007d38 <stm32l4_cmd_erase_bank1>:
{
	return stm32l4_cmd_erase(t, FLASH_CR_MER1 | FLASH_CR_MER2);
}

static bool stm32l4_cmd_erase_bank1(target *t)
{
 8007d38:	b508      	push	{r3, lr}
	return stm32l4_cmd_erase(t, FLASH_CR_MER1);
 8007d3a:	2104      	movs	r1, #4
 8007d3c:	f7ff ffa2 	bl	8007c84 <stm32l4_cmd_erase>
}
 8007d40:	bd08      	pop	{r3, pc}

08007d42 <stm32l4_cmd_erase_mass>:
		return false;
	return true;
}

static bool stm32l4_cmd_erase_mass(target *t)
{
 8007d42:	b508      	push	{r3, lr}
	return stm32l4_cmd_erase(t, FLASH_CR_MER1 | FLASH_CR_MER2);
 8007d44:	4901      	ldr	r1, [pc, #4]	; (8007d4c <stm32l4_cmd_erase_mass+0xa>)
 8007d46:	f7ff ff9d 	bl	8007c84 <stm32l4_cmd_erase>
}
 8007d4a:	bd08      	pop	{r3, pc}
 8007d4c:	00008004 	.word	0x00008004

08007d50 <stm32l4_flash_erase>:
		target_mem_write32(t, FLASH_KEYR, KEY2);
	}
}

static int stm32l4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8007d50:	b5f0      	push	{r4, r5, r6, r7, lr}
	target *t = f->t;
 8007d52:	6985      	ldr	r5, [r0, #24]
	uint16_t sr;
	uint32_t bank1_start = ((struct stm32l4_flash *)f)->bank1_start;
 8007d54:	6b83      	ldr	r3, [r0, #56]	; 0x38
		target_mem_write32(t, FLASH_KEYR, KEY2);
	}
}

static int stm32l4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8007d56:	b085      	sub	sp, #20
	target *t = f->t;
	uint16_t sr;
	uint32_t bank1_start = ((struct stm32l4_flash *)f)->bank1_start;
	uint32_t page;

	stm32l4_flash_unlock(t);
 8007d58:	1c28      	adds	r0, r5, #0
		target_mem_write32(t, FLASH_KEYR, KEY2);
	}
}

static int stm32l4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8007d5a:	9202      	str	r2, [sp, #8]
	target *t = f->t;
	uint16_t sr;
	uint32_t bank1_start = ((struct stm32l4_flash *)f)->bank1_start;
 8007d5c:	9303      	str	r3, [sp, #12]
		target_mem_write32(t, FLASH_KEYR, KEY2);
	}
}

static int stm32l4_flash_erase(struct target_flash *f, target_addr addr, size_t len)
{
 8007d5e:	9101      	str	r1, [sp, #4]
	target *t = f->t;
	uint16_t sr;
	uint32_t bank1_start = ((struct stm32l4_flash *)f)->bank1_start;
	uint32_t page;

	stm32l4_flash_unlock(t);
 8007d60:	f7ff ff76 	bl	8007c50 <stm32l4_flash_unlock>

	page = (addr - 0x08000000) / PAGE_SIZE;
 8007d64:	22f8      	movs	r2, #248	; 0xf8
 8007d66:	9b01      	ldr	r3, [sp, #4]
 8007d68:	0612      	lsls	r2, r2, #24
 8007d6a:	189b      	adds	r3, r3, r2
	while(len) {
 8007d6c:	9e02      	ldr	r6, [sp, #8]
	uint32_t bank1_start = ((struct stm32l4_flash *)f)->bank1_start;
	uint32_t page;

	stm32l4_flash_unlock(t);

	page = (addr - 0x08000000) / PAGE_SIZE;
 8007d6e:	0adf      	lsrs	r7, r3, #11
	while(len) {
 8007d70:	2e00      	cmp	r6, #0
 8007d72:	d027      	beq.n	8007dc4 <stm32l4_flash_erase+0x74>
 8007d74:	9902      	ldr	r1, [sp, #8]
 8007d76:	9b01      	ldr	r3, [sp, #4]
		uint32_t cr;

		cr = FLASH_CR_PER | (page << FLASH_CR_PAGE_SHIFT );
 8007d78:	00fa      	lsls	r2, r7, #3
 8007d7a:	185b      	adds	r3, r3, r1
		if (addr >= bank1_start)
 8007d7c:	9903      	ldr	r1, [sp, #12]
 8007d7e:	1b9b      	subs	r3, r3, r6

	page = (addr - 0x08000000) / PAGE_SIZE;
	while(len) {
		uint32_t cr;

		cr = FLASH_CR_PER | (page << FLASH_CR_PAGE_SHIFT );
 8007d80:	2402      	movs	r4, #2
		if (addr >= bank1_start)
 8007d82:	428b      	cmp	r3, r1
 8007d84:	d300      	bcc.n	8007d88 <stm32l4_flash_erase+0x38>
			cr |= FLASH_CR_BKER;
 8007d86:	4c15      	ldr	r4, [pc, #84]	; (8007ddc <stm32l4_flash_erase+0x8c>)
 8007d88:	4314      	orrs	r4, r2
		/* Flash page erase instruction */
		target_mem_write32(t, FLASH_CR, cr);
 8007d8a:	1c28      	adds	r0, r5, #0
 8007d8c:	4914      	ldr	r1, [pc, #80]	; (8007de0 <stm32l4_flash_erase+0x90>)
 8007d8e:	1c22      	adds	r2, r4, #0
 8007d90:	f000 fbd4 	bl	800853c <target_mem_write32>
		/* write address to FMA */
		cr |= FLASH_CR_STRT;
 8007d94:	2280      	movs	r2, #128	; 0x80
 8007d96:	0252      	lsls	r2, r2, #9
 8007d98:	4322      	orrs	r2, r4
		target_mem_write32(t, FLASH_CR, cr);
 8007d9a:	1c28      	adds	r0, r5, #0
 8007d9c:	4910      	ldr	r1, [pc, #64]	; (8007de0 <stm32l4_flash_erase+0x90>)
 8007d9e:	f000 fbcd 	bl	800853c <target_mem_write32>

		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
 8007da2:	1c28      	adds	r0, r5, #0
 8007da4:	490f      	ldr	r1, [pc, #60]	; (8007de4 <stm32l4_flash_erase+0x94>)
 8007da6:	f000 fbc1 	bl	800852c <target_mem_read32>
 8007daa:	03c3      	lsls	r3, r0, #15
 8007dac:	d506      	bpl.n	8007dbc <stm32l4_flash_erase+0x6c>
			if(target_check_error(t))
 8007dae:	1c28      	adds	r0, r5, #0
 8007db0:	f000 fb32 	bl	8008418 <target_check_error>
 8007db4:	2800      	cmp	r0, #0
 8007db6:	d0f4      	beq.n	8007da2 <stm32l4_flash_erase+0x52>
				return -1;
 8007db8:	2001      	movs	r0, #1
 8007dba:	e00b      	b.n	8007dd4 <stm32l4_flash_erase+0x84>

		len  -= PAGE_SIZE;
 8007dbc:	4b0a      	ldr	r3, [pc, #40]	; (8007de8 <stm32l4_flash_erase+0x98>)
		addr += PAGE_SIZE;
		page++;
 8007dbe:	3701      	adds	r7, #1
		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
			if(target_check_error(t))
				return -1;

		len  -= PAGE_SIZE;
 8007dc0:	18f6      	adds	r6, r6, r3
 8007dc2:	e7d5      	b.n	8007d70 <stm32l4_flash_erase+0x20>
		addr += PAGE_SIZE;
		page++;
	}

	/* Check for error */
	sr = target_mem_read32(t, FLASH_SR);
 8007dc4:	1c28      	adds	r0, r5, #0
 8007dc6:	4907      	ldr	r1, [pc, #28]	; (8007de4 <stm32l4_flash_erase+0x94>)
 8007dc8:	f000 fbb0 	bl	800852c <target_mem_read32>
	if(sr & FLASH_SR_ERROR_MASK)
 8007dcc:	4b07      	ldr	r3, [pc, #28]	; (8007dec <stm32l4_flash_erase+0x9c>)
 8007dce:	4018      	ands	r0, r3
 8007dd0:	1e43      	subs	r3, r0, #1
 8007dd2:	4198      	sbcs	r0, r3
		target_mem_write32(t, FLASH_CR, cr);

		/* Read FLASH_SR to poll for BSY bit */
		while(target_mem_read32(t, FLASH_SR) & FLASH_SR_BSY)
			if(target_check_error(t))
				return -1;
 8007dd4:	4240      	negs	r0, r0
	sr = target_mem_read32(t, FLASH_SR);
	if(sr & FLASH_SR_ERROR_MASK)
		return -1;

	return 0;
}
 8007dd6:	b005      	add	sp, #20
 8007dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007dda:	46c0      	nop			; (mov r8, r8)
 8007ddc:	00000802 	.word	0x00000802
 8007de0:	40022014 	.word	0x40022014
 8007de4:	40022010 	.word	0x40022010
 8007de8:	fffff800 	.word	0xfffff800
 8007dec:	0000c3fa 	.word	0x0000c3fa

08007df0 <stm32l4_probe>:
	sf->bank1_start = bank1_start;
	target_add_flash(t, f);
}

bool stm32l4_probe(target *t)
{
 8007df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t idcode;
	uint32_t size;
	uint32_t options;
	uint32_t bank1_start = 0x08040000;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
 8007df2:	492b      	ldr	r1, [pc, #172]	; (8007ea0 <stm32l4_probe+0xb0>)
	sf->bank1_start = bank1_start;
	target_add_flash(t, f);
}

bool stm32l4_probe(target *t)
{
 8007df4:	1c04      	adds	r4, r0, #0
	uint32_t idcode;
	uint32_t size;
	uint32_t options;
	uint32_t bank1_start = 0x08040000;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
 8007df6:	f000 fb99 	bl	800852c <target_mem_read32>
	switch(idcode & 0xFFF) {
 8007dfa:	4b2a      	ldr	r3, [pc, #168]	; (8007ea4 <stm32l4_probe+0xb4>)
 8007dfc:	0500      	lsls	r0, r0, #20
 8007dfe:	0d00      	lsrs	r0, r0, #20
 8007e00:	4298      	cmp	r0, r3
 8007e02:	d14a      	bne.n	8007e9a <stm32l4_probe+0xaa>
	case 0x415: /*  */
		t->driver = stm32l4_driver_str;
 8007e04:	4e28      	ldr	r6, [pc, #160]	; (8007ea8 <stm32l4_probe+0xb8>)
		target_add_ram(t, 0x10000000, 1 << 15);
 8007e06:	2180      	movs	r1, #128	; 0x80
	uint32_t bank1_start = 0x08040000;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
	switch(idcode & 0xFFF) {
	case 0x415: /*  */
		t->driver = stm32l4_driver_str;
 8007e08:	1c33      	adds	r3, r6, #0
		target_add_ram(t, 0x10000000, 1 << 15);
 8007e0a:	2280      	movs	r2, #128	; 0x80
	uint32_t bank1_start = 0x08040000;

	idcode = target_mem_read32(t, DBGMCU_IDCODE);
	switch(idcode & 0xFFF) {
	case 0x415: /*  */
		t->driver = stm32l4_driver_str;
 8007e0c:	3364      	adds	r3, #100	; 0x64
 8007e0e:	6623      	str	r3, [r4, #96]	; 0x60
		target_add_ram(t, 0x10000000, 1 << 15);
 8007e10:	1c20      	adds	r0, r4, #0
 8007e12:	0549      	lsls	r1, r1, #21
 8007e14:	0212      	lsls	r2, r2, #8
 8007e16:	f000 f98d 	bl	8008134 <target_add_ram>
		target_add_ram(t, 0x20000000, 3 << 15);
 8007e1a:	2180      	movs	r1, #128	; 0x80
 8007e1c:	22c0      	movs	r2, #192	; 0xc0
 8007e1e:	1c20      	adds	r0, r4, #0
 8007e20:	0252      	lsls	r2, r2, #9
 8007e22:	0589      	lsls	r1, r1, #22
 8007e24:	f000 f986 	bl	8008134 <target_add_ram>
		size    = (target_mem_read32(t, FLASH_SIZE_REG) & 0xffff);
 8007e28:	4920      	ldr	r1, [pc, #128]	; (8007eac <stm32l4_probe+0xbc>)
 8007e2a:	1c20      	adds	r0, r4, #0
 8007e2c:	f000 fb7e 	bl	800852c <target_mem_read32>
		options =  target_mem_read32(t, FLASH_OPTR);
 8007e30:	491f      	ldr	r1, [pc, #124]	; (8007eb0 <stm32l4_probe+0xc0>)
	switch(idcode & 0xFFF) {
	case 0x415: /*  */
		t->driver = stm32l4_driver_str;
		target_add_ram(t, 0x10000000, 1 << 15);
		target_add_ram(t, 0x20000000, 3 << 15);
		size    = (target_mem_read32(t, FLASH_SIZE_REG) & 0xffff);
 8007e32:	b285      	uxth	r5, r0
		options =  target_mem_read32(t, FLASH_OPTR);
 8007e34:	1c20      	adds	r0, r4, #0
 8007e36:	f000 fb79 	bl	800852c <target_mem_read32>
		if ((size < 0x400) && (options & OR_DUALBANK))
 8007e3a:	4b1e      	ldr	r3, [pc, #120]	; (8007eb4 <stm32l4_probe+0xc4>)
 8007e3c:	429d      	cmp	r5, r3
 8007e3e:	d806      	bhi.n	8007e4e <stm32l4_probe+0x5e>
 8007e40:	0283      	lsls	r3, r0, #10
 8007e42:	d504      	bpl.n	8007e4e <stm32l4_probe+0x5e>
			bank1_start =  0x08000000 + (size << 9);
 8007e44:	2380      	movs	r3, #128	; 0x80
 8007e46:	026f      	lsls	r7, r5, #9
 8007e48:	051b      	lsls	r3, r3, #20
 8007e4a:	18ff      	adds	r7, r7, r3
 8007e4c:	e000      	b.n	8007e50 <stm32l4_probe+0x60>
bool stm32l4_probe(target *t)
{
	uint32_t idcode;
	uint32_t size;
	uint32_t options;
	uint32_t bank1_start = 0x08040000;
 8007e4e:	4f1a      	ldr	r7, [pc, #104]	; (8007eb8 <stm32l4_probe+0xc8>)

static void stm32l4_add_flash(target *t,
                              uint32_t addr, size_t length, size_t blocksize,
                              uint32_t bank1_start)
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
 8007e50:	213c      	movs	r1, #60	; 0x3c
 8007e52:	2001      	movs	r0, #1
 8007e54:	f004 fd10 	bl	800c878 <calloc>
	struct target_flash *f = &sf->f;
	f->start = addr;
 8007e58:	2380      	movs	r3, #128	; 0x80
	f->length = length;
	f->blocksize = blocksize;
	f->erase = stm32l4_flash_erase;
 8007e5a:	4a18      	ldr	r2, [pc, #96]	; (8007ebc <stm32l4_probe+0xcc>)
                              uint32_t addr, size_t length, size_t blocksize,
                              uint32_t bank1_start)
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
 8007e5c:	051b      	lsls	r3, r3, #20
	f->length = length;
	f->blocksize = blocksize;
	f->erase = stm32l4_flash_erase;
 8007e5e:	60c2      	str	r2, [r0, #12]
	f->write = target_flash_write_buffered;
 8007e60:	4a17      	ldr	r2, [pc, #92]	; (8007ec0 <stm32l4_probe+0xd0>)
                              uint32_t addr, size_t length, size_t blocksize,
                              uint32_t bank1_start)
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
 8007e62:	6003      	str	r3, [r0, #0]
	f->length = length;
	f->blocksize = blocksize;
	f->erase = stm32l4_flash_erase;
	f->write = target_flash_write_buffered;
 8007e64:	6102      	str	r2, [r0, #16]
	f->done = target_flash_done_buffered;
 8007e66:	4a17      	ldr	r2, [pc, #92]	; (8007ec4 <stm32l4_probe+0xd4>)
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = blocksize;
 8007e68:	2380      	movs	r3, #128	; 0x80
	f->erase = stm32l4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
 8007e6a:	6142      	str	r2, [r0, #20]
	f->write_buf = stm32l4_flash_write;
 8007e6c:	4a16      	ldr	r2, [pc, #88]	; (8007ec8 <stm32l4_probe+0xd8>)
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = blocksize;
 8007e6e:	011b      	lsls	r3, r3, #4
	f->erase = stm32l4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = stm32l4_flash_write;
 8007e70:	62c2      	str	r2, [r0, #44]	; 0x2c
	f->buf_size = 2048;
	f->erased = 0xff;
 8007e72:	22ff      	movs	r2, #255	; 0xff
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
	f->blocksize = blocksize;
 8007e74:	6083      	str	r3, [r0, #8]
	f->erase = stm32l4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = stm32l4_flash_write;
	f->buf_size = 2048;
 8007e76:	6283      	str	r3, [r0, #40]	; 0x28
		target_add_ram(t, 0x20000000, 3 << 15);
		size    = (target_mem_read32(t, FLASH_SIZE_REG) & 0xffff);
		options =  target_mem_read32(t, FLASH_OPTR);
		if ((size < 0x400) && (options & OR_DUALBANK))
			bank1_start =  0x08000000 + (size << 9);
		stm32l4_add_flash(t, 0x08000000, size << 10, PAGE_SIZE, bank1_start);
 8007e78:	02ad      	lsls	r5, r5, #10
	f->erase = stm32l4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = stm32l4_flash_write;
	f->buf_size = 2048;
	f->erased = 0xff;
 8007e7a:	1d43      	adds	r3, r0, #5

static void stm32l4_add_flash(target *t,
                              uint32_t addr, size_t length, size_t blocksize,
                              uint32_t bank1_start)
{
	struct stm32l4_flash *sf = calloc(1, sizeof(*sf));
 8007e7c:	1c01      	adds	r1, r0, #0
	struct target_flash *f = &sf->f;
	f->start = addr;
	f->length = length;
 8007e7e:	6045      	str	r5, [r0, #4]
	f->erase = stm32l4_flash_erase;
	f->write = target_flash_write_buffered;
	f->done = target_flash_done_buffered;
	f->write_buf = stm32l4_flash_write;
	f->buf_size = 2048;
	f->erased = 0xff;
 8007e80:	77da      	strb	r2, [r3, #31]
	sf->bank1_start = bank1_start;
 8007e82:	6387      	str	r7, [r0, #56]	; 0x38
	target_add_flash(t, f);
 8007e84:	1c20      	adds	r0, r4, #0
 8007e86:	f000 f962 	bl	800814e <target_add_flash>
		size    = (target_mem_read32(t, FLASH_SIZE_REG) & 0xffff);
		options =  target_mem_read32(t, FLASH_OPTR);
		if ((size < 0x400) && (options & OR_DUALBANK))
			bank1_start =  0x08000000 + (size << 9);
		stm32l4_add_flash(t, 0x08000000, size << 10, PAGE_SIZE, bank1_start);
		target_add_commands(t, stm32l4_cmd_list, "STM32L4");
 8007e8a:	1c31      	adds	r1, r6, #0
 8007e8c:	1c20      	adds	r0, r4, #0
 8007e8e:	3170      	adds	r1, #112	; 0x70
 8007e90:	4a0e      	ldr	r2, [pc, #56]	; (8007ecc <stm32l4_probe+0xdc>)
 8007e92:	f000 f90f 	bl	80080b4 <target_add_commands>
		return true;
 8007e96:	2001      	movs	r0, #1
 8007e98:	e000      	b.n	8007e9c <stm32l4_probe+0xac>
	}
	return false;
 8007e9a:	2000      	movs	r0, #0
}
 8007e9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007e9e:	46c0      	nop			; (mov r8, r8)
 8007ea0:	e0042000 	.word	0xe0042000
 8007ea4:	00000415 	.word	0x00000415
 8007ea8:	08013538 	.word	0x08013538
 8007eac:	1fff75e0 	.word	0x1fff75e0
 8007eb0:	40022020 	.word	0x40022020
 8007eb4:	000003ff 	.word	0x000003ff
 8007eb8:	08040000 	.word	0x08040000
 8007ebc:	08007d51 	.word	0x08007d51
 8007ec0:	0800834b 	.word	0x0800834b
 8007ec4:	080083dd 	.word	0x080083dd
 8007ec8:	08007c09 	.word	0x08007c09
 8007ecc:	08013604 	.word	0x08013604

08007ed0 <swdptap_init>:
#include "swdptap.h"

int swdptap_init(void)
{
	return 0;
}
 8007ed0:	2000      	movs	r0, #0
 8007ed2:	4770      	bx	lr

08007ed4 <swdptap_bit_in>:
	if(!dir)
		SWDIO_MODE_DRIVE();
}

bool swdptap_bit_in(void)
{
 8007ed4:	b510      	push	{r4, lr}
static void swdptap_turnaround(uint8_t dir)
{
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
 8007ed6:	4b16      	ldr	r3, [pc, #88]	; (8007f30 <swdptap_bit_in+0x5c>)
 8007ed8:	781a      	ldrb	r2, [r3, #0]
 8007eda:	2a01      	cmp	r2, #1
 8007edc:	d013      	beq.n	8007f06 <swdptap_bit_in+0x32>
	olddir = dir;
 8007ede:	2201      	movs	r2, #1
#ifdef DEBUG_SWD_BITS
	DEBUG("%s", dir ? "\n-> ":"\n<- ");
#endif

	if(dir)
		SWDIO_MODE_FLOAT();
 8007ee0:	2490      	movs	r4, #144	; 0x90
{
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
	olddir = dir;
 8007ee2:	701a      	strb	r2, [r3, #0]
#ifdef DEBUG_SWD_BITS
	DEBUG("%s", dir ? "\n-> ":"\n<- ");
#endif

	if(dir)
		SWDIO_MODE_FLOAT();
 8007ee4:	05e4      	lsls	r4, r4, #23
 8007ee6:	6822      	ldr	r2, [r4, #0]
 8007ee8:	4b12      	ldr	r3, [pc, #72]	; (8007f34 <swdptap_bit_in+0x60>)
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007eea:	1c20      	adds	r0, r4, #0
#ifdef DEBUG_SWD_BITS
	DEBUG("%s", dir ? "\n-> ":"\n<- ");
#endif

	if(dir)
		SWDIO_MODE_FLOAT();
 8007eec:	401a      	ands	r2, r3
 8007eee:	6022      	str	r2, [r4, #0]
 8007ef0:	4a11      	ldr	r2, [pc, #68]	; (8007f38 <swdptap_bit_in+0x64>)
 8007ef2:	6811      	ldr	r1, [r2, #0]
 8007ef4:	400b      	ands	r3, r1
 8007ef6:	6013      	str	r3, [r2, #0]
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007ef8:	2140      	movs	r1, #64	; 0x40
 8007efa:	f003 fbdb 	bl	800b6b4 <gpio_set>
	gpio_clear(SWCLK_PORT, SWCLK_PIN);
 8007efe:	1c20      	adds	r0, r4, #0
 8007f00:	2140      	movs	r1, #64	; 0x40
 8007f02:	f003 fbd9 	bl	800b6b8 <gpio_clear>
{
	uint16_t ret;

	swdptap_turnaround(1);

	ret = gpio_get(SWDIO_PORT, SWDIO_PIN);
 8007f06:	2090      	movs	r0, #144	; 0x90
 8007f08:	2120      	movs	r1, #32
 8007f0a:	05c0      	lsls	r0, r0, #23
 8007f0c:	f003 fbd7 	bl	800b6be <gpio_get>
 8007f10:	1c04      	adds	r4, r0, #0
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007f12:	2090      	movs	r0, #144	; 0x90
 8007f14:	2140      	movs	r1, #64	; 0x40
 8007f16:	05c0      	lsls	r0, r0, #23
 8007f18:	f003 fbcc 	bl	800b6b4 <gpio_set>
	gpio_clear(SWCLK_PORT, SWCLK_PIN);
 8007f1c:	2090      	movs	r0, #144	; 0x90
 8007f1e:	2140      	movs	r1, #64	; 0x40
 8007f20:	05c0      	lsls	r0, r0, #23
 8007f22:	f003 fbc9 	bl	800b6b8 <gpio_clear>

#ifdef DEBUG_SWD_BITS
	DEBUG("%d", ret?1:0);
#endif

	return ret != 0;
 8007f26:	1e60      	subs	r0, r4, #1
 8007f28:	4184      	sbcs	r4, r0
 8007f2a:	b2e0      	uxtb	r0, r4
}
 8007f2c:	bd10      	pop	{r4, pc}
 8007f2e:	46c0      	nop			; (mov r8, r8)
 8007f30:	200011de 	.word	0x200011de
 8007f34:	fffff3ff 	.word	0xfffff3ff
 8007f38:	4800000c 	.word	0x4800000c

08007f3c <swdptap_bit_out>:

void swdptap_bit_out(bool val)
{
 8007f3c:	b538      	push	{r3, r4, r5, lr}
static void swdptap_turnaround(uint8_t dir)
{
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
 8007f3e:	4b1f      	ldr	r3, [pc, #124]	; (8007fbc <swdptap_bit_out+0x80>)

	return ret != 0;
}

void swdptap_bit_out(bool val)
{
 8007f40:	1c05      	adds	r5, r0, #0
static void swdptap_turnaround(uint8_t dir)
{
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
 8007f42:	781a      	ldrb	r2, [r3, #0]
 8007f44:	2a00      	cmp	r2, #0
 8007f46:	d023      	beq.n	8007f90 <swdptap_bit_out+0x54>
	DEBUG("%s", dir ? "\n-> ":"\n<- ");
#endif

	if(dir)
		SWDIO_MODE_FLOAT();
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007f48:	2490      	movs	r4, #144	; 0x90
{
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
	olddir = dir;
 8007f4a:	2200      	movs	r2, #0
	DEBUG("%s", dir ? "\n-> ":"\n<- ");
#endif

	if(dir)
		SWDIO_MODE_FLOAT();
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007f4c:	05e4      	lsls	r4, r4, #23
 8007f4e:	1c20      	adds	r0, r4, #0
 8007f50:	2140      	movs	r1, #64	; 0x40
{
	static uint8_t olddir = 0;

	/* Don't turnaround if direction not changing */
	if(dir == olddir) return;
	olddir = dir;
 8007f52:	701a      	strb	r2, [r3, #0]
	DEBUG("%s", dir ? "\n-> ":"\n<- ");
#endif

	if(dir)
		SWDIO_MODE_FLOAT();
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007f54:	f003 fbae 	bl	800b6b4 <gpio_set>
	gpio_clear(SWCLK_PORT, SWCLK_PIN);
 8007f58:	2140      	movs	r1, #64	; 0x40
 8007f5a:	1c20      	adds	r0, r4, #0
 8007f5c:	f003 fbac 	bl	800b6b8 <gpio_clear>
	if(!dir)
		SWDIO_MODE_DRIVE();
 8007f60:	6822      	ldr	r2, [r4, #0]
 8007f62:	4b17      	ldr	r3, [pc, #92]	; (8007fc0 <swdptap_bit_out+0x84>)
 8007f64:	401a      	ands	r2, r3
 8007f66:	6022      	str	r2, [r4, #0]
 8007f68:	4a16      	ldr	r2, [pc, #88]	; (8007fc4 <swdptap_bit_out+0x88>)
 8007f6a:	6811      	ldr	r1, [r2, #0]
 8007f6c:	400b      	ands	r3, r1
 8007f6e:	6013      	str	r3, [r2, #0]
 8007f70:	2280      	movs	r2, #128	; 0x80
 8007f72:	213f      	movs	r1, #63	; 0x3f
 8007f74:	6823      	ldr	r3, [r4, #0]
 8007f76:	00d2      	lsls	r2, r2, #3
 8007f78:	4313      	orrs	r3, r2
 8007f7a:	4a13      	ldr	r2, [pc, #76]	; (8007fc8 <swdptap_bit_out+0x8c>)
 8007f7c:	6023      	str	r3, [r4, #0]
 8007f7e:	6813      	ldr	r3, [r2, #0]
 8007f80:	438b      	bics	r3, r1
 8007f82:	21c0      	movs	r1, #192	; 0xc0
 8007f84:	6013      	str	r3, [r2, #0]
 8007f86:	4a11      	ldr	r2, [pc, #68]	; (8007fcc <swdptap_bit_out+0x90>)
 8007f88:	0109      	lsls	r1, r1, #4
 8007f8a:	6813      	ldr	r3, [r2, #0]
 8007f8c:	430b      	orrs	r3, r1
 8007f8e:	6013      	str	r3, [r2, #0]
	DEBUG("%d", val);
#endif

	swdptap_turnaround(0);

	gpio_set_val(SWDIO_PORT, SWDIO_PIN, val);
 8007f90:	2090      	movs	r0, #144	; 0x90
 8007f92:	2120      	movs	r1, #32
 8007f94:	05c0      	lsls	r0, r0, #23
 8007f96:	2d00      	cmp	r5, #0
 8007f98:	d002      	beq.n	8007fa0 <swdptap_bit_out+0x64>
 8007f9a:	f003 fb8b 	bl	800b6b4 <gpio_set>
 8007f9e:	e001      	b.n	8007fa4 <swdptap_bit_out+0x68>
 8007fa0:	f003 fb8a 	bl	800b6b8 <gpio_clear>
	gpio_set(SWCLK_PORT, SWCLK_PIN);
 8007fa4:	2090      	movs	r0, #144	; 0x90
 8007fa6:	2140      	movs	r1, #64	; 0x40
 8007fa8:	05c0      	lsls	r0, r0, #23
 8007faa:	f003 fb83 	bl	800b6b4 <gpio_set>
	gpio_clear(SWCLK_PORT, SWCLK_PIN);
 8007fae:	2090      	movs	r0, #144	; 0x90
 8007fb0:	2140      	movs	r1, #64	; 0x40
 8007fb2:	05c0      	lsls	r0, r0, #23
 8007fb4:	f003 fb80 	bl	800b6b8 <gpio_clear>
}
 8007fb8:	bd38      	pop	{r3, r4, r5, pc}
 8007fba:	46c0      	nop			; (mov r8, r8)
 8007fbc:	200011de 	.word	0x200011de
 8007fc0:	fffff3ff 	.word	0xfffff3ff
 8007fc4:	4800000c 	.word	0x4800000c
 8007fc8:	48000004 	.word	0x48000004
 8007fcc:	48000008 	.word	0x48000008

08007fd0 <target_new>:
#include <stdarg.h>

target *target_list = NULL;

target *target_new(void)
{
 8007fd0:	b508      	push	{r3, lr}
	target *t = (void*)calloc(1, sizeof(*t));
 8007fd2:	2001      	movs	r0, #1
 8007fd4:	2174      	movs	r1, #116	; 0x74
 8007fd6:	f004 fc4f 	bl	800c878 <calloc>
	t->next = target_list;
 8007fda:	4b02      	ldr	r3, [pc, #8]	; (8007fe4 <target_new+0x14>)
 8007fdc:	681a      	ldr	r2, [r3, #0]
	target_list = t;
 8007fde:	6018      	str	r0, [r3, #0]
target *target_list = NULL;

target *target_new(void)
{
	target *t = (void*)calloc(1, sizeof(*t));
	t->next = target_list;
 8007fe0:	6682      	str	r2, [r0, #104]	; 0x68
	target_list = t;

	return t;
}
 8007fe2:	bd08      	pop	{r3, pc}
 8007fe4:	200011e0 	.word	0x200011e0

08007fe8 <target_foreach>:

bool target_foreach(void (*cb)(int, target *t, void *context), void *context)
{
 8007fe8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007fea:	1c0f      	adds	r7, r1, #0
	int i = 1;
 8007fec:	2601      	movs	r6, #1
	target *t = target_list;
 8007fee:	4c09      	ldr	r4, [pc, #36]	; (8008014 <target_foreach+0x2c>)

	return t;
}

bool target_foreach(void (*cb)(int, target *t, void *context), void *context)
{
 8007ff0:	9001      	str	r0, [sp, #4]
	int i = 1;
	target *t = target_list;
 8007ff2:	6825      	ldr	r5, [r4, #0]
	for (; t; t = t->next, i++)
 8007ff4:	2d00      	cmp	r5, #0
 8007ff6:	d007      	beq.n	8008008 <target_foreach+0x20>
		cb(i, t, context);
 8007ff8:	1c30      	adds	r0, r6, #0
 8007ffa:	1c29      	adds	r1, r5, #0
 8007ffc:	1c3a      	adds	r2, r7, #0
 8007ffe:	9b01      	ldr	r3, [sp, #4]
 8008000:	4798      	blx	r3

bool target_foreach(void (*cb)(int, target *t, void *context), void *context)
{
	int i = 1;
	target *t = target_list;
	for (; t; t = t->next, i++)
 8008002:	3601      	adds	r6, #1
 8008004:	6ead      	ldr	r5, [r5, #104]	; 0x68
 8008006:	e7f5      	b.n	8007ff4 <target_foreach+0xc>
		cb(i, t, context);
	return target_list != NULL;
 8008008:	6820      	ldr	r0, [r4, #0]
 800800a:	1e43      	subs	r3, r0, #1
 800800c:	4198      	sbcs	r0, r3
 800800e:	b2c0      	uxtb	r0, r0
}
 8008010:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8008012:	46c0      	nop			; (mov r8, r8)
 8008014:	200011e0 	.word	0x200011e0

08008018 <target_list_free>:

void target_list_free(void)
{
 8008018:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct target_command_s *tc;

	while(target_list) {
 800801a:	4d25      	ldr	r5, [pc, #148]	; (80080b0 <target_list_free+0x98>)
 800801c:	6829      	ldr	r1, [r5, #0]
 800801e:	1c2c      	adds	r4, r5, #0
 8008020:	2900      	cmp	r1, #0
 8008022:	d043      	beq.n	80080ac <target_list_free+0x94>
		target *t = target_list->next;
		if (target_list->tc)
 8008024:	6848      	ldr	r0, [r1, #4]
void target_list_free(void)
{
	struct target_command_s *tc;

	while(target_list) {
		target *t = target_list->next;
 8008026:	6e8e      	ldr	r6, [r1, #104]	; 0x68
		if (target_list->tc)
 8008028:	2800      	cmp	r0, #0
 800802a:	d001      	beq.n	8008030 <target_list_free+0x18>
			target_list->tc->destroy_callback(target_list->tc, target_list);
 800802c:	6803      	ldr	r3, [r0, #0]
 800802e:	4798      	blx	r3
		if (target_list->priv)
 8008030:	682b      	ldr	r3, [r5, #0]
 8008032:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 8008034:	2800      	cmp	r0, #0
 8008036:	d001      	beq.n	800803c <target_list_free+0x24>
			target_list->priv_free(target_list->priv);
 8008038:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800803a:	4798      	blx	r3
		while (target_list->commands) {
 800803c:	6823      	ldr	r3, [r4, #0]
 800803e:	6e58      	ldr	r0, [r3, #100]	; 0x64
 8008040:	2800      	cmp	r0, #0
 8008042:	d005      	beq.n	8008050 <target_list_free+0x38>
			tc = target_list->commands->next;
 8008044:	6887      	ldr	r7, [r0, #8]
			free(target_list->commands);
 8008046:	f004 fc2d 	bl	800c8a4 <free>
			target_list->commands = tc;
 800804a:	6823      	ldr	r3, [r4, #0]
 800804c:	665f      	str	r7, [r3, #100]	; 0x64
 800804e:	e7f5      	b.n	800803c <target_list_free+0x24>
		}
		if (target_list->dyn_mem_map)
 8008050:	6d58      	ldr	r0, [r3, #84]	; 0x54
 8008052:	2800      	cmp	r0, #0
 8008054:	d001      	beq.n	800805a <target_list_free+0x42>
			free(target_list->dyn_mem_map);
 8008056:	f004 fc25 	bl	800c8a4 <free>
		while (target_list->ram) {
 800805a:	6823      	ldr	r3, [r4, #0]
 800805c:	6d98      	ldr	r0, [r3, #88]	; 0x58
 800805e:	2800      	cmp	r0, #0
 8008060:	d011      	beq.n	8008086 <target_list_free+0x6e>
			void * next = target_list->ram->next;
 8008062:	6887      	ldr	r7, [r0, #8]
			free(target_list->ram);
 8008064:	f004 fc1e 	bl	800c8a4 <free>
			target_list->ram = next;
 8008068:	6823      	ldr	r3, [r4, #0]
 800806a:	659f      	str	r7, [r3, #88]	; 0x58
 800806c:	e7f5      	b.n	800805a <target_list_free+0x42>
		}
		while (target_list->flash) {
			void * next = target_list->flash->next;
			if (target_list->flash->buf)
 800806e:	6b58      	ldr	r0, [r3, #52]	; 0x34
			void * next = target_list->ram->next;
			free(target_list->ram);
			target_list->ram = next;
		}
		while (target_list->flash) {
			void * next = target_list->flash->next;
 8008070:	69df      	ldr	r7, [r3, #28]
			if (target_list->flash->buf)
 8008072:	2800      	cmp	r0, #0
 8008074:	d001      	beq.n	800807a <target_list_free+0x62>
				free(target_list->flash->buf);
 8008076:	f004 fc15 	bl	800c8a4 <free>
			free(target_list->flash);
 800807a:	6823      	ldr	r3, [r4, #0]
 800807c:	6dd8      	ldr	r0, [r3, #92]	; 0x5c
 800807e:	f004 fc11 	bl	800c8a4 <free>
			target_list->flash = next;
 8008082:	6823      	ldr	r3, [r4, #0]
 8008084:	65df      	str	r7, [r3, #92]	; 0x5c
		while (target_list->ram) {
			void * next = target_list->ram->next;
			free(target_list->ram);
			target_list->ram = next;
		}
		while (target_list->flash) {
 8008086:	6823      	ldr	r3, [r4, #0]
 8008088:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800808a:	2b00      	cmp	r3, #0
 800808c:	d1ef      	bne.n	800806e <target_list_free+0x56>
			if (target_list->flash->buf)
				free(target_list->flash->buf);
			free(target_list->flash);
			target_list->flash = next;
		}
		while (target_list->bw_list) {
 800808e:	6820      	ldr	r0, [r4, #0]
 8008090:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8008092:	2b00      	cmp	r3, #0
 8008094:	d006      	beq.n	80080a4 <target_list_free+0x8c>
			void * next = target_list->bw_list->next;
			free(target_list->bw_list);
 8008096:	1c18      	adds	r0, r3, #0
				free(target_list->flash->buf);
			free(target_list->flash);
			target_list->flash = next;
		}
		while (target_list->bw_list) {
			void * next = target_list->bw_list->next;
 8008098:	681f      	ldr	r7, [r3, #0]
			free(target_list->bw_list);
 800809a:	f004 fc03 	bl	800c8a4 <free>
			target_list->bw_list = next;
 800809e:	6823      	ldr	r3, [r4, #0]
 80080a0:	649f      	str	r7, [r3, #72]	; 0x48
 80080a2:	e7f4      	b.n	800808e <target_list_free+0x76>
		}
		free(target_list);
 80080a4:	f004 fbfe 	bl	800c8a4 <free>
		target_list = t;
 80080a8:	602e      	str	r6, [r5, #0]
 80080aa:	e7b6      	b.n	800801a <target_list_free+0x2>
	}
}
 80080ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80080ae:	46c0      	nop			; (mov r8, r8)
 80080b0:	200011e0 	.word	0x200011e0

080080b4 <target_add_commands>:

void target_add_commands(target *t, const struct command_s *cmds, const char *name)
{
 80080b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct target_command_s *tc;
	if (t->commands) {
 80080b6:	6e44      	ldr	r4, [r0, #100]	; 0x64
		target_list = t;
	}
}

void target_add_commands(target *t, const struct command_s *cmds, const char *name)
{
 80080b8:	1c05      	adds	r5, r0, #0
 80080ba:	1c0e      	adds	r6, r1, #0
 80080bc:	1c17      	adds	r7, r2, #0
	struct target_command_s *tc;
	if (t->commands) {
 80080be:	2c00      	cmp	r4, #0
 80080c0:	d009      	beq.n	80080d6 <target_add_commands+0x22>
		for (tc = t->commands; tc->next; tc = tc->next);
 80080c2:	68a3      	ldr	r3, [r4, #8]
 80080c4:	2b00      	cmp	r3, #0
 80080c6:	d001      	beq.n	80080cc <target_add_commands+0x18>
 80080c8:	1c1c      	adds	r4, r3, #0
 80080ca:	e7fa      	b.n	80080c2 <target_add_commands+0xe>
		tc = tc->next = malloc(sizeof(*tc));
 80080cc:	200c      	movs	r0, #12
 80080ce:	f004 fbdf 	bl	800c890 <malloc>
 80080d2:	60a0      	str	r0, [r4, #8]
 80080d4:	e003      	b.n	80080de <target_add_commands+0x2a>
	} else {
		t->commands = tc = malloc(sizeof(*tc));
 80080d6:	200c      	movs	r0, #12
 80080d8:	f004 fbda 	bl	800c890 <malloc>
 80080dc:	6668      	str	r0, [r5, #100]	; 0x64
	}
	tc->specific_name = name;
	tc->cmds = cmds;
	tc->next = NULL;
 80080de:	2300      	movs	r3, #0
		for (tc = t->commands; tc->next; tc = tc->next);
		tc = tc->next = malloc(sizeof(*tc));
	} else {
		t->commands = tc = malloc(sizeof(*tc));
	}
	tc->specific_name = name;
 80080e0:	6007      	str	r7, [r0, #0]
	tc->cmds = cmds;
 80080e2:	6046      	str	r6, [r0, #4]
	tc->next = NULL;
 80080e4:	6083      	str	r3, [r0, #8]
}
 80080e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080080e8 <target_attach>:
			return target_attach(t, tc);
	return NULL;
}

target *target_attach(target *t, struct target_controller *tc)
{
 80080e8:	b538      	push	{r3, r4, r5, lr}
 80080ea:	1c04      	adds	r4, r0, #0
	if (t->tc)
 80080ec:	6840      	ldr	r0, [r0, #4]
			return target_attach(t, tc);
	return NULL;
}

target *target_attach(target *t, struct target_controller *tc)
{
 80080ee:	1c0d      	adds	r5, r1, #0
	if (t->tc)
 80080f0:	2800      	cmp	r0, #0
 80080f2:	d002      	beq.n	80080fa <target_attach+0x12>
		t->tc->destroy_callback(t->tc, t);
 80080f4:	6803      	ldr	r3, [r0, #0]
 80080f6:	1c21      	adds	r1, r4, #0
 80080f8:	4798      	blx	r3

	t->tc = tc;

	if (!t->attach(t))
 80080fa:	68a3      	ldr	r3, [r4, #8]
target *target_attach(target *t, struct target_controller *tc)
{
	if (t->tc)
		t->tc->destroy_callback(t->tc, t);

	t->tc = tc;
 80080fc:	6065      	str	r5, [r4, #4]

	if (!t->attach(t))
 80080fe:	1c20      	adds	r0, r4, #0
 8008100:	4798      	blx	r3
		return NULL;
 8008102:	1e03      	subs	r3, r0, #0
	if (t->tc)
		t->tc->destroy_callback(t->tc, t);

	t->tc = tc;

	if (!t->attach(t))
 8008104:	d002      	beq.n	800810c <target_attach+0x24>
		return NULL;

	t->attached = true;
 8008106:	2301      	movs	r3, #1
 8008108:	7023      	strb	r3, [r4, #0]
	return t;
 800810a:	1c23      	adds	r3, r4, #0
}
 800810c:	1c18      	adds	r0, r3, #0
 800810e:	bd38      	pop	{r3, r4, r5, pc}

08008110 <target_attach_n>:
	tc->cmds = cmds;
	tc->next = NULL;
}

target *target_attach_n(int n, struct target_controller *tc)
{
 8008110:	b508      	push	{r3, lr}
	target *t;
	int i;
	for(t = target_list, i = 1; t; t = t->next, i++)
 8008112:	4b07      	ldr	r3, [pc, #28]	; (8008130 <target_attach_n+0x20>)
	tc->cmds = cmds;
	tc->next = NULL;
}

target *target_attach_n(int n, struct target_controller *tc)
{
 8008114:	1c02      	adds	r2, r0, #0
	target *t;
	int i;
	for(t = target_list, i = 1; t; t = t->next, i++)
 8008116:	6818      	ldr	r0, [r3, #0]
 8008118:	2301      	movs	r3, #1
 800811a:	2800      	cmp	r0, #0
 800811c:	d007      	beq.n	800812e <target_attach_n+0x1e>
		if(i == n)
 800811e:	4293      	cmp	r3, r2
 8008120:	d102      	bne.n	8008128 <target_attach_n+0x18>
			return target_attach(t, tc);
 8008122:	f7ff ffe1 	bl	80080e8 <target_attach>
 8008126:	e002      	b.n	800812e <target_attach_n+0x1e>

target *target_attach_n(int n, struct target_controller *tc)
{
	target *t;
	int i;
	for(t = target_list, i = 1; t; t = t->next, i++)
 8008128:	6e80      	ldr	r0, [r0, #104]	; 0x68
 800812a:	3301      	adds	r3, #1
 800812c:	e7f5      	b.n	800811a <target_attach_n+0xa>
		if(i == n)
			return target_attach(t, tc);
	return NULL;
}
 800812e:	bd08      	pop	{r3, pc}
 8008130:	200011e0 	.word	0x200011e0

08008134 <target_add_ram>:
	t->attached = true;
	return t;
}

void target_add_ram(target *t, target_addr start, uint32_t len)
{
 8008134:	b570      	push	{r4, r5, r6, lr}
 8008136:	1c04      	adds	r4, r0, #0
	struct target_ram *ram = malloc(sizeof(*ram));
 8008138:	200c      	movs	r0, #12
	t->attached = true;
	return t;
}

void target_add_ram(target *t, target_addr start, uint32_t len)
{
 800813a:	1c0e      	adds	r6, r1, #0
 800813c:	1c15      	adds	r5, r2, #0
	struct target_ram *ram = malloc(sizeof(*ram));
 800813e:	f004 fba7 	bl	800c890 <malloc>
	ram->start = start;
	ram->length = len;
	ram->next = t->ram;
 8008142:	6da3      	ldr	r3, [r4, #88]	; 0x58
}

void target_add_ram(target *t, target_addr start, uint32_t len)
{
	struct target_ram *ram = malloc(sizeof(*ram));
	ram->start = start;
 8008144:	6006      	str	r6, [r0, #0]
	ram->length = len;
 8008146:	6045      	str	r5, [r0, #4]
	ram->next = t->ram;
 8008148:	6083      	str	r3, [r0, #8]
	t->ram = ram;
 800814a:	65a0      	str	r0, [r4, #88]	; 0x58
}
 800814c:	bd70      	pop	{r4, r5, r6, pc}

0800814e <target_add_flash>:

void target_add_flash(target *t, struct target_flash *f)
{
	f->t = t;
	f->next = t->flash;
 800814e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
	t->ram = ram;
}

void target_add_flash(target *t, struct target_flash *f)
{
	f->t = t;
 8008150:	6188      	str	r0, [r1, #24]
	f->next = t->flash;
 8008152:	61cb      	str	r3, [r1, #28]
	t->flash = f;
 8008154:	65c1      	str	r1, [r0, #92]	; 0x5c
}
 8008156:	4770      	bx	lr

08008158 <target_mem_map>:
	                            (uint32_t)f->blocksize);
	return i;
}

const char *target_mem_map(target *t)
{
 8008158:	b5f0      	push	{r4, r5, r6, r7, lr}
 800815a:	6d44      	ldr	r4, [r0, #84]	; 0x54
 800815c:	b087      	sub	sp, #28
	if (t->dyn_mem_map)
 800815e:	2c00      	cmp	r4, #0
 8008160:	d143      	bne.n	80081ea <target_mem_map+0x92>
 8008162:	1c04      	adds	r4, r0, #0
		return t->dyn_mem_map;

	/* FIXME size buffer */
	size_t len = 1024;
	char *tmp = malloc(len);
 8008164:	2080      	movs	r0, #128	; 0x80
 8008166:	00c0      	lsls	r0, r0, #3
 8008168:	f004 fb92 	bl	800c890 <malloc>
	size_t i = 0;
	i = snprintf(&tmp[i], len - i, "<memory-map>");
 800816c:	2180      	movs	r1, #128	; 0x80
 800816e:	4a20      	ldr	r2, [pc, #128]	; (80081f0 <target_mem_map+0x98>)
 8008170:	00c9      	lsls	r1, r1, #3
	if (t->dyn_mem_map)
		return t->dyn_mem_map;

	/* FIXME size buffer */
	size_t len = 1024;
	char *tmp = malloc(len);
 8008172:	9003      	str	r0, [sp, #12]
	size_t i = 0;
	i = snprintf(&tmp[i], len - i, "<memory-map>");
 8008174:	f004 fd82 	bl	800cc7c <sniprintf>
 8008178:	1c05      	adds	r5, r0, #0
	/* Map each defined RAM */
	for (struct target_ram *r = t->ram; r; r = r->next)
 800817a:	6da6      	ldr	r6, [r4, #88]	; 0x58
 800817c:	2e00      	cmp	r6, #0
 800817e:	d00d      	beq.n	800819c <target_mem_map+0x44>
		i += map_ram(&tmp[i], len - i, r);
 8008180:	2180      	movs	r1, #128	; 0x80
 8008182:	9b03      	ldr	r3, [sp, #12]
 8008184:	00c9      	lsls	r1, r1, #3
 8008186:	1958      	adds	r0, r3, r5
	t->flash = f;
}

static ssize_t map_ram(char *buf, size_t len, struct target_ram *ram)
{
	return snprintf(buf, len, "<memory type=\"ram\" start=\"0x%08"PRIx32
 8008188:	6873      	ldr	r3, [r6, #4]
	char *tmp = malloc(len);
	size_t i = 0;
	i = snprintf(&tmp[i], len - i, "<memory-map>");
	/* Map each defined RAM */
	for (struct target_ram *r = t->ram; r; r = r->next)
		i += map_ram(&tmp[i], len - i, r);
 800818a:	1b49      	subs	r1, r1, r5
	t->flash = f;
}

static ssize_t map_ram(char *buf, size_t len, struct target_ram *ram)
{
	return snprintf(buf, len, "<memory type=\"ram\" start=\"0x%08"PRIx32
 800818c:	9300      	str	r3, [sp, #0]
 800818e:	6833      	ldr	r3, [r6, #0]
 8008190:	4a18      	ldr	r2, [pc, #96]	; (80081f4 <target_mem_map+0x9c>)
 8008192:	f004 fd73 	bl	800cc7c <sniprintf>
	size_t len = 1024;
	char *tmp = malloc(len);
	size_t i = 0;
	i = snprintf(&tmp[i], len - i, "<memory-map>");
	/* Map each defined RAM */
	for (struct target_ram *r = t->ram; r; r = r->next)
 8008196:	68b6      	ldr	r6, [r6, #8]
		i += map_ram(&tmp[i], len - i, r);
 8008198:	182d      	adds	r5, r5, r0
 800819a:	e7ef      	b.n	800817c <target_mem_map+0x24>
	/* Map each defined Flash */
	for (struct target_flash *f = t->flash; f; f = f->next)
 800819c:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 800819e:	2180      	movs	r1, #128	; 0x80
 80081a0:	9b03      	ldr	r3, [sp, #12]
 80081a2:	00c9      	lsls	r1, r1, #3
 80081a4:	195b      	adds	r3, r3, r5
 80081a6:	9304      	str	r3, [sp, #16]
 80081a8:	2e00      	cmp	r6, #0
 80081aa:	d016      	beq.n	80081da <target_mem_map+0x82>
		i += map_flash(&tmp[i], len - i, f);
 80081ac:	1b4b      	subs	r3, r1, r5
 80081ae:	9305      	str	r3, [sp, #20]
}

static ssize_t map_flash(char *buf, size_t len, struct target_flash *f)
{
	int i = 0;
	i += snprintf(&buf[i], len - i, "<memory type=\"flash\" start=\"0x%08"PRIx32
 80081b0:	6873      	ldr	r3, [r6, #4]
 80081b2:	9905      	ldr	r1, [sp, #20]
 80081b4:	9300      	str	r3, [sp, #0]
 80081b6:	6833      	ldr	r3, [r6, #0]
 80081b8:	4a0f      	ldr	r2, [pc, #60]	; (80081f8 <target_mem_map+0xa0>)
 80081ba:	9804      	ldr	r0, [sp, #16]
 80081bc:	f004 fd5e 	bl	800cc7c <sniprintf>
 80081c0:	1c07      	adds	r7, r0, #0
	                                "\" length=\"0x%"PRIx32"\">",
	                                f->start, (uint32_t)f->length);
	i += snprintf(&buf[i], len - i, "<property name=\"blocksize\">0x%"PRIx32
 80081c2:	9b04      	ldr	r3, [sp, #16]
 80081c4:	4a0d      	ldr	r2, [pc, #52]	; (80081fc <target_mem_map+0xa4>)
 80081c6:	1818      	adds	r0, r3, r0
 80081c8:	9b05      	ldr	r3, [sp, #20]
 80081ca:	1bd9      	subs	r1, r3, r7
 80081cc:	68b3      	ldr	r3, [r6, #8]
 80081ce:	f004 fd55 	bl	800cc7c <sniprintf>
 80081d2:	183f      	adds	r7, r7, r0
	/* Map each defined RAM */
	for (struct target_ram *r = t->ram; r; r = r->next)
		i += map_ram(&tmp[i], len - i, r);
	/* Map each defined Flash */
	for (struct target_flash *f = t->flash; f; f = f->next)
		i += map_flash(&tmp[i], len - i, f);
 80081d4:	19ed      	adds	r5, r5, r7
	i = snprintf(&tmp[i], len - i, "<memory-map>");
	/* Map each defined RAM */
	for (struct target_ram *r = t->ram; r; r = r->next)
		i += map_ram(&tmp[i], len - i, r);
	/* Map each defined Flash */
	for (struct target_flash *f = t->flash; f; f = f->next)
 80081d6:	69f6      	ldr	r6, [r6, #28]
 80081d8:	e7e1      	b.n	800819e <target_mem_map+0x46>
		i += map_flash(&tmp[i], len - i, f);
	i += snprintf(&tmp[i], len - i, "</memory-map>");
 80081da:	1c18      	adds	r0, r3, #0
 80081dc:	1b49      	subs	r1, r1, r5
 80081de:	4a08      	ldr	r2, [pc, #32]	; (8008200 <target_mem_map+0xa8>)
 80081e0:	f004 fd4c 	bl	800cc7c <sniprintf>

	t->dyn_mem_map = tmp;
 80081e4:	9b03      	ldr	r3, [sp, #12]
 80081e6:	6563      	str	r3, [r4, #84]	; 0x54

	return t->dyn_mem_map;
 80081e8:	1c1c      	adds	r4, r3, #0
}
 80081ea:	1c20      	adds	r0, r4, #0
 80081ec:	b007      	add	sp, #28
 80081ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80081f0:	08013664 	.word	0x08013664
 80081f4:	08013671 	.word	0x08013671
 80081f8:	080136a5 	.word	0x080136a5
 80081fc:	080136da 	.word	0x080136da
 8008200:	0801370f 	.word	0x0801370f

08008204 <target_flash_erase>:
	return NULL;
}

int target_flash_erase(target *t, target_addr addr, size_t len)
{
	int ret = 0;
 8008204:	2300      	movs	r3, #0
			return f;
	return NULL;
}

int target_flash_erase(target *t, target_addr addr, size_t len)
{
 8008206:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008208:	1c0e      	adds	r6, r1, #0
 800820a:	1c17      	adds	r7, r2, #0
 800820c:	9001      	str	r0, [sp, #4]
	int ret = 0;
 800820e:	9300      	str	r3, [sp, #0]
	while (len) {
 8008210:	2f00      	cmp	r7, #0
 8008212:	d020      	beq.n	8008256 <target_flash_erase+0x52>
 8008214:	9b01      	ldr	r3, [sp, #4]
 8008216:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
	return t->dyn_mem_map;
}

static struct target_flash *flash_for_addr(target *t, uint32_t addr)
{
	for (struct target_flash *f = t->flash; f; f = f->next)
 8008218:	2c00      	cmp	r4, #0
 800821a:	d008      	beq.n	800822e <target_flash_erase+0x2a>
		if ((f->start <= addr) &&
 800821c:	6823      	ldr	r3, [r4, #0]
 800821e:	42b3      	cmp	r3, r6
 8008220:	d803      	bhi.n	800822a <target_flash_erase+0x26>
		    (addr < (f->start + f->length)))
 8008222:	6862      	ldr	r2, [r4, #4]
 8008224:	189b      	adds	r3, r3, r2
}

static struct target_flash *flash_for_addr(target *t, uint32_t addr)
{
	for (struct target_flash *f = t->flash; f; f = f->next)
		if ((f->start <= addr) &&
 8008226:	429e      	cmp	r6, r3
 8008228:	d301      	bcc.n	800822e <target_flash_erase+0x2a>
	return t->dyn_mem_map;
}

static struct target_flash *flash_for_addr(target *t, uint32_t addr)
{
	for (struct target_flash *f = t->flash; f; f = f->next)
 800822a:	69e4      	ldr	r4, [r4, #28]
 800822c:	e7f4      	b.n	8008218 <target_flash_erase+0x14>
int target_flash_erase(target *t, target_addr addr, size_t len)
{
	int ret = 0;
	while (len) {
		struct target_flash *f = flash_for_addr(t, addr);
		size_t tmplen = MIN(len, f->length - (addr % f->length));
 800822e:	6865      	ldr	r5, [r4, #4]
 8008230:	1c30      	adds	r0, r6, #0
 8008232:	1c29      	adds	r1, r5, #0
 8008234:	f006 fc32 	bl	800ea9c <__aeabi_uidivmod>
 8008238:	1a6d      	subs	r5, r5, r1
 800823a:	42bd      	cmp	r5, r7
 800823c:	d900      	bls.n	8008240 <target_flash_erase+0x3c>
 800823e:	1c3d      	adds	r5, r7, #0
		ret |= f->erase(f, addr, tmplen);
 8008240:	68e3      	ldr	r3, [r4, #12]
 8008242:	1c31      	adds	r1, r6, #0
 8008244:	1c20      	adds	r0, r4, #0
 8008246:	1c2a      	adds	r2, r5, #0
 8008248:	4798      	blx	r3
 800824a:	9b00      	ldr	r3, [sp, #0]
		addr += tmplen;
 800824c:	1976      	adds	r6, r6, r5
{
	int ret = 0;
	while (len) {
		struct target_flash *f = flash_for_addr(t, addr);
		size_t tmplen = MIN(len, f->length - (addr % f->length));
		ret |= f->erase(f, addr, tmplen);
 800824e:	4303      	orrs	r3, r0
 8008250:	9300      	str	r3, [sp, #0]
		addr += tmplen;
		len -= tmplen;
 8008252:	1b7f      	subs	r7, r7, r5
 8008254:	e7dc      	b.n	8008210 <target_flash_erase+0xc>
	}
	return ret;
}
 8008256:	9800      	ldr	r0, [sp, #0]
 8008258:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800825a <target_flash_write>:

int target_flash_write(target *t,
                       target_addr dest, const void *src, size_t len)
{
 800825a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800825c:	1c1d      	adds	r5, r3, #0
	int ret = 0;
 800825e:	2300      	movs	r3, #0
	return ret;
}

int target_flash_write(target *t,
                       target_addr dest, const void *src, size_t len)
{
 8008260:	b089      	sub	sp, #36	; 0x24
 8008262:	af00      	add	r7, sp, #0
 8008264:	60b8      	str	r0, [r7, #8]
 8008266:	61f9      	str	r1, [r7, #28]
 8008268:	613a      	str	r2, [r7, #16]
	int ret = 0;
 800826a:	61bb      	str	r3, [r7, #24]
	while (len) {
 800826c:	2d00      	cmp	r5, #0
 800826e:	d059      	beq.n	8008324 <target_flash_write+0xca>
 8008270:	68bb      	ldr	r3, [r7, #8]
 8008272:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
	return t->dyn_mem_map;
}

static struct target_flash *flash_for_addr(target *t, uint32_t addr)
{
	for (struct target_flash *f = t->flash; f; f = f->next)
 8008274:	2c00      	cmp	r4, #0
 8008276:	d053      	beq.n	8008320 <target_flash_write+0xc6>
		if ((f->start <= addr) &&
 8008278:	6823      	ldr	r3, [r4, #0]
 800827a:	69fa      	ldr	r2, [r7, #28]
 800827c:	4293      	cmp	r3, r2
 800827e:	d83d      	bhi.n	80082fc <target_flash_write+0xa2>
		    (addr < (f->start + f->length)))
 8008280:	6866      	ldr	r6, [r4, #4]
 8008282:	18f3      	adds	r3, r6, r3
}

static struct target_flash *flash_for_addr(target *t, uint32_t addr)
{
	for (struct target_flash *f = t->flash; f; f = f->next)
		if ((f->start <= addr) &&
 8008284:	429a      	cmp	r2, r3
 8008286:	d239      	bcs.n	80082fc <target_flash_write+0xa2>
                       target_addr dest, const void *src, size_t len)
{
	int ret = 0;
	while (len) {
		struct target_flash *f = flash_for_addr(t, dest);
		size_t tmplen = MIN(len, f->length - (dest % f->length));
 8008288:	1c10      	adds	r0, r2, #0
 800828a:	1c31      	adds	r1, r6, #0
 800828c:	f006 fc06 	bl	800ea9c <__aeabi_uidivmod>
 8008290:	1a73      	subs	r3, r6, r1
 8008292:	617b      	str	r3, [r7, #20]
 8008294:	42ab      	cmp	r3, r5
 8008296:	d900      	bls.n	800829a <target_flash_write+0x40>
 8008298:	617d      	str	r5, [r7, #20]
		if (f->align > 1) {
 800829a:	6a26      	ldr	r6, [r4, #32]
 800829c:	2e01      	cmp	r6, #1
 800829e:	dd2f      	ble.n	8008300 <target_flash_write+0xa6>
 80082a0:	466b      	mov	r3, sp
			uint32_t offset = dest % f->align;
 80082a2:	69f8      	ldr	r0, [r7, #28]
 80082a4:	1c31      	adds	r1, r6, #0
 80082a6:	607b      	str	r3, [r7, #4]
 80082a8:	f006 fbf8 	bl	800ea9c <__aeabi_uidivmod>
			uint8_t data[ALIGN(offset + len, f->align)];
 80082ac:	466a      	mov	r2, sp
 80082ae:	1e73      	subs	r3, r6, #1
 80082b0:	185b      	adds	r3, r3, r1
 80082b2:	195b      	adds	r3, r3, r5
 80082b4:	4276      	negs	r6, r6
 80082b6:	401e      	ands	r6, r3
 80082b8:	1df3      	adds	r3, r6, #7
 80082ba:	08db      	lsrs	r3, r3, #3
 80082bc:	00db      	lsls	r3, r3, #3
 80082be:	1ad3      	subs	r3, r2, r3
 80082c0:	469d      	mov	sp, r3
	int ret = 0;
	while (len) {
		struct target_flash *f = flash_for_addr(t, dest);
		size_t tmplen = MIN(len, f->length - (dest % f->length));
		if (f->align > 1) {
			uint32_t offset = dest % f->align;
 80082c2:	60f9      	str	r1, [r7, #12]
			uint8_t data[ALIGN(offset + len, f->align)];
			memset(data, f->erased, sizeof(data));
 80082c4:	1d63      	adds	r3, r4, #5
 80082c6:	7fd9      	ldrb	r1, [r3, #31]
 80082c8:	4668      	mov	r0, sp
 80082ca:	1c32      	adds	r2, r6, #0
 80082cc:	f004 fb11 	bl	800c8f2 <memset>
			memcpy((uint8_t *)data + offset, src, len);
 80082d0:	68fb      	ldr	r3, [r7, #12]
 80082d2:	6939      	ldr	r1, [r7, #16]
 80082d4:	446b      	add	r3, sp
 80082d6:	1c18      	adds	r0, r3, #0
 80082d8:	1c2a      	adds	r2, r5, #0
 80082da:	f004 faed 	bl	800c8b8 <memcpy>
			ret |= f->write(f, dest - offset, data, sizeof(data));
 80082de:	69fb      	ldr	r3, [r7, #28]
 80082e0:	68fa      	ldr	r2, [r7, #12]
 80082e2:	1c20      	adds	r0, r4, #0
 80082e4:	1a99      	subs	r1, r3, r2
 80082e6:	6923      	ldr	r3, [r4, #16]
 80082e8:	466a      	mov	r2, sp
 80082ea:	469c      	mov	ip, r3
 80082ec:	1c33      	adds	r3, r6, #0
 80082ee:	47e0      	blx	ip
 80082f0:	69bb      	ldr	r3, [r7, #24]
 80082f2:	4303      	orrs	r3, r0
 80082f4:	61bb      	str	r3, [r7, #24]
 80082f6:	687b      	ldr	r3, [r7, #4]
 80082f8:	469d      	mov	sp, r3
 80082fa:	e00a      	b.n	8008312 <target_flash_write+0xb8>
	return t->dyn_mem_map;
}

static struct target_flash *flash_for_addr(target *t, uint32_t addr)
{
	for (struct target_flash *f = t->flash; f; f = f->next)
 80082fc:	69e4      	ldr	r4, [r4, #28]
 80082fe:	e7b9      	b.n	8008274 <target_flash_write+0x1a>
			uint8_t data[ALIGN(offset + len, f->align)];
			memset(data, f->erased, sizeof(data));
			memcpy((uint8_t *)data + offset, src, len);
			ret |= f->write(f, dest - offset, data, sizeof(data));
		} else {
			ret |= f->write(f, dest, src, tmplen);
 8008300:	697b      	ldr	r3, [r7, #20]
 8008302:	6926      	ldr	r6, [r4, #16]
 8008304:	1c20      	adds	r0, r4, #0
 8008306:	69f9      	ldr	r1, [r7, #28]
 8008308:	693a      	ldr	r2, [r7, #16]
 800830a:	47b0      	blx	r6
 800830c:	69bb      	ldr	r3, [r7, #24]
 800830e:	4303      	orrs	r3, r0
 8008310:	61bb      	str	r3, [r7, #24]
		}
		src += tmplen;
 8008312:	697a      	ldr	r2, [r7, #20]
 8008314:	693b      	ldr	r3, [r7, #16]
 8008316:	4694      	mov	ip, r2
 8008318:	4463      	add	r3, ip
 800831a:	613b      	str	r3, [r7, #16]
		len -= tmplen;
 800831c:	1aad      	subs	r5, r5, r2
 800831e:	e7a5      	b.n	800826c <target_flash_write+0x12>
                       target_addr dest, const void *src, size_t len)
{
	int ret = 0;
	while (len) {
		struct target_flash *f = flash_for_addr(t, dest);
		size_t tmplen = MIN(len, f->length - (dest % f->length));
 8008320:	6863      	ldr	r3, [r4, #4]
 8008322:	deff      	udf	#255	; 0xff
		}
		src += tmplen;
		len -= tmplen;
	}
	return ret;
}
 8008324:	46bd      	mov	sp, r7
 8008326:	69b8      	ldr	r0, [r7, #24]
 8008328:	b009      	add	sp, #36	; 0x24
 800832a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800832c <target_flash_done>:

int target_flash_done(target *t)
{
 800832c:	b510      	push	{r4, lr}
	for (struct target_flash *f = t->flash; f; f = f->next) {
 800832e:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
 8008330:	2c00      	cmp	r4, #0
 8008332:	d008      	beq.n	8008346 <target_flash_done+0x1a>
		if (f->done) {
 8008334:	6963      	ldr	r3, [r4, #20]
 8008336:	2b00      	cmp	r3, #0
 8008338:	d003      	beq.n	8008342 <target_flash_done+0x16>
			int tmp = f->done(f);
 800833a:	1c20      	adds	r0, r4, #0
 800833c:	4798      	blx	r3
			if (tmp)
 800833e:	2800      	cmp	r0, #0
 8008340:	d102      	bne.n	8008348 <target_flash_done+0x1c>
	return ret;
}

int target_flash_done(target *t)
{
	for (struct target_flash *f = t->flash; f; f = f->next) {
 8008342:	69e4      	ldr	r4, [r4, #28]
 8008344:	e7f4      	b.n	8008330 <target_flash_done+0x4>
			int tmp = f->done(f);
			if (tmp)
				return tmp;
		}
	}
	return 0;
 8008346:	1c20      	adds	r0, r4, #0
}
 8008348:	bd10      	pop	{r4, pc}

0800834a <target_flash_write_buffered>:

int target_flash_write_buffered(struct target_flash *f,
                                target_addr dest, const void *src, size_t len)
{
 800834a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800834c:	1c1e      	adds	r6, r3, #0
	int ret = 0;

	if (f->buf == NULL) {
 800834e:	6b43      	ldr	r3, [r0, #52]	; 0x34
	return 0;
}

int target_flash_write_buffered(struct target_flash *f,
                                target_addr dest, const void *src, size_t len)
{
 8008350:	b085      	sub	sp, #20
 8008352:	1c04      	adds	r4, r0, #0
 8008354:	1c0f      	adds	r7, r1, #0
 8008356:	9202      	str	r2, [sp, #8]
	int ret = 0;

	if (f->buf == NULL) {
 8008358:	2b00      	cmp	r3, #0
 800835a:	d106      	bne.n	800836a <target_flash_write_buffered+0x20>
		/* Allocate flash sector buffer */
		f->buf = malloc(f->buf_size);
 800835c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800835e:	f004 fa97 	bl	800c890 <malloc>
		f->buf_addr = -1;
 8008362:	2301      	movs	r3, #1
 8008364:	425b      	negs	r3, r3
{
	int ret = 0;

	if (f->buf == NULL) {
		/* Allocate flash sector buffer */
		f->buf = malloc(f->buf_size);
 8008366:	6360      	str	r0, [r4, #52]	; 0x34
		f->buf_addr = -1;
 8008368:	6323      	str	r3, [r4, #48]	; 0x30
	return 0;
}

int target_flash_write_buffered(struct target_flash *f,
                                target_addr dest, const void *src, size_t len)
{
 800836a:	2300      	movs	r3, #0
 800836c:	9300      	str	r3, [sp, #0]
	if (f->buf == NULL) {
		/* Allocate flash sector buffer */
		f->buf = malloc(f->buf_size);
		f->buf_addr = -1;
	}
	while (len) {
 800836e:	2e00      	cmp	r6, #0
 8008370:	d031      	beq.n	80083d6 <target_flash_write_buffered+0x8c>
		uint32_t offset = dest % f->buf_size;
 8008372:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8008374:	1c38      	adds	r0, r7, #0
 8008376:	1c29      	adds	r1, r5, #0
 8008378:	f006 fb90 	bl	800ea9c <__aeabi_uidivmod>
		uint32_t base = dest - offset;
 800837c:	1a7b      	subs	r3, r7, r1
		/* Allocate flash sector buffer */
		f->buf = malloc(f->buf_size);
		f->buf_addr = -1;
	}
	while (len) {
		uint32_t offset = dest % f->buf_size;
 800837e:	9101      	str	r1, [sp, #4]
		uint32_t base = dest - offset;
		if (base != f->buf_addr) {
 8008380:	6b21      	ldr	r1, [r4, #48]	; 0x30
		f->buf = malloc(f->buf_size);
		f->buf_addr = -1;
	}
	while (len) {
		uint32_t offset = dest % f->buf_size;
		uint32_t base = dest - offset;
 8008382:	9303      	str	r3, [sp, #12]
		if (base != f->buf_addr) {
 8008384:	428b      	cmp	r3, r1
 8008386:	d011      	beq.n	80083ac <target_flash_write_buffered+0x62>
			if (f->buf_addr != (uint32_t)-1) {
 8008388:	1c4b      	adds	r3, r1, #1
 800838a:	d007      	beq.n	800839c <target_flash_write_buffered+0x52>
				/* Write sector to flash if valid */
				ret |= f->write_buf(f, f->buf_addr,
 800838c:	1c2b      	adds	r3, r5, #0
 800838e:	1c20      	adds	r0, r4, #0
 8008390:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8008392:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8008394:	47a8      	blx	r5
 8008396:	9b00      	ldr	r3, [sp, #0]
 8008398:	4303      	orrs	r3, r0
 800839a:	9300      	str	r3, [sp, #0]
				                    f->buf, f->buf_size);
			}
			/* Setup buffer for a new sector */
			f->buf_addr = base;
 800839c:	9b03      	ldr	r3, [sp, #12]
			memset(f->buf, f->erased, f->buf_size);
 800839e:	6b60      	ldr	r0, [r4, #52]	; 0x34
				/* Write sector to flash if valid */
				ret |= f->write_buf(f, f->buf_addr,
				                    f->buf, f->buf_size);
			}
			/* Setup buffer for a new sector */
			f->buf_addr = base;
 80083a0:	6323      	str	r3, [r4, #48]	; 0x30
			memset(f->buf, f->erased, f->buf_size);
 80083a2:	1d63      	adds	r3, r4, #5
 80083a4:	7fd9      	ldrb	r1, [r3, #31]
 80083a6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80083a8:	f004 faa3 	bl	800c8f2 <memset>
		}
		/* Copy chunk into sector buffer */
		size_t sectlen = MIN(f->buf_size - offset, len);
 80083ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80083ae:	9a01      	ldr	r2, [sp, #4]
 80083b0:	1a9d      	subs	r5, r3, r2
 80083b2:	42b5      	cmp	r5, r6
 80083b4:	d900      	bls.n	80083b8 <target_flash_write_buffered+0x6e>
 80083b6:	1c35      	adds	r5, r6, #0
		memcpy(f->buf + offset, src, sectlen);
 80083b8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80083ba:	9b01      	ldr	r3, [sp, #4]
 80083bc:	4694      	mov	ip, r2
 80083be:	4463      	add	r3, ip
 80083c0:	1c18      	adds	r0, r3, #0
 80083c2:	9902      	ldr	r1, [sp, #8]
 80083c4:	1c2a      	adds	r2, r5, #0
 80083c6:	f004 fa77 	bl	800c8b8 <memcpy>
		dest += sectlen;
		src += sectlen;
 80083ca:	9b02      	ldr	r3, [sp, #8]
			memset(f->buf, f->erased, f->buf_size);
		}
		/* Copy chunk into sector buffer */
		size_t sectlen = MIN(f->buf_size - offset, len);
		memcpy(f->buf + offset, src, sectlen);
		dest += sectlen;
 80083cc:	197f      	adds	r7, r7, r5
		src += sectlen;
 80083ce:	195b      	adds	r3, r3, r5
 80083d0:	9302      	str	r3, [sp, #8]
		len -= sectlen;
 80083d2:	1b76      	subs	r6, r6, r5
 80083d4:	e7cb      	b.n	800836e <target_flash_write_buffered+0x24>
	}
	return ret;
}
 80083d6:	9800      	ldr	r0, [sp, #0]
 80083d8:	b005      	add	sp, #20
 80083da:	bdf0      	pop	{r4, r5, r6, r7, pc}

080083dc <target_flash_done_buffered>:

int target_flash_done_buffered(struct target_flash *f)
{
	int ret = 0;
	if ((f->buf != NULL) &&(f->buf_addr != (uint32_t)-1)) {
 80083dc:	6b42      	ldr	r2, [r0, #52]	; 0x34
	}
	return ret;
}

int target_flash_done_buffered(struct target_flash *f)
{
 80083de:	b538      	push	{r3, r4, r5, lr}
	int ret = 0;
 80083e0:	1e15      	subs	r5, r2, #0
	if ((f->buf != NULL) &&(f->buf_addr != (uint32_t)-1)) {
 80083e2:	d010      	beq.n	8008406 <target_flash_done_buffered+0x2a>
 80083e4:	6b01      	ldr	r1, [r0, #48]	; 0x30
	return ret;
}

int target_flash_done_buffered(struct target_flash *f)
{
	int ret = 0;
 80083e6:	2500      	movs	r5, #0
	if ((f->buf != NULL) &&(f->buf_addr != (uint32_t)-1)) {
 80083e8:	1c4b      	adds	r3, r1, #1
 80083ea:	d00c      	beq.n	8008406 <target_flash_done_buffered+0x2a>
		/* Write sector to flash if valid */
		ret = f->write_buf(f, f->buf_addr, f->buf, f->buf_size);
 80083ec:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80083ee:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80083f0:	1c04      	adds	r4, r0, #0
 80083f2:	47a8      	blx	r5
		f->buf_addr = -1;
 80083f4:	2301      	movs	r3, #1
 80083f6:	425b      	negs	r3, r3
 80083f8:	6323      	str	r3, [r4, #48]	; 0x30
int target_flash_done_buffered(struct target_flash *f)
{
	int ret = 0;
	if ((f->buf != NULL) &&(f->buf_addr != (uint32_t)-1)) {
		/* Write sector to flash if valid */
		ret = f->write_buf(f, f->buf_addr, f->buf, f->buf_size);
 80083fa:	1c05      	adds	r5, r0, #0
		f->buf_addr = -1;
		free(f->buf);
 80083fc:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80083fe:	f004 fa51 	bl	800c8a4 <free>
		f->buf = NULL;
 8008402:	2300      	movs	r3, #0
 8008404:	6363      	str	r3, [r4, #52]	; 0x34
	}

	return ret;
}
 8008406:	1c28      	adds	r0, r5, #0
 8008408:	bd38      	pop	{r3, r4, r5, pc}

0800840a <target_detach>:

/* Wrapper functions */
void target_detach(target *t)
{
 800840a:	b510      	push	{r4, lr}
 800840c:	1c04      	adds	r4, r0, #0
	t->detach(t);
 800840e:	68e3      	ldr	r3, [r4, #12]
 8008410:	4798      	blx	r3
	t->attached = false;
 8008412:	2300      	movs	r3, #0
 8008414:	7023      	strb	r3, [r4, #0]
}
 8008416:	bd10      	pop	{r4, pc}

08008418 <target_check_error>:

bool target_check_error(target *t) { return t->check_error(t); }
 8008418:	b508      	push	{r3, lr}
 800841a:	6903      	ldr	r3, [r0, #16]
 800841c:	4798      	blx	r3
 800841e:	bd08      	pop	{r3, pc}

08008420 <target_attached>:
bool target_attached(target *t) { return t->attached; }
 8008420:	7800      	ldrb	r0, [r0, #0]
 8008422:	4770      	bx	lr

08008424 <target_mem_read>:

/* Memory access functions */
int target_mem_read(target *t, void *dest, target_addr src, size_t len)
{
 8008424:	b538      	push	{r3, r4, r5, lr}
 8008426:	1c04      	adds	r4, r0, #0
	t->mem_read(t, dest, src, len);
 8008428:	6965      	ldr	r5, [r4, #20]
 800842a:	47a8      	blx	r5
	return target_check_error(t);
 800842c:	1c20      	adds	r0, r4, #0
 800842e:	f7ff fff3 	bl	8008418 <target_check_error>
}
 8008432:	bd38      	pop	{r3, r4, r5, pc}

08008434 <target_mem_write>:

int target_mem_write(target *t, target_addr dest, const void *src, size_t len)
{
 8008434:	b538      	push	{r3, r4, r5, lr}
 8008436:	1c04      	adds	r4, r0, #0
	t->mem_write(t, dest, src, len);
 8008438:	69a5      	ldr	r5, [r4, #24]
 800843a:	47a8      	blx	r5
	return target_check_error(t);
 800843c:	1c20      	adds	r0, r4, #0
 800843e:	f7ff ffeb 	bl	8008418 <target_check_error>
}
 8008442:	bd38      	pop	{r3, r4, r5, pc}

08008444 <target_regs_read>:

/* Register access functions */
void target_regs_read(target *t, void *data) { t->regs_read(t, data); }
 8008444:	b508      	push	{r3, lr}
 8008446:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8008448:	4798      	blx	r3
 800844a:	bd08      	pop	{r3, pc}

0800844c <target_regs_write>:
void target_regs_write(target *t, const void *data) { t->regs_write(t, data); }
 800844c:	b508      	push	{r3, lr}
 800844e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8008450:	4798      	blx	r3
 8008452:	bd08      	pop	{r3, pc}

08008454 <target_reset>:

/* Halt/resume functions */
void target_reset(target *t) { t->reset(t); }
 8008454:	b508      	push	{r3, lr}
 8008456:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8008458:	4798      	blx	r3
 800845a:	bd08      	pop	{r3, pc}

0800845c <target_halt_request>:
void target_halt_request(target *t) { t->halt_request(t); }
 800845c:	b508      	push	{r3, lr}
 800845e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008460:	4798      	blx	r3
 8008462:	bd08      	pop	{r3, pc}

08008464 <target_halt_poll>:
enum target_halt_reason target_halt_poll(target *t, target_addr *watch)
{
 8008464:	b508      	push	{r3, lr}
	return t->halt_poll(t, watch);
 8008466:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8008468:	4798      	blx	r3
}
 800846a:	bd08      	pop	{r3, pc}

0800846c <target_halt_resume>:

void target_halt_resume(target *t, bool step) { t->halt_resume(t, step); }
 800846c:	b508      	push	{r3, lr}
 800846e:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8008470:	4798      	blx	r3
 8008472:	bd08      	pop	{r3, pc}

08008474 <target_breakwatch_set>:

/* Break-/watchpoint functions */
int target_breakwatch_set(target *t,
                          enum target_breakwatch type, target_addr addr, size_t len)
{
 8008474:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008476:	b089      	sub	sp, #36	; 0x24
 8008478:	1c04      	adds	r4, r0, #0
 800847a:	1c0f      	adds	r7, r1, #0
 800847c:	1c16      	adds	r6, r2, #0
	struct breakwatch bw = {
 800847e:	4668      	mov	r0, sp
 8008480:	2100      	movs	r1, #0
 8008482:	2220      	movs	r2, #32
void target_halt_resume(target *t, bool step) { t->halt_resume(t, step); }

/* Break-/watchpoint functions */
int target_breakwatch_set(target *t,
                          enum target_breakwatch type, target_addr addr, size_t len)
{
 8008484:	1c1d      	adds	r5, r3, #0
	struct breakwatch bw = {
 8008486:	f004 fa34 	bl	800c8f2 <memset>
 800848a:	466b      	mov	r3, sp
 800848c:	711f      	strb	r7, [r3, #4]
		.addr = addr,
		.size = len,
	};
	int ret = 1;

	if (t->breakwatch_set)
 800848e:	6c23      	ldr	r3, [r4, #64]	; 0x40

/* Break-/watchpoint functions */
int target_breakwatch_set(target *t,
                          enum target_breakwatch type, target_addr addr, size_t len)
{
	struct breakwatch bw = {
 8008490:	9503      	str	r5, [sp, #12]
 8008492:	9602      	str	r6, [sp, #8]
		.type = type,
		.addr = addr,
		.size = len,
	};
	int ret = 1;
 8008494:	2501      	movs	r5, #1

	if (t->breakwatch_set)
 8008496:	2b00      	cmp	r3, #0
 8008498:	d00f      	beq.n	80084ba <target_breakwatch_set+0x46>
		ret = t->breakwatch_set(t, &bw);
 800849a:	1c20      	adds	r0, r4, #0
 800849c:	4669      	mov	r1, sp
 800849e:	4798      	blx	r3
 80084a0:	1e05      	subs	r5, r0, #0

	if (ret == 0) {
 80084a2:	d10a      	bne.n	80084ba <target_breakwatch_set+0x46>
		/* Success, make a heap copy and add to list */
		struct breakwatch *bwm = malloc(sizeof bw);
 80084a4:	2020      	movs	r0, #32
 80084a6:	f004 f9f3 	bl	800c890 <malloc>
 80084aa:	1c06      	adds	r6, r0, #0
		memcpy(bwm, &bw, sizeof(bw));
 80084ac:	4669      	mov	r1, sp
 80084ae:	2220      	movs	r2, #32
 80084b0:	f004 fa02 	bl	800c8b8 <memcpy>
		bwm->next = t->bw_list;
 80084b4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		t->bw_list = bwm;
 80084b6:	64a6      	str	r6, [r4, #72]	; 0x48

	if (ret == 0) {
		/* Success, make a heap copy and add to list */
		struct breakwatch *bwm = malloc(sizeof bw);
		memcpy(bwm, &bw, sizeof(bw));
		bwm->next = t->bw_list;
 80084b8:	6033      	str	r3, [r6, #0]
		t->bw_list = bwm;
	}

	return ret;
}
 80084ba:	1c28      	adds	r0, r5, #0
 80084bc:	b009      	add	sp, #36	; 0x24
 80084be:	bdf0      	pop	{r4, r5, r6, r7, pc}

080084c0 <target_breakwatch_clear>:

int target_breakwatch_clear(target *t,
                            enum target_breakwatch type, target_addr addr, size_t len)
{
 80084c0:	b570      	push	{r4, r5, r6, lr}
	struct breakwatch *bwp = NULL, *bw;
 80084c2:	2500      	movs	r5, #0
	int ret = 1;
	for (bw = t->bw_list; bw; bw = bw->next, bwp = bw)
 80084c4:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80084c6:	2c00      	cmp	r4, #0
 80084c8:	d00b      	beq.n	80084e2 <target_breakwatch_clear+0x22>
		if ((bw->type == type) &&
 80084ca:	7926      	ldrb	r6, [r4, #4]
 80084cc:	428e      	cmp	r6, r1
 80084ce:	d105      	bne.n	80084dc <target_breakwatch_clear+0x1c>
 80084d0:	68a6      	ldr	r6, [r4, #8]
 80084d2:	4296      	cmp	r6, r2
 80084d4:	d102      	bne.n	80084dc <target_breakwatch_clear+0x1c>
		    (bw->addr == addr) &&
 80084d6:	68e6      	ldr	r6, [r4, #12]
 80084d8:	429e      	cmp	r6, r3
 80084da:	d005      	beq.n	80084e8 <target_breakwatch_clear+0x28>
int target_breakwatch_clear(target *t,
                            enum target_breakwatch type, target_addr addr, size_t len)
{
	struct breakwatch *bwp = NULL, *bw;
	int ret = 1;
	for (bw = t->bw_list; bw; bw = bw->next, bwp = bw)
 80084dc:	6824      	ldr	r4, [r4, #0]
 80084de:	1c25      	adds	r5, r4, #0
 80084e0:	e7f1      	b.n	80084c6 <target_breakwatch_clear+0x6>
		    (bw->addr == addr) &&
		    (bw->size == len))
			break;

	if (bw == NULL)
		return -1;
 80084e2:	2301      	movs	r3, #1
 80084e4:	425b      	negs	r3, r3
 80084e6:	e013      	b.n	8008510 <target_breakwatch_clear+0x50>

	if (t->breakwatch_clear)
 80084e8:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80084ea:	2b00      	cmp	r3, #0
 80084ec:	d00f      	beq.n	800850e <target_breakwatch_clear+0x4e>
		ret = t->breakwatch_clear(t, bw);
 80084ee:	1c21      	adds	r1, r4, #0
 80084f0:	1c06      	adds	r6, r0, #0
 80084f2:	4798      	blx	r3
 80084f4:	1e03      	subs	r3, r0, #0

	if (ret == 0) {
 80084f6:	d10b      	bne.n	8008510 <target_breakwatch_clear+0x50>
 80084f8:	6823      	ldr	r3, [r4, #0]
		if (bwp == NULL) {
 80084fa:	2d00      	cmp	r5, #0
 80084fc:	d101      	bne.n	8008502 <target_breakwatch_clear+0x42>
			t->bw_list = bw->next;
 80084fe:	64b3      	str	r3, [r6, #72]	; 0x48
 8008500:	e000      	b.n	8008504 <target_breakwatch_clear+0x44>
		} else {
			bwp->next = bw->next;
 8008502:	602b      	str	r3, [r5, #0]
		}
		free(bw);
 8008504:	1c20      	adds	r0, r4, #0
 8008506:	f004 f9cd 	bl	800c8a4 <free>
 800850a:	2300      	movs	r3, #0
 800850c:	e000      	b.n	8008510 <target_breakwatch_clear+0x50>

int target_breakwatch_clear(target *t,
                            enum target_breakwatch type, target_addr addr, size_t len)
{
	struct breakwatch *bwp = NULL, *bw;
	int ret = 1;
 800850e:	3301      	adds	r3, #1
			bwp->next = bw->next;
		}
		free(bw);
	}
	return ret;
}
 8008510:	1c18      	adds	r0, r3, #0
 8008512:	bd70      	pop	{r4, r5, r6, pc}

08008514 <target_regs_size>:

/* Accessor functions */
size_t target_regs_size(target *t)
{
	return t->regs_size;
 8008514:	69c0      	ldr	r0, [r0, #28]
}
 8008516:	4770      	bx	lr

08008518 <target_tdesc>:

const char *target_tdesc(target *t)
{
	return t->tdesc ? t->tdesc : "";
 8008518:	6a00      	ldr	r0, [r0, #32]
 800851a:	2800      	cmp	r0, #0
 800851c:	d100      	bne.n	8008520 <target_tdesc+0x8>
 800851e:	4801      	ldr	r0, [pc, #4]	; (8008524 <target_tdesc+0xc>)
}
 8008520:	4770      	bx	lr
 8008522:	46c0      	nop			; (mov r8, r8)
 8008524:	0800fd99 	.word	0x0800fd99

08008528 <target_driver_name>:

const char *target_driver_name(target *t)
{
	return t->driver;
 8008528:	6e00      	ldr	r0, [r0, #96]	; 0x60
}
 800852a:	4770      	bx	lr

0800852c <target_mem_read32>:

uint32_t target_mem_read32(target *t, uint32_t addr)
{
 800852c:	b513      	push	{r0, r1, r4, lr}
 800852e:	1c0a      	adds	r2, r1, #0
	uint32_t ret;
	t->mem_read(t, &ret, addr, sizeof(ret));
 8008530:	6944      	ldr	r4, [r0, #20]
 8008532:	a901      	add	r1, sp, #4
 8008534:	2304      	movs	r3, #4
 8008536:	47a0      	blx	r4
	return ret;
}
 8008538:	9801      	ldr	r0, [sp, #4]
 800853a:	bd16      	pop	{r1, r2, r4, pc}

0800853c <target_mem_write32>:

void target_mem_write32(target *t, uint32_t addr, uint32_t value)
{
 800853c:	b513      	push	{r0, r1, r4, lr}
	t->mem_write(t, addr, &value, sizeof(value));
 800853e:	2304      	movs	r3, #4
	t->mem_read(t, &ret, addr, sizeof(ret));
	return ret;
}

void target_mem_write32(target *t, uint32_t addr, uint32_t value)
{
 8008540:	9201      	str	r2, [sp, #4]
	t->mem_write(t, addr, &value, sizeof(value));
 8008542:	6984      	ldr	r4, [r0, #24]
 8008544:	aa01      	add	r2, sp, #4
 8008546:	47a0      	blx	r4
}
 8008548:	bd13      	pop	{r0, r1, r4, pc}

0800854a <target_mem_read16>:

uint16_t target_mem_read16(target *t, uint32_t addr)
{
 800854a:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint16_t ret;
	t->mem_read(t, &ret, addr, sizeof(ret));
 800854c:	466b      	mov	r3, sp
 800854e:	1d9c      	adds	r4, r3, #6
 8008550:	6945      	ldr	r5, [r0, #20]
{
	t->mem_write(t, addr, &value, sizeof(value));
}

uint16_t target_mem_read16(target *t, uint32_t addr)
{
 8008552:	1c0a      	adds	r2, r1, #0
	uint16_t ret;
	t->mem_read(t, &ret, addr, sizeof(ret));
 8008554:	2302      	movs	r3, #2
 8008556:	1c21      	adds	r1, r4, #0
 8008558:	47a8      	blx	r5
	return ret;
 800855a:	8820      	ldrh	r0, [r4, #0]
}
 800855c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0800855e <target_mem_write16>:

void target_mem_write16(target *t, uint32_t addr, uint16_t value)
{
 800855e:	b513      	push	{r0, r1, r4, lr}
 8008560:	466b      	mov	r3, sp
 8008562:	80da      	strh	r2, [r3, #6]
 8008564:	3306      	adds	r3, #6
	t->mem_write(t, addr, &value, sizeof(value));
 8008566:	1c1a      	adds	r2, r3, #0
 8008568:	6984      	ldr	r4, [r0, #24]
 800856a:	2302      	movs	r3, #2
 800856c:	47a0      	blx	r4
}
 800856e:	bd13      	pop	{r0, r1, r4, pc}

08008570 <target_mem_read8>:

uint8_t target_mem_read8(target *t, uint32_t addr)
{
 8008570:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t ret;
	t->mem_read(t, &ret, addr, sizeof(ret));
 8008572:	466b      	mov	r3, sp
 8008574:	1ddc      	adds	r4, r3, #7
 8008576:	6945      	ldr	r5, [r0, #20]
{
	t->mem_write(t, addr, &value, sizeof(value));
}

uint8_t target_mem_read8(target *t, uint32_t addr)
{
 8008578:	1c0a      	adds	r2, r1, #0
	uint8_t ret;
	t->mem_read(t, &ret, addr, sizeof(ret));
 800857a:	2301      	movs	r3, #1
 800857c:	1c21      	adds	r1, r4, #0
 800857e:	47a8      	blx	r5
	return ret;
 8008580:	7820      	ldrb	r0, [r4, #0]
}
 8008582:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

08008584 <target_mem_write8>:

void target_mem_write8(target *t, uint32_t addr, uint8_t value)
{
 8008584:	b513      	push	{r0, r1, r4, lr}
 8008586:	466b      	mov	r3, sp
 8008588:	71da      	strb	r2, [r3, #7]
 800858a:	3307      	adds	r3, #7
	t->mem_write(t, addr, &value, sizeof(value));
 800858c:	1c1a      	adds	r2, r3, #0
 800858e:	6984      	ldr	r4, [r0, #24]
 8008590:	2301      	movs	r3, #1
 8008592:	47a0      	blx	r4
}
 8008594:	bd13      	pop	{r0, r1, r4, pc}

08008596 <target_command>:
			tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);
	}
}

int target_command(target *t, int argc, const char *argv[])
{
 8008596:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008598:	1c07      	adds	r7, r0, #0
 800859a:	1c16      	adds	r6, r2, #0
 800859c:	b085      	sub	sp, #20
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next)
 800859e:	6e44      	ldr	r4, [r0, #100]	; 0x64
			tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);
	}
}

int target_command(target *t, int argc, const char *argv[])
{
 80085a0:	9103      	str	r1, [sp, #12]
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next)
 80085a2:	2c00      	cmp	r4, #0
 80085a4:	d01d      	beq.n	80085e2 <target_command+0x4c>
		for(const struct command_s *c = tc->cmds; c->cmd; c++)
 80085a6:	6865      	ldr	r5, [r4, #4]
 80085a8:	682b      	ldr	r3, [r5, #0]
 80085aa:	9301      	str	r3, [sp, #4]
 80085ac:	2b00      	cmp	r3, #0
 80085ae:	d016      	beq.n	80085de <target_command+0x48>
			if(!strncmp(argv[0], c->cmd, strlen(argv[0])))
 80085b0:	6833      	ldr	r3, [r6, #0]
 80085b2:	1c18      	adds	r0, r3, #0
 80085b4:	9302      	str	r3, [sp, #8]
 80085b6:	f004 fc37 	bl	800ce28 <strlen>
 80085ba:	9901      	ldr	r1, [sp, #4]
 80085bc:	1c02      	adds	r2, r0, #0
 80085be:	9802      	ldr	r0, [sp, #8]
 80085c0:	f004 fc60 	bl	800ce84 <strncmp>
 80085c4:	2800      	cmp	r0, #0
 80085c6:	d108      	bne.n	80085da <target_command+0x44>
				return !c->handler(t, argc, argv);
 80085c8:	686b      	ldr	r3, [r5, #4]
 80085ca:	1c38      	adds	r0, r7, #0
 80085cc:	9903      	ldr	r1, [sp, #12]
 80085ce:	1c32      	adds	r2, r6, #0
 80085d0:	4798      	blx	r3
 80085d2:	2301      	movs	r3, #1
 80085d4:	4058      	eors	r0, r3
 80085d6:	b2c0      	uxtb	r0, r0
 80085d8:	e005      	b.n	80085e6 <target_command+0x50>
}

int target_command(target *t, int argc, const char *argv[])
{
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next)
		for(const struct command_s *c = tc->cmds; c->cmd; c++)
 80085da:	350c      	adds	r5, #12
 80085dc:	e7e4      	b.n	80085a8 <target_command+0x12>
	}
}

int target_command(target *t, int argc, const char *argv[])
{
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next)
 80085de:	68a4      	ldr	r4, [r4, #8]
 80085e0:	e7df      	b.n	80085a2 <target_command+0xc>
		for(const struct command_s *c = tc->cmds; c->cmd; c++)
			if(!strncmp(argv[0], c->cmd, strlen(argv[0])))
				return !c->handler(t, argc, argv);
	return -1;
 80085e2:	2001      	movs	r0, #1
 80085e4:	4240      	negs	r0, r0
}
 80085e6:	b005      	add	sp, #20
 80085e8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080085ea <tc_printf>:

void tc_printf(target *t, const char *fmt, ...)
{
 80085ea:	b40e      	push	{r1, r2, r3}
 80085ec:	b503      	push	{r0, r1, lr}
	(void)t;
	va_list ap;

	if (t->tc == NULL)
 80085ee:	6840      	ldr	r0, [r0, #4]
 80085f0:	2800      	cmp	r0, #0
 80085f2:	d004      	beq.n	80085fe <tc_printf+0x14>
		return;

	va_start(ap, fmt);
 80085f4:	aa04      	add	r2, sp, #16
	t->tc->printf(t->tc, fmt, ap);
 80085f6:	6843      	ldr	r3, [r0, #4]
 80085f8:	9903      	ldr	r1, [sp, #12]
	va_list ap;

	if (t->tc == NULL)
		return;

	va_start(ap, fmt);
 80085fa:	9201      	str	r2, [sp, #4]
	t->tc->printf(t->tc, fmt, ap);
 80085fc:	4798      	blx	r3
	va_end(ap);
}
 80085fe:	b002      	add	sp, #8
 8008600:	bc08      	pop	{r3}
 8008602:	b003      	add	sp, #12
 8008604:	4718      	bx	r3

08008606 <target_command_help>:
{
	t->mem_write(t, addr, &value, sizeof(value));
}

void target_command_help(target *t)
{
 8008606:	b570      	push	{r4, r5, r6, lr}
 8008608:	1c06      	adds	r6, r0, #0
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next) {
 800860a:	6e44      	ldr	r4, [r0, #100]	; 0x64
 800860c:	2c00      	cmp	r4, #0
 800860e:	d011      	beq.n	8008634 <target_command_help+0x2e>
		tc_printf(t, "%s specific commands:\n", tc->specific_name);
 8008610:	1c30      	adds	r0, r6, #0
 8008612:	4909      	ldr	r1, [pc, #36]	; (8008638 <target_command_help+0x32>)
 8008614:	6822      	ldr	r2, [r4, #0]
 8008616:	f7ff ffe8 	bl	80085ea <tc_printf>
		for(const struct command_s *c = tc->cmds; c->cmd; c++)
 800861a:	6865      	ldr	r5, [r4, #4]
 800861c:	682a      	ldr	r2, [r5, #0]
 800861e:	2a00      	cmp	r2, #0
 8008620:	d006      	beq.n	8008630 <target_command_help+0x2a>
			tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);
 8008622:	68ab      	ldr	r3, [r5, #8]
 8008624:	1c30      	adds	r0, r6, #0
 8008626:	4905      	ldr	r1, [pc, #20]	; (800863c <target_command_help+0x36>)
 8008628:	f7ff ffdf 	bl	80085ea <tc_printf>

void target_command_help(target *t)
{
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next) {
		tc_printf(t, "%s specific commands:\n", tc->specific_name);
		for(const struct command_s *c = tc->cmds; c->cmd; c++)
 800862c:	350c      	adds	r5, #12
 800862e:	e7f5      	b.n	800861c <target_command_help+0x16>
	t->mem_write(t, addr, &value, sizeof(value));
}

void target_command_help(target *t)
{
	for (struct target_command_s *tc = t->commands; tc; tc = tc->next) {
 8008630:	68a4      	ldr	r4, [r4, #8]
 8008632:	e7eb      	b.n	800860c <target_command_help+0x6>
		tc_printf(t, "%s specific commands:\n", tc->specific_name);
		for(const struct command_s *c = tc->cmds; c->cmd; c++)
			tc_printf(t, "\t%s -- %s\n", c->cmd, c->help);
	}
}
 8008634:	bd70      	pop	{r4, r5, r6, pc}
 8008636:	46c0      	nop			; (mov r8, r8)
 8008638:	0801371d 	.word	0x0801371d
 800863c:	0800fd6c 	.word	0x0800fd6c

08008640 <tc_open>:
}

/* Interface to host system calls */
int tc_open(target *t, target_addr path, size_t plen,
            enum target_open_flags flags, mode_t mode)
{
 8008640:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (t->tc->open == NULL) {
 8008642:	6840      	ldr	r0, [r0, #4]
 8008644:	6884      	ldr	r4, [r0, #8]
 8008646:	2c00      	cmp	r4, #0
 8008648:	d105      	bne.n	8008656 <tc_open+0x16>
		t->tc->errno_ = TARGET_ENFILE;
 800864a:	2317      	movs	r3, #23
 800864c:	3038      	adds	r0, #56	; 0x38
 800864e:	7003      	strb	r3, [r0, #0]
		return -1;
 8008650:	2001      	movs	r0, #1
 8008652:	4240      	negs	r0, r0
 8008654:	e002      	b.n	800865c <tc_open+0x1c>
	}
	return t->tc->open(t->tc, path, plen, flags, mode);
 8008656:	9d06      	ldr	r5, [sp, #24]
 8008658:	9500      	str	r5, [sp, #0]
 800865a:	47a0      	blx	r4
}
 800865c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0800865e <tc_close>:

int tc_close(target *t, int fd)
{
	if (t->tc->close == NULL) {
 800865e:	6840      	ldr	r0, [r0, #4]
	}
	return t->tc->open(t->tc, path, plen, flags, mode);
}

int tc_close(target *t, int fd)
{
 8008660:	b508      	push	{r3, lr}
	if (t->tc->close == NULL) {
 8008662:	68c3      	ldr	r3, [r0, #12]
 8008664:	2b00      	cmp	r3, #0
 8008666:	d105      	bne.n	8008674 <tc_close+0x16>
		t->tc->errno_ = TARGET_EBADF;
 8008668:	3038      	adds	r0, #56	; 0x38
 800866a:	3309      	adds	r3, #9
 800866c:	7003      	strb	r3, [r0, #0]
		return -1;
 800866e:	2001      	movs	r0, #1
 8008670:	4240      	negs	r0, r0
 8008672:	e000      	b.n	8008676 <tc_close+0x18>
	}
	return t->tc->close(t->tc, fd);
 8008674:	4798      	blx	r3
}
 8008676:	bd08      	pop	{r3, pc}

08008678 <tc_read>:

int tc_read(target *t, int fd, target_addr buf, unsigned int count)
{
 8008678:	b538      	push	{r3, r4, r5, lr}
	if (t->tc->read == NULL)
 800867a:	6845      	ldr	r5, [r0, #4]
 800867c:	692c      	ldr	r4, [r5, #16]
		return 0;
 800867e:	1e20      	subs	r0, r4, #0
	return t->tc->close(t->tc, fd);
}

int tc_read(target *t, int fd, target_addr buf, unsigned int count)
{
	if (t->tc->read == NULL)
 8008680:	d001      	beq.n	8008686 <tc_read+0xe>
		return 0;
	return t->tc->read(t->tc, fd, buf, count);
 8008682:	1c28      	adds	r0, r5, #0
 8008684:	47a0      	blx	r4
}
 8008686:	bd38      	pop	{r3, r4, r5, pc}

08008688 <tc_write>:

int tc_write(target *t, int fd, target_addr buf, unsigned int count)
{
 8008688:	b538      	push	{r3, r4, r5, lr}
	if (t->tc->write == NULL)
 800868a:	6845      	ldr	r5, [r0, #4]
 800868c:	696c      	ldr	r4, [r5, #20]
		return 0;
 800868e:	1e20      	subs	r0, r4, #0
	return t->tc->read(t->tc, fd, buf, count);
}

int tc_write(target *t, int fd, target_addr buf, unsigned int count)
{
	if (t->tc->write == NULL)
 8008690:	d001      	beq.n	8008696 <tc_write+0xe>
		return 0;
	return t->tc->write(t->tc, fd, buf, count);
 8008692:	1c28      	adds	r0, r5, #0
 8008694:	47a0      	blx	r4
}
 8008696:	bd38      	pop	{r3, r4, r5, pc}

08008698 <tc_lseek>:

long tc_lseek(target *t, int fd, long offset, enum target_seek_flag flag)
{
 8008698:	b538      	push	{r3, r4, r5, lr}
	if (t->tc->lseek == NULL)
 800869a:	6845      	ldr	r5, [r0, #4]
 800869c:	69ac      	ldr	r4, [r5, #24]
		return 0;
 800869e:	1e20      	subs	r0, r4, #0
	return t->tc->write(t->tc, fd, buf, count);
}

long tc_lseek(target *t, int fd, long offset, enum target_seek_flag flag)
{
	if (t->tc->lseek == NULL)
 80086a0:	d001      	beq.n	80086a6 <tc_lseek+0xe>
		return 0;
	return t->tc->lseek(t->tc, fd, offset, flag);
 80086a2:	1c28      	adds	r0, r5, #0
 80086a4:	47a0      	blx	r4
}
 80086a6:	bd38      	pop	{r3, r4, r5, pc}

080086a8 <tc_rename>:

int tc_rename(target *t, target_addr oldpath, size_t oldlen,
                         target_addr newpath, size_t newlen)
{
 80086a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (t->tc->rename == NULL) {
 80086aa:	6840      	ldr	r0, [r0, #4]
 80086ac:	69c4      	ldr	r4, [r0, #28]
 80086ae:	2c00      	cmp	r4, #0
 80086b0:	d105      	bne.n	80086be <tc_rename+0x16>
		t->tc->errno_ = TARGET_ENOENT;
 80086b2:	2302      	movs	r3, #2
 80086b4:	3038      	adds	r0, #56	; 0x38
 80086b6:	7003      	strb	r3, [r0, #0]
		return -1;
 80086b8:	2001      	movs	r0, #1
 80086ba:	4240      	negs	r0, r0
 80086bc:	e002      	b.n	80086c4 <tc_rename+0x1c>
	}
	return t->tc->rename(t->tc, oldpath, oldlen, newpath, newlen);
 80086be:	9d06      	ldr	r5, [sp, #24]
 80086c0:	9500      	str	r5, [sp, #0]
 80086c2:	47a0      	blx	r4
}
 80086c4:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

080086c6 <tc_unlink>:

int tc_unlink(target *t, target_addr path, size_t plen)
{
	if (t->tc->unlink == NULL) {
 80086c6:	6840      	ldr	r0, [r0, #4]
	}
	return t->tc->rename(t->tc, oldpath, oldlen, newpath, newlen);
}

int tc_unlink(target *t, target_addr path, size_t plen)
{
 80086c8:	b508      	push	{r3, lr}
	if (t->tc->unlink == NULL) {
 80086ca:	6a03      	ldr	r3, [r0, #32]
 80086cc:	2b00      	cmp	r3, #0
 80086ce:	d105      	bne.n	80086dc <tc_unlink+0x16>
		t->tc->errno_ = TARGET_ENOENT;
 80086d0:	3038      	adds	r0, #56	; 0x38
 80086d2:	3302      	adds	r3, #2
 80086d4:	7003      	strb	r3, [r0, #0]
		return -1;
 80086d6:	2001      	movs	r0, #1
 80086d8:	4240      	negs	r0, r0
 80086da:	e000      	b.n	80086de <tc_unlink+0x18>
	}
	return t->tc->unlink(t->tc, path, plen);
 80086dc:	4798      	blx	r3
}
 80086de:	bd08      	pop	{r3, pc}

080086e0 <tc_stat>:

int tc_stat(target *t, target_addr path, size_t plen, target_addr buf)
{
	if (t->tc->stat == NULL) {
 80086e0:	6840      	ldr	r0, [r0, #4]
	}
	return t->tc->unlink(t->tc, path, plen);
}

int tc_stat(target *t, target_addr path, size_t plen, target_addr buf)
{
 80086e2:	b510      	push	{r4, lr}
	if (t->tc->stat == NULL) {
 80086e4:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80086e6:	2c00      	cmp	r4, #0
 80086e8:	d105      	bne.n	80086f6 <tc_stat+0x16>
		t->tc->errno_ = TARGET_ENOENT;
 80086ea:	2302      	movs	r3, #2
 80086ec:	3038      	adds	r0, #56	; 0x38
 80086ee:	7003      	strb	r3, [r0, #0]
		return -1;
 80086f0:	2001      	movs	r0, #1
 80086f2:	4240      	negs	r0, r0
 80086f4:	e000      	b.n	80086f8 <tc_stat+0x18>
	}
	return t->tc->stat(t->tc, path, plen, buf);
 80086f6:	47a0      	blx	r4
}
 80086f8:	bd10      	pop	{r4, pc}

080086fa <tc_fstat>:

int tc_fstat(target *t, int fd, target_addr buf)
{
 80086fa:	b510      	push	{r4, lr}
	if (t->tc->fstat == NULL) {
 80086fc:	6844      	ldr	r4, [r0, #4]
 80086fe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		return 0;
 8008700:	1e18      	subs	r0, r3, #0
	return t->tc->stat(t->tc, path, plen, buf);
}

int tc_fstat(target *t, int fd, target_addr buf)
{
	if (t->tc->fstat == NULL) {
 8008702:	d001      	beq.n	8008708 <tc_fstat+0xe>
		return 0;
	}
	return t->tc->fstat(t->tc, fd, buf);
 8008704:	1c20      	adds	r0, r4, #0
 8008706:	4798      	blx	r3
}
 8008708:	bd10      	pop	{r4, pc}

0800870a <tc_gettimeofday>:

int tc_gettimeofday(target *t, target_addr tv, target_addr tz)
{
	if (t->tc->gettimeofday == NULL) {
 800870a:	6840      	ldr	r0, [r0, #4]
	}
	return t->tc->fstat(t->tc, fd, buf);
}

int tc_gettimeofday(target *t, target_addr tv, target_addr tz)
{
 800870c:	b508      	push	{r3, lr}
	if (t->tc->gettimeofday == NULL) {
 800870e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8008710:	2b00      	cmp	r3, #0
 8008712:	d001      	beq.n	8008718 <tc_gettimeofday+0xe>
		return -1;
	}
	return t->tc->gettimeofday(t->tc, tv, tz);
 8008714:	4798      	blx	r3
 8008716:	e001      	b.n	800871c <tc_gettimeofday+0x12>
}

int tc_gettimeofday(target *t, target_addr tv, target_addr tz)
{
	if (t->tc->gettimeofday == NULL) {
		return -1;
 8008718:	2001      	movs	r0, #1
 800871a:	4240      	negs	r0, r0
	}
	return t->tc->gettimeofday(t->tc, tv, tz);
}
 800871c:	bd08      	pop	{r3, pc}

0800871e <tc_isatty>:

int tc_isatty(target *t, int fd)
{
	if (t->tc->isatty == NULL) {
 800871e:	6842      	ldr	r2, [r0, #4]
	}
	return t->tc->gettimeofday(t->tc, tv, tz);
}

int tc_isatty(target *t, int fd)
{
 8008720:	b508      	push	{r3, lr}
	if (t->tc->isatty == NULL) {
 8008722:	6b13      	ldr	r3, [r2, #48]	; 0x30
		return 1;
 8008724:	2001      	movs	r0, #1
	return t->tc->gettimeofday(t->tc, tv, tz);
}

int tc_isatty(target *t, int fd)
{
	if (t->tc->isatty == NULL) {
 8008726:	2b00      	cmp	r3, #0
 8008728:	d001      	beq.n	800872e <tc_isatty+0x10>
		return 1;
	}
	return t->tc->isatty(t->tc, fd);
 800872a:	1c10      	adds	r0, r2, #0
 800872c:	4798      	blx	r3
}
 800872e:	bd08      	pop	{r3, pc}

08008730 <tc_system>:

int tc_system(target *t, target_addr cmd, size_t cmdlen)
{
	if (t->tc->system == NULL) {
 8008730:	6840      	ldr	r0, [r0, #4]
	}
	return t->tc->isatty(t->tc, fd);
}

int tc_system(target *t, target_addr cmd, size_t cmdlen)
{
 8008732:	b508      	push	{r3, lr}
	if (t->tc->system == NULL) {
 8008734:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8008736:	2b00      	cmp	r3, #0
 8008738:	d001      	beq.n	800873e <tc_system+0xe>
		return -1;
	}
	return t->tc->system(t->tc, cmd, cmdlen);
 800873a:	4798      	blx	r3
 800873c:	e001      	b.n	8008742 <tc_system+0x12>
}

int tc_system(target *t, target_addr cmd, size_t cmdlen)
{
	if (t->tc->system == NULL) {
		return -1;
 800873e:	2001      	movs	r0, #1
 8008740:	4240      	negs	r0, r0
	}
	return t->tc->system(t->tc, cmd, cmdlen);
}
 8008742:	bd08      	pop	{r3, pc}

08008744 <runtime_does>:
	}
	IP.word = prev_ip;
}
static void runtime_does(void)
{
	latest->is_does_proper = 1;
 8008744:	2104      	movs	r1, #4
 8008746:	4b05      	ldr	r3, [pc, #20]	; (800875c <runtime_does+0x18>)
 8008748:	681b      	ldr	r3, [r3, #0]
 800874a:	7a1a      	ldrb	r2, [r3, #8]
 800874c:	430a      	orrs	r2, r1
 800874e:	721a      	strb	r2, [r3, #8]
	latest->cfa = (void(*)(void)) (IP.cell + 1);
 8008750:	4a03      	ldr	r2, [pc, #12]	; (8008760 <runtime_does+0x1c>)
 8008752:	6812      	ldr	r2, [r2, #0]
 8008754:	1852      	adds	r2, r2, r1
 8008756:	60da      	str	r2, [r3, #12]
	/* latest->is_smudged = 0; */
}
 8008758:	4770      	bx	lr
 800875a:	46c0      	nop			; (mov r8, r8)
 800875c:	20000068 	.word	0x20000068
 8008760:	200011e4 	.word	0x200011e4

08008764 <runtime_branch>:
	IP.word = (struct word **) rpop();
	if (nest --)
		goto back;
}
static void runtime_branch(void)
{ IP.word += * IP.cell; }
 8008764:	4a03      	ldr	r2, [pc, #12]	; (8008774 <runtime_branch+0x10>)
 8008766:	6811      	ldr	r1, [r2, #0]
 8008768:	680b      	ldr	r3, [r1, #0]
 800876a:	009b      	lsls	r3, r3, #2
 800876c:	18cb      	adds	r3, r1, r3
 800876e:	6013      	str	r3, [r2, #0]
 8008770:	4770      	bx	lr
 8008772:	46c0      	nop			; (mov r8, r8)
 8008774:	200011e4 	.word	0x200011e4

08008778 <runtime_marker>:
	rpush(top());
	do_equals();
}
static void runtime_marker(void)
{
	latest = (struct word *) WP->pfa[0];
 8008778:	4b03      	ldr	r3, [pc, #12]	; (8008788 <runtime_marker+0x10>)
 800877a:	4904      	ldr	r1, [pc, #16]	; (800878c <runtime_marker+0x14>)
 800877c:	685a      	ldr	r2, [r3, #4]
 800877e:	6910      	ldr	r0, [r2, #16]
	here.cell = (cell *) WP->pfa[1];
 8008780:	6952      	ldr	r2, [r2, #20]
	rpush(top());
	do_equals();
}
static void runtime_marker(void)
{
	latest = (struct word *) WP->pfa[0];
 8008782:	6008      	str	r0, [r1, #0]
	here.cell = (cell *) WP->pfa[1];
 8008784:	609a      	str	r2, [r3, #8]
}
 8008786:	4770      	bx	lr
 8008788:	200011e4 	.word	0x200011e4
 800878c:	20000068 	.word	0x20000068

08008790 <do_less_number_sign>:
/*******************************************************************************
	<#	[less-number-sign] 
(  -- )
	Initialize the pictured numeric output conversion process.
*******************************************************************************/
		{ pno.idx = sizeof pno.buf; /* pno.buf[-- pno.idx] = ' '; */ }
 8008790:	2282      	movs	r2, #130	; 0x82
 8008792:	4b01      	ldr	r3, [pc, #4]	; (8008798 <do_less_number_sign+0x8>)
 8008794:	60da      	str	r2, [r3, #12]
 8008796:	4770      	bx	lr
 8008798:	200011e4 	.word	0x200011e4

0800879c <do_align>:
	ALIGN	 
(  -- )
	If the data-space pointer is not aligned, reserve enough space
	to align it.
*******************************************************************************/
		{ cell x = (cell) here.cell; x += sizeof(cell) - 1; x &= ~ (sizeof(cell) - 1); here.cell = (cell *) x; }
 800879c:	2103      	movs	r1, #3
 800879e:	4a03      	ldr	r2, [pc, #12]	; (80087ac <do_align+0x10>)
 80087a0:	6893      	ldr	r3, [r2, #8]
 80087a2:	3303      	adds	r3, #3
 80087a4:	438b      	bics	r3, r1
 80087a6:	6093      	str	r3, [r2, #8]
 80087a8:	4770      	bx	lr
 80087aa:	46c0      	nop			; (mov r8, r8)
 80087ac:	200011e4 	.word	0x200011e4

080087b0 <do_decimal>:
/*******************************************************************************
	DECIMAL	 
(  -- )
	Set the numeric conversion radix to ten (decimal).
*******************************************************************************/
		{ base = 10; }
 80087b0:	220a      	movs	r2, #10
 80087b2:	4b01      	ldr	r3, [pc, #4]	; (80087b8 <do_decimal+0x8>)
 80087b4:	615a      	str	r2, [r3, #20]
 80087b6:	4770      	bx	lr
 80087b8:	20001264 	.word	0x20001264

080087bc <do_does>:
	'name'. The stack effects 'i*x' and 'j*x'
	represent arguments to and results from 'name',
	respectively.
*******************************************************************************/
{
	* here.word ++ = & xt_runtime_does;
 80087bc:	4a04      	ldr	r2, [pc, #16]	; (80087d0 <do_does+0x14>)
 80087be:	4905      	ldr	r1, [pc, #20]	; (80087d4 <do_does+0x18>)
 80087c0:	6893      	ldr	r3, [r2, #8]
 80087c2:	6019      	str	r1, [r3, #0]
	/* compile 'exit' */
	* here.word ++ = 0;
 80087c4:	1c19      	adds	r1, r3, #0
 80087c6:	3108      	adds	r1, #8
 80087c8:	6091      	str	r1, [r2, #8]
 80087ca:	2200      	movs	r2, #0
 80087cc:	605a      	str	r2, [r3, #4]
}
 80087ce:	4770      	bx	lr
 80087d0:	200011e4 	.word	0x200011e4
 80087d4:	08013734 	.word	0x08013734

080087d8 <do_exit>:
	Return control to the calling definition specified by
	'nest-sys'. Before executing 'EXIT' within a
	do-loop, a program shall discard the loop-control parameters
	by executing 'UNLOOP'.
*******************************************************************************/
		{ * here.cell ++ = 0; }
 80087d8:	4a03      	ldr	r2, [pc, #12]	; (80087e8 <do_exit+0x10>)
 80087da:	6893      	ldr	r3, [r2, #8]
 80087dc:	1d19      	adds	r1, r3, #4
 80087de:	6091      	str	r1, [r2, #8]
 80087e0:	2200      	movs	r2, #0
 80087e2:	601a      	str	r2, [r3, #0]
 80087e4:	4770      	bx	lr
 80087e6:	46c0      	nop			; (mov r8, r8)
 80087e8:	200011e4 	.word	0x200011e4

080087ec <do_immediate>:
(  -- )
	Make the most recent definition an immediate word. An ambiguous
	condition exists if the most recent definition does not have a
	name or if it was defined as a 'tools'{SYNONYM}.
*******************************************************************************/
		{ latest->is_immediate = 1; }
 80087ec:	2101      	movs	r1, #1
 80087ee:	4b03      	ldr	r3, [pc, #12]	; (80087fc <do_immediate+0x10>)
 80087f0:	681a      	ldr	r2, [r3, #0]
 80087f2:	7a13      	ldrb	r3, [r2, #8]
 80087f4:	430b      	orrs	r3, r1
 80087f6:	7213      	strb	r3, [r2, #8]
 80087f8:	4770      	bx	lr
 80087fa:	46c0      	nop			; (mov r8, r8)
 80087fc:	20000068 	.word	0x20000068

08008800 <do_recurse>:
	(  -- )
	Append the execution semantics of the current definition to
	the current definition. An ambiguous condition exists if
	'RECURSE' appears in a definition after 'DOES'.
*******************************************************************************/
		{ * here.word ++ = latest;  }
 8008800:	4a03      	ldr	r2, [pc, #12]	; (8008810 <do_recurse+0x10>)
 8008802:	6893      	ldr	r3, [r2, #8]
 8008804:	1d19      	adds	r1, r3, #4
 8008806:	6091      	str	r1, [r2, #8]
 8008808:	4a02      	ldr	r2, [pc, #8]	; (8008814 <do_recurse+0x14>)
 800880a:	6812      	ldr	r2, [r2, #0]
 800880c:	601a      	str	r2, [r3, #0]
 800880e:	4770      	bx	lr
 8008810:	200011e4 	.word	0x200011e4
 8008814:	20000068 	.word	0x20000068

08008818 <do_left_bracket>:
	Perform the execution semantics given below.
\execute
	(  -- )
	Enter interpretation state. '[' is an immediate word.
*******************************************************************************/
		{ state = STATE_INTERPRETING; }
 8008818:	2200      	movs	r2, #0
 800881a:	4b01      	ldr	r3, [pc, #4]	; (8008820 <do_left_bracket+0x8>)
 800881c:	619a      	str	r2, [r3, #24]
 800881e:	4770      	bx	lr
 8008820:	20001264 	.word	0x20001264

08008824 <do_right_bracket>:
/*******************************************************************************
	]	[right-bracket] 
(  -- )
	Enter compilation state.
*******************************************************************************/
		{ state = STATE_COMPILING; }
 8008824:	2201      	movs	r2, #1
 8008826:	4b02      	ldr	r3, [pc, #8]	; (8008830 <do_right_bracket+0xc>)
 8008828:	4252      	negs	r2, r2
 800882a:	619a      	str	r2, [r3, #24]
 800882c:	4770      	bx	lr
 800882e:	46c0      	nop			; (mov r8, r8)
 8008830:	20001264 	.word	0x20001264

08008834 <do_hex>:
/*******************************************************************************
	HEX	 
(  -- )
	Set contents of 'BASE' to sixteen.
*******************************************************************************/
		{ base = 16; }
 8008834:	2210      	movs	r2, #16
 8008836:	4b01      	ldr	r3, [pc, #4]	; (800883c <do_hex+0x8>)
 8008838:	615a      	str	r2, [r3, #20]
 800883a:	4770      	bx	lr
 800883c:	20001264 	.word	0x20001264

08008840 <do_break>:
/* internal use helper words */
void /* "ahead" */	do_ahead(void)
		{ * here.word ++ = & xt_runtime_branch; push((cell) here.cell ++); }

void /* "break" */	do_break(void)
		{ }
 8008840:	4770      	bx	lr

08008842 <do_smudge>:
void /* "colon-debug" */	do_colon_debug(void)
		{ push((cell) & env.colon_debug_enabled); }

void /* "smudge" */	do_smudge(void)
{
		latest->is_smudged = 1;
 8008842:	2102      	movs	r1, #2
 8008844:	4b02      	ldr	r3, [pc, #8]	; (8008850 <do_smudge+0xe>)
 8008846:	681a      	ldr	r2, [r3, #0]
 8008848:	7a13      	ldrb	r3, [r2, #8]
 800884a:	430b      	orrs	r3, r1
 800884c:	7213      	strb	r3, [r2, #8]
}
 800884e:	4770      	bx	lr
 8008850:	20000068 	.word	0x20000068

08008854 <do_unsmudge>:
void /* "unsmudge" */	do_unsmudge(void)
		{
		latest->is_smudged = 0;
 8008854:	2102      	movs	r1, #2
 8008856:	4b03      	ldr	r3, [pc, #12]	; (8008864 <do_unsmudge+0x10>)
 8008858:	681a      	ldr	r2, [r3, #0]
 800885a:	7a13      	ldrb	r3, [r2, #8]
 800885c:	438b      	bics	r3, r1
 800885e:	7213      	strb	r3, [r2, #8]
		}
 8008860:	4770      	bx	lr
 8008862:	46c0      	nop			; (mov r8, r8)
 8008864:	20000068 	.word	0x20000068

08008868 <sf_reset>:
/* reseting of the sforth engine is always available */
void /* "sf-reset" */	sf_reset(void)
{
	if (!latest_reset_value)
 8008868:	4b0c      	ldr	r3, [pc, #48]	; (800889c <sf_reset+0x34>)
 800886a:	4a0d      	ldr	r2, [pc, #52]	; (80088a0 <sf_reset+0x38>)
 800886c:	69d9      	ldr	r1, [r3, #28]
 800886e:	2900      	cmp	r1, #0
 8008870:	d102      	bne.n	8008878 <sf_reset+0x10>
		latest_reset_value = latest;
 8008872:	6812      	ldr	r2, [r2, #0]
 8008874:	61da      	str	r2, [r3, #28]
 8008876:	e000      	b.n	800887a <sf_reset+0x12>
	else
		latest = latest_reset_value;
 8008878:	6011      	str	r1, [r2, #0]
	input_spec.source_id = SOURCE_ID_USER_INPUT_DEVICE;
	input_spec.buf = inbuf_area;
 800887a:	1c19      	adds	r1, r3, #0
 800887c:	3130      	adds	r1, #48	; 0x30
{
	if (!latest_reset_value)
		latest_reset_value = latest;
	else
		latest = latest_reset_value;
	input_spec.source_id = SOURCE_ID_USER_INPUT_DEVICE;
 800887e:	2200      	movs	r2, #0
	input_spec.buf = inbuf_area;
 8008880:	62d9      	str	r1, [r3, #44]	; 0x2c
	input_spec.idx = input_spec.len = 0;
	state = STATE_INTERPRETING;
	base = 10;
 8008882:	210a      	movs	r1, #10
{
	if (!latest_reset_value)
		latest_reset_value = latest;
	else
		latest = latest_reset_value;
	input_spec.source_id = SOURCE_ID_USER_INPUT_DEVICE;
 8008884:	621a      	str	r2, [r3, #32]
	input_spec.buf = inbuf_area;
	input_spec.idx = input_spec.len = 0;
 8008886:	629a      	str	r2, [r3, #40]	; 0x28
 8008888:	625a      	str	r2, [r3, #36]	; 0x24
	state = STATE_INTERPRETING;
 800888a:	619a      	str	r2, [r3, #24]
	base = 10;
 800888c:	6159      	str	r1, [r3, #20]
	sp = rsp = 0;
 800888e:	4b05      	ldr	r3, [pc, #20]	; (80088a4 <sf_reset+0x3c>)
 8008890:	631a      	str	r2, [r3, #48]	; 0x30
 8008892:	635a      	str	r2, [r3, #52]	; 0x34
	here.cell = core;
 8008894:	4a04      	ldr	r2, [pc, #16]	; (80088a8 <sf_reset+0x40>)
 8008896:	3338      	adds	r3, #56	; 0x38
 8008898:	6093      	str	r3, [r2, #8]
}
 800889a:	4770      	bx	lr
 800889c:	20001264 	.word	0x20001264
 80088a0:	20000068 	.word	0x20000068
 80088a4:	20001364 	.word	0x20001364
 80088a8:	200011e4 	.word	0x200011e4

080088ac <do_abort>:
	( R]{j*x -- )
	Empty the data stack and perform the function of 'QUIT',
	which includes emptying the return stack, without displaying
	a message.
*******************************************************************************/
		{ sp = rsp = 0; longjmp(jmpenv, SF_EXC_CODE_ABORT); }
 80088ac:	2200      	movs	r2, #0
 80088ae:	4804      	ldr	r0, [pc, #16]	; (80088c0 <do_abort+0x14>)
 80088b0:	b508      	push	{r3, lr}
 80088b2:	4b04      	ldr	r3, [pc, #16]	; (80088c4 <do_abort+0x18>)
 80088b4:	3038      	adds	r0, #56	; 0x38
 80088b6:	2101      	movs	r1, #1
 80088b8:	631a      	str	r2, [r3, #48]	; 0x30
 80088ba:	635a      	str	r2, [r3, #52]	; 0x34
 80088bc:	f004 f986 	bl	800cbcc <longjmp>
 80088c0:	20001764 	.word	0x20001764
 80088c4:	20001364 	.word	0x20001364

080088c8 <do_bye>:

void /* "break" */	do_break(void)
		{ }

void /* "bye" */	do_bye(void)
		{ longjmp(jmpenv, SF_EXC_CODE_BYE); }
 80088c8:	4802      	ldr	r0, [pc, #8]	; (80088d4 <do_bye+0xc>)
 80088ca:	b508      	push	{r3, lr}
 80088cc:	3038      	adds	r0, #56	; 0x38
 80088ce:	2102      	movs	r1, #2
 80088d0:	f004 f97c 	bl	800cbcc <longjmp>
 80088d4:	20001764 	.word	0x20001764

080088d8 <do_backslash>:
\execute
	( "ccc<eol>" -- )
	Parse and discard the remainder of the parse area.
	'bs' is an immediate word.
*******************************************************************************/
{
 80088d8:	b510      	push	{r4, lr}
	if (input_spec.source_id == SOURCE_ID_USER_INPUT_DEVICE)
 80088da:	4b09      	ldr	r3, [pc, #36]	; (8008900 <do_backslash+0x28>)
 80088dc:	6a19      	ldr	r1, [r3, #32]
 80088de:	1c1a      	adds	r2, r3, #0
 80088e0:	2900      	cmp	r1, #0
 80088e2:	d102      	bne.n	80088ea <do_backslash+0x12>
		input_spec.idx = input_spec.len;
 80088e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80088e6:	625a      	str	r2, [r3, #36]	; 0x24
 80088e8:	e009      	b.n	80088fe <do_backslash+0x26>
	else
	{
		int i;
		for (i = input_spec.idx; i < input_spec.len; i ++)
 80088ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80088ec:	6a91      	ldr	r1, [r2, #40]	; 0x28
			if (input_spec.str[i] == '\n')
 80088ee:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
	if (input_spec.source_id == SOURCE_ID_USER_INPUT_DEVICE)
		input_spec.idx = input_spec.len;
	else
	{
		int i;
		for (i = input_spec.idx; i < input_spec.len; i ++)
 80088f0:	428b      	cmp	r3, r1
 80088f2:	d203      	bcs.n	80088fc <do_backslash+0x24>
			if (input_spec.str[i] == '\n')
 80088f4:	5cc4      	ldrb	r4, [r0, r3]
 80088f6:	3301      	adds	r3, #1
 80088f8:	2c0a      	cmp	r4, #10
 80088fa:	d1f9      	bne.n	80088f0 <do_backslash+0x18>
			{
				i ++;
				break;
			}
			input_spec.idx = i;
 80088fc:	6253      	str	r3, [r2, #36]	; 0x24
	}
}
 80088fe:	bd10      	pop	{r4, pc}
 8008900:	20001264 	.word	0x20001264

08008904 <xtolower>:
static void pick(void) { cell i; i = pop(); if (sp < i + 1) sabort("bad stack for pick"); push(dstack[sp - 1 - i]); }
/* roll routines */
static void roll(void) { cell i; i = top(); pick(); xmemmove(dstack + sp - 1 - i - 1, dstack + sp - 1 - i, (i + 1) * sizeof * dstack); pop(); }

/* miscellaneous helper routines */
int xtolower(int c) { if ('A' <= c && c <= 'Z') c = c - 'A' + 'a'; return c; }
 8008904:	1c03      	adds	r3, r0, #0
 8008906:	3b41      	subs	r3, #65	; 0x41
 8008908:	2b19      	cmp	r3, #25
 800890a:	d800      	bhi.n	800890e <xtolower+0xa>
 800890c:	3020      	adds	r0, #32
 800890e:	4770      	bx	lr

08008910 <xtoupper>:
int xtoupper(int c) { if ('a' <= c && c <= 'z') c = c - 'a' + 'A'; return c; }
 8008910:	1c03      	adds	r3, r0, #0
 8008912:	3b61      	subs	r3, #97	; 0x61
 8008914:	2b19      	cmp	r3, #25
 8008916:	d800      	bhi.n	800891a <xtoupper+0xa>
 8008918:	3820      	subs	r0, #32
 800891a:	4770      	bx	lr

0800891c <xisspace>:
int xisspace(int c) { return (c == ' ' || c == '\n' || c == '\t' || c == '\f' || c == '\r' || c == '\v') ? 1 : 0; }
 800891c:	1c03      	adds	r3, r0, #0
 800891e:	2001      	movs	r0, #1
 8008920:	2b20      	cmp	r3, #32
 8008922:	d004      	beq.n	800892e <xisspace+0x12>
 8008924:	2000      	movs	r0, #0
 8008926:	2204      	movs	r2, #4
 8008928:	3b09      	subs	r3, #9
 800892a:	429a      	cmp	r2, r3
 800892c:	4140      	adcs	r0, r0
 800892e:	4770      	bx	lr

08008930 <xstrlen>:
int xstrlen(const char * str) { int i = 0; while (* str ++) i ++; return i; }
 8008930:	1c02      	adds	r2, r0, #0
 8008932:	1c03      	adds	r3, r0, #0
 8008934:	1a98      	subs	r0, r3, r2
 8008936:	3301      	adds	r3, #1
 8008938:	1e59      	subs	r1, r3, #1
 800893a:	7809      	ldrb	r1, [r1, #0]
 800893c:	2900      	cmp	r1, #0
 800893e:	d1f9      	bne.n	8008934 <xstrlen+0x4>
 8008940:	4770      	bx	lr

08008942 <xmemcpy>:
void * xmemcpy(void * dest, const void * src, int len) { uint8_t * d = (uint8_t *) dest; const uint8_t * s = (const uint8_t *) src; while (len --) * d ++ = * s ++; return dest; }
 8008942:	2300      	movs	r3, #0
 8008944:	b510      	push	{r4, lr}
 8008946:	4293      	cmp	r3, r2
 8008948:	d003      	beq.n	8008952 <xmemcpy+0x10>
 800894a:	5ccc      	ldrb	r4, [r1, r3]
 800894c:	54c4      	strb	r4, [r0, r3]
 800894e:	3301      	adds	r3, #1
 8008950:	e7f9      	b.n	8008946 <xmemcpy+0x4>
 8008952:	bd10      	pop	{r4, pc}

08008954 <xmemset>:
void * xmemset(void * dest, int c, int len) { uint8_t * d = (uint8_t *) dest; while (len --) * d ++ = c; return dest; }
 8008954:	1c03      	adds	r3, r0, #0
 8008956:	1882      	adds	r2, r0, r2
 8008958:	4293      	cmp	r3, r2
 800895a:	d002      	beq.n	8008962 <xmemset+0xe>
 800895c:	7019      	strb	r1, [r3, #0]
 800895e:	3301      	adds	r3, #1
 8008960:	e7fa      	b.n	8008958 <xmemset+0x4>
 8008962:	4770      	bx	lr

08008964 <xmemmove>:
void * xmemmove(void * dest, const void * src, int len) { uint8_t * d = (uint8_t *) dest; const uint8_t * s = (const uint8_t *) src;
 8008964:	b510      	push	{r4, lr}
	if (d <= s) while (len --) * d ++ = * s ++; else { d += len; s += len; while (len --) * -- d = * -- s; } return dest; }
 8008966:	2300      	movs	r3, #0
 8008968:	4288      	cmp	r0, r1
 800896a:	d805      	bhi.n	8008978 <xmemmove+0x14>
 800896c:	4293      	cmp	r3, r2
 800896e:	d008      	beq.n	8008982 <xmemmove+0x1e>
 8008970:	5ccc      	ldrb	r4, [r1, r3]
 8008972:	54c4      	strb	r4, [r0, r3]
 8008974:	3301      	adds	r3, #1
 8008976:	e7f9      	b.n	800896c <xmemmove+0x8>
 8008978:	3a01      	subs	r2, #1
 800897a:	d302      	bcc.n	8008982 <xmemmove+0x1e>
 800897c:	5c8b      	ldrb	r3, [r1, r2]
 800897e:	5483      	strb	r3, [r0, r2]
 8008980:	e7fa      	b.n	8008978 <xmemmove+0x14>
 8008982:	bd10      	pop	{r4, pc}

08008984 <xmemcmp>:
int xmemcmp(const void *s1, const void *s2, int len) { unsigned const char * c1 = (unsigned const char *) s1, * c2 = (unsigned const char *) s2; while (len) { if (* c1 < * c2) return -1; if (* c1 ++ > * c2 ++) return 1; len --; } return 0; }
 8008984:	2300      	movs	r3, #0
 8008986:	b530      	push	{r4, r5, lr}
 8008988:	4293      	cmp	r3, r2
 800898a:	d008      	beq.n	800899e <xmemcmp+0x1a>
 800898c:	5cc5      	ldrb	r5, [r0, r3]
 800898e:	5ccc      	ldrb	r4, [r1, r3]
 8008990:	42a5      	cmp	r5, r4
 8008992:	d306      	bcc.n	80089a2 <xmemcmp+0x1e>
 8008994:	3301      	adds	r3, #1
 8008996:	42a5      	cmp	r5, r4
 8008998:	d9f6      	bls.n	8008988 <xmemcmp+0x4>
 800899a:	2001      	movs	r0, #1
 800899c:	e003      	b.n	80089a6 <xmemcmp+0x22>
 800899e:	2000      	movs	r0, #0
 80089a0:	e001      	b.n	80089a6 <xmemcmp+0x22>
 80089a2:	2001      	movs	r0, #1
 80089a4:	4240      	negs	r0, r0
 80089a6:	bd30      	pop	{r4, r5, pc}

080089a8 <xstrncasecmp>:
int xstrncasecmp(const char * s1, const char * s2, int n) { int i; while (n --) { i = xtolower(* (uint8_t *) s1); i -= xtolower(* (uint8_t *) s2); if (! i) { s1 ++, s2 ++; continue; } if (i < 0) return -1; return 1; } return 0; }
 80089a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80089aa:	1c04      	adds	r4, r0, #0
 80089ac:	1c0e      	adds	r6, r1, #0
 80089ae:	1885      	adds	r5, r0, r2
 80089b0:	42ac      	cmp	r4, r5
 80089b2:	d00f      	beq.n	80089d4 <xstrncasecmp+0x2c>
 80089b4:	7820      	ldrb	r0, [r4, #0]
 80089b6:	f7ff ffa5 	bl	8008904 <xtolower>
 80089ba:	1c07      	adds	r7, r0, #0
 80089bc:	7830      	ldrb	r0, [r6, #0]
 80089be:	f7ff ffa1 	bl	8008904 <xtolower>
 80089c2:	1a38      	subs	r0, r7, r0
 80089c4:	d102      	bne.n	80089cc <xstrncasecmp+0x24>
 80089c6:	3401      	adds	r4, #1
 80089c8:	3601      	adds	r6, #1
 80089ca:	e7f1      	b.n	80089b0 <xstrncasecmp+0x8>
 80089cc:	2301      	movs	r3, #1
 80089ce:	17c0      	asrs	r0, r0, #31
 80089d0:	4318      	orrs	r0, r3
 80089d2:	e000      	b.n	80089d6 <xstrncasecmp+0x2e>
 80089d4:	2000      	movs	r0, #0
 80089d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080089d8 <xstrncmp>:
int xstrncmp(const char * s1, const char * s2, int n) { int i; while (n --) { i = * (uint8_t *) s1; i -= * (uint8_t *) s2; if (! i) { s1 ++, s2 ++; continue; } if (i < 0) return -1; return 1; } return 0; }
 80089d8:	b530      	push	{r4, r5, lr}
 80089da:	2400      	movs	r4, #0
 80089dc:	4294      	cmp	r4, r2
 80089de:	d008      	beq.n	80089f2 <xstrncmp+0x1a>
 80089e0:	5d03      	ldrb	r3, [r0, r4]
 80089e2:	5d0d      	ldrb	r5, [r1, r4]
 80089e4:	3401      	adds	r4, #1
 80089e6:	1b5b      	subs	r3, r3, r5
 80089e8:	d0f8      	beq.n	80089dc <xstrncmp+0x4>
 80089ea:	17d8      	asrs	r0, r3, #31
 80089ec:	2301      	movs	r3, #1
 80089ee:	4318      	orrs	r0, r3
 80089f0:	e000      	b.n	80089f4 <xstrncmp+0x1c>
 80089f2:	2000      	movs	r0, #0
 80089f4:	bd30      	pop	{r4, r5, pc}

080089f6 <print_str>:
void print_str(const char * str) { /* note that we can't simply do: 'push((cell) str); push(xstrlen(str)); do_type();', because the stack may be corrupted */ while (* str) sfputc(* (uint8_t *) str ++); }
 80089f6:	b510      	push	{r4, lr}
 80089f8:	1c04      	adds	r4, r0, #0
 80089fa:	7820      	ldrb	r0, [r4, #0]
 80089fc:	2800      	cmp	r0, #0
 80089fe:	d003      	beq.n	8008a08 <print_str+0x12>
 8008a00:	3401      	adds	r4, #1
 8008a02:	f7fa fa93 	bl	8002f2c <sfputc>
 8008a06:	e7f8      	b.n	80089fa <print_str+0x4>
 8008a08:	bd10      	pop	{r4, pc}

08008a0a <strabort>:
}
pno;


static void strabort(const char * func, const char * msg) __attribute__ ((noreturn));
static void strabort(const char * func, const char * msg) { if (0) *(int*)0=0; print_str(func); print_str(": "); print_str(msg); print_str("\n"); do_abort(); }
 8008a0a:	b510      	push	{r4, lr}
 8008a0c:	1c0c      	adds	r4, r1, #0
 8008a0e:	f7ff fff2 	bl	80089f6 <print_str>
 8008a12:	4805      	ldr	r0, [pc, #20]	; (8008a28 <strabort+0x1e>)
 8008a14:	f7ff ffef 	bl	80089f6 <print_str>
 8008a18:	1c20      	adds	r0, r4, #0
 8008a1a:	f7ff ffec 	bl	80089f6 <print_str>
 8008a1e:	4803      	ldr	r0, [pc, #12]	; (8008a2c <strabort+0x22>)
 8008a20:	f7ff ffe9 	bl	80089f6 <print_str>
 8008a24:	f7ff ff42 	bl	80088ac <do_abort>
 8008a28:	08014bf4 	.word	0x08014bf4
 8008a2c:	0800fc8c 	.word	0x0800fc8c

08008a30 <push>:
static inline dcell popd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = (dcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
static inline sdcell spopd(void) { sdcell res; if (sp < 2) sabort("data stack underflow"); res = (sdcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
static inline cell rpop(void) { if (!rsp) sabort("return stack underflow"); return rstack[-- rsp]; }

/* push routines */
static inline void push(cell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = x; }
 8008a30:	4a08      	ldr	r2, [pc, #32]	; (8008a54 <push+0x24>)
 8008a32:	b508      	push	{r3, lr}
 8008a34:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8008a36:	2b20      	cmp	r3, #32
 8008a38:	d104      	bne.n	8008a44 <push+0x14>
 8008a3a:	4807      	ldr	r0, [pc, #28]	; (8008a58 <push+0x28>)
 8008a3c:	4907      	ldr	r1, [pc, #28]	; (8008a5c <push+0x2c>)
 8008a3e:	3010      	adds	r0, #16
 8008a40:	f7ff ffe3 	bl	8008a0a <strabort>
 8008a44:	1c59      	adds	r1, r3, #1
 8008a46:	6351      	str	r1, [r2, #52]	; 0x34
 8008a48:	4a05      	ldr	r2, [pc, #20]	; (8008a60 <push+0x30>)
 8008a4a:	009b      	lsls	r3, r3, #2
 8008a4c:	18d3      	adds	r3, r2, r3
 8008a4e:	6158      	str	r0, [r3, #20]
 8008a50:	bd08      	pop	{r3, pc}
 8008a52:	46c0      	nop			; (mov r8, r8)
 8008a54:	20001364 	.word	0x20001364
 8008a58:	08013734 	.word	0x08013734
 8008a5c:	080149f0 	.word	0x080149f0
 8008a60:	200017e4 	.word	0x200017e4

08008a64 <exec_does>:

		}
	}
}
static void exec_does(void)
{
 8008a64:	b538      	push	{r3, r4, r5, lr}
	struct word * w, ** prev_ip;

	prev_ip = IP.word;
 8008a66:	4c0d      	ldr	r4, [pc, #52]	; (8008a9c <exec_does+0x38>)
	IP.word = (struct word **) WP->cfa;
 8008a68:	6860      	ldr	r0, [r4, #4]
}
static void exec_does(void)
{
	struct word * w, ** prev_ip;

	prev_ip = IP.word;
 8008a6a:	6825      	ldr	r5, [r4, #0]
	IP.word = (struct word **) WP->cfa;
 8008a6c:	68c3      	ldr	r3, [r0, #12]
	push((cell) WP->pfa);
 8008a6e:	3010      	adds	r0, #16
static void exec_does(void)
{
	struct word * w, ** prev_ip;

	prev_ip = IP.word;
	IP.word = (struct word **) WP->cfa;
 8008a70:	6023      	str	r3, [r4, #0]
	push((cell) WP->pfa);
 8008a72:	f7ff ffdd 	bl	8008a30 <push>

	while ((w = * IP.word ++))
 8008a76:	6823      	ldr	r3, [r4, #0]
 8008a78:	1d1a      	adds	r2, r3, #4
 8008a7a:	681b      	ldr	r3, [r3, #0]
 8008a7c:	6022      	str	r2, [r4, #0]
 8008a7e:	2b00      	cmp	r3, #0
 8008a80:	d009      	beq.n	8008a96 <exec_does+0x32>
	{
		WP = w;
		if (!w->is_does_proper)
 8008a82:	7a1a      	ldrb	r2, [r3, #8]
	IP.word = (struct word **) WP->cfa;
	push((cell) WP->pfa);

	while ((w = * IP.word ++))
	{
		WP = w;
 8008a84:	6063      	str	r3, [r4, #4]
		if (!w->is_does_proper)
 8008a86:	0752      	lsls	r2, r2, #29
 8008a88:	d402      	bmi.n	8008a90 <exec_does+0x2c>
			w->cfa();
 8008a8a:	68db      	ldr	r3, [r3, #12]
 8008a8c:	4798      	blx	r3
 8008a8e:	e7f2      	b.n	8008a76 <exec_does+0x12>
		else
			exec_does();
 8008a90:	f7ff ffe8 	bl	8008a64 <exec_does>
 8008a94:	e7ef      	b.n	8008a76 <exec_does+0x12>
	}
	IP.word = prev_ip;
 8008a96:	6025      	str	r5, [r4, #0]
}
 8008a98:	bd38      	pop	{r3, r4, r5, pc}
 8008a9a:	46c0      	nop			; (mov r8, r8)
 8008a9c:	200011e4 	.word	0x200011e4

08008aa0 <do_to_in>:
(  -- a-addr)
	'a-addr' is the address of a cell containing the offset in
	characters from the start of the input buffer to the start of
	the parse area.
*******************************************************************************/
		{ push((cell) &input_spec.idx); }
 8008aa0:	b508      	push	{r3, lr}
 8008aa2:	4802      	ldr	r0, [pc, #8]	; (8008aac <do_to_in+0xc>)
 8008aa4:	3024      	adds	r0, #36	; 0x24
 8008aa6:	f7ff ffc3 	bl	8008a30 <push>
 8008aaa:	bd08      	pop	{r3, pc}
 8008aac:	20001264 	.word	0x20001264

08008ab0 <do_base>:
	BASE	 
(  -- a-addr)
	'a-addr' is the address of a cell containing the current
	number-conversion radix \{\{2...36\}\}.
*******************************************************************************/
		{ push((cell) & base); }
 8008ab0:	b508      	push	{r3, lr}
 8008ab2:	4802      	ldr	r0, [pc, #8]	; (8008abc <do_base+0xc>)
 8008ab4:	3014      	adds	r0, #20
 8008ab6:	f7ff ffbb 	bl	8008a30 <push>
 8008aba:	bd08      	pop	{r3, pc}
 8008abc:	20001264 	.word	0x20001264

08008ac0 <do_begin>:
	to the current definition.
\runtime
	(  -- )
	Continue execution.
*******************************************************************************/
		{ push((cell) here.cell); }
 8008ac0:	b508      	push	{r3, lr}
 8008ac2:	4b02      	ldr	r3, [pc, #8]	; (8008acc <do_begin+0xc>)
 8008ac4:	6898      	ldr	r0, [r3, #8]
 8008ac6:	f7ff ffb3 	bl	8008a30 <push>
 8008aca:	bd08      	pop	{r3, pc}
 8008acc:	200011e4 	.word	0x200011e4

08008ad0 <do_bl>:
/*******************************************************************************
	BL	[b-l] 
(  -- char)
	'char' is the character value for a space.
*******************************************************************************/
		{ push(' '); }
 8008ad0:	b508      	push	{r3, lr}
 8008ad2:	2020      	movs	r0, #32
 8008ad4:	f7ff ffac 	bl	8008a30 <push>
 8008ad8:	bd08      	pop	{r3, pc}

08008ada <runtime_constant>:
static void runtime_create(void)
{
	push((cell) & WP->pfa);
}
static void runtime_constant(void)
{ push(* WP->cells); }
 8008ada:	b508      	push	{r3, lr}
 8008adc:	4b02      	ldr	r3, [pc, #8]	; (8008ae8 <runtime_constant+0xe>)
 8008ade:	685b      	ldr	r3, [r3, #4]
 8008ae0:	6918      	ldr	r0, [r3, #16]
 8008ae2:	f7ff ffa5 	bl	8008a30 <push>
 8008ae6:	bd08      	pop	{r3, pc}
 8008ae8:	200011e4 	.word	0x200011e4

08008aec <runtime_create>:

/*********************************************************************************/
static void runtime_branch_on_false(void)
{ if (!pop()) IP.word += * IP.cell; else IP.word ++; }
static void runtime_create(void)
{
 8008aec:	b508      	push	{r3, lr}
	push((cell) & WP->pfa);
 8008aee:	4b03      	ldr	r3, [pc, #12]	; (8008afc <runtime_create+0x10>)
 8008af0:	6858      	ldr	r0, [r3, #4]
 8008af2:	3010      	adds	r0, #16
 8008af4:	f7ff ff9c 	bl	8008a30 <push>
}
 8008af8:	bd08      	pop	{r3, pc}
 8008afa:	46c0      	nop			; (mov r8, r8)
 8008afc:	200011e4 	.word	0x200011e4

08008b00 <do_here>:
/*******************************************************************************
	HERE	 
(  -- addr)
	'addr' is the data-space pointer.
*******************************************************************************/
		{ push((cell) here.cell); }
 8008b00:	b508      	push	{r3, lr}
 8008b02:	4b02      	ldr	r3, [pc, #8]	; (8008b0c <do_here+0xc>)
 8008b04:	6898      	ldr	r0, [r3, #8]
 8008b06:	f7ff ff93 	bl	8008a30 <push>
 8008b0a:	bd08      	pop	{r3, pc}
 8008b0c:	200011e4 	.word	0x200011e4

08008b10 <do_if>:
\runtime
	( x -- )
	If all bits of 'x' are zero, continue execution at the
	location specified by the resolution of 'orig'.
*******************************************************************************/
		{ * here.word ++ = & xt_runtime_branch_on_false; push((cell) here.cell ++); }
 8008b10:	b508      	push	{r3, lr}
 8008b12:	4a06      	ldr	r2, [pc, #24]	; (8008b2c <do_if+0x1c>)
 8008b14:	4b06      	ldr	r3, [pc, #24]	; (8008b30 <do_if+0x20>)
 8008b16:	6890      	ldr	r0, [r2, #8]
 8008b18:	3318      	adds	r3, #24
 8008b1a:	6003      	str	r3, [r0, #0]
 8008b1c:	1c03      	adds	r3, r0, #0
 8008b1e:	3004      	adds	r0, #4
 8008b20:	3308      	adds	r3, #8
 8008b22:	6093      	str	r3, [r2, #8]
 8008b24:	f7ff ff84 	bl	8008a30 <push>
 8008b28:	bd08      	pop	{r3, pc}
 8008b2a:	46c0      	nop			; (mov r8, r8)
 8008b2c:	200011e4 	.word	0x200011e4
 8008b30:	08013734 	.word	0x08013734

08008b34 <runtime_literal>:
		goto back;
}
static void runtime_branch(void)
{ IP.word += * IP.cell; }
static void runtime_literal(void)
{ push(* IP.cell ++); }
 8008b34:	b508      	push	{r3, lr}
 8008b36:	4a04      	ldr	r2, [pc, #16]	; (8008b48 <runtime_literal+0x14>)
 8008b38:	6813      	ldr	r3, [r2, #0]
 8008b3a:	1d19      	adds	r1, r3, #4
 8008b3c:	6818      	ldr	r0, [r3, #0]
 8008b3e:	6011      	str	r1, [r2, #0]
 8008b40:	f7ff ff76 	bl	8008a30 <push>
 8008b44:	bd08      	pop	{r3, pc}
 8008b46:	46c0      	nop			; (mov r8, r8)
 8008b48:	200011e4 	.word	0x200011e4

08008b4c <do_source>:
	SOURCE	 
(  -- c-addr u)
	'c-addr' is the address of, and 'u' is the number of
	characters in, the input buffer.
*******************************************************************************/
{
 8008b4c:	b510      	push	{r4, lr}
	switch (input_spec.source_id)
 8008b4e:	4c04      	ldr	r4, [pc, #16]	; (8008b60 <do_source+0x14>)
			/* input is a file */
		case SOURCE_ID_USER_INPUT_DEVICE:
			push((cell) input_spec.buf);
			break;
		case SOURCE_ID_STRING:
			push((cell) input_spec.str);
 8008b50:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8008b52:	f7ff ff6d 	bl	8008a30 <push>
			break;
	}
	push(input_spec.len);
 8008b56:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008b58:	f7ff ff6a 	bl	8008a30 <push>
}
 8008b5c:	bd10      	pop	{r4, pc}
 8008b5e:	46c0      	nop			; (mov r8, r8)
 8008b60:	20001264 	.word	0x20001264

08008b64 <do_state>:
	'[' (left-bracket),
	']' (right-bracket).
\note
	A program shall not directly alter the contents of 'STATE'.
*******************************************************************************/
		{ push((cell) & state); }
 8008b64:	b508      	push	{r3, lr}
 8008b66:	4802      	ldr	r0, [pc, #8]	; (8008b70 <do_state+0xc>)
 8008b68:	3018      	adds	r0, #24
 8008b6a:	f7ff ff61 	bl	8008a30 <push>
 8008b6e:	bd08      	pop	{r3, pc}
 8008b70:	20001264 	.word	0x20001264

08008b74 <do_case>:
	current definition.
\runtime
	(  -- )
	Continue execution.
*******************************************************************************/
		{ push(0); }
 8008b74:	b508      	push	{r3, lr}
 8008b76:	2000      	movs	r0, #0
 8008b78:	f7ff ff5a 	bl	8008a30 <push>
 8008b7c:	bd08      	pop	{r3, pc}

08008b7e <do_false>:
/*******************************************************************************
	FALSE	 
(  -- false)
	Return a 'false' flag.
*******************************************************************************/
		{ push(C_FALSE); }
 8008b7e:	b508      	push	{r3, lr}
 8008b80:	2000      	movs	r0, #0
 8008b82:	f7ff ff55 	bl	8008a30 <push>
 8008b86:	bd08      	pop	{r3, pc}

08008b88 <do_pad>:
	PAD	 
(  -- c-addr)
	'c-addr' is the address of a transient region that can
	be used to hold data for intermediate processing.
*******************************************************************************/
		{ push((cell) here.cell); }
 8008b88:	b508      	push	{r3, lr}
 8008b8a:	4b02      	ldr	r3, [pc, #8]	; (8008b94 <do_pad+0xc>)
 8008b8c:	6898      	ldr	r0, [r3, #8]
 8008b8e:	f7ff ff4f 	bl	8008a30 <push>
 8008b92:	bd08      	pop	{r3, pc}
 8008b94:	200011e4 	.word	0x200011e4

08008b98 <do_refill>:
	is considered successful. If there is no input available from
	the current input source, return \emph{false}.
	When the input source is a string from 'EVALUATE', return
	\emph{false} and perform no other action.
*******************************************************************************/
{
 8008b98:	b538      	push	{r3, r4, r5, lr}
int i, c;
	if (input_spec.source_id == SOURCE_ID_STRING) { push(C_FALSE); return; }
 8008b9a:	4d1c      	ldr	r5, [pc, #112]	; (8008c0c <do_refill+0x74>)
 8008b9c:	6a2b      	ldr	r3, [r5, #32]
 8008b9e:	3301      	adds	r3, #1
 8008ba0:	d101      	bne.n	8008ba6 <do_refill+0xe>
 8008ba2:	2000      	movs	r0, #0
 8008ba4:	e02e      	b.n	8008c04 <do_refill+0x6c>
	input_spec.idx = 0;
 8008ba6:	2400      	movs	r4, #0
 8008ba8:	626c      	str	r4, [r5, #36]	; 0x24
	i = 0;
	while (i < sizeof inbuf_area)
 8008baa:	2380      	movs	r3, #128	; 0x80
 8008bac:	005b      	lsls	r3, r3, #1
 8008bae:	429c      	cmp	r4, r3
 8008bb0:	d025      	beq.n	8008bfe <do_refill+0x66>
	{
		if (input_spec.source_id == SOURCE_ID_USER_INPUT_DEVICE)
 8008bb2:	6a28      	ldr	r0, [r5, #32]
 8008bb4:	2800      	cmp	r0, #0
 8008bb6:	d102      	bne.n	8008bbe <do_refill+0x26>
			c = sfgetc();
 8008bb8:	f7fa f9b4 	bl	8002f24 <sfgetc>
 8008bbc:	e001      	b.n	8008bc2 <do_refill+0x2a>
		else
			c = sffgetc(input_spec.file_id);
 8008bbe:	f002 f906 	bl	800adce <sffgetc>
		if (c == '\n' && input_spec.source_id == SOURCE_ID_USER_INPUT_DEVICE && env.cr_echo_enabled)
 8008bc2:	280a      	cmp	r0, #10
 8008bc4:	d109      	bne.n	8008bda <do_refill+0x42>
 8008bc6:	6a2b      	ldr	r3, [r5, #32]
 8008bc8:	2b00      	cmp	r3, #0
 8008bca:	d118      	bne.n	8008bfe <do_refill+0x66>
 8008bcc:	4b10      	ldr	r3, [pc, #64]	; (8008c10 <do_refill+0x78>)
 8008bce:	69db      	ldr	r3, [r3, #28]
 8008bd0:	2b00      	cmp	r3, #0
 8008bd2:	d014      	beq.n	8008bfe <do_refill+0x66>
			sfputc(c);
 8008bd4:	f7fa f9aa 	bl	8002f2c <sfputc>
 8008bd8:	e011      	b.n	8008bfe <do_refill+0x66>
		if (c == EOF)
 8008bda:	1c43      	adds	r3, r0, #1
 8008bdc:	d103      	bne.n	8008be6 <do_refill+0x4e>
		{
			input_spec.len = i;
 8008bde:	62ac      	str	r4, [r5, #40]	; 0x28
			if (!i)
 8008be0:	2c00      	cmp	r4, #0
 8008be2:	d0de      	beq.n	8008ba2 <do_refill+0xa>
 8008be4:	e00e      	b.n	8008c04 <do_refill+0x6c>
				push(C_FALSE);
			else
				push(C_TRUE);
			return;
		}
		switch (c)
 8008be6:	280a      	cmp	r0, #10
 8008be8:	d009      	beq.n	8008bfe <do_refill+0x66>
 8008bea:	2820      	cmp	r0, #32
 8008bec:	d001      	beq.n	8008bf2 <do_refill+0x5a>
 8008bee:	2809      	cmp	r0, #9
 8008bf0:	d101      	bne.n	8008bf6 <do_refill+0x5e>
				input_spec.len = i;
				push(C_TRUE);
				return;
			case ' ':
			case '\t':
				if (i >= REFILL_WATERMARK_LEVEL)
 8008bf2:	2cbf      	cmp	r4, #191	; 0xbf
 8008bf4:	dc03      	bgt.n	8008bfe <do_refill+0x66>
					push(C_TRUE);
					return;
				}
				/* fallout */
			default:
				input_spec.buf[i] = (uint8_t) c;
 8008bf6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8008bf8:	5518      	strb	r0, [r3, r4]
		}
		i ++;
 8008bfa:	3401      	adds	r4, #1
 8008bfc:	e7d5      	b.n	8008baa <do_refill+0x12>
	}
	input_spec.len = i;
	push(C_TRUE);
 8008bfe:	2001      	movs	r0, #1
			default:
				input_spec.buf[i] = (uint8_t) c;
		}
		i ++;
	}
	input_spec.len = i;
 8008c00:	62ac      	str	r4, [r5, #40]	; 0x28
	push(C_TRUE);
 8008c02:	4240      	negs	r0, r0
 8008c04:	f7ff ff14 	bl	8008a30 <push>
}
 8008c08:	bd38      	pop	{r3, r4, r5, pc}
 8008c0a:	46c0      	nop			; (mov r8, r8)
 8008c0c:	20001264 	.word	0x20001264
 8008c10:	20001864 	.word	0x20001864

08008c14 <do_save_input>:
	SAVE-INPUT	 
(  -- x_n {\ldots) x_1 n}
	'x_1' through 'x_n' describe the current state of the
	input source specification for later use by 'RESTORE-INPUT'.
*******************************************************************************/
{
 8008c14:	b510      	push	{r4, lr}
	push((cell) input_spec.buf);
 8008c16:	4c07      	ldr	r4, [pc, #28]	; (8008c34 <do_save_input+0x20>)
 8008c18:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8008c1a:	f7ff ff09 	bl	8008a30 <push>
	push((cell) input_spec.len);
 8008c1e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008c20:	f7ff ff06 	bl	8008a30 <push>
	push((cell) input_spec.idx);
 8008c24:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8008c26:	f7ff ff03 	bl	8008a30 <push>
	push((cell) input_spec.source_id);
 8008c2a:	6a20      	ldr	r0, [r4, #32]
 8008c2c:	f7ff ff00 	bl	8008a30 <push>
}
 8008c30:	bd10      	pop	{r4, pc}
 8008c32:	46c0      	nop			; (mov r8, r8)
 8008c34:	20001264 	.word	0x20001264

08008c38 <do_source_id>:
		 0	& User input device \\
		\hline\hline
		\end{tabular}
	\end{center}
*******************************************************************************/
		{ push(input_spec.source_id); }
 8008c38:	b508      	push	{r3, lr}
 8008c3a:	4b02      	ldr	r3, [pc, #8]	; (8008c44 <do_source_id+0xc>)
 8008c3c:	6a18      	ldr	r0, [r3, #32]
 8008c3e:	f7ff fef7 	bl	8008a30 <push>
 8008c42:	bd08      	pop	{r3, pc}
 8008c44:	20001264 	.word	0x20001264

08008c48 <do_true>:
	TRUE	 
(  -- true)
	Return a 'true' flag, a single-cell value with all
	bits set.
*******************************************************************************/
		{ push(C_TRUE); }
 8008c48:	2001      	movs	r0, #1
 8008c4a:	b508      	push	{r3, lr}
 8008c4c:	4240      	negs	r0, r0
 8008c4e:	f7ff feef 	bl	8008a30 <push>
 8008c52:	bd08      	pop	{r3, pc}

08008c54 <runtime_value>:
{
	latest = (struct word *) WP->pfa[0];
	here.cell = (cell *) WP->pfa[1];
}
static void runtime_value(void)
{ push(WP->cells[0]); }
 8008c54:	b508      	push	{r3, lr}
 8008c56:	4b03      	ldr	r3, [pc, #12]	; (8008c64 <runtime_value+0x10>)
 8008c58:	685b      	ldr	r3, [r3, #4]
 8008c5a:	6918      	ldr	r0, [r3, #16]
 8008c5c:	f7ff fee8 	bl	8008a30 <push>
 8008c60:	bd08      	pop	{r3, pc}
 8008c62:	46c0      	nop			; (mov r8, r8)
 8008c64:	200011e4 	.word	0x200011e4

08008c68 <do_ahead>:
 *
 *
 ******************************************************************************/
/* internal use helper words */
void /* "ahead" */	do_ahead(void)
		{ * here.word ++ = & xt_runtime_branch; push((cell) here.cell ++); }
 8008c68:	b508      	push	{r3, lr}
 8008c6a:	4a06      	ldr	r2, [pc, #24]	; (8008c84 <do_ahead+0x1c>)
 8008c6c:	4b06      	ldr	r3, [pc, #24]	; (8008c88 <do_ahead+0x20>)
 8008c6e:	6890      	ldr	r0, [r2, #8]
 8008c70:	3328      	adds	r3, #40	; 0x28
 8008c72:	6003      	str	r3, [r0, #0]
 8008c74:	1c03      	adds	r3, r0, #0
 8008c76:	3004      	adds	r0, #4
 8008c78:	3308      	adds	r3, #8
 8008c7a:	6093      	str	r3, [r2, #8]
 8008c7c:	f7ff fed8 	bl	8008a30 <push>
 8008c80:	bd08      	pop	{r3, pc}
 8008c82:	46c0      	nop			; (mov r8, r8)
 8008c84:	200011e4 	.word	0x200011e4
 8008c88:	08013734 	.word	0x08013734

08008c8c <do_latest>:

void /* "bye" */	do_bye(void)
		{ longjmp(jmpenv, SF_EXC_CODE_BYE); }

void /* "latest" */	do_latest(void)
		{ push((cell) &latest); }
 8008c8c:	b508      	push	{r3, lr}
 8008c8e:	4802      	ldr	r0, [pc, #8]	; (8008c98 <do_latest+0xc>)
 8008c90:	f7ff fece 	bl	8008a30 <push>
 8008c94:	bd08      	pop	{r3, pc}
 8008c96:	46c0      	nop			; (mov r8, r8)
 8008c98:	20000068 	.word	0x20000068

08008c9c <do_jmpenv>:

void /* "jmpenv" */	do_jmpenv(void)
		{ push((cell) &jmpenv); }
 8008c9c:	b508      	push	{r3, lr}
 8008c9e:	4802      	ldr	r0, [pc, #8]	; (8008ca8 <do_jmpenv+0xc>)
 8008ca0:	3038      	adds	r0, #56	; 0x38
 8008ca2:	f7ff fec5 	bl	8008a30 <push>
 8008ca6:	bd08      	pop	{r3, pc}
 8008ca8:	20001764 	.word	0x20001764

08008cac <do_cr_echo>:
	base = saved_base;
}

/* environment settings words */
void /* "cr-echo" */	do_cr_echo(void)
		{ push((cell) & env.cr_echo_enabled); }
 8008cac:	b508      	push	{r3, lr}
 8008cae:	4802      	ldr	r0, [pc, #8]	; (8008cb8 <do_cr_echo+0xc>)
 8008cb0:	301c      	adds	r0, #28
 8008cb2:	f7ff febd 	bl	8008a30 <push>
 8008cb6:	bd08      	pop	{r3, pc}
 8008cb8:	20001864 	.word	0x20001864

08008cbc <do_colon_debug>:

void /* "colon-debug" */	do_colon_debug(void)
		{ push((cell) & env.colon_debug_enabled); }
 8008cbc:	b508      	push	{r3, lr}
 8008cbe:	4802      	ldr	r0, [pc, #8]	; (8008cc8 <do_colon_debug+0xc>)
 8008cc0:	3020      	adds	r0, #32
 8008cc2:	f7ff feb5 	bl	8008a30 <push>
 8008cc6:	bd08      	pop	{r3, pc}
 8008cc8:	20001864 	.word	0x20001864

08008ccc <pop>:
#define sabort(x) strabort(__func__, x)

/* return and data stacks manipulation words */

/* pop routines */
static inline cell pop(void) { if (!sp) sabort("data stack underflow"); return dstack[-- sp]; }
 8008ccc:	4a08      	ldr	r2, [pc, #32]	; (8008cf0 <pop+0x24>)
 8008cce:	b508      	push	{r3, lr}
 8008cd0:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8008cd2:	2b00      	cmp	r3, #0
 8008cd4:	d104      	bne.n	8008ce0 <pop+0x14>
 8008cd6:	4807      	ldr	r0, [pc, #28]	; (8008cf4 <pop+0x28>)
 8008cd8:	4907      	ldr	r1, [pc, #28]	; (8008cf8 <pop+0x2c>)
 8008cda:	3038      	adds	r0, #56	; 0x38
 8008cdc:	f7ff fe95 	bl	8008a0a <strabort>
 8008ce0:	3b01      	subs	r3, #1
 8008ce2:	6353      	str	r3, [r2, #52]	; 0x34
 8008ce4:	4a05      	ldr	r2, [pc, #20]	; (8008cfc <pop+0x30>)
 8008ce6:	009b      	lsls	r3, r3, #2
 8008ce8:	18d3      	adds	r3, r2, r3
 8008cea:	6958      	ldr	r0, [r3, #20]
 8008cec:	bd08      	pop	{r3, pc}
 8008cee:	46c0      	nop			; (mov r8, r8)
 8008cf0:	20001364 	.word	0x20001364
 8008cf4:	08013734 	.word	0x08013734
 8008cf8:	08014a04 	.word	0x08014a04
 8008cfc:	200017e4 	.word	0x200017e4

08008d00 <do_comma>:
	If the data-space pointer is aligned when ',' begins
	execution, it will remain aligned when ',' finishes
	execution. An ambiguous condition exists if the data-space
	pointer is not aligned prior to execution of ','.
*******************************************************************************/
		{ * here.cell ++ = pop(); }
 8008d00:	b510      	push	{r4, lr}
 8008d02:	4b04      	ldr	r3, [pc, #16]	; (8008d14 <do_comma+0x14>)
 8008d04:	689c      	ldr	r4, [r3, #8]
 8008d06:	1d22      	adds	r2, r4, #4
 8008d08:	609a      	str	r2, [r3, #8]
 8008d0a:	f7ff ffdf 	bl	8008ccc <pop>
 8008d0e:	6020      	str	r0, [r4, #0]
 8008d10:	bd10      	pop	{r4, pc}
 8008d12:	46c0      	nop			; (mov r8, r8)
 8008d14:	200011e4 	.word	0x200011e4

08008d18 <do_compile_comma>:
	( xt -- )
	Append the execution semantics of the definition represented
	by 'xt' to the execution semantics of the current
	definition.
*******************************************************************************/
		{ do_comma(); }
 8008d18:	b508      	push	{r3, lr}
 8008d1a:	f7ff fff1 	bl	8008d00 <do_comma>
 8008d1e:	bd08      	pop	{r3, pc}

08008d20 <do_zero_equals>:
/*******************************************************************************
	0=	[zero-equals] 
( x -- flag)
	'flag' is true if and only if 'x' is equal to zero.
*******************************************************************************/
		{ push(pop() ? C_FALSE : C_TRUE); }
 8008d20:	b508      	push	{r3, lr}
 8008d22:	f7ff ffd3 	bl	8008ccc <pop>
 8008d26:	4243      	negs	r3, r0
 8008d28:	4158      	adcs	r0, r3
 8008d2a:	4240      	negs	r0, r0
 8008d2c:	f7ff fe80 	bl	8008a30 <push>
 8008d30:	bd08      	pop	{r3, pc}

08008d32 <do_one_plus>:
	1+	[one-plus] 
( n_1|u_1 -- n_2|u_2)
	Add one (1) to 'n_1|u_1' giving the sum
	'n_2|u_2'.
*******************************************************************************/
		{ push(pop() + 1);  }
 8008d32:	b508      	push	{r3, lr}
 8008d34:	f7ff ffca 	bl	8008ccc <pop>
 8008d38:	3001      	adds	r0, #1
 8008d3a:	f7ff fe79 	bl	8008a30 <push>
 8008d3e:	bd08      	pop	{r3, pc}

08008d40 <do_one_minus>:
	1-	[one-minus] 
( n_1|u_1 -- n_2|u_2)
	Subtract one (1) from 'n_1|u_1' giving the difference
	'n_2|u_2'.
*******************************************************************************/
		{ push(pop() - 1);  }
 8008d40:	b508      	push	{r3, lr}
 8008d42:	f7ff ffc3 	bl	8008ccc <pop>
 8008d46:	3801      	subs	r0, #1
 8008d48:	f7ff fe72 	bl	8008a30 <push>
 8008d4c:	bd08      	pop	{r3, pc}

08008d4e <do_two_store>:
	Store the cell pair 'x_1 x_2' at 'a-addr', with
	'x_2' at 'a-addr' and 'x_1' at the next
	consecutive cell. It is equivalent to the sequence
	'SWAP' 'OVER' '!' 'CELL+' '!'.
*******************************************************************************/
		{ cell * p = (cell *) pop(); * p ++ = pop(); * p = pop(); }
 8008d4e:	b510      	push	{r4, lr}
 8008d50:	f7ff ffbc 	bl	8008ccc <pop>
 8008d54:	1c04      	adds	r4, r0, #0
 8008d56:	f7ff ffb9 	bl	8008ccc <pop>
 8008d5a:	6020      	str	r0, [r4, #0]
 8008d5c:	f7ff ffb6 	bl	8008ccc <pop>
 8008d60:	6060      	str	r0, [r4, #4]
 8008d62:	bd10      	pop	{r4, pc}

08008d64 <do_two_star>:
( x_1 -- x_2)
	'x_2' is the result of shifting 'x_1' one bit toward
	the most-significant bit, filling the vacated least-significant
	bit with zero.
*******************************************************************************/
		{ push(pop() << 1); }
 8008d64:	b508      	push	{r3, lr}
 8008d66:	f7ff ffb1 	bl	8008ccc <pop>
 8008d6a:	0040      	lsls	r0, r0, #1
 8008d6c:	f7ff fe60 	bl	8008a30 <push>
 8008d70:	bd08      	pop	{r3, pc}

08008d72 <do_two_fetch>:
	Fetch the cell pair 'x_1 x_2' stored at 'a-addr'.
	'x_2' is stored at 'a-addr' and 'x_1' at the
	next consecutive cell. It is equivalent to the sequence
	'DUP' 'CELL+' '@' 'SWAP' '@'.
*******************************************************************************/
		{ cell * p = (cell *) pop(); push(p[1]); push(* p); }
 8008d72:	b510      	push	{r4, lr}
 8008d74:	f7ff ffaa 	bl	8008ccc <pop>
 8008d78:	1c04      	adds	r4, r0, #0
 8008d7a:	6840      	ldr	r0, [r0, #4]
 8008d7c:	f7ff fe58 	bl	8008a30 <push>
 8008d80:	6820      	ldr	r0, [r4, #0]
 8008d82:	f7ff fe55 	bl	8008a30 <push>
 8008d86:	bd10      	pop	{r4, pc}

08008d88 <do_to_body>:
( xt -- a-addr)
	'a-addr' is the data-field address corresponding to
	'xt'. An ambiguous condition exists if 'xt' is not
	for a word defined via 'CREATE'.
*******************************************************************************/
		{ push((cell) &((struct word *) pop())->pfa); }
 8008d88:	b508      	push	{r3, lr}
 8008d8a:	f7ff ff9f 	bl	8008ccc <pop>
 8008d8e:	3010      	adds	r0, #16
 8008d90:	f7ff fe4e 	bl	8008a30 <push>
 8008d94:	bd08      	pop	{r3, pc}

08008d96 <do_fetch>:
/*******************************************************************************
	@	[fetch] 
( a-addr -- x)
	'x' is the value stored at 'a-addr'.
*******************************************************************************/
		{ push(*(cell *) pop()); }
 8008d96:	b508      	push	{r3, lr}
 8008d98:	f7ff ff98 	bl	8008ccc <pop>
 8008d9c:	6800      	ldr	r0, [r0, #0]
 8008d9e:	f7ff fe47 	bl	8008a30 <push>
 8008da2:	bd08      	pop	{r3, pc}

08008da4 <do_aligned>:
	ALIGNED	 
( addr -- a-addr)
	'a-addr' is the first aligned address greater than or equal
	to 'addr'.
*******************************************************************************/
		{ cell x = pop(); x += sizeof(cell) - 1; x &= ~ (sizeof(cell) - 1); push(x); }
 8008da4:	b508      	push	{r3, lr}
 8008da6:	f7ff ff91 	bl	8008ccc <pop>
 8008daa:	2303      	movs	r3, #3
 8008dac:	3003      	adds	r0, #3
 8008dae:	4398      	bics	r0, r3
 8008db0:	f7ff fe3e 	bl	8008a30 <push>
 8008db4:	bd08      	pop	{r3, pc}

08008db6 <do_allot>:
	If the data-space pointer is character aligned and 'n' is a
	multiple of the size of a character when 'ALLOT' begins
	execution, it will remain character aligned when 'ALLOT'
	finishes execution.
*******************************************************************************/
		{ here.chr += pop(); }
 8008db6:	b508      	push	{r3, lr}
 8008db8:	f7ff ff88 	bl	8008ccc <pop>
 8008dbc:	4b02      	ldr	r3, [pc, #8]	; (8008dc8 <do_allot+0x12>)
 8008dbe:	689a      	ldr	r2, [r3, #8]
 8008dc0:	1810      	adds	r0, r2, r0
 8008dc2:	6098      	str	r0, [r3, #8]
 8008dc4:	bd08      	pop	{r3, pc}
 8008dc6:	46c0      	nop			; (mov r8, r8)
 8008dc8:	200011e4 	.word	0x200011e4

08008dcc <do_c_comma>:
	aligned when 'C,' begins execution, it will remain character
	aligned when 'C,' finishes execution.
	An ambiguous condition exists if the data-space pointer is not
	character-aligned prior to execution of 'C,'.
*******************************************************************************/
		{ * here.chr ++ = pop(); }
 8008dcc:	b510      	push	{r4, lr}
 8008dce:	4b04      	ldr	r3, [pc, #16]	; (8008de0 <do_c_comma+0x14>)
 8008dd0:	689c      	ldr	r4, [r3, #8]
 8008dd2:	1c62      	adds	r2, r4, #1
 8008dd4:	609a      	str	r2, [r3, #8]
 8008dd6:	f7ff ff79 	bl	8008ccc <pop>
 8008dda:	7020      	strb	r0, [r4, #0]
 8008ddc:	bd10      	pop	{r4, pc}
 8008dde:	46c0      	nop			; (mov r8, r8)
 8008de0:	200011e4 	.word	0x200011e4

08008de4 <do_c_fetch>:
( c-addr -- char)
	Fetch the character stored at 'c-addr'. When the cell size is
	greater than character size, the unused high-order bits are all
	zeroes.
*******************************************************************************/
		{ push(* (uint8_t *) pop()); }
 8008de4:	b508      	push	{r3, lr}
 8008de6:	f7ff ff71 	bl	8008ccc <pop>
 8008dea:	7800      	ldrb	r0, [r0, #0]
 8008dec:	f7ff fe20 	bl	8008a30 <push>
 8008df0:	bd08      	pop	{r3, pc}

08008df2 <do_cell_plus>:
	CELL+	[cell-plus] 
( a-addr_1 -- a-addr_2)
	Add the size in address units of a cell to 'a-addr_1', giving
	'a-addr_2'.
*******************************************************************************/
		{ push((cell) ((cell *) pop() + 1)); }
 8008df2:	b508      	push	{r3, lr}
 8008df4:	f7ff ff6a 	bl	8008ccc <pop>
 8008df8:	3004      	adds	r0, #4
 8008dfa:	f7ff fe19 	bl	8008a30 <push>
 8008dfe:	bd08      	pop	{r3, pc}

08008e00 <do_cells>:
/*******************************************************************************
	CELLS	 
( n_1 -- n_2)
	'n_2' is the size in address units of 'n_1' cells.
*******************************************************************************/
		{ push(pop() * sizeof(cell)); }
 8008e00:	b508      	push	{r3, lr}
 8008e02:	f7ff ff63 	bl	8008ccc <pop>
 8008e06:	0080      	lsls	r0, r0, #2
 8008e08:	f7ff fe12 	bl	8008a30 <push>
 8008e0c:	bd08      	pop	{r3, pc}

08008e0e <do_char_plus>:
	CHAR+	[char-plus] 
( c-addr_1 -- c-addr_2)
	Add the size in address units of a character to
	'c-addr_1', giving 'c-addr_2'.
*******************************************************************************/
		{ push((cell)((uint8_t *) pop() + 1)); }
 8008e0e:	b508      	push	{r3, lr}
 8008e10:	f7ff ff5c 	bl	8008ccc <pop>
 8008e14:	3001      	adds	r0, #1
 8008e16:	f7ff fe0b 	bl	8008a30 <push>
 8008e1a:	bd08      	pop	{r3, pc}

08008e1c <do_chars>:
	CHARS	[chars] 
( n_1 -- n_2)
	'n_2' is the size in address units of 'n_1'
	characters.
*******************************************************************************/
		{ push(pop() * sizeof(uint8_t)); }
 8008e1c:	b508      	push	{r3, lr}
 8008e1e:	f7ff ff55 	bl	8008ccc <pop>
 8008e22:	f7ff fe05 	bl	8008a30 <push>
 8008e26:	bd08      	pop	{r3, pc}

08008e28 <do_count>:
	string stored at 'c-addr_1'. 'c-addr_2' is the
	address of the first character after 'c-addr_1'. 'u'
	is the contents of the character at 'c-addr_1', which is
	the length in characters of the string at 'c-addr_2'.
*******************************************************************************/
		{ uint8_t * s = (uint8_t *) pop(); push((cell) s + 1); push(* s); }
 8008e28:	b510      	push	{r4, lr}
 8008e2a:	f7ff ff4f 	bl	8008ccc <pop>
 8008e2e:	1c04      	adds	r4, r0, #0
 8008e30:	3001      	adds	r0, #1
 8008e32:	f7ff fdfd 	bl	8008a30 <push>
 8008e36:	7820      	ldrb	r0, [r4, #0]
 8008e38:	f7ff fdfa 	bl	8008a30 <push>
 8008e3c:	bd10      	pop	{r4, pc}

08008e3e <do_drop>:
/*******************************************************************************
	DROP	 
( x -- )
	Remove 'x' from the stack.
*******************************************************************************/
		{ pop(); }
 8008e3e:	b508      	push	{r3, lr}
 8008e40:	f7ff ff44 	bl	8008ccc <pop>
 8008e44:	bd08      	pop	{r3, pc}

08008e46 <do_emit>:
	devices can respond differently to control characters, programs
	that use control characters to perform specific functions have
	an environmental dependency. Each EMIT deals with only one
	character.
*******************************************************************************/
		{ sfputc(pop()); }
 8008e46:	b508      	push	{r3, lr}
 8008e48:	f7ff ff40 	bl	8008ccc <pop>
 8008e4c:	f7fa f86e 	bl	8002f2c <sfputc>
 8008e50:	bd08      	pop	{r3, pc}

08008e52 <do_cr>:
	CR	[c-r] 
(  -- )
	Cause subsequent output to appear at the beginning of the next
	line.
*******************************************************************************/
		{ push('\n'); do_emit(); }
 8008e52:	b508      	push	{r3, lr}
 8008e54:	200a      	movs	r0, #10
 8008e56:	f7ff fdeb 	bl	8008a30 <push>
 8008e5a:	f7ff fff4 	bl	8008e46 <do_emit>
 8008e5e:	bd08      	pop	{r3, pc}

08008e60 <do_space>:
/*******************************************************************************
	SPACE	 
(  -- )
	Display one space.
*******************************************************************************/
		{ do_bl(); do_emit(); }
 8008e60:	b508      	push	{r3, lr}
 8008e62:	f7ff fe35 	bl	8008ad0 <do_bl>
 8008e66:	f7ff ffee 	bl	8008e46 <do_emit>
 8008e6a:	bd08      	pop	{r3, pc}

08008e6c <do_execute>:
( i*x xt -- j*x)
	Remove 'xt' from the stack and perform the semantics
	identified by it. Other stack effects are due to the word
	'EXECUTE'd.
*******************************************************************************/
		{ struct word * w = (struct word *) pop(); WP = w; if (!w->is_does_proper) w->cfa(); else exec_does(); }
 8008e6c:	b508      	push	{r3, lr}
 8008e6e:	f7ff ff2d 	bl	8008ccc <pop>
 8008e72:	4b05      	ldr	r3, [pc, #20]	; (8008e88 <do_execute+0x1c>)
 8008e74:	6058      	str	r0, [r3, #4]
 8008e76:	7a03      	ldrb	r3, [r0, #8]
 8008e78:	075b      	lsls	r3, r3, #29
 8008e7a:	d402      	bmi.n	8008e82 <do_execute+0x16>
 8008e7c:	68c3      	ldr	r3, [r0, #12]
 8008e7e:	4798      	blx	r3
 8008e80:	e001      	b.n	8008e86 <do_execute+0x1a>
 8008e82:	f7ff fdef 	bl	8008a64 <exec_does>
 8008e86:	bd08      	pop	{r3, pc}
 8008e88:	200011e4 	.word	0x200011e4

08008e8c <do_fill>:
( c-addr u char -- )
	If 'u' is greater than zero, store 'char' in each of
	'u' consecutive characters of memory beginning at
	'c-addr'.
*******************************************************************************/
		{ cell c = pop(), i = pop(); xmemset((void *) pop(), c, i); }
 8008e8c:	b538      	push	{r3, r4, r5, lr}
 8008e8e:	f7ff ff1d 	bl	8008ccc <pop>
 8008e92:	1c05      	adds	r5, r0, #0
 8008e94:	f7ff ff1a 	bl	8008ccc <pop>
 8008e98:	1c04      	adds	r4, r0, #0
 8008e9a:	f7ff ff17 	bl	8008ccc <pop>
 8008e9e:	1c29      	adds	r1, r5, #0
 8008ea0:	1c22      	adds	r2, r4, #0
 8008ea2:	f7ff fd57 	bl	8008954 <xmemset>
 8008ea6:	bd38      	pop	{r3, r4, r5, pc}

08008ea8 <do_find>:
*******************************************************************************/
{
struct word * w;
char * s;
int len;
	w = latest;
 8008ea8:	4b15      	ldr	r3, [pc, #84]	; (8008f00 <do_find+0x58>)
	If the definition is immediate, also return one ('1'),
	otherwise also return minus-one ('-1'). For a given string,
	the values returned by 'FIND' while compiling may differ
	from those returned while not compiling.
*******************************************************************************/
{
 8008eaa:	b570      	push	{r4, r5, r6, lr}
struct word * w;
char * s;
int len;
	w = latest;
 8008eac:	681c      	ldr	r4, [r3, #0]
	s = (char *) pop();
 8008eae:	f7ff ff0d 	bl	8008ccc <pop>
	len = *((unsigned char *) s);
 8008eb2:	7806      	ldrb	r6, [r0, #0]
{
struct word * w;
char * s;
int len;
	w = latest;
	s = (char *) pop();
 8008eb4:	1c05      	adds	r5, r0, #0
	len = *((unsigned char *) s);
	if (len)
 8008eb6:	2e00      	cmp	r6, #0
 8008eb8:	d01a      	beq.n	8008ef0 <do_find+0x48>
		while (w)
 8008eba:	2c00      	cmp	r4, #0
 8008ebc:	d018      	beq.n	8008ef0 <do_find+0x48>
		{
			if (!w->is_smudged)
 8008ebe:	7a23      	ldrb	r3, [r4, #8]
 8008ec0:	079b      	lsls	r3, r3, #30
 8008ec2:	d408      	bmi.n	8008ed6 <do_find+0x2e>
				/*
				if (!memcmp(s, w->name->str, len + 1))
				*/
				if (/* this is possible because of the
				     * new ':noname' code */ w->name)
 8008ec4:	6861      	ldr	r1, [r4, #4]
		{
			if (!w->is_smudged)
				/*
				if (!memcmp(s, w->name->str, len + 1))
				*/
				if (/* this is possible because of the
 8008ec6:	2900      	cmp	r1, #0
 8008ec8:	d005      	beq.n	8008ed6 <do_find+0x2e>
				     * new ':noname' code */ w->name)
					if (!xstrncasecmp(s, (char*) w->name->str, len + 1))
 8008eca:	1c72      	adds	r2, r6, #1
 8008ecc:	1c28      	adds	r0, r5, #0
 8008ece:	f7ff fd6b 	bl	80089a8 <xstrncasecmp>
 8008ed2:	2800      	cmp	r0, #0
 8008ed4:	d001      	beq.n	8008eda <do_find+0x32>
						break;
			w = w->link;
 8008ed6:	6824      	ldr	r4, [r4, #0]
 8008ed8:	e7ef      	b.n	8008eba <do_find+0x12>
		}
	else
		w = 0;
	if (w)
	{
		push((cell) w);
 8008eda:	1c20      	adds	r0, r4, #0
 8008edc:	f7ff fda8 	bl	8008a30 <push>
		push(w->is_immediate ? 1 : -1);
 8008ee0:	2201      	movs	r2, #1
 8008ee2:	7a23      	ldrb	r3, [r4, #8]
 8008ee4:	4013      	ands	r3, r2
 8008ee6:	4258      	negs	r0, r3
 8008ee8:	4143      	adcs	r3, r0
 8008eea:	4258      	negs	r0, r3
 8008eec:	4310      	orrs	r0, r2
 8008eee:	e003      	b.n	8008ef8 <do_find+0x50>
	}
	else
	{
		push((cell) s);
 8008ef0:	1c28      	adds	r0, r5, #0
 8008ef2:	f7ff fd9d 	bl	8008a30 <push>
		push(0);
 8008ef6:	2000      	movs	r0, #0
 8008ef8:	f7ff fd9a 	bl	8008a30 <push>
	}
}
 8008efc:	bd70      	pop	{r4, r5, r6, pc}
 8008efe:	46c0      	nop			; (mov r8, r8)
 8008f00:	20000068 	.word	0x20000068

08008f04 <do_hold>:
	Add 'char' to the beginning of the pictured numeric output
	string. An ambiguous condition exists if 'HOLD' executes
	outside of a 'num-start' 'num-end' delimited number
	conversion.
*******************************************************************************/
		{ pno.buf[-- pno.idx] = pop(); }
 8008f04:	b538      	push	{r3, r4, r5, lr}
 8008f06:	4d04      	ldr	r5, [pc, #16]	; (8008f18 <do_hold+0x14>)
 8008f08:	68eb      	ldr	r3, [r5, #12]
 8008f0a:	1e5c      	subs	r4, r3, #1
 8008f0c:	60ec      	str	r4, [r5, #12]
 8008f0e:	f7ff fedd 	bl	8008ccc <pop>
 8008f12:	192c      	adds	r4, r5, r4
 8008f14:	7420      	strb	r0, [r4, #16]
 8008f16:	bd38      	pop	{r3, r4, r5, pc}
 8008f18:	200011e4 	.word	0x200011e4

08008f1c <runtime_branch_on_false>:
/*! the sforth dictionary head, points to the most recently added dictionary word */
static struct word * latest = (struct word *)(dictionary + __COUNTER__), * latest_reset_value;

/*********************************************************************************/
static void runtime_branch_on_false(void)
{ if (!pop()) IP.word += * IP.cell; else IP.word ++; }
 8008f1c:	b508      	push	{r3, lr}
 8008f1e:	f7ff fed5 	bl	8008ccc <pop>
 8008f22:	4a06      	ldr	r2, [pc, #24]	; (8008f3c <runtime_branch_on_false+0x20>)
 8008f24:	2800      	cmp	r0, #0
 8008f26:	d104      	bne.n	8008f32 <runtime_branch_on_false+0x16>
 8008f28:	6811      	ldr	r1, [r2, #0]
 8008f2a:	680b      	ldr	r3, [r1, #0]
 8008f2c:	009b      	lsls	r3, r3, #2
 8008f2e:	18cb      	adds	r3, r1, r3
 8008f30:	e001      	b.n	8008f36 <runtime_branch_on_false+0x1a>
 8008f32:	6813      	ldr	r3, [r2, #0]
 8008f34:	3304      	adds	r3, #4
 8008f36:	6013      	str	r3, [r2, #0]
 8008f38:	bd08      	pop	{r3, pc}
 8008f3a:	46c0      	nop			; (mov r8, r8)
 8008f3c:	200011e4 	.word	0x200011e4

08008f40 <do_invert>:
	INVERT	 
( x_1 -- x_2)
	Invert all bits of 'x_1', giving its logical inverse
	'x_2'.
*******************************************************************************/
		{ push(~ pop()); }
 8008f40:	b508      	push	{r3, lr}
 8008f42:	f7ff fec3 	bl	8008ccc <pop>
 8008f46:	43c0      	mvns	r0, r0
 8008f48:	f7ff fd72 	bl	8008a30 <push>
 8008f4c:	bd08      	pop	{r3, pc}

08008f4e <do_literal>:
	(  -- x)
	Place 'x' on the stack.
*******************************************************************************/
/******************************************************************************/
void /* "literal" */	do_literal(void)
		{ * here.word ++ = & xt_runtime_literal; * here.cell ++ = pop(); }
 8008f4e:	b510      	push	{r4, lr}
 8008f50:	4a05      	ldr	r2, [pc, #20]	; (8008f68 <do_literal+0x1a>)
 8008f52:	4b06      	ldr	r3, [pc, #24]	; (8008f6c <do_literal+0x1e>)
 8008f54:	6894      	ldr	r4, [r2, #8]
 8008f56:	333c      	adds	r3, #60	; 0x3c
 8008f58:	6023      	str	r3, [r4, #0]
 8008f5a:	1c23      	adds	r3, r4, #0
 8008f5c:	3308      	adds	r3, #8
 8008f5e:	6093      	str	r3, [r2, #8]
 8008f60:	f7ff feb4 	bl	8008ccc <pop>
 8008f64:	6060      	str	r0, [r4, #4]
 8008f66:	bd10      	pop	{r4, pc}
 8008f68:	200011e4 	.word	0x200011e4
 8008f6c:	08013734 	.word	0x08013734

08008f70 <do_move>:
	consecutive address units at 'addr_2'. After 'MOVE'
	completes, the 'u' consecutive address units at 'addr_2'
	contain exactly what the 'u' consecutive address units at
	'addr_1' contained before the move.
*******************************************************************************/
		{ cell i = pop(); uint8_t * dest = (uint8_t *) pop(), * src = (uint8_t *) pop(); xmemmove(dest, src, i); }
 8008f70:	b538      	push	{r3, r4, r5, lr}
 8008f72:	f7ff feab 	bl	8008ccc <pop>
 8008f76:	1c04      	adds	r4, r0, #0
 8008f78:	f7ff fea8 	bl	8008ccc <pop>
 8008f7c:	1c05      	adds	r5, r0, #0
 8008f7e:	f7ff fea5 	bl	8008ccc <pop>
 8008f82:	1c22      	adds	r2, r4, #0
 8008f84:	1c01      	adds	r1, r0, #0
 8008f86:	1c28      	adds	r0, r5, #0
 8008f88:	f7ff fcec 	bl	8008964 <xmemmove>
 8008f8c:	bd38      	pop	{r3, r4, r5, pc}

08008f8e <do_spaces>:
/*******************************************************************************
	SPACES	 
( n -- )
	If 'n' is greater than zero, display 'n' spaces.
*******************************************************************************/
		{ cell i = pop(); while (i --) do_space(); }
 8008f8e:	b510      	push	{r4, lr}
 8008f90:	f7ff fe9c 	bl	8008ccc <pop>
 8008f94:	1c04      	adds	r4, r0, #0
 8008f96:	2c00      	cmp	r4, #0
 8008f98:	d003      	beq.n	8008fa2 <do_spaces+0x14>
 8008f9a:	f7ff ff61 	bl	8008e60 <do_space>
 8008f9e:	3c01      	subs	r4, #1
 8008fa0:	e7f9      	b.n	8008f96 <do_spaces+0x8>
 8008fa2:	bd10      	pop	{r4, pc}

08008fa4 <do_then>:
	the location of the appended run-time semantics.
\runtime
	(  -- )
	Continue execution.
*******************************************************************************/
		{ cell * p = (cell *) pop(); * p = (cell)(here.cell - p); }
 8008fa4:	b508      	push	{r3, lr}
 8008fa6:	f7ff fe91 	bl	8008ccc <pop>
 8008faa:	4b03      	ldr	r3, [pc, #12]	; (8008fb8 <do_then+0x14>)
 8008fac:	689b      	ldr	r3, [r3, #8]
 8008fae:	1a1b      	subs	r3, r3, r0
 8008fb0:	109b      	asrs	r3, r3, #2
 8008fb2:	6003      	str	r3, [r0, #0]
 8008fb4:	bd08      	pop	{r3, pc}
 8008fb6:	46c0      	nop			; (mov r8, r8)
 8008fb8:	200011e4 	.word	0x200011e4

08008fbc <do_repeat>:
	following the appended run-time semantics.
\runtime
	(  -- )
	Continue execution at the location given by 'dest'.
*******************************************************************************/
		{ * here.word ++ = & xt_runtime_branch; * here.cell = (cell)((const struct word **) pop() - here.word); here.cell ++; do_then(); }
 8008fbc:	b570      	push	{r4, r5, r6, lr}
 8008fbe:	4d08      	ldr	r5, [pc, #32]	; (8008fe0 <do_repeat+0x24>)
 8008fc0:	4b08      	ldr	r3, [pc, #32]	; (8008fe4 <do_repeat+0x28>)
 8008fc2:	68ac      	ldr	r4, [r5, #8]
 8008fc4:	3328      	adds	r3, #40	; 0x28
 8008fc6:	1d26      	adds	r6, r4, #4
 8008fc8:	6023      	str	r3, [r4, #0]
 8008fca:	60ae      	str	r6, [r5, #8]
 8008fcc:	f7ff fe7e 	bl	8008ccc <pop>
 8008fd0:	1b80      	subs	r0, r0, r6
 8008fd2:	1080      	asrs	r0, r0, #2
 8008fd4:	6060      	str	r0, [r4, #4]
 8008fd6:	3408      	adds	r4, #8
 8008fd8:	60ac      	str	r4, [r5, #8]
 8008fda:	f7ff ffe3 	bl	8008fa4 <do_then>
 8008fde:	bd70      	pop	{r4, r5, r6, pc}
 8008fe0:	200011e4 	.word	0x200011e4
 8008fe4:	08013734 	.word	0x08013734

08008fe8 <do_type>:
	inclusive, the corresponding standard character, specified
	Because different output devices can respond differently to
	control characters, programs that use control characters to
	perform specific functions have an environmental dependency.
*******************************************************************************/
		{ cell i = pop(); uint8_t * s = (uint8_t *) pop(); while (i --) push ((cell) * s ++), do_emit(); }
 8008fe8:	b538      	push	{r3, r4, r5, lr}
 8008fea:	f7ff fe6f 	bl	8008ccc <pop>
 8008fee:	1c05      	adds	r5, r0, #0
 8008ff0:	f7ff fe6c 	bl	8008ccc <pop>
 8008ff4:	1c04      	adds	r4, r0, #0
 8008ff6:	1945      	adds	r5, r0, r5
 8008ff8:	42ac      	cmp	r4, r5
 8008ffa:	d006      	beq.n	800900a <do_type+0x22>
 8008ffc:	7820      	ldrb	r0, [r4, #0]
 8008ffe:	f7ff fd17 	bl	8008a30 <push>
 8009002:	3401      	adds	r4, #1
 8009004:	f7ff ff1f 	bl	8008e46 <do_emit>
 8009008:	e7f6      	b.n	8008ff8 <do_type+0x10>
 800900a:	bd38      	pop	{r3, r4, r5, pc}

0800900c <do_until>:
*******************************************************************************/
		// !!! gcc bug ??? - the row below does not work under mingw32, it works under linux
		// looks like this is related to some undefined behaviour, which is not reported
		// as a warning by gcc, though
		//{ * here.word ++ = & xt_runtime_branch_on_false; * here.cell ++ = (cell) ((const struct word **) pop() - here.word); }
		{ * here.word ++ = & xt_runtime_branch_on_false; * here.cell = (cell) ((const struct word **) pop() - here.word); here.cell ++; }
 800900c:	b570      	push	{r4, r5, r6, lr}
 800900e:	4d07      	ldr	r5, [pc, #28]	; (800902c <do_until+0x20>)
 8009010:	4b07      	ldr	r3, [pc, #28]	; (8009030 <do_until+0x24>)
 8009012:	68ac      	ldr	r4, [r5, #8]
 8009014:	3318      	adds	r3, #24
 8009016:	1d26      	adds	r6, r4, #4
 8009018:	6023      	str	r3, [r4, #0]
 800901a:	60ae      	str	r6, [r5, #8]
 800901c:	f7ff fe56 	bl	8008ccc <pop>
 8009020:	1b80      	subs	r0, r0, r6
 8009022:	1080      	asrs	r0, r0, #2
 8009024:	6060      	str	r0, [r4, #4]
 8009026:	3408      	adds	r4, #8
 8009028:	60ac      	str	r4, [r5, #8]
 800902a:	bd70      	pop	{r4, r5, r6, pc}
 800902c:	200011e4 	.word	0x200011e4
 8009030:	08013734 	.word	0x08013734

08009034 <do_zero_not_equals>:
	0<>	[zero-not-equals] 
( x -- flag)
	'flag' is true if and only if 'x' is not equal to
	zero.
*******************************************************************************/
		{ push(pop() ? C_TRUE : C_FALSE); }
 8009034:	b508      	push	{r3, lr}
 8009036:	f7ff fe49 	bl	8008ccc <pop>
 800903a:	1e43      	subs	r3, r0, #1
 800903c:	4198      	sbcs	r0, r3
 800903e:	4240      	negs	r0, r0
 8009040:	f7ff fcf6 	bl	8008a30 <push>
 8009044:	bd08      	pop	{r3, pc}

08009046 <do_again>:
	(  -- )
	Continue execution at the location specified by 'dest'.
	If no other control flow words are used, any program code
	after 'AGAIN' will not be executed.
*******************************************************************************/
		{ * here.word ++ = &xt_runtime_branch; * here.cell = (cell *) pop() - here.cell; here.cell ++; }
 8009046:	b570      	push	{r4, r5, r6, lr}
 8009048:	4d07      	ldr	r5, [pc, #28]	; (8009068 <do_again+0x22>)
 800904a:	4b08      	ldr	r3, [pc, #32]	; (800906c <do_again+0x26>)
 800904c:	68ac      	ldr	r4, [r5, #8]
 800904e:	3328      	adds	r3, #40	; 0x28
 8009050:	1d26      	adds	r6, r4, #4
 8009052:	6023      	str	r3, [r4, #0]
 8009054:	60ae      	str	r6, [r5, #8]
 8009056:	f7ff fe39 	bl	8008ccc <pop>
 800905a:	1b80      	subs	r0, r0, r6
 800905c:	1080      	asrs	r0, r0, #2
 800905e:	6060      	str	r0, [r4, #4]
 8009060:	3408      	adds	r4, #8
 8009062:	60ac      	str	r4, [r5, #8]
 8009064:	bd70      	pop	{r4, r5, r6, pc}
 8009066:	46c0      	nop			; (mov r8, r8)
 8009068:	200011e4 	.word	0x200011e4
 800906c:	08013734 	.word	0x08013734

08009070 <do_erase>:
( addr u -- )
	If 'u' is greater than zero, clear all bits in each of
	'u' consecutive address units of memory beginning at
	'addr'.
*******************************************************************************/
		{ cell x = pop(); xmemset((void *) pop(), 0, x); }
 8009070:	b510      	push	{r4, lr}
 8009072:	f7ff fe2b 	bl	8008ccc <pop>
 8009076:	1c04      	adds	r4, r0, #0
 8009078:	f7ff fe28 	bl	8008ccc <pop>
 800907c:	2100      	movs	r1, #0
 800907e:	1c22      	adds	r2, r4, #0
 8009080:	f7ff fc68 	bl	8008954 <xmemset>
 8009084:	bd10      	pop	{r4, pc}

08009086 <do_parse>:
	Parse 'ccc' delimited by the delimiter 'char'.
	'c-addr' is the address (within the input buffer) and
	'u' is the length of the parsed string. If the parse area
	was empty, the resulting string has a zero length.
*******************************************************************************/
{
 8009086:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
uint8_t c;
const uint8_t * s;
int i;
	do_source();
 8009088:	f7ff fd60 	bl	8008b4c <do_source>
	pop();
 800908c:	f7ff fe1e 	bl	8008ccc <pop>
	s = (const uint8_t *) pop();
 8009090:	f7ff fe1c 	bl	8008ccc <pop>
 8009094:	9001      	str	r0, [sp, #4]
	c = (uint8_t) pop();
 8009096:	f7ff fe19 	bl	8008ccc <pop>
	/* sanity check */
	if (input_spec.idx >= input_spec.len)
 800909a:	4b24      	ldr	r3, [pc, #144]	; (800912c <do_parse+0xa6>)
const uint8_t * s;
int i;
	do_source();
	pop();
	s = (const uint8_t *) pop();
	c = (uint8_t) pop();
 800909c:	1c05      	adds	r5, r0, #0
	/* sanity check */
	if (input_spec.idx >= input_spec.len)
 800909e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80090a0:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 80090a2:	1c1f      	adds	r7, r3, #0
 80090a4:	42b4      	cmp	r4, r6
 80090a6:	d308      	bcc.n	80090ba <do_parse+0x34>
	{
		input_spec.idx = input_spec.len;
 80090a8:	625e      	str	r6, [r3, #36]	; 0x24
		push((cell) (s + input_spec.len));
 80090aa:	9b01      	ldr	r3, [sp, #4]
 80090ac:	1998      	adds	r0, r3, r6
 80090ae:	f7ff fcbf 	bl	8008a30 <push>
		push(0);
 80090b2:	2000      	movs	r0, #0
 80090b4:	f7ff fcbc 	bl	8008a30 <push>
		return;
 80090b8:	e036      	b.n	8009128 <do_parse+0xa2>
 80090ba:	b2c0      	uxtb	r0, r0
	}
	i = 0;
	if (!xisspace(c))
 80090bc:	f7ff fc2e 	bl	800891c <xisspace>
 80090c0:	2800      	cmp	r0, #0
 80090c2:	d108      	bne.n	80090d6 <do_parse+0x50>
	{
		for (i = input_spec.idx; i < input_spec.len; i ++)
 80090c4:	42b4      	cmp	r4, r6
 80090c6:	d01e      	beq.n	8009106 <do_parse+0x80>
			if (i[s] == c)
 80090c8:	9b01      	ldr	r3, [sp, #4]
 80090ca:	5ce2      	ldrb	r2, [r4, r3]
 80090cc:	b2eb      	uxtb	r3, r5
 80090ce:	429a      	cmp	r2, r3
 80090d0:	d019      	beq.n	8009106 <do_parse+0x80>
		return;
	}
	i = 0;
	if (!xisspace(c))
	{
		for (i = input_spec.idx; i < input_spec.len; i ++)
 80090d2:	3401      	adds	r4, #1
 80090d4:	e7f6      	b.n	80090c4 <do_parse+0x3e>
				break;
	}
	else
	{
		/* special case for whitespace characters */
		for (i = input_spec.idx; i < input_spec.len; i ++)
 80090d6:	1c25      	adds	r5, r4, #0
 80090d8:	1c34      	adds	r4, r6, #0
 80090da:	42b5      	cmp	r5, r6
 80090dc:	d011      	beq.n	8009102 <do_parse+0x7c>
			if (!xisspace(i[s]))
 80090de:	9b01      	ldr	r3, [sp, #4]
 80090e0:	5ce8      	ldrb	r0, [r5, r3]
 80090e2:	f7ff fc1b 	bl	800891c <xisspace>
 80090e6:	2800      	cmp	r0, #0
 80090e8:	d102      	bne.n	80090f0 <do_parse+0x6a>
			{
				input_spec.idx = i;
 80090ea:	627d      	str	r5, [r7, #36]	; 0x24
				break;
 80090ec:	1c2c      	adds	r4, r5, #0
 80090ee:	e008      	b.n	8009102 <do_parse+0x7c>
				break;
	}
	else
	{
		/* special case for whitespace characters */
		for (i = input_spec.idx; i < input_spec.len; i ++)
 80090f0:	3501      	adds	r5, #1
 80090f2:	e7f2      	b.n	80090da <do_parse+0x54>
			{
				input_spec.idx = i;
				break;
			}
		for (; i < input_spec.len; i ++)
			if (xisspace(i[s]))
 80090f4:	9b01      	ldr	r3, [sp, #4]
 80090f6:	5ce0      	ldrb	r0, [r4, r3]
 80090f8:	f7ff fc10 	bl	800891c <xisspace>
 80090fc:	2800      	cmp	r0, #0
 80090fe:	d102      	bne.n	8009106 <do_parse+0x80>
			if (!xisspace(i[s]))
			{
				input_spec.idx = i;
				break;
			}
		for (; i < input_spec.len; i ++)
 8009100:	3401      	adds	r4, #1
 8009102:	42b4      	cmp	r4, r6
 8009104:	d3f6      	bcc.n	80090f4 <do_parse+0x6e>
			if (xisspace(i[s]))
				break;
	}
	push((cell) (s + input_spec.idx));
 8009106:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009108:	9b01      	ldr	r3, [sp, #4]
 800910a:	4694      	mov	ip, r2
 800910c:	4463      	add	r3, ip
 800910e:	1c18      	adds	r0, r3, #0
 8009110:	f7ff fc8e 	bl	8008a30 <push>
	push(i - input_spec.idx);
 8009114:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009116:	1ae0      	subs	r0, r4, r3
 8009118:	f7ff fc8a 	bl	8008a30 <push>
	if (i != input_spec.len)
		/* move past the delimiter character */
		i ++;
 800911c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800911e:	1ae3      	subs	r3, r4, r3
 8009120:	1e5a      	subs	r2, r3, #1
 8009122:	4193      	sbcs	r3, r2
 8009124:	18e4      	adds	r4, r4, r3
	input_spec.idx = i;
 8009126:	627c      	str	r4, [r7, #36]	; 0x24
}
 8009128:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800912a:	46c0      	nop			; (mov r8, r8)
 800912c:	20001264 	.word	0x20001264

08009130 <do_parse_name>:
		\tab '[']' isnotspace? xt-skip 'p' end-word restlen r: start-word ) \\
		\tab '2DUP' 1 'MIN' '+' 'SOURCE' 'DROP' '-' 'toIN' '!' \\
		\tab 'DROP' 'Rfrom' 'TUCK' '-' ';'
	\end{implement}
*******************************************************************************/
	{ do_bl(); do_parse(); }
 8009130:	b508      	push	{r3, lr}
 8009132:	f7ff fccd 	bl	8008ad0 <do_bl>
 8009136:	f7ff ffa6 	bl	8009086 <do_parse>
 800913a:	bd08      	pop	{r3, pc}

0800913c <do_paren>:
	(right parenthesis).
	'(' is an immediate word.
	The number of characters in 'ccc' may be zero to the
	number of characters in the parse area.
*******************************************************************************/
{
 800913c:	b510      	push	{r4, lr}
	while (1)
	{
		push(')');
 800913e:	2029      	movs	r0, #41	; 0x29
 8009140:	f7ff fc76 	bl	8008a30 <push>
		do_parse();
 8009144:	f7ff ff9f 	bl	8009086 <do_parse>
		if (input_spec.source_id == SOURCE_ID_STRING)
 8009148:	4c0d      	ldr	r4, [pc, #52]	; (8009180 <do_paren+0x44>)
 800914a:	6a23      	ldr	r3, [r4, #32]
 800914c:	3301      	adds	r3, #1
 800914e:	d102      	bne.n	8009156 <do_paren+0x1a>
		{
			pop();
 8009150:	f7ff fdbc 	bl	8008ccc <pop>
			break;
 8009154:	e010      	b.n	8009178 <do_paren+0x3c>
		}
		else
		{
			/* input is the user input device, or a file */
			pop();
 8009156:	f7ff fdb9 	bl	8008ccc <pop>
			if (input_spec.buf[input_spec.idx - 1] == ')')
 800915a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800915c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800915e:	18d3      	adds	r3, r2, r3
 8009160:	3b01      	subs	r3, #1
 8009162:	781b      	ldrb	r3, [r3, #0]
 8009164:	2b29      	cmp	r3, #41	; 0x29
 8009166:	d007      	beq.n	8009178 <do_paren+0x3c>
				break;
			pop();
 8009168:	f7ff fdb0 	bl	8008ccc <pop>
			do_refill();
 800916c:	f7ff fd14 	bl	8008b98 <do_refill>
			if (!pop())
 8009170:	f7ff fdac 	bl	8008ccc <pop>
 8009174:	2800      	cmp	r0, #0
 8009176:	d1e2      	bne.n	800913e <do_paren+0x2>
				break;
		}
	}
	pop();
 8009178:	f7ff fda8 	bl	8008ccc <pop>
}
 800917c:	bd10      	pop	{r4, pc}
 800917e:	46c0      	nop			; (mov r8, r8)
 8009180:	20001264 	.word	0x20001264

08009184 <do_char>:
	CHAR	[char] 
( "<spaces>name" -- char)
	Skip leading space delimiters. Parse 'name' delimited by
	a space. Put the value of its first character onto the stack.
*******************************************************************************/
		{ do_bl(); do_parse(); if (pop()) push(*(uint8_t *) pop()); else pop(), push(0); }
 8009184:	b510      	push	{r4, lr}
 8009186:	f7ff fca3 	bl	8008ad0 <do_bl>
 800918a:	f7ff ff7c 	bl	8009086 <do_parse>
 800918e:	f7ff fd9d 	bl	8008ccc <pop>
 8009192:	1e04      	subs	r4, r0, #0
 8009194:	d003      	beq.n	800919e <do_char+0x1a>
 8009196:	f7ff fd99 	bl	8008ccc <pop>
 800919a:	7800      	ldrb	r0, [r0, #0]
 800919c:	e002      	b.n	80091a4 <do_char+0x20>
 800919e:	f7ff fd95 	bl	8008ccc <pop>
 80091a2:	1c20      	adds	r0, r4, #0
 80091a4:	f7ff fc44 	bl	8008a30 <push>
 80091a8:	bd10      	pop	{r4, pc}

080091aa <do_word>:
	the parsed word as a counted string. If the parse area was
	empty or contained no characters other than the delimiter, the
	resulting string has a zero length.
	A program may replace characters within the string.
*******************************************************************************/
{
 80091aa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
uint8_t c;
cell i;
const uint8_t * s;
	c = (uint8_t) pop();
 80091ac:	f7ff fd8e 	bl	8008ccc <pop>
 80091b0:	1c06      	adds	r6, r0, #0
	do_source();
 80091b2:	f7ff fccb 	bl	8008b4c <do_source>
	pop();
 80091b6:	f7ff fd89 	bl	8008ccc <pop>
	s = (const uint8_t *) pop();
 80091ba:	f7ff fd87 	bl	8008ccc <pop>
	wordpad.len = 0;
 80091be:	2200      	movs	r2, #0
 80091c0:	4c20      	ldr	r4, [pc, #128]	; (8009244 <do_word+0x9a>)
cell i;
const uint8_t * s;
	c = (uint8_t) pop();
	do_source();
	pop();
	s = (const uint8_t *) pop();
 80091c2:	9000      	str	r0, [sp, #0]
	wordpad.len = 0;
 80091c4:	1d63      	adds	r3, r4, #5
 80091c6:	77da      	strb	r2, [r3, #31]
	if (input_spec.idx >= input_spec.len)
 80091c8:	4b1f      	ldr	r3, [pc, #124]	; (8009248 <do_word+0x9e>)
 80091ca:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 80091cc:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 80091ce:	9301      	str	r3, [sp, #4]
 80091d0:	42bd      	cmp	r5, r7
 80091d2:	d302      	bcc.n	80091da <do_word+0x30>
	{
		push((cell) & wordpad);
 80091d4:	1c20      	adds	r0, r4, #0
 80091d6:	3024      	adds	r0, #36	; 0x24
 80091d8:	e030      	b.n	800923c <do_word+0x92>
 80091da:	b2f6      	uxtb	r6, r6
		return;
	}
	/* special case for whitespace characters */
	if (xisspace(c))
 80091dc:	1c30      	adds	r0, r6, #0
 80091de:	f7ff fb9d 	bl	800891c <xisspace>
 80091e2:	2800      	cmp	r0, #0
 80091e4:	d00e      	beq.n	8009204 <do_word+0x5a>
		while (1)
		{
			i = input_spec.idx;
			while (xisspace(s[i]) && i < input_spec.len)
 80091e6:	9b00      	ldr	r3, [sp, #0]
 80091e8:	5ce8      	ldrb	r0, [r5, r3]
 80091ea:	f7ff fb97 	bl	800891c <xisspace>
 80091ee:	2800      	cmp	r0, #0
 80091f0:	d104      	bne.n	80091fc <do_word+0x52>
				i ++;
			input_spec.idx = i;
 80091f2:	9b01      	ldr	r3, [sp, #4]
 80091f4:	625d      	str	r5, [r3, #36]	; 0x24
			if (i == input_spec.len)
 80091f6:	42bd      	cmp	r5, r7
 80091f8:	d104      	bne.n	8009204 <do_word+0x5a>
 80091fa:	e7eb      	b.n	80091d4 <do_word+0x2a>
	/* special case for whitespace characters */
	if (xisspace(c))
		while (1)
		{
			i = input_spec.idx;
			while (xisspace(s[i]) && i < input_spec.len)
 80091fc:	42bd      	cmp	r5, r7
 80091fe:	d0f8      	beq.n	80091f2 <do_word+0x48>
				i ++;
 8009200:	3501      	adds	r5, #1
 8009202:	e7f0      	b.n	80091e6 <do_word+0x3c>
				push((cell) & wordpad);
				return;
			}
			break;
		}
	push(c);
 8009204:	1c30      	adds	r0, r6, #0
 8009206:	f7ff fc13 	bl	8008a30 <push>
	do_parse();
 800920a:	f7ff ff3c 	bl	8009086 <do_parse>
	i = pop();
 800920e:	f7ff fd5d 	bl	8008ccc <pop>
 8009212:	1e05      	subs	r5, r0, #0
 8009214:	2dff      	cmp	r5, #255	; 0xff
 8009216:	d900      	bls.n	800921a <do_word+0x70>
 8009218:	25ff      	movs	r5, #255	; 0xff
	if (i > sizeof wordpad.buf - 1)
		i = sizeof wordpad.buf - 1;
	wordpad.len = i;
 800921a:	1d67      	adds	r7, r4, #5
 800921c:	77fd      	strb	r5, [r7, #31]
	xmemcpy(wordpad.buf, (char *) pop(), i);
 800921e:	f7ff fd55 	bl	8008ccc <pop>
 8009222:	1c01      	adds	r1, r0, #0
 8009224:	1c20      	adds	r0, r4, #0
 8009226:	1c26      	adds	r6, r4, #0
 8009228:	1c2a      	adds	r2, r5, #0
 800922a:	3025      	adds	r0, #37	; 0x25
 800922c:	f7ff fb89 	bl	8008942 <xmemcpy>
 8009230:	3624      	adds	r6, #36	; 0x24
	/* also null-terminate the string; this is to facilitate numeric conversions
	 * in do_quit() */
	wordpad.buf[i] = 0;
 8009232:	2300      	movs	r3, #0
	push((cell) & wordpad);
 8009234:	1c30      	adds	r0, r6, #0
		i = sizeof wordpad.buf - 1;
	wordpad.len = i;
	xmemcpy(wordpad.buf, (char *) pop(), i);
	/* also null-terminate the string; this is to facilitate numeric conversions
	 * in do_quit() */
	wordpad.buf[i] = 0;
 8009236:	197d      	adds	r5, r7, r5
 8009238:	3501      	adds	r5, #1
 800923a:	77eb      	strb	r3, [r5, #31]
	push((cell) & wordpad);
 800923c:	f7ff fbf8 	bl	8008a30 <push>
}
 8009240:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009242:	46c0      	nop			; (mov r8, r8)
 8009244:	20001864 	.word	0x20001864
 8009248:	20001264 	.word	0x20001264

0800924c <do_bracket_char>:
\runtime
	(  -- char)
	Place 'char', the value of the first character of
	'name', on the stack.
*******************************************************************************/
		{ do_bl(); do_word(); do_count(); pop(); push(* (uint8_t *) pop()); do_literal(); }
 800924c:	b508      	push	{r3, lr}
 800924e:	f7ff fc3f 	bl	8008ad0 <do_bl>
 8009252:	f7ff ffaa 	bl	80091aa <do_word>
 8009256:	f7ff fde7 	bl	8008e28 <do_count>
 800925a:	f7ff fd37 	bl	8008ccc <pop>
 800925e:	f7ff fd35 	bl	8008ccc <pop>
 8009262:	7800      	ldrb	r0, [r0, #0]
 8009264:	f7ff fbe4 	bl	8008a30 <push>
 8009268:	f7ff fe71 	bl	8008f4e <do_literal>
 800926c:	bd08      	pop	{r3, pc}

0800926e <do_c_quote>:
	(  -- c-addr)
	Return 'c-addr', a counted string consisting of the
	characters 'ccc'. A program shall not alter the returned
	string.
*******************************************************************************/
{
 800926e:	b570      	push	{r4, r5, r6, lr}
uint8_t * s; cell len; do_ahead(); push('"'); do_parse(); s = here.chr; * s = len = pop(); xmemcpy(s + 1, (void *) pop(), len);
 8009270:	f7ff fcfa 	bl	8008c68 <do_ahead>
 8009274:	2022      	movs	r0, #34	; 0x22
 8009276:	f7ff fbdb 	bl	8008a30 <push>
 800927a:	f7ff ff04 	bl	8009086 <do_parse>
 800927e:	4e0d      	ldr	r6, [pc, #52]	; (80092b4 <do_c_quote+0x46>)
 8009280:	68b5      	ldr	r5, [r6, #8]
 8009282:	f7ff fd23 	bl	8008ccc <pop>
 8009286:	1c04      	adds	r4, r0, #0
 8009288:	7028      	strb	r0, [r5, #0]
 800928a:	f7ff fd1f 	bl	8008ccc <pop>
 800928e:	1c22      	adds	r2, r4, #0
	here.chr += len + 1; do_align(); do_then(); push((cell) s); do_literal();
 8009290:	3401      	adds	r4, #1
	Return 'c-addr', a counted string consisting of the
	characters 'ccc'. A program shall not alter the returned
	string.
*******************************************************************************/
{
uint8_t * s; cell len; do_ahead(); push('"'); do_parse(); s = here.chr; * s = len = pop(); xmemcpy(s + 1, (void *) pop(), len);
 8009292:	1c01      	adds	r1, r0, #0
	here.chr += len + 1; do_align(); do_then(); push((cell) s); do_literal();
 8009294:	192c      	adds	r4, r5, r4
	Return 'c-addr', a counted string consisting of the
	characters 'ccc'. A program shall not alter the returned
	string.
*******************************************************************************/
{
uint8_t * s; cell len; do_ahead(); push('"'); do_parse(); s = here.chr; * s = len = pop(); xmemcpy(s + 1, (void *) pop(), len);
 8009296:	1c68      	adds	r0, r5, #1
 8009298:	f7ff fb53 	bl	8008942 <xmemcpy>
	here.chr += len + 1; do_align(); do_then(); push((cell) s); do_literal();
 800929c:	60b4      	str	r4, [r6, #8]
 800929e:	f7ff fa7d 	bl	800879c <do_align>
 80092a2:	f7ff fe7f 	bl	8008fa4 <do_then>
 80092a6:	1c28      	adds	r0, r5, #0
 80092a8:	f7ff fbc2 	bl	8008a30 <push>
 80092ac:	f7ff fe4f 	bl	8008f4e <do_literal>
}
 80092b0:	bd70      	pop	{r4, r5, r6, pc}
 80092b2:	46c0      	nop			; (mov r8, r8)
 80092b4:	200011e4 	.word	0x200011e4

080092b8 <do_restore_input>:
	described by 'x_1' through 'x_n'. 'flag' is
	true if the input source specification cannot be so restored.
	An ambiguous condition exists if the input source represented
	by the arguments is not the same as the current input source.
*******************************************************************************/
{
 80092b8:	b510      	push	{r4, lr}
	input_spec.source_id = pop();
 80092ba:	f7ff fd07 	bl	8008ccc <pop>
 80092be:	4c09      	ldr	r4, [pc, #36]	; (80092e4 <do_restore_input+0x2c>)
 80092c0:	6220      	str	r0, [r4, #32]
	input_spec.idx = pop();
 80092c2:	f7ff fd03 	bl	8008ccc <pop>
 80092c6:	6260      	str	r0, [r4, #36]	; 0x24
	input_spec.len = pop();
 80092c8:	f7ff fd00 	bl	8008ccc <pop>
 80092cc:	62a0      	str	r0, [r4, #40]	; 0x28
	input_spec.buf = (uint8_t *) pop();
 80092ce:	f7ff fcfd 	bl	8008ccc <pop>
	 *		(which itself can be used from various sources - e.g.
	 *		the 'user input device' (whatever that is), files, etc.),
	 *		perform this simple hack: if when all of the input specification
	 *		data fields are restored, if the input source is not a string,
	 *		set the input buffer to the 'inbuf_area' */
	if (input_spec.source_id != SOURCE_ID_STRING)
 80092d2:	6a23      	ldr	r3, [r4, #32]
*******************************************************************************/
{
	input_spec.source_id = pop();
	input_spec.idx = pop();
	input_spec.len = pop();
	input_spec.buf = (uint8_t *) pop();
 80092d4:	62e0      	str	r0, [r4, #44]	; 0x2c
	 *		(which itself can be used from various sources - e.g.
	 *		the 'user input device' (whatever that is), files, etc.),
	 *		perform this simple hack: if when all of the input specification
	 *		data fields are restored, if the input source is not a string,
	 *		set the input buffer to the 'inbuf_area' */
	if (input_spec.source_id != SOURCE_ID_STRING)
 80092d6:	3301      	adds	r3, #1
 80092d8:	d002      	beq.n	80092e0 <do_restore_input+0x28>
		input_spec.buf = inbuf_area;
 80092da:	1c23      	adds	r3, r4, #0
 80092dc:	3330      	adds	r3, #48	; 0x30
 80092de:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 80092e0:	bd10      	pop	{r4, pc}
 80092e2:	46c0      	nop			; (mov r8, r8)
 80092e4:	20001264 	.word	0x20001264

080092e8 <do_within>:
	 'n_1|u_1' <  'n_3|u_3')) is true, returning
	\emph{false} otherwise. An ambiguous condition exists
	'n_1|u_1', 'n_2|u_2', and 'n_3|u_3' are not
	all the same type.
*******************************************************************************/
{
 80092e8:	b538      	push	{r3, r4, r5, lr}
cell u1, u2, u3;
	u3 = pop(), u2 = pop(), u1 = pop();
 80092ea:	f7ff fcef 	bl	8008ccc <pop>
 80092ee:	1c04      	adds	r4, r0, #0
 80092f0:	f7ff fcec 	bl	8008ccc <pop>
 80092f4:	1c05      	adds	r5, r0, #0
 80092f6:	f7ff fce9 	bl	8008ccc <pop>
	if ((u2 < u3 && u2 <= u1 && u1 < u3)
 80092fa:	42a5      	cmp	r5, r4
 80092fc:	d204      	bcs.n	8009308 <do_within+0x20>
 80092fe:	4285      	cmp	r5, r0
 8009300:	d80b      	bhi.n	800931a <do_within+0x32>
 8009302:	42a0      	cmp	r0, r4
 8009304:	d20f      	bcs.n	8009326 <do_within+0x3e>
 8009306:	e005      	b.n	8009314 <do_within+0x2c>
		|| (u2 > u3 && (u2 <= u1 || u1 < u3)))
 8009308:	42a5      	cmp	r5, r4
 800930a:	d908      	bls.n	800931e <do_within+0x36>
 800930c:	4285      	cmp	r5, r0
 800930e:	d901      	bls.n	8009314 <do_within+0x2c>
 8009310:	42a0      	cmp	r0, r4
 8009312:	d204      	bcs.n	800931e <do_within+0x36>
		push(C_TRUE);
 8009314:	2001      	movs	r0, #1
 8009316:	4240      	negs	r0, r0
 8009318:	e002      	b.n	8009320 <do_within+0x38>
*******************************************************************************/
{
cell u1, u2, u3;
	u3 = pop(), u2 = pop(), u1 = pop();
	if ((u2 < u3 && u2 <= u1 && u1 < u3)
		|| (u2 > u3 && (u2 <= u1 || u1 < u3)))
 800931a:	42a5      	cmp	r5, r4
 800931c:	d8f8      	bhi.n	8009310 <do_within+0x28>
		push(C_TRUE);
	else
		push(C_FALSE);
 800931e:	2000      	movs	r0, #0
 8009320:	f7ff fb86 	bl	8008a30 <push>
}
 8009324:	bd38      	pop	{r3, r4, r5, pc}
*******************************************************************************/
{
cell u1, u2, u3;
	u3 = pop(), u2 = pop(), u1 = pop();
	if ((u2 < u3 && u2 <= u1 && u1 < u3)
		|| (u2 > u3 && (u2 <= u1 || u1 < u3)))
 8009326:	42a5      	cmp	r5, r4
 8009328:	d8f4      	bhi.n	8009314 <do_within+0x2c>
 800932a:	e7f8      	b.n	800931e <do_within+0x36>

0800932c <do_to_name>:
			push(dstack[i]), do_dot();
		do_cr();
	}
}
void /* ">name" */		do_to_name(void)
{
 800932c:	b508      	push	{r3, lr}
	push((cell)((struct word *)pop())->name);
 800932e:	f7ff fccd 	bl	8008ccc <pop>
 8009332:	6840      	ldr	r0, [r0, #4]
 8009334:	f7ff fb7c 	bl	8008a30 <push>
}
 8009338:	bd08      	pop	{r3, pc}

0800933a <top>:
static inline void pushd(dcell x) { if (sp > DSTACK_SIZE - 2) sabort("data stack overflow"); dstack[sp ++] = (cell) x; dstack[sp ++] = (cell) (x >> CELL_NR_BITS); }
static inline void spushd(sdcell x) { pushd((dcell) x); }
static inline void rpush(cell x) { if (rsp == RSTACK_SIZE) sabort("return stack overflow"); rstack[rsp ++] = x; }

/* top routines */
static inline cell top(void) { if (!sp) sabort("data stack empty"); return dstack[sp - 1]; }
 800933a:	b508      	push	{r3, lr}
 800933c:	4b07      	ldr	r3, [pc, #28]	; (800935c <top+0x22>)
 800933e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009340:	2b00      	cmp	r3, #0
 8009342:	d104      	bne.n	800934e <top+0x14>
 8009344:	4806      	ldr	r0, [pc, #24]	; (8009360 <top+0x26>)
 8009346:	4907      	ldr	r1, [pc, #28]	; (8009364 <top+0x2a>)
 8009348:	304c      	adds	r0, #76	; 0x4c
 800934a:	f7ff fb5e 	bl	8008a0a <strabort>
 800934e:	3b01      	subs	r3, #1
 8009350:	4a05      	ldr	r2, [pc, #20]	; (8009368 <top+0x2e>)
 8009352:	009b      	lsls	r3, r3, #2
 8009354:	18d3      	adds	r3, r2, r3
 8009356:	6958      	ldr	r0, [r3, #20]
 8009358:	bd08      	pop	{r3, pc}
 800935a:	46c0      	nop			; (mov r8, r8)
 800935c:	20001364 	.word	0x20001364
 8009360:	08013734 	.word	0x08013734
 8009364:	08014a19 	.word	0x08014a19
 8009368:	200017e4 	.word	0x200017e4

0800936c <do_question_dup>:
/*******************************************************************************
	?DUP	[question-dupe] 
( x -- 0 | x x)
	Duplicate 'x' if it is non-zero.
*******************************************************************************/
		{ cell x; if ((x = top())) push(x); }
 800936c:	b508      	push	{r3, lr}
 800936e:	f7ff ffe4 	bl	800933a <top>
 8009372:	2800      	cmp	r0, #0
 8009374:	d001      	beq.n	800937a <do_question_dup+0xe>
 8009376:	f7ff fb5b 	bl	8008a30 <push>
 800937a:	bd08      	pop	{r3, pc}

0800937c <popd>:
/* return and data stacks manipulation words */

/* pop routines */
static inline cell pop(void) { if (!sp) sabort("data stack underflow"); return dstack[-- sp]; }
static inline scell spop(void) { if (!sp) sabort("data stack underflow"); return (scell) dstack[-- sp]; }
static inline dcell popd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = (dcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
 800937c:	b510      	push	{r4, lr}
 800937e:	4c0a      	ldr	r4, [pc, #40]	; (80093a8 <popd+0x2c>)
 8009380:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009382:	2b01      	cmp	r3, #1
 8009384:	dc04      	bgt.n	8009390 <popd+0x14>
 8009386:	4809      	ldr	r0, [pc, #36]	; (80093ac <popd+0x30>)
 8009388:	4909      	ldr	r1, [pc, #36]	; (80093b0 <popd+0x34>)
 800938a:	3050      	adds	r0, #80	; 0x50
 800938c:	f7ff fb3d 	bl	8008a0a <strabort>
 8009390:	4808      	ldr	r0, [pc, #32]	; (80093b4 <popd+0x38>)
 8009392:	1e5a      	subs	r2, r3, #1
 8009394:	3b02      	subs	r3, #2
 8009396:	6363      	str	r3, [r4, #52]	; 0x34
 8009398:	0092      	lsls	r2, r2, #2
 800939a:	009b      	lsls	r3, r3, #2
 800939c:	1882      	adds	r2, r0, r2
 800939e:	18c3      	adds	r3, r0, r3
 80093a0:	6951      	ldr	r1, [r2, #20]
 80093a2:	6958      	ldr	r0, [r3, #20]
 80093a4:	bd10      	pop	{r4, pc}
 80093a6:	46c0      	nop			; (mov r8, r8)
 80093a8:	20001364 	.word	0x20001364
 80093ac:	08013734 	.word	0x08013734
 80093b0:	08014a04 	.word	0x08014a04
 80093b4:	200017e4 	.word	0x200017e4

080093b8 <do_store>:
/*******************************************************************************
	!	[store]
( x a-addr -- )
	Store 'x' at 'a-addr'.
*******************************************************************************/
		{ dcell x = popd(); *(cell *) ((cell)(x >> CELL_NR_BITS)) = (cell) x; }
 80093b8:	b508      	push	{r3, lr}
 80093ba:	f7ff ffdf 	bl	800937c <popd>
 80093be:	6008      	str	r0, [r1, #0]
 80093c0:	bd08      	pop	{r3, pc}

080093c2 <do_number_sign_greater>:
	Drop 'xd'. Make the pictured numeric output string
	available as a character string. 'c-addr' and 'u'
	specify the resulting character string. A program may replace
	characters within the string.
*******************************************************************************/
		{ popd(); push((cell)(pno.buf + pno.idx)); push(PNOBUF_SIZE - pno.idx); }
 80093c2:	b510      	push	{r4, lr}
 80093c4:	f7ff ffda 	bl	800937c <popd>
 80093c8:	4c05      	ldr	r4, [pc, #20]	; (80093e0 <do_number_sign_greater+0x1e>)
 80093ca:	68e3      	ldr	r3, [r4, #12]
 80093cc:	18e0      	adds	r0, r4, r3
 80093ce:	3010      	adds	r0, #16
 80093d0:	f7ff fb2e 	bl	8008a30 <push>
 80093d4:	2382      	movs	r3, #130	; 0x82
 80093d6:	68e0      	ldr	r0, [r4, #12]
 80093d8:	1a18      	subs	r0, r3, r0
 80093da:	f7ff fb29 	bl	8008a30 <push>
 80093de:	bd10      	pop	{r4, pc}
 80093e0:	200011e4 	.word	0x200011e4

080093e4 <do_star>:
	*	[star] 
( n_1|u_1 n_2|u_2 -- n_3|u_3)
	Multiply 'n_1|u_1' by 'n_2|u_2' giving the product
	'n_3|u_3'.
*******************************************************************************/
		{ dcell x = popd(); push((cell)((cell)(x >> CELL_NR_BITS) * (cell)x)); }
 80093e4:	b508      	push	{r3, lr}
 80093e6:	f7ff ffc9 	bl	800937c <popd>
 80093ea:	4348      	muls	r0, r1
 80093ec:	f7ff fb20 	bl	8008a30 <push>
 80093f0:	bd08      	pop	{r3, pc}

080093f2 <do_plus>:
	+	[plus] 
( n_1|u_1 n_2|u_2 -- n_3|u_3)
	Add 'n_2|u_2' to 'n_1|u_1', giving the sum
	'n_3|u_3'.
*******************************************************************************/
		{ dcell x = popd(); push(((cell) (x >> CELL_NR_BITS)) + ((cell) x)); }
 80093f2:	b508      	push	{r3, lr}
 80093f4:	f7ff ffc2 	bl	800937c <popd>
 80093f8:	1808      	adds	r0, r1, r0
 80093fa:	f7ff fb19 	bl	8008a30 <push>
 80093fe:	bd08      	pop	{r3, pc}

08009400 <do_plus_store>:
/*******************************************************************************
	+!	[plus-store] 
( n|u a-addr -- )
	Add 'n|u' to the single-cell number at 'a-addr'.
*******************************************************************************/
		{ dcell x = popd(); * ((cell *) ((cell) (x >> CELL_NR_BITS))) += (cell) x; }
 8009400:	b508      	push	{r3, lr}
 8009402:	f7ff ffbb 	bl	800937c <popd>
 8009406:	680b      	ldr	r3, [r1, #0]
 8009408:	1818      	adds	r0, r3, r0
 800940a:	6008      	str	r0, [r1, #0]
 800940c:	bd08      	pop	{r3, pc}

0800940e <do_minus>:
	-	[minus] 
( n_1|u_1 n_2|u_2 -- n_3|u_3)
	Subtract 'n_2|u_2' from 'n_1|u_1', giving the
	difference 'n_3|u_3'.
*******************************************************************************/
		{ dcell x = popd(); push((cell) x - (cell)(x >> CELL_NR_BITS)); }
 800940e:	b508      	push	{r3, lr}
 8009410:	f7ff ffb4 	bl	800937c <popd>
 8009414:	1a40      	subs	r0, r0, r1
 8009416:	f7ff fb0b 	bl	8008a30 <push>
 800941a:	bd08      	pop	{r3, pc}

0800941c <do_unused>:
	UNUSED	 
(  -- u)
	'u' is the amount of space remaining in the region addressed
	by 'HERE', in address units.
*******************************************************************************/
		{ push(SFORTH_CORE_SIZE_IN_CELLS); do_cells(); push((cell) core); push((cell) here.cell); do_minus(); do_plus(); }
 800941c:	2080      	movs	r0, #128	; 0x80
 800941e:	b508      	push	{r3, lr}
 8009420:	0040      	lsls	r0, r0, #1
 8009422:	f7ff fb05 	bl	8008a30 <push>
 8009426:	f7ff fceb 	bl	8008e00 <do_cells>
 800942a:	4806      	ldr	r0, [pc, #24]	; (8009444 <do_unused+0x28>)
 800942c:	3038      	adds	r0, #56	; 0x38
 800942e:	f7ff faff 	bl	8008a30 <push>
 8009432:	4b05      	ldr	r3, [pc, #20]	; (8009448 <do_unused+0x2c>)
 8009434:	6898      	ldr	r0, [r3, #8]
 8009436:	f7ff fafb 	bl	8008a30 <push>
 800943a:	f7ff ffe8 	bl	800940e <do_minus>
 800943e:	f7ff ffd8 	bl	80093f2 <do_plus>
 8009442:	bd08      	pop	{r3, pc}
 8009444:	20001364 	.word	0x20001364
 8009448:	200011e4 	.word	0x200011e4

0800944c <do_two_drop>:
/*******************************************************************************
	2DROP	[two-drop] 
( x_1 x_2 -- )
	Drop cell pair 'x_1 x_2' from the stack.
*******************************************************************************/
		{ popd(); }
 800944c:	b508      	push	{r3, lr}
 800944e:	f7ff ff95 	bl	800937c <popd>
 8009452:	bd08      	pop	{r3, pc}

08009454 <do_less_than>:
	<	[less-than] 
( n_1 n_2 -- flag)
	'flag' is true if and only if 'n_1' is less than
	'n_2'.
*******************************************************************************/
		{ dcell x = popd(); push(((scell)(cell) x < (scell)(cell)(x >> CELL_NR_BITS)) ? C_TRUE : C_FALSE); }
 8009454:	b508      	push	{r3, lr}
 8009456:	f7ff ff91 	bl	800937c <popd>
 800945a:	2301      	movs	r3, #1
 800945c:	4288      	cmp	r0, r1
 800945e:	db00      	blt.n	8009462 <do_less_than+0xe>
 8009460:	2300      	movs	r3, #0
 8009462:	4258      	negs	r0, r3
 8009464:	f7ff fae4 	bl	8008a30 <push>
 8009468:	bd08      	pop	{r3, pc}

0800946a <do_equals>:
	=	[equals] 
( x_1 x_2 -- flag)
	'flag' is true if and only if 'x_1' is bit-for-bit
	the same as 'x_2'.
*******************************************************************************/
		{ dcell x = popd(); push(((cell)(x >> CELL_NR_BITS) == (cell) x) ? C_TRUE : C_FALSE); }
 800946a:	b508      	push	{r3, lr}
 800946c:	f7ff ff86 	bl	800937c <popd>
 8009470:	1a08      	subs	r0, r1, r0
 8009472:	4241      	negs	r1, r0
 8009474:	4148      	adcs	r0, r1
 8009476:	4240      	negs	r0, r0
 8009478:	f7ff fada 	bl	8008a30 <push>
 800947c:	bd08      	pop	{r3, pc}

0800947e <do_greater_than>:
/*******************************************************************************
	>	[greater-than] 
( n_1 n_2 -- flag)
	'flag' is true if and only if 'n_1' is greater than 'n_2'.
*******************************************************************************/
		{ dcell x = popd(); push(((scell)(cell) x > (scell)(cell)(x >> CELL_NR_BITS)) ? C_TRUE : C_FALSE); }
 800947e:	b508      	push	{r3, lr}
 8009480:	f7ff ff7c 	bl	800937c <popd>
 8009484:	2301      	movs	r3, #1
 8009486:	4288      	cmp	r0, r1
 8009488:	dc00      	bgt.n	800948c <do_greater_than+0xe>
 800948a:	2300      	movs	r3, #0
 800948c:	4258      	negs	r0, r3
 800948e:	f7ff facf 	bl	8008a30 <push>
 8009492:	bd08      	pop	{r3, pc}

08009494 <do_and>:
	AND	 
( x_1 x_2 -- x_3)
	'x_3' is the bit-by-bit logical ``and'' of 'x_1'
	with 'x_2'.
*******************************************************************************/
		{ dcell x = popd(); push((cell)(x >> CELL_NR_BITS) & (cell) x); }
 8009494:	b508      	push	{r3, lr}
 8009496:	f7ff ff71 	bl	800937c <popd>
 800949a:	4008      	ands	r0, r1
 800949c:	f7ff fac8 	bl	8008a30 <push>
 80094a0:	bd08      	pop	{r3, pc}

080094a2 <do_c_store>:
( char c-addr -- )
	Store 'char' at 'c-addr'. When character size is smaller
	than cell size, only the number of low-order bits corresponding to
	character size are transferred.
*******************************************************************************/
		{ dcell x = popd(); *(uint8_t *) ((cell)(x >> CELL_NR_BITS)) = (uint8_t) x; }
 80094a2:	b508      	push	{r3, lr}
 80094a4:	f7ff ff6a 	bl	800937c <popd>
 80094a8:	7008      	strb	r0, [r1, #0]
 80094aa:	bd08      	pop	{r3, pc}

080094ac <do_lshift>:
	'x_1', giving 'x_2'. Put zeroes into the least
	significant bits vacated by the shift. An ambiguous condition
	exists if 'u' is greater than or equal to the number of
	bits in a cell.
*******************************************************************************/
		{ dcell t = popd(); cell x, y; x = (cell) t; y = (cell)(t >> CELL_NR_BITS); push(x << y); }
 80094ac:	b508      	push	{r3, lr}
 80094ae:	f7ff ff65 	bl	800937c <popd>
 80094b2:	4088      	lsls	r0, r1
 80094b4:	f7ff fabc 	bl	8008a30 <push>
 80094b8:	bd08      	pop	{r3, pc}

080094ba <do_or>:
	OR	 
( x_1 x_2 -- x_3)
	'x_3' is the bit-by-bit inclusive-or of 'x_1' with
	'x_2'.
*******************************************************************************/
		{ dcell x = popd(); push((cell)(x >> CELL_NR_BITS) | (cell) x); }
 80094ba:	b508      	push	{r3, lr}
 80094bc:	f7ff ff5e 	bl	800937c <popd>
 80094c0:	4308      	orrs	r0, r1
 80094c2:	f7ff fab5 	bl	8008a30 <push>
 80094c6:	bd08      	pop	{r3, pc}

080094c8 <do_rshift>:
	'x_1', giving 'x_2'. Put zeroes into the most
	significant bits vacated by the shift. An ambiguous condition
	exists if 'u' is greater than or equal to the number of
	bits in a cell.
*******************************************************************************/
		{ dcell t = popd(); cell x, y; x = (cell) t; y = (cell)(t >> CELL_NR_BITS); push(x >> y); }
 80094c8:	b508      	push	{r3, lr}
 80094ca:	f7ff ff57 	bl	800937c <popd>
 80094ce:	40c8      	lsrs	r0, r1
 80094d0:	f7ff faae 	bl	8008a30 <push>
 80094d4:	bd08      	pop	{r3, pc}

080094d6 <do_u_less_than>:
	U<	[u-less-than] 
( u_1 u_2 -- flag)
	'flag' is true if and only if 'u_1' is less than
	'u_2'.
*******************************************************************************/
		{ dcell x = popd(); push(((cell) x < (cell)(x >> CELL_NR_BITS)) ? C_TRUE : C_FALSE); }
 80094d6:	b508      	push	{r3, lr}
 80094d8:	f7ff ff50 	bl	800937c <popd>
 80094dc:	4288      	cmp	r0, r1
 80094de:	4180      	sbcs	r0, r0
 80094e0:	f7ff faa6 	bl	8008a30 <push>
 80094e4:	bd08      	pop	{r3, pc}

080094e6 <do_u_m_slash_mod>:
	and the remainder 'u_2'. All values and arithmetic are
	unsigned. An ambiguous condition exists if 'u_1' is zero or
	if the quotient lies outside the range of a single-cell unsigned
	integer.
*******************************************************************************/
		{ dcell ud; cell u1 = pop(), q, r; ud = popd(); q = ud / u1; r = ud % u1; push(r); push(q); }
 80094e6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80094e8:	f7ff fbf0 	bl	8008ccc <pop>
 80094ec:	2400      	movs	r4, #0
 80094ee:	1c05      	adds	r5, r0, #0
 80094f0:	f7ff ff44 	bl	800937c <popd>
 80094f4:	1c2a      	adds	r2, r5, #0
 80094f6:	1c23      	adds	r3, r4, #0
 80094f8:	1c06      	adds	r6, r0, #0
 80094fa:	1c0f      	adds	r7, r1, #0
 80094fc:	f005 fbfa 	bl	800ecf4 <__aeabi_uldivmod>
 8009500:	1c10      	adds	r0, r2, #0
 8009502:	f7ff fa95 	bl	8008a30 <push>
 8009506:	1c2a      	adds	r2, r5, #0
 8009508:	1c30      	adds	r0, r6, #0
 800950a:	1c39      	adds	r1, r7, #0
 800950c:	1c23      	adds	r3, r4, #0
 800950e:	f005 fbf1 	bl	800ecf4 <__aeabi_uldivmod>
 8009512:	f7ff fa8d 	bl	8008a30 <push>
 8009516:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08009518 <do_xor>:
	XOR	[x-or] 
( x_1 x_2 -- x_3)
	'x_3' is the bit-by-bit exclusive-or of 'x_1' with
	'x_2'.
*******************************************************************************/
		{ dcell res = popd(); push((res >> CELL_NR_BITS) ^ (res & (cell) -1)); }
 8009518:	b508      	push	{r3, lr}
 800951a:	f7ff ff2f 	bl	800937c <popd>
 800951e:	4048      	eors	r0, r1
 8009520:	f7ff fa86 	bl	8008a30 <push>
 8009524:	bd08      	pop	{r3, pc}

08009526 <do_not_equals>:
	<>	[not-equals] 
( x_1 x_2 -- flag)
	'flag' is true if and only if 'x_1' is not bit-for-bit
	the same as 'x_2'.
*******************************************************************************/
		{ dcell x = popd(); push(((cell) x != (cell)(x >> CELL_NR_BITS)) ? C_TRUE : C_FALSE); }
 8009526:	b508      	push	{r3, lr}
 8009528:	f7ff ff28 	bl	800937c <popd>
 800952c:	1a40      	subs	r0, r0, r1
 800952e:	1e41      	subs	r1, r0, #1
 8009530:	4188      	sbcs	r0, r1
 8009532:	4240      	negs	r0, r0
 8009534:	f7ff fa7c 	bl	8008a30 <push>
 8009538:	bd08      	pop	{r3, pc}

0800953a <do_u_greater_than>:
	U>	[u-greater-than] 
( u_1 u_2 -- flag)
	'flag' is true if and only if 'u_1' is greater than
	'u_2'.
*******************************************************************************/
		{ dcell x = popd(); push(((cell) x > (cell)(x >> CELL_NR_BITS)) ? C_TRUE : C_FALSE); }
 800953a:	b508      	push	{r3, lr}
 800953c:	f7ff ff1e 	bl	800937c <popd>
 8009540:	4281      	cmp	r1, r0
 8009542:	4180      	sbcs	r0, r0
 8009544:	f7ff fa74 	bl	8008a30 <push>
 8009548:	bd08      	pop	{r3, pc}

0800954a <pushd>:
static inline cell rpop(void) { if (!rsp) sabort("return stack underflow"); return rstack[-- rsp]; }

/* push routines */
static inline void push(cell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = x; }
static inline void spush(scell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = (cell) x; }
static inline void pushd(dcell x) { if (sp > DSTACK_SIZE - 2) sabort("data stack overflow"); dstack[sp ++] = (cell) x; dstack[sp ++] = (cell) (x >> CELL_NR_BITS); }
 800954a:	b538      	push	{r3, r4, r5, lr}
 800954c:	4d09      	ldr	r5, [pc, #36]	; (8009574 <pushd+0x2a>)
 800954e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8009550:	2b1e      	cmp	r3, #30
 8009552:	dd04      	ble.n	800955e <pushd+0x14>
 8009554:	4808      	ldr	r0, [pc, #32]	; (8009578 <pushd+0x2e>)
 8009556:	4909      	ldr	r1, [pc, #36]	; (800957c <pushd+0x32>)
 8009558:	3055      	adds	r0, #85	; 0x55
 800955a:	f7ff fa56 	bl	8008a0a <strabort>
 800955e:	4c08      	ldr	r4, [pc, #32]	; (8009580 <pushd+0x36>)
 8009560:	009a      	lsls	r2, r3, #2
 8009562:	18a2      	adds	r2, r4, r2
 8009564:	6150      	str	r0, [r2, #20]
 8009566:	1c9a      	adds	r2, r3, #2
 8009568:	3301      	adds	r3, #1
 800956a:	009b      	lsls	r3, r3, #2
 800956c:	18e3      	adds	r3, r4, r3
 800956e:	636a      	str	r2, [r5, #52]	; 0x34
 8009570:	6159      	str	r1, [r3, #20]
 8009572:	bd38      	pop	{r3, r4, r5, pc}
 8009574:	20001364 	.word	0x20001364
 8009578:	08013734 	.word	0x08013734
 800957c:	080149f0 	.word	0x080149f0
 8009580:	200017e4 	.word	0x200017e4

08009584 <do_two_swap>:
/*******************************************************************************
	2SWAP	[two-swap] 
( x_1 x_2 x_3 x_4 -- x_3 x_4 x_1 x_2)
	Exchange the top two cell pairs.
*******************************************************************************/
		{ dcell x = popd(), y = popd(); pushd(x); pushd(y); }
 8009584:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009586:	f7ff fef9 	bl	800937c <popd>
 800958a:	1c0d      	adds	r5, r1, #0
 800958c:	1c04      	adds	r4, r0, #0
 800958e:	f7ff fef5 	bl	800937c <popd>
 8009592:	1c06      	adds	r6, r0, #0
 8009594:	1c0f      	adds	r7, r1, #0
 8009596:	1c20      	adds	r0, r4, #0
 8009598:	1c29      	adds	r1, r5, #0
 800959a:	f7ff ffd6 	bl	800954a <pushd>
 800959e:	1c30      	adds	r0, r6, #0
 80095a0:	1c39      	adds	r1, r7, #0
 80095a2:	f7ff ffd2 	bl	800954a <pushd>
 80095a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080095a8 <do_to_number>:
	or the first character past the end of the string if the string was
	entirely converted. 'u_2' is the number of unconverted
	characters in the string. An ambiguous condition exists if
	'ud_2' overflows during the conversion.
*******************************************************************************/
{
 80095a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80095aa:	b087      	sub	sp, #28
	dcell res; bool sign = false; cell i = pop(); uint8_t c, * s = (uint8_t *) pop();
 80095ac:	f7ff fb8e 	bl	8008ccc <pop>
 80095b0:	1c04      	adds	r4, r0, #0
 80095b2:	f7ff fb8b 	bl	8008ccc <pop>
 80095b6:	1c05      	adds	r5, r0, #0
	res = popd();
 80095b8:	f7ff fee0 	bl	800937c <popd>
	cell saved_base = base;
 80095bc:	4b36      	ldr	r3, [pc, #216]	; (8009698 <do_to_number+0xf0>)
	characters in the string. An ambiguous condition exists if
	'ud_2' overflows during the conversion.
*******************************************************************************/
{
	dcell res; bool sign = false; cell i = pop(); uint8_t c, * s = (uint8_t *) pop();
	res = popd();
 80095be:	9000      	str	r0, [sp, #0]
 80095c0:	9101      	str	r1, [sp, #4]
	cell saved_base = base;
 80095c2:	695a      	ldr	r2, [r3, #20]
 80095c4:	9205      	str	r2, [sp, #20]
	/* handle numeric base selection symbols */
	if (i) switch (*s)
 80095c6:	2c00      	cmp	r4, #0
 80095c8:	d057      	beq.n	800967a <do_to_number+0xd2>
 80095ca:	782a      	ldrb	r2, [r5, #0]
 80095cc:	2a24      	cmp	r2, #36	; 0x24
 80095ce:	d005      	beq.n	80095dc <do_to_number+0x34>
 80095d0:	2a25      	cmp	r2, #37	; 0x25
 80095d2:	d005      	beq.n	80095e0 <do_to_number+0x38>
 80095d4:	2a23      	cmp	r2, #35	; 0x23
 80095d6:	d109      	bne.n	80095ec <do_to_number+0x44>
	{
		case '#': base = 10; if (0)
 80095d8:	3a19      	subs	r2, #25
 80095da:	e002      	b.n	80095e2 <do_to_number+0x3a>
		case '$': base = 16; if (0)
 80095dc:	2210      	movs	r2, #16
 80095de:	e000      	b.n	80095e2 <do_to_number+0x3a>
		case '%': base = 2;
 80095e0:	2202      	movs	r2, #2
			  s ++, i --;
 80095e2:	3c01      	subs	r4, #1
	/* handle numeric base selection symbols */
	if (i) switch (*s)
	{
		case '#': base = 10; if (0)
		case '$': base = 16; if (0)
		case '%': base = 2;
 80095e4:	615a      	str	r2, [r3, #20]
			  s ++, i --;
 80095e6:	3501      	adds	r5, #1
	}
	if (i && MIN_BASE <= base && base <= MAX_BASE)
 80095e8:	2c00      	cmp	r4, #0
 80095ea:	d046      	beq.n	800967a <do_to_number+0xd2>
 80095ec:	695b      	ldr	r3, [r3, #20]
 80095ee:	9304      	str	r3, [sp, #16]
 80095f0:	3b02      	subs	r3, #2
 80095f2:	2b22      	cmp	r3, #34	; 0x22
 80095f4:	d841      	bhi.n	800967a <do_to_number+0xd2>
	{
		/* handle sign */
		c = * s;
 80095f6:	782b      	ldrb	r3, [r5, #0]
		sign = (c == '-') ? true : false;
		if (c == '-' || c == '+')
 80095f8:	22fd      	movs	r2, #253	; 0xfd
 80095fa:	1c19      	adds	r1, r3, #0
	}
	if (i && MIN_BASE <= base && base <= MAX_BASE)
	{
		/* handle sign */
		c = * s;
		sign = (c == '-') ? true : false;
 80095fc:	2700      	movs	r7, #0
		if (c == '-' || c == '+')
 80095fe:	392b      	subs	r1, #43	; 0x2b
 8009600:	400a      	ands	r2, r1
 8009602:	42ba      	cmp	r2, r7
 8009604:	d10b      	bne.n	800961e <do_to_number+0x76>
			s ++, i --;
 8009606:	3c01      	subs	r4, #1
		if (!i)
 8009608:	42bc      	cmp	r4, r7
 800960a:	d006      	beq.n	800961a <do_to_number+0x72>
	}
	if (i && MIN_BASE <= base && base <= MAX_BASE)
	{
		/* handle sign */
		c = * s;
		sign = (c == '-') ? true : false;
 800960c:	3b2d      	subs	r3, #45	; 0x2d
 800960e:	1c1f      	adds	r7, r3, #0
 8009610:	427b      	negs	r3, r7
 8009612:	415f      	adcs	r7, r3
		if (c == '-' || c == '+')
			s ++, i --;
 8009614:	3501      	adds	r5, #1
	}
	if (i && MIN_BASE <= base && base <= MAX_BASE)
	{
		/* handle sign */
		c = * s;
		sign = (c == '-') ? true : false;
 8009616:	b2ff      	uxtb	r7, r7
 8009618:	e001      	b.n	800961e <do_to_number+0x76>
		if (c == '-' || c == '+')
			s ++, i --;
		if (!i)
			/* failure */
			s--, i ++, sign = false;
 800961a:	2401      	movs	r4, #1
 800961c:	1c17      	adds	r7, r2, #0
		while (i)
		{
			c = * s;
			c = xtolower(c);
 800961e:	7828      	ldrb	r0, [r5, #0]
 8009620:	f7ff f970 	bl	8008904 <xtolower>
 8009624:	b2c0      	uxtb	r0, r0
			if ('0' <= c && c <= '9')
 8009626:	1c06      	adds	r6, r0, #0
 8009628:	3e30      	subs	r6, #48	; 0x30
 800962a:	b2f6      	uxtb	r6, r6
 800962c:	2e09      	cmp	r6, #9
 800962e:	d905      	bls.n	800963c <do_to_number+0x94>
				c -= '0';
			else if ('a' <= c && c <= 'z')
 8009630:	1c03      	adds	r3, r0, #0
 8009632:	3b61      	subs	r3, #97	; 0x61
 8009634:	2b19      	cmp	r3, #25
 8009636:	d817      	bhi.n	8009668 <do_to_number+0xc0>
				c -= 'a' - 10;
 8009638:	3857      	subs	r0, #87	; 0x57
 800963a:	b2c6      	uxtb	r6, r0
			else
				/* cannot convert digit */
				break;
			if (c >= base)
 800963c:	9b04      	ldr	r3, [sp, #16]
 800963e:	429e      	cmp	r6, r3
 8009640:	d212      	bcs.n	8009668 <do_to_number+0xc0>
				/* failure */
				break;
			res *= base;
 8009642:	9800      	ldr	r0, [sp, #0]
 8009644:	9901      	ldr	r1, [sp, #4]
 8009646:	1c1a      	adds	r2, r3, #0
 8009648:	2300      	movs	r3, #0
 800964a:	f005 fb73 	bl	800ed34 <__aeabi_lmul>
			res += c;
 800964e:	2300      	movs	r3, #0
 8009650:	9602      	str	r6, [sp, #8]
 8009652:	9303      	str	r3, [sp, #12]
 8009654:	9a02      	ldr	r2, [sp, #8]
 8009656:	9b03      	ldr	r3, [sp, #12]
 8009658:	1812      	adds	r2, r2, r0
 800965a:	414b      	adcs	r3, r1
			s ++;
			i --;
 800965c:	3c01      	subs	r4, #1
				break;
			if (c >= base)
				/* failure */
				break;
			res *= base;
			res += c;
 800965e:	9200      	str	r2, [sp, #0]
 8009660:	9301      	str	r3, [sp, #4]
			s ++;
 8009662:	3501      	adds	r5, #1
		if (c == '-' || c == '+')
			s ++, i --;
		if (!i)
			/* failure */
			s--, i ++, sign = false;
		while (i)
 8009664:	2c00      	cmp	r4, #0
 8009666:	d1da      	bne.n	800961e <do_to_number+0x76>
			res += c;
			s ++;
			i --;
		}
	}
	if (sign)
 8009668:	2f00      	cmp	r7, #0
 800966a:	d006      	beq.n	800967a <do_to_number+0xd2>
		res = - res;
 800966c:	9800      	ldr	r0, [sp, #0]
 800966e:	9901      	ldr	r1, [sp, #4]
 8009670:	2300      	movs	r3, #0
 8009672:	4242      	negs	r2, r0
 8009674:	418b      	sbcs	r3, r1
 8009676:	9200      	str	r2, [sp, #0]
 8009678:	9301      	str	r3, [sp, #4]
	pushd(res), push((cell) s), push(i);
 800967a:	9800      	ldr	r0, [sp, #0]
 800967c:	9901      	ldr	r1, [sp, #4]
 800967e:	f7ff ff64 	bl	800954a <pushd>
 8009682:	1c28      	adds	r0, r5, #0
 8009684:	f7ff f9d4 	bl	8008a30 <push>
 8009688:	1c20      	adds	r0, r4, #0
 800968a:	f7ff f9d1 	bl	8008a30 <push>
	base = saved_base;
 800968e:	4b02      	ldr	r3, [pc, #8]	; (8009698 <do_to_number+0xf0>)
 8009690:	9a05      	ldr	r2, [sp, #20]
 8009692:	615a      	str	r2, [r3, #20]
}
 8009694:	b007      	add	sp, #28
 8009696:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009698:	20001264 	.word	0x20001264

0800969c <do_m_star>:
/*******************************************************************************
	M*	[m-star] 
( n_1 n_2 -- d)
	'd' is the signed product of 'n_1' times 'n_2'.
*******************************************************************************/
		{ dcell x = popd(); spushd((sdcell)(scell)(cell)(x >> CELL_NR_BITS) * (sdcell)(scell)(cell) x); }
 800969c:	b508      	push	{r3, lr}
 800969e:	f7ff fe6d 	bl	800937c <popd>
 80096a2:	1c02      	adds	r2, r0, #0
 80096a4:	1c08      	adds	r0, r1, #0
 80096a6:	17d3      	asrs	r3, r2, #31
 80096a8:	17c9      	asrs	r1, r1, #31
 80096aa:	f005 fb43 	bl	800ed34 <__aeabi_lmul>
static inline void spushd(sdcell x) { pushd((dcell) x); }
 80096ae:	f7ff ff4c 	bl	800954a <pushd>
 80096b2:	bd08      	pop	{r3, pc}

080096b4 <do_u_m_star>:
	UM*	[u-m-star] 
( u_1 u_2 -- ud)
	Multiply 'u_1' by 'u_2', giving the unsigned double-cell
	product 'ud'. All values and arithmetic are unsigned.
*******************************************************************************/
		{ dcell x = popd(); pushd((dcell)(cell)(x >> CELL_NR_BITS) * (dcell)(cell) x); }
 80096b4:	b508      	push	{r3, lr}
 80096b6:	f7ff fe61 	bl	800937c <popd>
 80096ba:	2300      	movs	r3, #0
 80096bc:	1c0a      	adds	r2, r1, #0
 80096be:	1c19      	adds	r1, r3, #0
 80096c0:	f005 fb38 	bl	800ed34 <__aeabi_lmul>
 80096c4:	f7ff ff41 	bl	800954a <pushd>
 80096c8:	bd08      	pop	{r3, pc}

080096ca <do_number_sign>:
	to external form and add the resulting character to the beginning
	of the pictured numeric output string. An ambiguous condition
	exists if 'num' executes outside of a 
	'num-start' 'num-end' delimited number conversion.
*******************************************************************************/
{
 80096ca:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
static const char digs[10 + 26] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
dcell x = popd(), q; cell r; if (!(MIN_BASE <= base && base <= MAX_BASE)) sabort("bad numeric base"); q = x / base, r = x % base; pushd(q); pno.buf[-- pno.idx] = digs[r]; }
 80096cc:	f7ff fe56 	bl	800937c <popd>
 80096d0:	4b11      	ldr	r3, [pc, #68]	; (8009718 <do_number_sign+0x4e>)
 80096d2:	1c06      	adds	r6, r0, #0
 80096d4:	695d      	ldr	r5, [r3, #20]
 80096d6:	1c0f      	adds	r7, r1, #0
 80096d8:	1eab      	subs	r3, r5, #2
 80096da:	4c10      	ldr	r4, [pc, #64]	; (800971c <do_number_sign+0x52>)
 80096dc:	2b22      	cmp	r3, #34	; 0x22
 80096de:	d904      	bls.n	80096ea <do_number_sign+0x20>
 80096e0:	1c20      	adds	r0, r4, #0
 80096e2:	490f      	ldr	r1, [pc, #60]	; (8009720 <do_number_sign+0x56>)
 80096e4:	305b      	adds	r0, #91	; 0x5b
 80096e6:	f7ff f990 	bl	8008a0a <strabort>
 80096ea:	1c2a      	adds	r2, r5, #0
 80096ec:	2300      	movs	r3, #0
 80096ee:	f005 fb01 	bl	800ecf4 <__aeabi_uldivmod>
 80096f2:	f7ff ff2a 	bl	800954a <pushd>
 80096f6:	4a0b      	ldr	r2, [pc, #44]	; (8009724 <do_number_sign+0x5a>)
 80096f8:	1c30      	adds	r0, r6, #0
 80096fa:	68d3      	ldr	r3, [r2, #12]
 80096fc:	1c39      	adds	r1, r7, #0
 80096fe:	3b01      	subs	r3, #1
 8009700:	60d3      	str	r3, [r2, #12]
 8009702:	18d3      	adds	r3, r2, r3
 8009704:	9301      	str	r3, [sp, #4]
 8009706:	1c2a      	adds	r2, r5, #0
 8009708:	2300      	movs	r3, #0
 800970a:	f005 faf3 	bl	800ecf4 <__aeabi_uldivmod>
 800970e:	346a      	adds	r4, #106	; 0x6a
 8009710:	5ca3      	ldrb	r3, [r4, r2]
 8009712:	9a01      	ldr	r2, [sp, #4]
 8009714:	7413      	strb	r3, [r2, #16]
 8009716:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009718:	20001264 	.word	0x20001264
 800971c:	08013734 	.word	0x08013734
 8009720:	08014a2a 	.word	0x08014a2a
 8009724:	200011e4 	.word	0x200011e4

08009728 <topd>:
static inline void rpush(cell x) { if (rsp == RSTACK_SIZE) sabort("return stack overflow"); rstack[rsp ++] = x; }

/* top routines */
static inline cell top(void) { if (!sp) sabort("data stack empty"); return dstack[sp - 1]; }
static inline dcell topd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = dstack[sp - 1]; res <<= CELL_NR_BITS; return res | dstack[sp - 2]; }
 8009728:	b508      	push	{r3, lr}
 800972a:	4b09      	ldr	r3, [pc, #36]	; (8009750 <topd+0x28>)
 800972c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800972e:	2b01      	cmp	r3, #1
 8009730:	dc04      	bgt.n	800973c <topd+0x14>
 8009732:	4808      	ldr	r0, [pc, #32]	; (8009754 <topd+0x2c>)
 8009734:	4908      	ldr	r1, [pc, #32]	; (8009758 <topd+0x30>)
 8009736:	300e      	adds	r0, #14
 8009738:	f7ff f967 	bl	8008a0a <strabort>
 800973c:	4807      	ldr	r0, [pc, #28]	; (800975c <topd+0x34>)
 800973e:	1e5a      	subs	r2, r3, #1
 8009740:	3b02      	subs	r3, #2
 8009742:	0092      	lsls	r2, r2, #2
 8009744:	009b      	lsls	r3, r3, #2
 8009746:	1882      	adds	r2, r0, r2
 8009748:	18c3      	adds	r3, r0, r3
 800974a:	6951      	ldr	r1, [r2, #20]
 800974c:	6958      	ldr	r0, [r3, #20]
 800974e:	bd08      	pop	{r3, pc}
 8009750:	20001364 	.word	0x20001364
 8009754:	080137b4 	.word	0x080137b4
 8009758:	08014a04 	.word	0x08014a04
 800975c:	200017e4 	.word	0x200017e4

08009760 <do_number_sign_s>:
	'num'. Continue conversion until the quotient is zero.
	'ud_2' is zero. An ambiguous condition exists if
	'numS' executes outside of a 'num-start' 'num-end'
	delimited number conversion.
*******************************************************************************/
		{ do do_number_sign(); while (topd()); }
 8009760:	b508      	push	{r3, lr}
 8009762:	f7ff ffb2 	bl	80096ca <do_number_sign>
 8009766:	f7ff ffdf 	bl	8009728 <topd>
 800976a:	4301      	orrs	r1, r0
 800976c:	d1f9      	bne.n	8009762 <do_number_sign_s+0x2>
 800976e:	bd08      	pop	{r3, pc}

08009770 <do_u_dot>:
/*******************************************************************************
	U.	[u-dot] 
( u -- )
	Display 'u' in free field format.
*******************************************************************************/
		{ push(0); do_less_number_sign(); do_number_sign_s(); do_number_sign_greater(); do_type(); do_space(); }
 8009770:	b508      	push	{r3, lr}
 8009772:	2000      	movs	r0, #0
 8009774:	f7ff f95c 	bl	8008a30 <push>
/*******************************************************************************
	<#	[less-number-sign] 
(  -- )
	Initialize the pictured numeric output conversion process.
*******************************************************************************/
		{ pno.idx = sizeof pno.buf; /* pno.buf[-- pno.idx] = ' '; */ }
 8009778:	2282      	movs	r2, #130	; 0x82
 800977a:	4b05      	ldr	r3, [pc, #20]	; (8009790 <do_u_dot+0x20>)
 800977c:	60da      	str	r2, [r3, #12]
/*******************************************************************************
	U.	[u-dot] 
( u -- )
	Display 'u' in free field format.
*******************************************************************************/
		{ push(0); do_less_number_sign(); do_number_sign_s(); do_number_sign_greater(); do_type(); do_space(); }
 800977e:	f7ff ffef 	bl	8009760 <do_number_sign_s>
 8009782:	f7ff fe1e 	bl	80093c2 <do_number_sign_greater>
 8009786:	f7ff fc2f 	bl	8008fe8 <do_type>
 800978a:	f7ff fb69 	bl	8008e60 <do_space>
 800978e:	bd08      	pop	{r3, pc}
 8009790:	200011e4 	.word	0x200011e4

08009794 <do_u_dot_r>:
	Display 'u' right aligned in a field 'n' characters
	wide. If the number of characters required to display 'u'
	is greater than 'n', all digits are displayed with no leading
	spaces in a field as wide as necessary.
*******************************************************************************/
		{ scell x = pop();
 8009794:	b510      	push	{r4, lr}
 8009796:	f7ff fa99 	bl	8008ccc <pop>
 800979a:	1c04      	adds	r4, r0, #0
		push(0); do_less_number_sign(); do_number_sign_s(); do_number_sign_greater();
 800979c:	2000      	movs	r0, #0
 800979e:	f7ff f947 	bl	8008a30 <push>
/*******************************************************************************
	<#	[less-number-sign] 
(  -- )
	Initialize the pictured numeric output conversion process.
*******************************************************************************/
		{ pno.idx = sizeof pno.buf; /* pno.buf[-- pno.idx] = ' '; */ }
 80097a2:	2282      	movs	r2, #130	; 0x82
 80097a4:	4b09      	ldr	r3, [pc, #36]	; (80097cc <do_u_dot_r+0x38>)
 80097a6:	60da      	str	r2, [r3, #12]
	wide. If the number of characters required to display 'u'
	is greater than 'n', all digits are displayed with no leading
	spaces in a field as wide as necessary.
*******************************************************************************/
		{ scell x = pop();
		push(0); do_less_number_sign(); do_number_sign_s(); do_number_sign_greater();
 80097a8:	f7ff ffda 	bl	8009760 <do_number_sign_s>
 80097ac:	f7ff fe09 	bl	80093c2 <do_number_sign_greater>
		x -= top(); if (x > 0) push(x), do_spaces();
 80097b0:	f7ff fdc3 	bl	800933a <top>
 80097b4:	1a20      	subs	r0, r4, r0
 80097b6:	2800      	cmp	r0, #0
 80097b8:	dd03      	ble.n	80097c2 <do_u_dot_r+0x2e>
 80097ba:	f7ff f939 	bl	8008a30 <push>
 80097be:	f7ff fbe6 	bl	8008f8e <do_spaces>
		do_type(); do_space(); }
 80097c2:	f7ff fc11 	bl	8008fe8 <do_type>
 80097c6:	f7ff fb4b 	bl	8008e60 <do_space>
 80097ca:	bd10      	pop	{r4, pc}
 80097cc:	200011e4 	.word	0x200011e4

080097d0 <do_two_dup>:
/*******************************************************************************
	2DUP	[two-dupe] 
( x_1 x_2 -- x_1 x_2 x_1 x_2)
	Duplicate cell pair 'x_1 x_2'.
*******************************************************************************/
		{ pushd(topd()); }
 80097d0:	b508      	push	{r3, lr}
 80097d2:	f7ff ffa9 	bl	8009728 <topd>
 80097d6:	f7ff feb8 	bl	800954a <pushd>
 80097da:	bd08      	pop	{r3, pc}

080097dc <do_dot_paren>:
\execute
	( "ccc<paren>" -- )
	Parse and display 'ccc' delimited by ")" (right
	parenthesis). '.p' is an immediate word.
*******************************************************************************/
{
 80097dc:	b510      	push	{r4, lr}
	while (1)
	{
		push(')');
 80097de:	2029      	movs	r0, #41	; 0x29
 80097e0:	f7ff f926 	bl	8008a30 <push>
		do_parse();
 80097e4:	f7ff fc4f 	bl	8009086 <do_parse>
		do_two_dup();
 80097e8:	f7ff fff2 	bl	80097d0 <do_two_dup>
		do_type();
 80097ec:	f7ff fbfc 	bl	8008fe8 <do_type>
		if (input_spec.source_id == SOURCE_ID_STRING)
 80097f0:	4c0e      	ldr	r4, [pc, #56]	; (800982c <do_dot_paren+0x50>)
 80097f2:	6a23      	ldr	r3, [r4, #32]
 80097f4:	3301      	adds	r3, #1
 80097f6:	d102      	bne.n	80097fe <do_dot_paren+0x22>
		{
			pop();
 80097f8:	f7ff fa68 	bl	8008ccc <pop>
			break;
 80097fc:	e013      	b.n	8009826 <do_dot_paren+0x4a>
		}
		else
		{
			/* input is a file or the user input device */
			pop();
 80097fe:	f7ff fa65 	bl	8008ccc <pop>
			if (input_spec.buf[input_spec.idx - 1] == ')')
 8009802:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8009804:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009806:	18d3      	adds	r3, r2, r3
 8009808:	3b01      	subs	r3, #1
 800980a:	781b      	ldrb	r3, [r3, #0]
 800980c:	2b29      	cmp	r3, #41	; 0x29
 800980e:	d00a      	beq.n	8009826 <do_dot_paren+0x4a>
				break;
			pop();
 8009810:	f7ff fa5c 	bl	8008ccc <pop>
			do_refill();
 8009814:	f7ff f9c0 	bl	8008b98 <do_refill>
			if (!top())
 8009818:	f7ff fd8f 	bl	800933a <top>
 800981c:	2800      	cmp	r0, #0
 800981e:	d002      	beq.n	8009826 <do_dot_paren+0x4a>
				/* refill failed */
				break;
			pop();
 8009820:	f7ff fa54 	bl	8008ccc <pop>
		}
	}
 8009824:	e7db      	b.n	80097de <do_dot_paren+0x2>
	pop();
 8009826:	f7ff fa51 	bl	8008ccc <pop>
}
 800982a:	bd10      	pop	{r4, pc}
 800982c:	20001264 	.word	0x20001264

08009830 <do_tick>:
	a space. Find 'name' and return 'xt', the execution
	token for 'name'. An ambiguous condition exists if
	'name' is not found. When interpreting,
	" ' xyz EXECUTE" is equivalent to " xyz".
*******************************************************************************/
		{ do_bl(); do_word(); do_find(); if (!pop()) sabort("word not found"); }
 8009830:	b508      	push	{r3, lr}
 8009832:	f7ff f94d 	bl	8008ad0 <do_bl>
 8009836:	f7ff fcb8 	bl	80091aa <do_word>
 800983a:	f7ff fb35 	bl	8008ea8 <do_find>
 800983e:	f7ff fa45 	bl	8008ccc <pop>
 8009842:	2800      	cmp	r0, #0
 8009844:	d104      	bne.n	8009850 <do_tick+0x20>
 8009846:	4803      	ldr	r0, [pc, #12]	; (8009854 <do_tick+0x24>)
 8009848:	4903      	ldr	r1, [pc, #12]	; (8009858 <do_tick+0x28>)
 800984a:	3013      	adds	r0, #19
 800984c:	f7ff f8dd 	bl	8008a0a <strabort>
 8009850:	bd08      	pop	{r3, pc}
 8009852:	46c0      	nop			; (mov r8, r8)
 8009854:	080137b4 	.word	0x080137b4
 8009858:	08014b78 	.word	0x08014b78

0800985c <do_bracket_tick>:
	Place 'name''s execution token 'xt' on the stack.
	The execution token returned by the compiled phrase
	" ['] X" is the same value returned by
	" ' X" outside of compilation state.
*******************************************************************************/
		{ do_tick(); do_literal(); }
 800985c:	b508      	push	{r3, lr}
 800985e:	f7ff ffe7 	bl	8009830 <do_tick>
 8009862:	f7ff fb74 	bl	8008f4e <do_literal>
 8009866:	bd08      	pop	{r3, pc}

08009868 <spop>:

/* return and data stacks manipulation words */

/* pop routines */
static inline cell pop(void) { if (!sp) sabort("data stack underflow"); return dstack[-- sp]; }
static inline scell spop(void) { if (!sp) sabort("data stack underflow"); return (scell) dstack[-- sp]; }
 8009868:	4a08      	ldr	r2, [pc, #32]	; (800988c <spop+0x24>)
 800986a:	b508      	push	{r3, lr}
 800986c:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800986e:	2b00      	cmp	r3, #0
 8009870:	d104      	bne.n	800987c <spop+0x14>
 8009872:	4807      	ldr	r0, [pc, #28]	; (8009890 <spop+0x28>)
 8009874:	4907      	ldr	r1, [pc, #28]	; (8009894 <spop+0x2c>)
 8009876:	301b      	adds	r0, #27
 8009878:	f7ff f8c7 	bl	8008a0a <strabort>
 800987c:	3b01      	subs	r3, #1
 800987e:	6353      	str	r3, [r2, #52]	; 0x34
 8009880:	4a05      	ldr	r2, [pc, #20]	; (8009898 <spop+0x30>)
 8009882:	009b      	lsls	r3, r3, #2
 8009884:	18d3      	adds	r3, r2, r3
 8009886:	6958      	ldr	r0, [r3, #20]
 8009888:	bd08      	pop	{r3, pc}
 800988a:	46c0      	nop			; (mov r8, r8)
 800988c:	20001364 	.word	0x20001364
 8009890:	080137b4 	.word	0x080137b4
 8009894:	08014a04 	.word	0x08014a04
 8009898:	200017e4 	.word	0x200017e4

0800989c <runtime_plus_loop>:
	latest->is_does_proper = 1;
	latest->cfa = (void(*)(void)) (IP.cell + 1);
	/* latest->is_smudged = 0; */
}
static void runtime_plus_loop(void)
{
 800989c:	b5f0      	push	{r4, r5, r6, r7, lr}
sdcell cnt, limit, i;

	cnt = ((scell *)rstack)[rsp - 1];
 800989e:	4c22      	ldr	r4, [pc, #136]	; (8009928 <runtime_plus_loop+0x8c>)
 80098a0:	4a22      	ldr	r2, [pc, #136]	; (800992c <runtime_plus_loop+0x90>)
 80098a2:	6b23      	ldr	r3, [r4, #48]	; 0x30
	latest->is_does_proper = 1;
	latest->cfa = (void(*)(void)) (IP.cell + 1);
	/* latest->is_smudged = 0; */
}
static void runtime_plus_loop(void)
{
 80098a4:	b087      	sub	sp, #28
sdcell cnt, limit, i;

	cnt = ((scell *)rstack)[rsp - 1];
 80098a6:	9305      	str	r3, [sp, #20]
 80098a8:	4e21      	ldr	r6, [pc, #132]	; (8009930 <runtime_plus_loop+0x94>)
 80098aa:	189b      	adds	r3, r3, r2
 80098ac:	009b      	lsls	r3, r3, #2
 80098ae:	18f3      	adds	r3, r6, r3
 80098b0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	limit = ((scell *)rstack)[rsp - 2];
 80098b2:	6a5f      	ldr	r7, [r3, #36]	; 0x24
}
static void runtime_plus_loop(void)
{
sdcell cnt, limit, i;

	cnt = ((scell *)rstack)[rsp - 1];
 80098b4:	9202      	str	r2, [sp, #8]
 80098b6:	17d2      	asrs	r2, r2, #31
 80098b8:	9203      	str	r2, [sp, #12]
	limit = ((scell *)rstack)[rsp - 2];
	i = cnt + spop();
 80098ba:	f7ff ffd5 	bl	8009868 <spop>
 80098be:	1c02      	adds	r2, r0, #0
 80098c0:	17c3      	asrs	r3, r0, #31
 80098c2:	9802      	ldr	r0, [sp, #8]
 80098c4:	9903      	ldr	r1, [sp, #12]
 80098c6:	1812      	adds	r2, r2, r0
 80098c8:	414b      	adcs	r3, r1
 80098ca:	9200      	str	r2, [sp, #0]
 80098cc:	9301      	str	r3, [sp, #4]
	if (cnt < limit)
 80098ce:	9b03      	ldr	r3, [sp, #12]
static void runtime_plus_loop(void)
{
sdcell cnt, limit, i;

	cnt = ((scell *)rstack)[rsp - 1];
	limit = ((scell *)rstack)[rsp - 2];
 80098d0:	17fd      	asrs	r5, r7, #31
 80098d2:	4818      	ldr	r0, [pc, #96]	; (8009934 <runtime_plus_loop+0x98>)
	i = cnt + spop();
	if (cnt < limit)
 80098d4:	429d      	cmp	r5, r3
 80098d6:	dc03      	bgt.n	80098e0 <runtime_plus_loop+0x44>
 80098d8:	d10e      	bne.n	80098f8 <runtime_plus_loop+0x5c>
 80098da:	9b02      	ldr	r3, [sp, #8]
 80098dc:	429f      	cmp	r7, r3
 80098de:	d90b      	bls.n	80098f8 <runtime_plus_loop+0x5c>
	{
		dstack[sp] = (i >= limit ? 1 : 0);
 80098e0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80098e2:	0099      	lsls	r1, r3, #2
 80098e4:	9b01      	ldr	r3, [sp, #4]
 80098e6:	1841      	adds	r1, r0, r1
 80098e8:	2001      	movs	r0, #1
 80098ea:	429d      	cmp	r5, r3
 80098ec:	dc0f      	bgt.n	800990e <runtime_plus_loop+0x72>
 80098ee:	d10f      	bne.n	8009910 <runtime_plus_loop+0x74>
 80098f0:	9b00      	ldr	r3, [sp, #0]
 80098f2:	429f      	cmp	r7, r3
 80098f4:	d90c      	bls.n	8009910 <runtime_plus_loop+0x74>
 80098f6:	e00a      	b.n	800990e <runtime_plus_loop+0x72>
	}
	else if (cnt >= limit)
	{
		dstack[sp] = (i < limit ? 1 : 0);
 80098f8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80098fa:	0099      	lsls	r1, r3, #2
 80098fc:	9b01      	ldr	r3, [sp, #4]
 80098fe:	1841      	adds	r1, r0, r1
 8009900:	2001      	movs	r0, #1
 8009902:	429d      	cmp	r5, r3
 8009904:	dc04      	bgt.n	8009910 <runtime_plus_loop+0x74>
 8009906:	d102      	bne.n	800990e <runtime_plus_loop+0x72>
 8009908:	9b00      	ldr	r3, [sp, #0]
 800990a:	429f      	cmp	r7, r3
 800990c:	d800      	bhi.n	8009910 <runtime_plus_loop+0x74>
 800990e:	2000      	movs	r0, #0
	}
	sp ++;
 8009910:	6b63      	ldr	r3, [r4, #52]	; 0x34
	{
		dstack[sp] = (i >= limit ? 1 : 0);
	}
	else if (cnt >= limit)
	{
		dstack[sp] = (i < limit ? 1 : 0);
 8009912:	6148      	str	r0, [r1, #20]
	}
	sp ++;
 8009914:	3301      	adds	r3, #1
 8009916:	6363      	str	r3, [r4, #52]	; 0x34
	rstack[rsp - 1] = i;
 8009918:	9b05      	ldr	r3, [sp, #20]
 800991a:	3b01      	subs	r3, #1
 800991c:	009b      	lsls	r3, r3, #2
 800991e:	18f6      	adds	r6, r6, r3
 8009920:	9b00      	ldr	r3, [sp, #0]
 8009922:	62b3      	str	r3, [r6, #40]	; 0x28
}
 8009924:	b007      	add	sp, #28
 8009926:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009928:	20001364 	.word	0x20001364
 800992c:	3fffffff 	.word	0x3fffffff
 8009930:	20001964 	.word	0x20001964
 8009934:	200017e4 	.word	0x200017e4

08009938 <do_zero_less>:
/*******************************************************************************
	0<	[zero-less] 
( n -- flag)
	'flag' is true if and only if 'n' is less than zero.
*******************************************************************************/
		{ push((spop() < 0) ? C_TRUE : C_FALSE); }
 8009938:	b508      	push	{r3, lr}
 800993a:	f7ff ff95 	bl	8009868 <spop>
 800993e:	17c0      	asrs	r0, r0, #31
 8009940:	f7ff f876 	bl	8008a30 <push>
 8009944:	bd08      	pop	{r3, pc}

08009946 <do_s_to_d>:
	S>D	[s-to-d] 
( n -- d)
	Convert the number 'n' to the double-cell number 'd'
	with the same numerical value.
*******************************************************************************/
		{ spushd((sdcell) spop()); }
 8009946:	b508      	push	{r3, lr}
 8009948:	f7ff ff8e 	bl	8009868 <spop>

/* push routines */
static inline void push(cell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = x; }
static inline void spush(scell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = (cell) x; }
static inline void pushd(dcell x) { if (sp > DSTACK_SIZE - 2) sabort("data stack overflow"); dstack[sp ++] = (cell) x; dstack[sp ++] = (cell) (x >> CELL_NR_BITS); }
static inline void spushd(sdcell x) { pushd((dcell) x); }
 800994c:	17c1      	asrs	r1, r0, #31
 800994e:	f7ff fdfc 	bl	800954a <pushd>
 8009952:	bd08      	pop	{r3, pc}

08009954 <do_sign>:
	If 'n' is negative, add a minus sign to the beginning of
	the pictured numeric output string. An ambiguous condition exists
	if 'SIGN' executes outside of a 'num-start' 'num-end'
	delimited number conversion.
*******************************************************************************/
		{ if (spop() < 0) pno.buf[-- pno.idx] = '-'; }
 8009954:	b508      	push	{r3, lr}
 8009956:	f7ff ff87 	bl	8009868 <spop>
 800995a:	2800      	cmp	r0, #0
 800995c:	da06      	bge.n	800996c <do_sign+0x18>
 800995e:	4a04      	ldr	r2, [pc, #16]	; (8009970 <do_sign+0x1c>)
 8009960:	68d3      	ldr	r3, [r2, #12]
 8009962:	3b01      	subs	r3, #1
 8009964:	60d3      	str	r3, [r2, #12]
 8009966:	18d3      	adds	r3, r2, r3
 8009968:	222d      	movs	r2, #45	; 0x2d
 800996a:	741a      	strb	r2, [r3, #16]
 800996c:	bd08      	pop	{r3, pc}
 800996e:	46c0      	nop			; (mov r8, r8)
 8009970:	200011e4 	.word	0x200011e4

08009974 <do_zero_greater>:
	0>	[zero-greater] 
( n -- flag)
	'flag' is true if and only if 'n' is greater than
	zero.
*******************************************************************************/
		{ push((spop() > 0) ? C_TRUE : C_FALSE); }
 8009974:	b508      	push	{r3, lr}
 8009976:	f7ff ff77 	bl	8009868 <spop>
 800997a:	17c3      	asrs	r3, r0, #31
 800997c:	1a18      	subs	r0, r3, r0
 800997e:	17c0      	asrs	r0, r0, #31
 8009980:	f7ff f856 	bl	8008a30 <push>
 8009984:	bd08      	pop	{r3, pc}

08009986 <spush>:
static inline sdcell spopd(void) { sdcell res; if (sp < 2) sabort("data stack underflow"); res = (sdcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
static inline cell rpop(void) { if (!rsp) sabort("return stack underflow"); return rstack[-- rsp]; }

/* push routines */
static inline void push(cell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = x; }
static inline void spush(scell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = (cell) x; }
 8009986:	4a08      	ldr	r2, [pc, #32]	; (80099a8 <spush+0x22>)
 8009988:	b508      	push	{r3, lr}
 800998a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800998c:	2b20      	cmp	r3, #32
 800998e:	d104      	bne.n	800999a <spush+0x14>
 8009990:	4806      	ldr	r0, [pc, #24]	; (80099ac <spush+0x26>)
 8009992:	4907      	ldr	r1, [pc, #28]	; (80099b0 <spush+0x2a>)
 8009994:	3020      	adds	r0, #32
 8009996:	f7ff f838 	bl	8008a0a <strabort>
 800999a:	1c59      	adds	r1, r3, #1
 800999c:	6351      	str	r1, [r2, #52]	; 0x34
 800999e:	4a05      	ldr	r2, [pc, #20]	; (80099b4 <spush+0x2e>)
 80099a0:	009b      	lsls	r3, r3, #2
 80099a2:	18d3      	adds	r3, r2, r3
 80099a4:	6158      	str	r0, [r3, #20]
 80099a6:	bd08      	pop	{r3, pc}
 80099a8:	20001364 	.word	0x20001364
 80099ac:	080137b4 	.word	0x080137b4
 80099b0:	080149f0 	.word	0x080149f0
 80099b4:	200017e4 	.word	0x200017e4

080099b8 <do_two_slash>:
( x_1 -- x_2)
	'x_2' is the result of shifting 'x_1' one bit toward
	the least-significant bit, leaving the most-significant bit
	unchanged.
*******************************************************************************/
		{ spush(spop() >> 1); }
 80099b8:	b508      	push	{r3, lr}
 80099ba:	f7ff ff55 	bl	8009868 <spop>
 80099be:	1040      	asrs	r0, r0, #1
 80099c0:	f7ff ffe1 	bl	8009986 <spush>
 80099c4:	bd08      	pop	{r3, pc}

080099c6 <do_abs>:
/*******************************************************************************
	ABS	[abs] 
( n -- u)
	'u' is the absolute value of 'n'.
*******************************************************************************/
		{ scell x = spop(); spush(x >= 0 ? x : - x); }
 80099c6:	b508      	push	{r3, lr}
 80099c8:	f7ff ff4e 	bl	8009868 <spop>
 80099cc:	17c3      	asrs	r3, r0, #31
 80099ce:	18c0      	adds	r0, r0, r3
 80099d0:	4058      	eors	r0, r3
 80099d2:	f7ff ffd8 	bl	8009986 <spush>
 80099d6:	bd08      	pop	{r3, pc}

080099d8 <do_depth>:
	DEPTH	 
(  -- +n)
	'+n' is the number of single-cell values contained in the
	data stack before '+n' was placed on the stack.
*******************************************************************************/
		{ spush(sp); }
 80099d8:	b508      	push	{r3, lr}
 80099da:	4b02      	ldr	r3, [pc, #8]	; (80099e4 <do_depth+0xc>)
 80099dc:	6b58      	ldr	r0, [r3, #52]	; 0x34
 80099de:	f7ff ffd2 	bl	8009986 <spush>
 80099e2:	bd08      	pop	{r3, pc}
 80099e4:	20001364 	.word	0x20001364

080099e8 <do_max>:
/*******************************************************************************
	MAX	 
( n_1 n_2 -- n_3)
	'n_3' is the greater of 'n_1' and 'n_2'.
*******************************************************************************/
		{ dcell t = popd(); scell x, y; x = (cell) t; y = (cell)(t >> CELL_NR_BITS); spush(x > y ? x : y); }
 80099e8:	b508      	push	{r3, lr}
 80099ea:	f7ff fcc7 	bl	800937c <popd>
 80099ee:	4281      	cmp	r1, r0
 80099f0:	da00      	bge.n	80099f4 <do_max+0xc>
 80099f2:	1c01      	adds	r1, r0, #0
 80099f4:	1c08      	adds	r0, r1, #0
 80099f6:	f7ff ffc6 	bl	8009986 <spush>
 80099fa:	bd08      	pop	{r3, pc}

080099fc <do_min>:
/*******************************************************************************
	MIN	 
( n_1 n_2 -- n_3)
	'n_3' is the lesser of 'n_1' and 'n_2'.
*******************************************************************************/
		{ dcell t = popd(); scell x, y; x = (cell) t; y = (cell)(t >> CELL_NR_BITS); spush(x < y ? x : y); }
 80099fc:	b508      	push	{r3, lr}
 80099fe:	f7ff fcbd 	bl	800937c <popd>
 8009a02:	4281      	cmp	r1, r0
 8009a04:	dd00      	ble.n	8009a08 <do_min+0xc>
 8009a06:	1c01      	adds	r1, r0, #0
 8009a08:	1c08      	adds	r0, r1, #0
 8009a0a:	f7ff ffbc 	bl	8009986 <spush>
 8009a0e:	bd08      	pop	{r3, pc}

08009a10 <do_negate>:
/*******************************************************************************
	NEGATE	 
( n_1 -- n_2)
	Negate 'n_1', giving its arithmetic inverse 'n_2'.
*******************************************************************************/
		{ spush(- spop()); }
 8009a10:	b508      	push	{r3, lr}
 8009a12:	f7ff ff29 	bl	8009868 <spop>
 8009a16:	4240      	negs	r0, r0
 8009a18:	f7ff ffb5 	bl	8009986 <spush>
 8009a1c:	bd08      	pop	{r3, pc}

08009a1e <do_star_slash>:
	be the same as that returned by either the phrase
	'toR' 'M*' 'Rfrom' 'FM/MOD' 'SWAP' 'DROP'
	or the phrase
	'toR' 'M*' 'Rfrom' 'SM/REM' 'SWAP' 'DROP'.
*******************************************************************************/
		{ sdcell x; scell n3, n4; n3 = spop(); x = (sdcell) spop() * (sdcell) spop(); if (n3) n4 = x / n3; else /* ??? what to do here */ sabort("divide by zero"); spush(n4); }
 8009a1e:	b538      	push	{r3, r4, r5, lr}
 8009a20:	f7ff ff22 	bl	8009868 <spop>
 8009a24:	1c04      	adds	r4, r0, #0
 8009a26:	f7ff ff1f 	bl	8009868 <spop>
 8009a2a:	1c05      	adds	r5, r0, #0
 8009a2c:	f7ff ff1c 	bl	8009868 <spop>
 8009a30:	17e9      	asrs	r1, r5, #31
 8009a32:	1c02      	adds	r2, r0, #0
 8009a34:	17c3      	asrs	r3, r0, #31
 8009a36:	1c28      	adds	r0, r5, #0
 8009a38:	f005 f97c 	bl	800ed34 <__aeabi_lmul>
 8009a3c:	2c00      	cmp	r4, #0
 8009a3e:	d006      	beq.n	8009a4e <do_star_slash+0x30>
 8009a40:	17e3      	asrs	r3, r4, #31
 8009a42:	1c22      	adds	r2, r4, #0
 8009a44:	f005 f932 	bl	800ecac <__aeabi_ldivmod>
 8009a48:	f7ff ff9d 	bl	8009986 <spush>
 8009a4c:	bd38      	pop	{r3, r4, r5, pc}
 8009a4e:	4802      	ldr	r0, [pc, #8]	; (8009a58 <do_star_slash+0x3a>)
 8009a50:	4902      	ldr	r1, [pc, #8]	; (8009a5c <do_star_slash+0x3e>)
 8009a52:	3026      	adds	r0, #38	; 0x26
 8009a54:	f7fe ffd9 	bl	8008a0a <strabort>
 8009a58:	080137b4 	.word	0x080137b4
 8009a5c:	08014a3b 	.word	0x08014a3b

08009a60 <do_star_slash_mod>:
	sign, the implementation-defined result returned will be the
	same as that returned by either the phrase
	'toR' 'M*' 'Rfrom' 'FM/MOD' or the phrase
	'toR' 'M*' 'Rfrom' 'SM/REM'.
*******************************************************************************/
		{ sdcell x; scell n3, n4, n5; n3 = spop(); x = (sdcell) spop() * (sdcell) spop(); if (n3) n4 = x % n3, n5 = x / n3; else /* ??? what to do here */ sabort("divide by zero"); spush(n4); spush(n5); }
 8009a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009a62:	f7ff ff01 	bl	8009868 <spop>
 8009a66:	1c04      	adds	r4, r0, #0
 8009a68:	f7ff fefe 	bl	8009868 <spop>
 8009a6c:	1c05      	adds	r5, r0, #0
 8009a6e:	f7ff fefb 	bl	8009868 <spop>
 8009a72:	17e9      	asrs	r1, r5, #31
 8009a74:	1c02      	adds	r2, r0, #0
 8009a76:	17c3      	asrs	r3, r0, #31
 8009a78:	1c28      	adds	r0, r5, #0
 8009a7a:	f005 f95b 	bl	800ed34 <__aeabi_lmul>
 8009a7e:	1c06      	adds	r6, r0, #0
 8009a80:	1c0f      	adds	r7, r1, #0
 8009a82:	2c00      	cmp	r4, #0
 8009a84:	d010      	beq.n	8009aa8 <do_star_slash_mod+0x48>
 8009a86:	17e5      	asrs	r5, r4, #31
 8009a88:	1c2b      	adds	r3, r5, #0
 8009a8a:	1c22      	adds	r2, r4, #0
 8009a8c:	f005 f90e 	bl	800ecac <__aeabi_ldivmod>
 8009a90:	1c10      	adds	r0, r2, #0
 8009a92:	f7ff ff78 	bl	8009986 <spush>
 8009a96:	1c2b      	adds	r3, r5, #0
 8009a98:	1c30      	adds	r0, r6, #0
 8009a9a:	1c39      	adds	r1, r7, #0
 8009a9c:	1c22      	adds	r2, r4, #0
 8009a9e:	f005 f905 	bl	800ecac <__aeabi_ldivmod>
 8009aa2:	f7ff ff70 	bl	8009986 <spush>
 8009aa6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009aa8:	4802      	ldr	r0, [pc, #8]	; (8009ab4 <do_star_slash_mod+0x54>)
 8009aaa:	4903      	ldr	r1, [pc, #12]	; (8009ab8 <do_star_slash_mod+0x58>)
 8009aac:	3034      	adds	r0, #52	; 0x34
 8009aae:	f7fe ffac 	bl	8008a0a <strabort>
 8009ab2:	46c0      	nop			; (mov r8, r8)
 8009ab4:	080137b4 	.word	0x080137b4
 8009ab8:	08014a3b 	.word	0x08014a3b

08009abc <rpop>:
/* pop routines */
static inline cell pop(void) { if (!sp) sabort("data stack underflow"); return dstack[-- sp]; }
static inline scell spop(void) { if (!sp) sabort("data stack underflow"); return (scell) dstack[-- sp]; }
static inline dcell popd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = (dcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
static inline sdcell spopd(void) { sdcell res; if (sp < 2) sabort("data stack underflow"); res = (sdcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
static inline cell rpop(void) { if (!rsp) sabort("return stack underflow"); return rstack[-- rsp]; }
 8009abc:	4a08      	ldr	r2, [pc, #32]	; (8009ae0 <rpop+0x24>)
 8009abe:	b508      	push	{r3, lr}
 8009ac0:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009ac2:	2b00      	cmp	r3, #0
 8009ac4:	d104      	bne.n	8009ad0 <rpop+0x14>
 8009ac6:	4807      	ldr	r0, [pc, #28]	; (8009ae4 <rpop+0x28>)
 8009ac8:	4907      	ldr	r1, [pc, #28]	; (8009ae8 <rpop+0x2c>)
 8009aca:	3046      	adds	r0, #70	; 0x46
 8009acc:	f7fe ff9d 	bl	8008a0a <strabort>
 8009ad0:	3b01      	subs	r3, #1
 8009ad2:	6313      	str	r3, [r2, #48]	; 0x30
 8009ad4:	4a05      	ldr	r2, [pc, #20]	; (8009aec <rpop+0x30>)
 8009ad6:	009b      	lsls	r3, r3, #2
 8009ad8:	18d3      	adds	r3, r2, r3
 8009ada:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8009adc:	bd08      	pop	{r3, pc}
 8009ade:	46c0      	nop			; (mov r8, r8)
 8009ae0:	20001364 	.word	0x20001364
 8009ae4:	080137b4 	.word	0x080137b4
 8009ae8:	08014a4a 	.word	0x08014a4a
 8009aec:	20001964 	.word	0x20001964

08009af0 <do_r_from>:
\execute
	(  -- x)
	( R]{x -- )
	Move 'x' from the return stack to the data stack.
*******************************************************************************/
		{ push(rpop()); }
 8009af0:	b508      	push	{r3, lr}
 8009af2:	f7ff ffe3 	bl	8009abc <rpop>
 8009af6:	f7fe ff9b 	bl	8008a30 <push>
 8009afa:	bd08      	pop	{r3, pc}

08009afc <ddup>:

/* swap routines */
static inline void swap(void) { cell t; if (sp < 2) sabort("data stack underflow"); t = dstack[sp - 2]; dstack[sp - 2] = dstack[sp - 1]; dstack[sp - 1] = t; }

/* dup routines */
static inline void ddup(void) { if (!sp) sabort("data stack empty"); if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp] = dstack[sp - 1]; sp ++; }
 8009afc:	490d      	ldr	r1, [pc, #52]	; (8009b34 <ddup+0x38>)
 8009afe:	b510      	push	{r4, lr}
 8009b00:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8009b02:	2b00      	cmp	r3, #0
 8009b04:	d103      	bne.n	8009b0e <ddup+0x12>
 8009b06:	480c      	ldr	r0, [pc, #48]	; (8009b38 <ddup+0x3c>)
 8009b08:	490c      	ldr	r1, [pc, #48]	; (8009b3c <ddup+0x40>)
 8009b0a:	304b      	adds	r0, #75	; 0x4b
 8009b0c:	e004      	b.n	8009b18 <ddup+0x1c>
 8009b0e:	2b20      	cmp	r3, #32
 8009b10:	d104      	bne.n	8009b1c <ddup+0x20>
 8009b12:	4809      	ldr	r0, [pc, #36]	; (8009b38 <ddup+0x3c>)
 8009b14:	490a      	ldr	r1, [pc, #40]	; (8009b40 <ddup+0x44>)
 8009b16:	304b      	adds	r0, #75	; 0x4b
 8009b18:	f7fe ff77 	bl	8008a0a <strabort>
 8009b1c:	4809      	ldr	r0, [pc, #36]	; (8009b44 <ddup+0x48>)
 8009b1e:	1e5a      	subs	r2, r3, #1
 8009b20:	0092      	lsls	r2, r2, #2
 8009b22:	1882      	adds	r2, r0, r2
 8009b24:	6954      	ldr	r4, [r2, #20]
 8009b26:	009a      	lsls	r2, r3, #2
 8009b28:	1882      	adds	r2, r0, r2
 8009b2a:	3301      	adds	r3, #1
 8009b2c:	6154      	str	r4, [r2, #20]
 8009b2e:	634b      	str	r3, [r1, #52]	; 0x34
 8009b30:	bd10      	pop	{r4, pc}
 8009b32:	46c0      	nop			; (mov r8, r8)
 8009b34:	20001364 	.word	0x20001364
 8009b38:	080137b4 	.word	0x080137b4
 8009b3c:	08014a19 	.word	0x08014a19
 8009b40:	080149f0 	.word	0x080149f0
 8009b44:	200017e4 	.word	0x200017e4

08009b48 <do_dup>:
/*******************************************************************************
	DUP	[dupe] 
( x -- x x)
	Duplicate 'x'.
*******************************************************************************/
		{ ddup(); }
 8009b48:	b508      	push	{r3, lr}
 8009b4a:	f7ff ffd7 	bl	8009afc <ddup>
 8009b4e:	bd08      	pop	{r3, pc}

08009b50 <rot>:
/* over routines */
static inline void over(void) { if (sp < 2 || sp == DSTACK_SIZE) sabort("cannot execute over in data stack"); dstack[sp] = dstack[sp - 2]; sp ++; }
static inline void two_over(void) { if (sp < 4 || sp > DSTACK_SIZE - 2) sabort("data stack overflow"); dstack[sp] = dstack[sp - 4]; dstack[sp + 1] = dstack[sp - 3]; sp += 2; }

/* rot routines */
static inline void rot(void) { if (sp < 3) sabort("cannot execute rot in data stack"); cell x; x = dstack[sp - 3]; dstack[sp - 3] = dstack[sp - 2]; dstack[sp - 2] = dstack[sp - 1]; dstack[sp - 1] = x; }
 8009b50:	b538      	push	{r3, r4, r5, lr}
 8009b52:	4b0d      	ldr	r3, [pc, #52]	; (8009b88 <rot+0x38>)
 8009b54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009b56:	2b02      	cmp	r3, #2
 8009b58:	dc04      	bgt.n	8009b64 <rot+0x14>
 8009b5a:	480c      	ldr	r0, [pc, #48]	; (8009b8c <rot+0x3c>)
 8009b5c:	490c      	ldr	r1, [pc, #48]	; (8009b90 <rot+0x40>)
 8009b5e:	3050      	adds	r0, #80	; 0x50
 8009b60:	f7fe ff53 	bl	8008a0a <strabort>
 8009b64:	4c0b      	ldr	r4, [pc, #44]	; (8009b94 <rot+0x44>)
 8009b66:	1e9a      	subs	r2, r3, #2
 8009b68:	0092      	lsls	r2, r2, #2
 8009b6a:	18a2      	adds	r2, r4, r2
 8009b6c:	1ed9      	subs	r1, r3, #3
 8009b6e:	6955      	ldr	r5, [r2, #20]
 8009b70:	0089      	lsls	r1, r1, #2
 8009b72:	3b01      	subs	r3, #1
 8009b74:	1861      	adds	r1, r4, r1
 8009b76:	009b      	lsls	r3, r3, #2
 8009b78:	6948      	ldr	r0, [r1, #20]
 8009b7a:	18e3      	adds	r3, r4, r3
 8009b7c:	614d      	str	r5, [r1, #20]
 8009b7e:	6959      	ldr	r1, [r3, #20]
 8009b80:	6151      	str	r1, [r2, #20]
 8009b82:	6158      	str	r0, [r3, #20]
 8009b84:	bd38      	pop	{r3, r4, r5, pc}
 8009b86:	46c0      	nop			; (mov r8, r8)
 8009b88:	20001364 	.word	0x20001364
 8009b8c:	080137b4 	.word	0x080137b4
 8009b90:	08014a61 	.word	0x08014a61
 8009b94:	200017e4 	.word	0x200017e4

08009b98 <do_dot>:
/*******************************************************************************
	.	[dot] 
( n -- )
	Display 'n' in free field format.
*******************************************************************************/
		{ ddup(); do_abs(); push(0); do_less_number_sign(); do_number_sign_s(); rot(); do_sign(); do_number_sign_greater(); do_type(); do_space(); }
 8009b98:	b508      	push	{r3, lr}
 8009b9a:	f7ff ffaf 	bl	8009afc <ddup>
 8009b9e:	f7ff ff12 	bl	80099c6 <do_abs>
 8009ba2:	2000      	movs	r0, #0
 8009ba4:	f7fe ff44 	bl	8008a30 <push>
/*******************************************************************************
	<#	[less-number-sign] 
(  -- )
	Initialize the pictured numeric output conversion process.
*******************************************************************************/
		{ pno.idx = sizeof pno.buf; /* pno.buf[-- pno.idx] = ' '; */ }
 8009ba8:	2282      	movs	r2, #130	; 0x82
 8009baa:	4b07      	ldr	r3, [pc, #28]	; (8009bc8 <do_dot+0x30>)
 8009bac:	60da      	str	r2, [r3, #12]
/*******************************************************************************
	.	[dot] 
( n -- )
	Display 'n' in free field format.
*******************************************************************************/
		{ ddup(); do_abs(); push(0); do_less_number_sign(); do_number_sign_s(); rot(); do_sign(); do_number_sign_greater(); do_type(); do_space(); }
 8009bae:	f7ff fdd7 	bl	8009760 <do_number_sign_s>
 8009bb2:	f7ff ffcd 	bl	8009b50 <rot>
 8009bb6:	f7ff fecd 	bl	8009954 <do_sign>
 8009bba:	f7ff fc02 	bl	80093c2 <do_number_sign_greater>
 8009bbe:	f7ff fa13 	bl	8008fe8 <do_type>
 8009bc2:	f7ff f94d 	bl	8008e60 <do_space>
 8009bc6:	bd08      	pop	{r3, pc}
 8009bc8:	200011e4 	.word	0x200011e4

08009bcc <do_question>:
{
	push((cell)((struct word *)pop())->name);
}

void /* "?" */		do_question(void)
		{ do_dup(), do_fetch(), do_dot(); }
 8009bcc:	b508      	push	{r3, lr}
/*******************************************************************************
	DUP	[dupe] 
( x -- x x)
	Duplicate 'x'.
*******************************************************************************/
		{ ddup(); }
 8009bce:	f7ff ff95 	bl	8009afc <ddup>
{
	push((cell)((struct word *)pop())->name);
}

void /* "?" */		do_question(void)
		{ do_dup(), do_fetch(), do_dot(); }
 8009bd2:	f7ff f8e0 	bl	8008d96 <do_fetch>
 8009bd6:	f7ff ffdf 	bl	8009b98 <do_dot>
 8009bda:	bd08      	pop	{r3, pc}

08009bdc <do_rot>:
/*******************************************************************************
	ROT	[rote] 
( x_1 x_2 x_3 -- x_2 x_3 x_1)
	Rotate the top three stack entries.
*******************************************************************************/
		{ rot(); }
 8009bdc:	b508      	push	{r3, lr}
 8009bde:	f7ff ffb7 	bl	8009b50 <rot>
 8009be2:	bd08      	pop	{r3, pc}

08009be4 <do_dot_r>:
	Display 'n_1' right aligned in a field 'n_2'
	characters wide. If the number of characters required to display
	'n_1' is greater than 'n_2', all digits are displayed
	with no leading spaces in a field as wide as necessary.
*******************************************************************************/
		{ scell x = pop();
 8009be4:	b510      	push	{r4, lr}
 8009be6:	f7ff f871 	bl	8008ccc <pop>
 8009bea:	1c04      	adds	r4, r0, #0
		ddup(); do_abs(); push(0); do_less_number_sign(); do_number_sign_s(); rot(); do_sign(); do_number_sign_greater();
 8009bec:	f7ff ff86 	bl	8009afc <ddup>
 8009bf0:	f7ff fee9 	bl	80099c6 <do_abs>
 8009bf4:	2000      	movs	r0, #0
 8009bf6:	f7fe ff1b 	bl	8008a30 <push>
/*******************************************************************************
	<#	[less-number-sign] 
(  -- )
	Initialize the pictured numeric output conversion process.
*******************************************************************************/
		{ pno.idx = sizeof pno.buf; /* pno.buf[-- pno.idx] = ' '; */ }
 8009bfa:	2282      	movs	r2, #130	; 0x82
 8009bfc:	4b0b      	ldr	r3, [pc, #44]	; (8009c2c <do_dot_r+0x48>)
 8009bfe:	60da      	str	r2, [r3, #12]
	characters wide. If the number of characters required to display
	'n_1' is greater than 'n_2', all digits are displayed
	with no leading spaces in a field as wide as necessary.
*******************************************************************************/
		{ scell x = pop();
		ddup(); do_abs(); push(0); do_less_number_sign(); do_number_sign_s(); rot(); do_sign(); do_number_sign_greater();
 8009c00:	f7ff fdae 	bl	8009760 <do_number_sign_s>
 8009c04:	f7ff ffa4 	bl	8009b50 <rot>
 8009c08:	f7ff fea4 	bl	8009954 <do_sign>
 8009c0c:	f7ff fbd9 	bl	80093c2 <do_number_sign_greater>
		x -= top(); if (x > 0) push(x), do_spaces();
 8009c10:	f7ff fb93 	bl	800933a <top>
 8009c14:	1a20      	subs	r0, r4, r0
 8009c16:	2800      	cmp	r0, #0
 8009c18:	dd03      	ble.n	8009c22 <do_dot_r+0x3e>
 8009c1a:	f7fe ff09 	bl	8008a30 <push>
 8009c1e:	f7ff f9b6 	bl	8008f8e <do_spaces>
		do_type(); do_space(); }
 8009c22:	f7ff f9e1 	bl	8008fe8 <do_type>
 8009c26:	f7ff f91b 	bl	8008e60 <do_space>
 8009c2a:	bd10      	pop	{r4, pc}
 8009c2c:	200011e4 	.word	0x200011e4

08009c30 <do_endof>:
\runtime
	(  -- )
	Continue execution at the location specified by the consumer
	of 'case-sys_2'.
*******************************************************************************/
		{ do_ahead(); rot(); rot(); do_then(); push(pop() + 1); }
 8009c30:	b508      	push	{r3, lr}
 8009c32:	f7ff f819 	bl	8008c68 <do_ahead>
 8009c36:	f7ff ff8b 	bl	8009b50 <rot>
 8009c3a:	f7ff ff89 	bl	8009b50 <rot>
 8009c3e:	f7ff f9b1 	bl	8008fa4 <do_then>
 8009c42:	f7ff f843 	bl	8008ccc <pop>
 8009c46:	3001      	adds	r0, #1
 8009c48:	f7fe fef2 	bl	8008a30 <push>
 8009c4c:	bd08      	pop	{r3, pc}

08009c4e <do_tuck>:
/*******************************************************************************
	TUCK	 
( x_1 x_2 -- x_2 x_1 x_2)
	Copy the first (top) stack item below the second stack item.
*******************************************************************************/
		{ ddup(); rot(); rot(); }
 8009c4e:	b508      	push	{r3, lr}
 8009c50:	f7ff ff54 	bl	8009afc <ddup>
 8009c54:	f7ff ff7c 	bl	8009b50 <rot>
 8009c58:	f7ff ff7a 	bl	8009b50 <rot>
 8009c5c:	bd08      	pop	{r3, pc}

08009c5e <do_slash>:
	returned by either the phrase
	'toR' 'StoD' 'Rfrom' 'FM/MOD' 'SWAP' 'DROP'
	or the phrase
	'toR' 'StoD' 'Rfrom' 'SM/REM' 'SWAP' 'DROP'.
*******************************************************************************/
		{ dcell x = popd(); if (!(cell)(x >> CELL_NR_BITS)) sabort("divide by zero"); push(((scell) (cell) x) / ((scell)(cell)(x >> CELL_NR_BITS))); }
 8009c5e:	b508      	push	{r3, lr}
 8009c60:	f7ff fb8c 	bl	800937c <popd>
 8009c64:	2900      	cmp	r1, #0
 8009c66:	d104      	bne.n	8009c72 <do_slash+0x14>
 8009c68:	4804      	ldr	r0, [pc, #16]	; (8009c7c <do_slash+0x1e>)
 8009c6a:	4905      	ldr	r1, [pc, #20]	; (8009c80 <do_slash+0x22>)
 8009c6c:	3054      	adds	r0, #84	; 0x54
 8009c6e:	f7fe fecc 	bl	8008a0a <strabort>
 8009c72:	f004 ff1d 	bl	800eab0 <__aeabi_idiv>
 8009c76:	f7fe fedb 	bl	8008a30 <push>
 8009c7a:	bd08      	pop	{r3, pc}
 8009c7c:	080137b4 	.word	0x080137b4
 8009c80:	08014a3b 	.word	0x08014a3b

08009c84 <do_slash_mod>:
	returned will be the same as that returned by either the phrase
	'toR' 'StoD' 'Rfrom' 'FM/MOD'
	or the phrase
	'toR' 'StoD' 'Rfrom' 'SM/REM'.
*******************************************************************************/
		{ dcell x = popd(); if (!(cell)(x >> CELL_NR_BITS)) sabort("divide by zero"); push(((scell) (cell) x) % ((scell)(cell)(x >> CELL_NR_BITS))); push(((scell) (cell) x) / ((scell)(cell)(x >> CELL_NR_BITS))); }
 8009c84:	b538      	push	{r3, r4, r5, lr}
 8009c86:	f7ff fb79 	bl	800937c <popd>
 8009c8a:	1c05      	adds	r5, r0, #0
 8009c8c:	1e0c      	subs	r4, r1, #0
 8009c8e:	d104      	bne.n	8009c9a <do_slash_mod+0x16>
 8009c90:	4808      	ldr	r0, [pc, #32]	; (8009cb4 <do_slash_mod+0x30>)
 8009c92:	4909      	ldr	r1, [pc, #36]	; (8009cb8 <do_slash_mod+0x34>)
 8009c94:	305d      	adds	r0, #93	; 0x5d
 8009c96:	f7fe feb8 	bl	8008a0a <strabort>
 8009c9a:	f004 ffef 	bl	800ec7c <__aeabi_idivmod>
 8009c9e:	1c08      	adds	r0, r1, #0
 8009ca0:	f7fe fec6 	bl	8008a30 <push>
 8009ca4:	1c28      	adds	r0, r5, #0
 8009ca6:	1c21      	adds	r1, r4, #0
 8009ca8:	f004 ff02 	bl	800eab0 <__aeabi_idiv>
 8009cac:	f7fe fec0 	bl	8008a30 <push>
 8009cb0:	bd38      	pop	{r3, r4, r5, pc}
 8009cb2:	46c0      	nop			; (mov r8, r8)
 8009cb4:	080137b4 	.word	0x080137b4
 8009cb8:	08014a3b 	.word	0x08014a3b

08009cbc <do_two_over>:
static inline void two_r_from(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; rsp -= 2; sp += 2; }
static inline void two_r_fetch(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; sp += 2; }

/* over routines */
static inline void over(void) { if (sp < 2 || sp == DSTACK_SIZE) sabort("cannot execute over in data stack"); dstack[sp] = dstack[sp - 2]; sp ++; }
static inline void two_over(void) { if (sp < 4 || sp > DSTACK_SIZE - 2) sabort("data stack overflow"); dstack[sp] = dstack[sp - 4]; dstack[sp + 1] = dstack[sp - 3]; sp += 2; }
 8009cbc:	490e      	ldr	r1, [pc, #56]	; (8009cf8 <do_two_over+0x3c>)
/*******************************************************************************
	2OVER	[two-over] 
( x_1 x_2 x_3 x_4 -- x_1 x_2 x_3 x_4 x_1 x_2)
	Copy cell pair 'x_1 x_2' to the top of the stack.
*******************************************************************************/
		{ two_over(); }
 8009cbe:	b510      	push	{r4, lr}
 8009cc0:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8009cc2:	1f1a      	subs	r2, r3, #4
 8009cc4:	2a1a      	cmp	r2, #26
 8009cc6:	d904      	bls.n	8009cd2 <do_two_over+0x16>
 8009cc8:	480c      	ldr	r0, [pc, #48]	; (8009cfc <do_two_over+0x40>)
 8009cca:	490d      	ldr	r1, [pc, #52]	; (8009d00 <do_two_over+0x44>)
 8009ccc:	306a      	adds	r0, #106	; 0x6a
 8009cce:	f7fe fe9c 	bl	8008a0a <strabort>
 8009cd2:	4c0c      	ldr	r4, [pc, #48]	; (8009d04 <do_two_over+0x48>)
 8009cd4:	0092      	lsls	r2, r2, #2
 8009cd6:	18a2      	adds	r2, r4, r2
 8009cd8:	6950      	ldr	r0, [r2, #20]
 8009cda:	009a      	lsls	r2, r3, #2
 8009cdc:	18a2      	adds	r2, r4, r2
 8009cde:	6150      	str	r0, [r2, #20]
 8009ce0:	1ed8      	subs	r0, r3, #3
 8009ce2:	0080      	lsls	r0, r0, #2
 8009ce4:	1820      	adds	r0, r4, r0
 8009ce6:	1c5a      	adds	r2, r3, #1
 8009ce8:	6940      	ldr	r0, [r0, #20]
 8009cea:	0092      	lsls	r2, r2, #2
 8009cec:	18a2      	adds	r2, r4, r2
 8009cee:	3302      	adds	r3, #2
 8009cf0:	6150      	str	r0, [r2, #20]
 8009cf2:	634b      	str	r3, [r1, #52]	; 0x34
 8009cf4:	bd10      	pop	{r4, pc}
 8009cf6:	46c0      	nop			; (mov r8, r8)
 8009cf8:	20001364 	.word	0x20001364
 8009cfc:	080137b4 	.word	0x080137b4
 8009d00:	080149f0 	.word	0x080149f0
 8009d04:	200017e4 	.word	0x200017e4

08009d08 <rpush>:
/* push routines */
static inline void push(cell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = x; }
static inline void spush(scell x) { if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp ++] = (cell) x; }
static inline void pushd(dcell x) { if (sp > DSTACK_SIZE - 2) sabort("data stack overflow"); dstack[sp ++] = (cell) x; dstack[sp ++] = (cell) (x >> CELL_NR_BITS); }
static inline void spushd(sdcell x) { pushd((dcell) x); }
static inline void rpush(cell x) { if (rsp == RSTACK_SIZE) sabort("return stack overflow"); rstack[rsp ++] = x; }
 8009d08:	4a08      	ldr	r2, [pc, #32]	; (8009d2c <rpush+0x24>)
 8009d0a:	b508      	push	{r3, lr}
 8009d0c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009d0e:	2b20      	cmp	r3, #32
 8009d10:	d104      	bne.n	8009d1c <rpush+0x14>
 8009d12:	4807      	ldr	r0, [pc, #28]	; (8009d30 <rpush+0x28>)
 8009d14:	4907      	ldr	r1, [pc, #28]	; (8009d34 <rpush+0x2c>)
 8009d16:	3073      	adds	r0, #115	; 0x73
 8009d18:	f7fe fe77 	bl	8008a0a <strabort>
 8009d1c:	1c59      	adds	r1, r3, #1
 8009d1e:	6311      	str	r1, [r2, #48]	; 0x30
 8009d20:	4a05      	ldr	r2, [pc, #20]	; (8009d38 <rpush+0x30>)
 8009d22:	009b      	lsls	r3, r3, #2
 8009d24:	18d3      	adds	r3, r2, r3
 8009d26:	6298      	str	r0, [r3, #40]	; 0x28
 8009d28:	bd08      	pop	{r3, pc}
 8009d2a:	46c0      	nop			; (mov r8, r8)
 8009d2c:	20001364 	.word	0x20001364
 8009d30:	080137b4 	.word	0x080137b4
 8009d34:	08014a82 	.word	0x08014a82
 8009d38:	20001964 	.word	0x20001964

08009d3c <do_to_r>:
\execute
	( x -- )
	( R]{ -- x)
	Move 'x' to the return stack.
*******************************************************************************/
		{ rpush(pop()); }
 8009d3c:	b508      	push	{r3, lr}
 8009d3e:	f7fe ffc5 	bl	8008ccc <pop>
 8009d42:	f7ff ffe1 	bl	8009d08 <rpush>
 8009d46:	bd08      	pop	{r3, pc}

08009d48 <do_semicolon>:
\runtime
	(  -- )
	( R]{nest-sys -- )
	Return to the calling definition specified by 'nest-sys'.
*******************************************************************************/
		{ if (state != STATE_COMPILING) sabort("bad state"); do_exit(); latest->is_smudged = 0; state = STATE_INTERPRETING; }
 8009d48:	b510      	push	{r4, lr}
 8009d4a:	4c0a      	ldr	r4, [pc, #40]	; (8009d74 <do_semicolon+0x2c>)
 8009d4c:	69a3      	ldr	r3, [r4, #24]
 8009d4e:	3301      	adds	r3, #1
 8009d50:	d004      	beq.n	8009d5c <do_semicolon+0x14>
 8009d52:	4809      	ldr	r0, [pc, #36]	; (8009d78 <do_semicolon+0x30>)
 8009d54:	4909      	ldr	r1, [pc, #36]	; (8009d7c <do_semicolon+0x34>)
 8009d56:	3079      	adds	r0, #121	; 0x79
 8009d58:	f7fe fe57 	bl	8008a0a <strabort>
 8009d5c:	f7fe fd3c 	bl	80087d8 <do_exit>
 8009d60:	2102      	movs	r1, #2
 8009d62:	4b07      	ldr	r3, [pc, #28]	; (8009d80 <do_semicolon+0x38>)
 8009d64:	681a      	ldr	r2, [r3, #0]
 8009d66:	7a13      	ldrb	r3, [r2, #8]
 8009d68:	438b      	bics	r3, r1
 8009d6a:	7213      	strb	r3, [r2, #8]
 8009d6c:	2300      	movs	r3, #0
 8009d6e:	61a3      	str	r3, [r4, #24]
 8009d70:	bd10      	pop	{r4, pc}
 8009d72:	46c0      	nop			; (mov r8, r8)
 8009d74:	20001264 	.word	0x20001264
 8009d78:	080137b4 	.word	0x080137b4
 8009d7c:	08014a98 	.word	0x08014a98
 8009d80:	20000068 	.word	0x20000068

08009d84 <do_create>:
	(  -- a-addr)
	'a-addr' is the address of 'name''s data field.
	The execution semantics of 'name' may be extended by
	using 'DOES'.
*******************************************************************************/
{
 8009d84:	b570      	push	{r4, r5, r6, lr}
cell x;
uint8_t * s;
struct word * w;
	do_bl();
 8009d86:	f7fe fea3 	bl	8008ad0 <do_bl>
	do_word();
 8009d8a:	f7ff fa0e 	bl	80091aa <do_word>
	do_count();
 8009d8e:	f7ff f84b 	bl	8008e28 <do_count>
	s = here.chr;
 8009d92:	4d15      	ldr	r5, [pc, #84]	; (8009de8 <do_create+0x64>)
 8009d94:	68ae      	ldr	r6, [r5, #8]
	x = pop();
 8009d96:	f7fe ff99 	bl	8008ccc <pop>
 8009d9a:	1e04      	subs	r4, r0, #0
	if (!x) strabort(__func__, "refusing to use a zero-length string as a name");
 8009d9c:	d104      	bne.n	8009da8 <do_create+0x24>
 8009d9e:	4813      	ldr	r0, [pc, #76]	; (8009dec <do_create+0x68>)
 8009da0:	4913      	ldr	r1, [pc, #76]	; (8009df0 <do_create+0x6c>)
 8009da2:	3006      	adds	r0, #6
 8009da4:	f7fe fe31 	bl	8008a0a <strabort>
	* s = x;
 8009da8:	7030      	strb	r0, [r6, #0]
	xmemcpy((char *) (s + 1), (char *) pop(), x);
 8009daa:	f7fe ff8f 	bl	8008ccc <pop>
 8009dae:	1c22      	adds	r2, r4, #0
	here.chr += x + 1;
 8009db0:	3401      	adds	r4, #1
	do_count();
	s = here.chr;
	x = pop();
	if (!x) strabort(__func__, "refusing to use a zero-length string as a name");
	* s = x;
	xmemcpy((char *) (s + 1), (char *) pop(), x);
 8009db2:	1c01      	adds	r1, r0, #0
	here.chr += x + 1;
 8009db4:	1934      	adds	r4, r6, r4
	do_count();
	s = here.chr;
	x = pop();
	if (!x) strabort(__func__, "refusing to use a zero-length string as a name");
	* s = x;
	xmemcpy((char *) (s + 1), (char *) pop(), x);
 8009db6:	1c70      	adds	r0, r6, #1
 8009db8:	f7fe fdc3 	bl	8008942 <xmemcpy>
	here.chr += x + 1;
 8009dbc:	60ac      	str	r4, [r5, #8]
	do_align();
 8009dbe:	f7fe fced 	bl	800879c <do_align>
	w = (struct word *) here.cell;
 8009dc2:	68ac      	ldr	r4, [r5, #8]
	xmemset(w, 0, sizeof * w);
 8009dc4:	2100      	movs	r1, #0
 8009dc6:	1c20      	adds	r0, r4, #0
 8009dc8:	2210      	movs	r2, #16
 8009dca:	f7fe fdc3 	bl	8008954 <xmemset>
	w->link = latest;
 8009dce:	4b09      	ldr	r3, [pc, #36]	; (8009df4 <do_create+0x70>)
	w->name = (union cstr *) s;
 8009dd0:	6066      	str	r6, [r4, #4]
	xmemcpy((char *) (s + 1), (char *) pop(), x);
	here.chr += x + 1;
	do_align();
	w = (struct word *) here.cell;
	xmemset(w, 0, sizeof * w);
	w->link = latest;
 8009dd2:	681a      	ldr	r2, [r3, #0]
 8009dd4:	6022      	str	r2, [r4, #0]
	w->name = (union cstr *) s;
	w->cfa = runtime_create;
 8009dd6:	4a08      	ldr	r2, [pc, #32]	; (8009df8 <do_create+0x74>)
	latest = w;
 8009dd8:	601c      	str	r4, [r3, #0]
	do_align();
	w = (struct word *) here.cell;
	xmemset(w, 0, sizeof * w);
	w->link = latest;
	w->name = (union cstr *) s;
	w->cfa = runtime_create;
 8009dda:	60e2      	str	r2, [r4, #12]
	latest = w;
	here.chr += sizeof(struct word);
 8009ddc:	3410      	adds	r4, #16
 8009dde:	60ac      	str	r4, [r5, #8]
	do_align();
 8009de0:	f7fe fcdc 	bl	800879c <do_align>
}
 8009de4:	bd70      	pop	{r4, r5, r6, pc}
 8009de6:	46c0      	nop			; (mov r8, r8)
 8009de8:	200011e4 	.word	0x200011e4
 8009dec:	08013834 	.word	0x08013834
 8009df0:	08014aa2 	.word	0x08014aa2
 8009df4:	20000068 	.word	0x20000068
 8009df8:	08008aed 	.word	0x08008aed

08009dfc <do_constant>:
	'name' is referred to as a ``constant''.
\execute[name]
	(  -- x)
	Place 'x' on the stack.
*******************************************************************************/
		{ do_create(); * here.cell ++ = pop(); latest->cfa = runtime_constant; }
 8009dfc:	b510      	push	{r4, lr}
 8009dfe:	f7ff ffc1 	bl	8009d84 <do_create>
 8009e02:	4b06      	ldr	r3, [pc, #24]	; (8009e1c <do_constant+0x20>)
 8009e04:	689c      	ldr	r4, [r3, #8]
 8009e06:	1d22      	adds	r2, r4, #4
 8009e08:	609a      	str	r2, [r3, #8]
 8009e0a:	f7fe ff5f 	bl	8008ccc <pop>
 8009e0e:	4b04      	ldr	r3, [pc, #16]	; (8009e20 <do_constant+0x24>)
 8009e10:	4a04      	ldr	r2, [pc, #16]	; (8009e24 <do_constant+0x28>)
 8009e12:	681b      	ldr	r3, [r3, #0]
 8009e14:	6020      	str	r0, [r4, #0]
 8009e16:	60da      	str	r2, [r3, #12]
 8009e18:	bd10      	pop	{r4, pc}
 8009e1a:	46c0      	nop			; (mov r8, r8)
 8009e1c:	200011e4 	.word	0x200011e4
 8009e20:	20000068 	.word	0x20000068
 8009e24:	08008adb 	.word	0x08008adb

08009e28 <do_variable>:
	(  -- a-addr)
	'a-addr' is the address of the reserved cell. A program
	is responsible for initializing the contents of the reserved
	cell.
*******************************************************************************/
		{ do_create(); here.cell ++; }
 8009e28:	b508      	push	{r3, lr}
 8009e2a:	f7ff ffab 	bl	8009d84 <do_create>
 8009e2e:	4a02      	ldr	r2, [pc, #8]	; (8009e38 <do_variable+0x10>)
 8009e30:	6893      	ldr	r3, [r2, #8]
 8009e32:	3304      	adds	r3, #4
 8009e34:	6093      	str	r3, [r2, #8]
 8009e36:	bd08      	pop	{r3, pc}
 8009e38:	200011e4 	.word	0x200011e4

08009e3c <do_buffer_colon>:

	\param{a-addr} is the address of the space reserved by \word{BUFFER:} when
	it defined \param{name}.  The program is responsible for initializing the
	contents.
*******************************************************************************/
{ do_create(); do_allot(); }
 8009e3c:	b508      	push	{r3, lr}
 8009e3e:	f7ff ffa1 	bl	8009d84 <do_create>
 8009e42:	f7fe ffb8 	bl	8008db6 <do_allot>
 8009e46:	bd08      	pop	{r3, pc}

08009e48 <do_marker>:
	definitions. Restoration of any structures still existing that
	could refer to deleted definitions or deallocated data space is
	not necessarily provided. No other contextual information such
	as numeric base is affected.
*******************************************************************************/
{
 8009e48:	b510      	push	{r4, lr}
	push((cell) here.cell);
 8009e4a:	4b09      	ldr	r3, [pc, #36]	; (8009e70 <do_marker+0x28>)
 8009e4c:	6898      	ldr	r0, [r3, #8]
 8009e4e:	f7fe fdef 	bl	8008a30 <push>
	push((cell) latest);
 8009e52:	4c08      	ldr	r4, [pc, #32]	; (8009e74 <do_marker+0x2c>)
 8009e54:	6820      	ldr	r0, [r4, #0]
 8009e56:	f7fe fdeb 	bl	8008a30 <push>
	do_create();
 8009e5a:	f7ff ff93 	bl	8009d84 <do_create>
	do_comma();
 8009e5e:	f7fe ff4f 	bl	8008d00 <do_comma>
	do_comma();
 8009e62:	f7fe ff4d 	bl	8008d00 <do_comma>
	latest->cfa = runtime_marker;
 8009e66:	6823      	ldr	r3, [r4, #0]
 8009e68:	4a03      	ldr	r2, [pc, #12]	; (8009e78 <do_marker+0x30>)
 8009e6a:	60da      	str	r2, [r3, #12]
}
 8009e6c:	bd10      	pop	{r4, pc}
 8009e6e:	46c0      	nop			; (mov r8, r8)
 8009e70:	200011e4 	.word	0x200011e4
 8009e74:	20000068 	.word	0x20000068
 8009e78:	08008779 	.word	0x08008779

08009e7c <do_value>:
	'x' to be assigned to 'name'.
\runtime['TO' 'name']
	( x -- )
	Assign the value 'x' to 'name'.
*******************************************************************************/
		{ do_create(); latest->cfa = runtime_value; * here.cell ++ = pop(); }
 8009e7c:	b510      	push	{r4, lr}
 8009e7e:	f7ff ff81 	bl	8009d84 <do_create>
 8009e82:	4b06      	ldr	r3, [pc, #24]	; (8009e9c <do_value+0x20>)
 8009e84:	4a06      	ldr	r2, [pc, #24]	; (8009ea0 <do_value+0x24>)
 8009e86:	681b      	ldr	r3, [r3, #0]
 8009e88:	60da      	str	r2, [r3, #12]
 8009e8a:	4b06      	ldr	r3, [pc, #24]	; (8009ea4 <do_value+0x28>)
 8009e8c:	689c      	ldr	r4, [r3, #8]
 8009e8e:	1d22      	adds	r2, r4, #4
 8009e90:	609a      	str	r2, [r3, #8]
 8009e92:	f7fe ff1b 	bl	8008ccc <pop>
 8009e96:	6020      	str	r0, [r4, #0]
 8009e98:	bd10      	pop	{r4, pc}
 8009e9a:	46c0      	nop			; (mov r8, r8)
 8009e9c:	20000068 	.word	0x20000068
 8009ea0:	08008c55 	.word	0x08008c55
 8009ea4:	200011e4 	.word	0x200011e4

08009ea8 <do_colon>:
	( i*x -- j*x)
	Execute the definition 'name'. The stack effects
	'i*x' and 'j*x' represent arguments to and
	results from 'name', respectively.
*******************************************************************************/
		{ if (state != STATE_INTERPRETING) sabort("bad state"); state = STATE_COMPILING; do_create(); latest->is_smudged = 1; latest->cfa = runtime_colon; }
 8009ea8:	b508      	push	{r3, lr}
 8009eaa:	4b0b      	ldr	r3, [pc, #44]	; (8009ed8 <do_colon+0x30>)
 8009eac:	699a      	ldr	r2, [r3, #24]
 8009eae:	2a00      	cmp	r2, #0
 8009eb0:	d004      	beq.n	8009ebc <do_colon+0x14>
 8009eb2:	480a      	ldr	r0, [pc, #40]	; (8009edc <do_colon+0x34>)
 8009eb4:	490a      	ldr	r1, [pc, #40]	; (8009ee0 <do_colon+0x38>)
 8009eb6:	3010      	adds	r0, #16
 8009eb8:	f7fe fda7 	bl	8008a0a <strabort>
 8009ebc:	2201      	movs	r2, #1
 8009ebe:	4252      	negs	r2, r2
 8009ec0:	619a      	str	r2, [r3, #24]
 8009ec2:	f7ff ff5f 	bl	8009d84 <do_create>
 8009ec6:	2102      	movs	r1, #2
 8009ec8:	4b06      	ldr	r3, [pc, #24]	; (8009ee4 <do_colon+0x3c>)
 8009eca:	681b      	ldr	r3, [r3, #0]
 8009ecc:	7a1a      	ldrb	r2, [r3, #8]
 8009ece:	430a      	orrs	r2, r1
 8009ed0:	721a      	strb	r2, [r3, #8]
 8009ed2:	4a05      	ldr	r2, [pc, #20]	; (8009ee8 <do_colon+0x40>)
 8009ed4:	60da      	str	r2, [r3, #12]
 8009ed6:	bd08      	pop	{r3, pc}
 8009ed8:	20001264 	.word	0x20001264
 8009edc:	08013834 	.word	0x08013834
 8009ee0:	08014a98 	.word	0x08014a98
 8009ee4:	20000068 	.word	0x20000068
 8009ee8:	0800a6b9 	.word	0x0800a6b9

08009eec <swap>:
static inline cell top(void) { if (!sp) sabort("data stack empty"); return dstack[sp - 1]; }
static inline dcell topd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = dstack[sp - 1]; res <<= CELL_NR_BITS; return res | dstack[sp - 2]; }
static inline cell rtop(void) { if (!rsp) sabort("return stack empty"); return rstack[rsp - 1]; }

/* swap routines */
static inline void swap(void) { cell t; if (sp < 2) sabort("data stack underflow"); t = dstack[sp - 2]; dstack[sp - 2] = dstack[sp - 1]; dstack[sp - 1] = t; }
 8009eec:	b508      	push	{r3, lr}
 8009eee:	4b0a      	ldr	r3, [pc, #40]	; (8009f18 <swap+0x2c>)
 8009ef0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8009ef2:	2b01      	cmp	r3, #1
 8009ef4:	dc04      	bgt.n	8009f00 <swap+0x14>
 8009ef6:	4809      	ldr	r0, [pc, #36]	; (8009f1c <swap+0x30>)
 8009ef8:	4909      	ldr	r1, [pc, #36]	; (8009f20 <swap+0x34>)
 8009efa:	3019      	adds	r0, #25
 8009efc:	f7fe fd85 	bl	8008a0a <strabort>
 8009f00:	4908      	ldr	r1, [pc, #32]	; (8009f24 <swap+0x38>)
 8009f02:	1e9a      	subs	r2, r3, #2
 8009f04:	3b01      	subs	r3, #1
 8009f06:	0092      	lsls	r2, r2, #2
 8009f08:	009b      	lsls	r3, r3, #2
 8009f0a:	188a      	adds	r2, r1, r2
 8009f0c:	18cb      	adds	r3, r1, r3
 8009f0e:	6950      	ldr	r0, [r2, #20]
 8009f10:	6959      	ldr	r1, [r3, #20]
 8009f12:	6151      	str	r1, [r2, #20]
 8009f14:	6158      	str	r0, [r3, #20]
 8009f16:	bd08      	pop	{r3, pc}
 8009f18:	20001364 	.word	0x20001364
 8009f1c:	08013834 	.word	0x08013834
 8009f20:	08014a04 	.word	0x08014a04
 8009f24:	200017e4 	.word	0x200017e4

08009f28 <do_else>:
\runtime
	(  -- )
	Continue execution at the location given by the resolution of
	'orig_2'.
*******************************************************************************/
		{ do_ahead(); swap(); do_then(); }
 8009f28:	b508      	push	{r3, lr}
 8009f2a:	f7fe fe9d 	bl	8008c68 <do_ahead>
 8009f2e:	f7ff ffdd 	bl	8009eec <swap>
 8009f32:	f7ff f837 	bl	8008fa4 <do_then>
 8009f36:	bd08      	pop	{r3, pc}

08009f38 <do_swap>:
/*******************************************************************************
	SWAP	 
( x_1 x_2 -- x_2 x_1)
	Exchange the top two stack items.
*******************************************************************************/
		{ swap(); }
 8009f38:	b508      	push	{r3, lr}
 8009f3a:	f7ff ffd7 	bl	8009eec <swap>
 8009f3e:	bd08      	pop	{r3, pc}

08009f40 <do_nip>:
/*******************************************************************************
	NIP	 
( x_1 x_2 -- x_2)
	Drop the first item below the top of stack.
*******************************************************************************/
		{ swap(); pop(); }
 8009f40:	b508      	push	{r3, lr}
 8009f42:	f7ff ffd3 	bl	8009eec <swap>
 8009f46:	f7fe fec1 	bl	8008ccc <pop>
 8009f4a:	bd08      	pop	{r3, pc}

08009f4c <spopd>:

/* pop routines */
static inline cell pop(void) { if (!sp) sabort("data stack underflow"); return dstack[-- sp]; }
static inline scell spop(void) { if (!sp) sabort("data stack underflow"); return (scell) dstack[-- sp]; }
static inline dcell popd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = (dcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
static inline sdcell spopd(void) { sdcell res; if (sp < 2) sabort("data stack underflow"); res = (sdcell) dstack[-- sp]; res <<= CELL_NR_BITS; return res | dstack[-- sp]; }
 8009f4c:	b510      	push	{r4, lr}
 8009f4e:	4c0a      	ldr	r4, [pc, #40]	; (8009f78 <spopd+0x2c>)
 8009f50:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009f52:	2b01      	cmp	r3, #1
 8009f54:	dc04      	bgt.n	8009f60 <spopd+0x14>
 8009f56:	4809      	ldr	r0, [pc, #36]	; (8009f7c <spopd+0x30>)
 8009f58:	4909      	ldr	r1, [pc, #36]	; (8009f80 <spopd+0x34>)
 8009f5a:	301e      	adds	r0, #30
 8009f5c:	f7fe fd55 	bl	8008a0a <strabort>
 8009f60:	4808      	ldr	r0, [pc, #32]	; (8009f84 <spopd+0x38>)
 8009f62:	1e5a      	subs	r2, r3, #1
 8009f64:	3b02      	subs	r3, #2
 8009f66:	6363      	str	r3, [r4, #52]	; 0x34
 8009f68:	0092      	lsls	r2, r2, #2
 8009f6a:	009b      	lsls	r3, r3, #2
 8009f6c:	1882      	adds	r2, r0, r2
 8009f6e:	18c3      	adds	r3, r0, r3
 8009f70:	6951      	ldr	r1, [r2, #20]
 8009f72:	6958      	ldr	r0, [r3, #20]
 8009f74:	bd10      	pop	{r4, pc}
 8009f76:	46c0      	nop			; (mov r8, r8)
 8009f78:	20001364 	.word	0x20001364
 8009f7c:	08013834 	.word	0x08013834
 8009f80:	08014a04 	.word	0x08014a04
 8009f84:	200017e4 	.word	0x200017e4

08009f88 <do_f_m_slash_mod>:
	'n_3' and the remainder 'n_2'. Input and output stack
	arguments are signed. An ambiguous condition exists if
	'n_1' is zero or if the quotient lies outside the range of
	a single-cell signed integer.
*******************************************************************************/
		{ sdcell d1; scell n1, q, r; n1 = spop(); d1 = spopd(); if (!n1) sabort("divide by zero"); q = d1 / n1; r = d1 % n1; /* fixup */ if (r && ((d1 < 0 && n1 > 0) || (d1 > 0 && n1 < 0))) q --, r += n1; spush(r); spush(q); }
 8009f88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8009f8a:	f7ff fc6d 	bl	8009868 <spop>
 8009f8e:	1c04      	adds	r4, r0, #0
 8009f90:	f7ff ffdc 	bl	8009f4c <spopd>
 8009f94:	1c07      	adds	r7, r0, #0
 8009f96:	1c0d      	adds	r5, r1, #0
 8009f98:	2c00      	cmp	r4, #0
 8009f9a:	d104      	bne.n	8009fa6 <do_f_m_slash_mod+0x1e>
 8009f9c:	4812      	ldr	r0, [pc, #72]	; (8009fe8 <do_f_m_slash_mod+0x60>)
 8009f9e:	4913      	ldr	r1, [pc, #76]	; (8009fec <do_f_m_slash_mod+0x64>)
 8009fa0:	3024      	adds	r0, #36	; 0x24
 8009fa2:	f7fe fd32 	bl	8008a0a <strabort>
 8009fa6:	17e3      	asrs	r3, r4, #31
 8009fa8:	1c22      	adds	r2, r4, #0
 8009faa:	9301      	str	r3, [sp, #4]
 8009fac:	f004 fe7e 	bl	800ecac <__aeabi_ldivmod>
 8009fb0:	1c29      	adds	r1, r5, #0
 8009fb2:	1c06      	adds	r6, r0, #0
 8009fb4:	1c22      	adds	r2, r4, #0
 8009fb6:	1c38      	adds	r0, r7, #0
 8009fb8:	9b01      	ldr	r3, [sp, #4]
 8009fba:	f004 fe77 	bl	800ecac <__aeabi_ldivmod>
 8009fbe:	2a00      	cmp	r2, #0
 8009fc0:	d00a      	beq.n	8009fd8 <do_f_m_slash_mod+0x50>
 8009fc2:	2d00      	cmp	r5, #0
 8009fc4:	da02      	bge.n	8009fcc <do_f_m_slash_mod+0x44>
 8009fc6:	2c00      	cmp	r4, #0
 8009fc8:	dc04      	bgt.n	8009fd4 <do_f_m_slash_mod+0x4c>
 8009fca:	e005      	b.n	8009fd8 <do_f_m_slash_mod+0x50>
 8009fcc:	433d      	orrs	r5, r7
 8009fce:	d003      	beq.n	8009fd8 <do_f_m_slash_mod+0x50>
 8009fd0:	2c00      	cmp	r4, #0
 8009fd2:	da01      	bge.n	8009fd8 <do_f_m_slash_mod+0x50>
 8009fd4:	3e01      	subs	r6, #1
 8009fd6:	1912      	adds	r2, r2, r4
 8009fd8:	1c10      	adds	r0, r2, #0
 8009fda:	f7ff fcd4 	bl	8009986 <spush>
 8009fde:	1c30      	adds	r0, r6, #0
 8009fe0:	f7ff fcd1 	bl	8009986 <spush>
 8009fe4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009fe6:	46c0      	nop			; (mov r8, r8)
 8009fe8:	08013834 	.word	0x08013834
 8009fec:	08014a3b 	.word	0x08014a3b

08009ff0 <do_i>:
	( R]{loop-sys -- loop-sys)
	'n|u' is a copy of the current (innermost) loop index.
	An ambiguous condition exists if the loop control parameters
	are unavailable.
*******************************************************************************/
		{ if (rsp < 2) sabort("return stack underflow"); push(rstack[rsp - 1]); }
 8009ff0:	b508      	push	{r3, lr}
 8009ff2:	4b08      	ldr	r3, [pc, #32]	; (800a014 <do_i+0x24>)
 8009ff4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ff6:	2b01      	cmp	r3, #1
 8009ff8:	dc04      	bgt.n	800a004 <do_i+0x14>
 8009ffa:	4807      	ldr	r0, [pc, #28]	; (800a018 <do_i+0x28>)
 8009ffc:	4907      	ldr	r1, [pc, #28]	; (800a01c <do_i+0x2c>)
 8009ffe:	3035      	adds	r0, #53	; 0x35
 800a000:	f7fe fd03 	bl	8008a0a <strabort>
 800a004:	4a06      	ldr	r2, [pc, #24]	; (800a020 <do_i+0x30>)
 800a006:	3b01      	subs	r3, #1
 800a008:	009b      	lsls	r3, r3, #2
 800a00a:	18d3      	adds	r3, r2, r3
 800a00c:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800a00e:	f7fe fd0f 	bl	8008a30 <push>
 800a012:	bd08      	pop	{r3, pc}
 800a014:	20001364 	.word	0x20001364
 800a018:	08013834 	.word	0x08013834
 800a01c:	08014a4a 	.word	0x08014a4a
 800a020:	20001964 	.word	0x20001964

0800a024 <do_j>:
	( R]{loop-sys_1 loop-sys_2 -- loop-sys_1 loop-sys_2)
	'n|u' is a copy of the next-outer loop index. An
	ambiguous condition exists if the loop control parameters of
	the next-outer loop, 'loop-sys_1', are unavailable.
*******************************************************************************/
		{ if (rsp < 4) sabort("return stack underflow"); push(rstack[rsp - 3]); }
 800a024:	b508      	push	{r3, lr}
 800a026:	4b08      	ldr	r3, [pc, #32]	; (800a048 <do_j+0x24>)
 800a028:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a02a:	2b03      	cmp	r3, #3
 800a02c:	dc04      	bgt.n	800a038 <do_j+0x14>
 800a02e:	4807      	ldr	r0, [pc, #28]	; (800a04c <do_j+0x28>)
 800a030:	4907      	ldr	r1, [pc, #28]	; (800a050 <do_j+0x2c>)
 800a032:	303a      	adds	r0, #58	; 0x3a
 800a034:	f7fe fce9 	bl	8008a0a <strabort>
 800a038:	4a06      	ldr	r2, [pc, #24]	; (800a054 <do_j+0x30>)
 800a03a:	3b03      	subs	r3, #3
 800a03c:	009b      	lsls	r3, r3, #2
 800a03e:	18d3      	adds	r3, r2, r3
 800a040:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800a042:	f7fe fcf5 	bl	8008a30 <push>
 800a046:	bd08      	pop	{r3, pc}
 800a048:	20001364 	.word	0x20001364
 800a04c:	08013834 	.word	0x08013834
 800a050:	08014a4a 	.word	0x08014a4a
 800a054:	20001964 	.word	0x20001964

0800a058 <two_r_fetch>:
static inline void ddup(void) { if (!sp) sabort("data stack empty"); if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp] = dstack[sp - 1]; sp ++; }

/* return stack manipulation routines */
static inline void two_to_r(void) { if (sp < 2 || rsp > RSTACK_SIZE - 2) sabort("bad stack"); rstack[rsp] = dstack[sp - 2]; rstack[rsp + 1] = dstack[sp - 1]; sp -= 2; rsp += 2; }
static inline void two_r_from(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; rsp -= 2; sp += 2; }
static inline void two_r_fetch(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; sp += 2; }
 800a058:	4810      	ldr	r0, [pc, #64]	; (800a09c <two_r_fetch+0x44>)
 800a05a:	b570      	push	{r4, r5, r6, lr}
 800a05c:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a05e:	2b01      	cmp	r3, #1
 800a060:	dd02      	ble.n	800a068 <two_r_fetch+0x10>
 800a062:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800a064:	2a1e      	cmp	r2, #30
 800a066:	dd04      	ble.n	800a072 <two_r_fetch+0x1a>
 800a068:	480d      	ldr	r0, [pc, #52]	; (800a0a0 <two_r_fetch+0x48>)
 800a06a:	490e      	ldr	r1, [pc, #56]	; (800a0a4 <two_r_fetch+0x4c>)
 800a06c:	303f      	adds	r0, #63	; 0x3f
 800a06e:	f7fe fccc 	bl	8008a0a <strabort>
 800a072:	4c0d      	ldr	r4, [pc, #52]	; (800a0a8 <two_r_fetch+0x50>)
 800a074:	1e9d      	subs	r5, r3, #2
 800a076:	00ad      	lsls	r5, r5, #2
 800a078:	4e0c      	ldr	r6, [pc, #48]	; (800a0ac <two_r_fetch+0x54>)
 800a07a:	1965      	adds	r5, r4, r5
 800a07c:	6aad      	ldr	r5, [r5, #40]	; 0x28
 800a07e:	0091      	lsls	r1, r2, #2
 800a080:	3b01      	subs	r3, #1
 800a082:	1871      	adds	r1, r6, r1
 800a084:	009b      	lsls	r3, r3, #2
 800a086:	614d      	str	r5, [r1, #20]
 800a088:	18e3      	adds	r3, r4, r3
 800a08a:	1c51      	adds	r1, r2, #1
 800a08c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a08e:	0089      	lsls	r1, r1, #2
 800a090:	1871      	adds	r1, r6, r1
 800a092:	3202      	adds	r2, #2
 800a094:	614b      	str	r3, [r1, #20]
 800a096:	6342      	str	r2, [r0, #52]	; 0x34
 800a098:	bd70      	pop	{r4, r5, r6, pc}
 800a09a:	46c0      	nop			; (mov r8, r8)
 800a09c:	20001364 	.word	0x20001364
 800a0a0:	08013834 	.word	0x08013834
 800a0a4:	08014ad1 	.word	0x08014ad1
 800a0a8:	20001964 	.word	0x20001964
 800a0ac:	200017e4 	.word	0x200017e4

0800a0b0 <runtime_loop>:
static void runtime_branch(void)
{ IP.word += * IP.cell; }
static void runtime_literal(void)
{ push(* IP.cell ++); }
static void runtime_loop(void)
{
 800a0b0:	b508      	push	{r3, lr}
	two_r_fetch();
 800a0b2:	f7ff ffd1 	bl	800a058 <two_r_fetch>
	push(pop() + 1);
 800a0b6:	f7fe fe09 	bl	8008ccc <pop>
 800a0ba:	3001      	adds	r0, #1
 800a0bc:	f7fe fcb8 	bl	8008a30 <push>
	rpop();
 800a0c0:	f7ff fcfc 	bl	8009abc <rpop>
	rpush(top());
 800a0c4:	f7ff f939 	bl	800933a <top>
 800a0c8:	f7ff fe1e 	bl	8009d08 <rpush>
	do_equals();
 800a0cc:	f7ff f9cd 	bl	800946a <do_equals>
}
 800a0d0:	bd08      	pop	{r3, pc}

0800a0d2 <do_two_r_fetch>:
	( R]{x_1 x_2 -- x_1 x_2)
	Copy cell pair 'x_1 x_2' from the return stack.
	Semantically equivalent to 'Rfrom' 'Rfrom' '2DUP'
	'toR' 'toR' 'SWAP'.
*******************************************************************************/
		{ two_r_fetch(); }
 800a0d2:	b508      	push	{r3, lr}
 800a0d4:	f7ff ffc0 	bl	800a058 <two_r_fetch>
 800a0d8:	bd08      	pop	{r3, pc}

0800a0da <do_mod>:
	returned by either the phrase
	'toR' 'StoD' 'Rfrom' 'FM/MOD' 'DROP'
	or the phrase
	'toR' 'StoD' 'Rfrom' 'SM/REM' 'DROP'.
*******************************************************************************/
		{ dcell x = popd(); if (!(cell)(x >> CELL_NR_BITS)) sabort("divide by zero"); push(((scell) (cell) x) % ((scell)(cell)(x >> CELL_NR_BITS))); }
 800a0da:	b508      	push	{r3, lr}
 800a0dc:	f7ff f94e 	bl	800937c <popd>
 800a0e0:	2900      	cmp	r1, #0
 800a0e2:	d104      	bne.n	800a0ee <do_mod+0x14>
 800a0e4:	4805      	ldr	r0, [pc, #20]	; (800a0fc <do_mod+0x22>)
 800a0e6:	4906      	ldr	r1, [pc, #24]	; (800a100 <do_mod+0x26>)
 800a0e8:	304b      	adds	r0, #75	; 0x4b
 800a0ea:	f7fe fc8e 	bl	8008a0a <strabort>
 800a0ee:	f004 fdc5 	bl	800ec7c <__aeabi_idivmod>
 800a0f2:	1c08      	adds	r0, r1, #0
 800a0f4:	f7fe fc9c 	bl	8008a30 <push>
 800a0f8:	bd08      	pop	{r3, pc}
 800a0fa:	46c0      	nop			; (mov r8, r8)
 800a0fc:	08013834 	.word	0x08013834
 800a100:	08014a3b 	.word	0x08014a3b

0800a104 <do_over>:
static inline void two_to_r(void) { if (sp < 2 || rsp > RSTACK_SIZE - 2) sabort("bad stack"); rstack[rsp] = dstack[sp - 2]; rstack[rsp + 1] = dstack[sp - 1]; sp -= 2; rsp += 2; }
static inline void two_r_from(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; rsp -= 2; sp += 2; }
static inline void two_r_fetch(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; sp += 2; }

/* over routines */
static inline void over(void) { if (sp < 2 || sp == DSTACK_SIZE) sabort("cannot execute over in data stack"); dstack[sp] = dstack[sp - 2]; sp ++; }
 800a104:	490b      	ldr	r1, [pc, #44]	; (800a134 <do_over+0x30>)
/*******************************************************************************
	OVER	 
( x_1 x_2 -- x_1 x_2 x_1)
	Place a copy of 'x_1' on top of the stack.
*******************************************************************************/
		{ over(); }
 800a106:	b510      	push	{r4, lr}
 800a108:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800a10a:	2b01      	cmp	r3, #1
 800a10c:	dd01      	ble.n	800a112 <do_over+0xe>
 800a10e:	2b20      	cmp	r3, #32
 800a110:	d104      	bne.n	800a11c <do_over+0x18>
 800a112:	4809      	ldr	r0, [pc, #36]	; (800a138 <do_over+0x34>)
 800a114:	4909      	ldr	r1, [pc, #36]	; (800a13c <do_over+0x38>)
 800a116:	3052      	adds	r0, #82	; 0x52
 800a118:	f7fe fc77 	bl	8008a0a <strabort>
 800a11c:	4808      	ldr	r0, [pc, #32]	; (800a140 <do_over+0x3c>)
 800a11e:	1e9a      	subs	r2, r3, #2
 800a120:	0092      	lsls	r2, r2, #2
 800a122:	1882      	adds	r2, r0, r2
 800a124:	6954      	ldr	r4, [r2, #20]
 800a126:	009a      	lsls	r2, r3, #2
 800a128:	1882      	adds	r2, r0, r2
 800a12a:	3301      	adds	r3, #1
 800a12c:	6154      	str	r4, [r2, #20]
 800a12e:	634b      	str	r3, [r1, #52]	; 0x34
 800a130:	bd10      	pop	{r4, pc}
 800a132:	46c0      	nop			; (mov r8, r8)
 800a134:	20001364 	.word	0x20001364
 800a138:	08013834 	.word	0x08013834
 800a13c:	08014adb 	.word	0x08014adb
 800a140:	200017e4 	.word	0x200017e4

0800a144 <do_r_fetch>:
\execute
	(  -- x)
	( R]{x -- x)
	Copy 'x' from the return stack to the data stack.
*******************************************************************************/
		{ push(rtop()); }
 800a144:	b508      	push	{r3, lr}
static inline void rpush(cell x) { if (rsp == RSTACK_SIZE) sabort("return stack overflow"); rstack[rsp ++] = x; }

/* top routines */
static inline cell top(void) { if (!sp) sabort("data stack empty"); return dstack[sp - 1]; }
static inline dcell topd(void) { dcell res; if (sp < 2) sabort("data stack underflow"); res = dstack[sp - 1]; res <<= CELL_NR_BITS; return res | dstack[sp - 2]; }
static inline cell rtop(void) { if (!rsp) sabort("return stack empty"); return rstack[rsp - 1]; }
 800a146:	4b08      	ldr	r3, [pc, #32]	; (800a168 <do_r_fetch+0x24>)
 800a148:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a14a:	2b00      	cmp	r3, #0
 800a14c:	d104      	bne.n	800a158 <do_r_fetch+0x14>
 800a14e:	4807      	ldr	r0, [pc, #28]	; (800a16c <do_r_fetch+0x28>)
 800a150:	4907      	ldr	r1, [pc, #28]	; (800a170 <do_r_fetch+0x2c>)
 800a152:	3057      	adds	r0, #87	; 0x57
 800a154:	f7fe fc59 	bl	8008a0a <strabort>
 800a158:	4a06      	ldr	r2, [pc, #24]	; (800a174 <do_r_fetch+0x30>)
 800a15a:	3b01      	subs	r3, #1
 800a15c:	009b      	lsls	r3, r3, #2
 800a15e:	18d3      	adds	r3, r2, r3
 800a160:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800a162:	f7fe fc65 	bl	8008a30 <push>
 800a166:	bd08      	pop	{r3, pc}
 800a168:	20001364 	.word	0x20001364
 800a16c:	08013834 	.word	0x08013834
 800a170:	08014afd 	.word	0x08014afd
 800a174:	20001964 	.word	0x20001964

0800a178 <do_s_m_slash_rem>:
	'n_3' and the remainder 'n_2'. Input and output stack
	arguments are signed. An ambiguous condition exists if 'n_1'
	is zero or if the quotient lies outside the range of a single-cell
	signed integer.
*******************************************************************************/
		{ sdcell x; scell q, r, y; y = spop(); x = spopd(); if (y == 0) sabort("divide by zero"); q = x / y; r = x % y; spush(r); spush(q); }
 800a178:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a17a:	f7ff fb75 	bl	8009868 <spop>
 800a17e:	1c04      	adds	r4, r0, #0
 800a180:	f7ff fee4 	bl	8009f4c <spopd>
 800a184:	1c06      	adds	r6, r0, #0
 800a186:	1c0f      	adds	r7, r1, #0
 800a188:	2c00      	cmp	r4, #0
 800a18a:	d104      	bne.n	800a196 <do_s_m_slash_rem+0x1e>
 800a18c:	480a      	ldr	r0, [pc, #40]	; (800a1b8 <do_s_m_slash_rem+0x40>)
 800a18e:	490b      	ldr	r1, [pc, #44]	; (800a1bc <do_s_m_slash_rem+0x44>)
 800a190:	305c      	adds	r0, #92	; 0x5c
 800a192:	f7fe fc3a 	bl	8008a0a <strabort>
 800a196:	17e5      	asrs	r5, r4, #31
 800a198:	1c2b      	adds	r3, r5, #0
 800a19a:	1c22      	adds	r2, r4, #0
 800a19c:	f004 fd86 	bl	800ecac <__aeabi_ldivmod>
 800a1a0:	1c10      	adds	r0, r2, #0
 800a1a2:	f7ff fbf0 	bl	8009986 <spush>
 800a1a6:	1c2b      	adds	r3, r5, #0
 800a1a8:	1c30      	adds	r0, r6, #0
 800a1aa:	1c39      	adds	r1, r7, #0
 800a1ac:	1c22      	adds	r2, r4, #0
 800a1ae:	f004 fd7d 	bl	800ecac <__aeabi_ldivmod>
 800a1b2:	f7ff fbe8 	bl	8009986 <spush>
 800a1b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a1b8:	08013834 	.word	0x08013834
 800a1bc:	08014a3b 	.word	0x08014a3b

0800a1c0 <pick>:
static inline void rot(void) { if (sp < 3) sabort("cannot execute rot in data stack"); cell x; x = dstack[sp - 3]; dstack[sp - 3] = dstack[sp - 2]; dstack[sp - 2] = dstack[sp - 1]; dstack[sp - 1] = x; }

/* r-from */
static inline void rfrom(void) { push(rpop()); }
/* pick routines */
static void pick(void) { cell i; i = pop(); if (sp < i + 1) sabort("bad stack for pick"); push(dstack[sp - 1 - i]); }
 800a1c0:	b508      	push	{r3, lr}
 800a1c2:	f7fe fd83 	bl	8008ccc <pop>
 800a1c6:	4b09      	ldr	r3, [pc, #36]	; (800a1ec <pick+0x2c>)
 800a1c8:	1c42      	adds	r2, r0, #1
 800a1ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a1cc:	4293      	cmp	r3, r2
 800a1ce:	d204      	bcs.n	800a1da <pick+0x1a>
 800a1d0:	4807      	ldr	r0, [pc, #28]	; (800a1f0 <pick+0x30>)
 800a1d2:	4908      	ldr	r1, [pc, #32]	; (800a1f4 <pick+0x34>)
 800a1d4:	306d      	adds	r0, #109	; 0x6d
 800a1d6:	f7fe fc18 	bl	8008a0a <strabort>
 800a1da:	3b01      	subs	r3, #1
 800a1dc:	1a18      	subs	r0, r3, r0
 800a1de:	4b06      	ldr	r3, [pc, #24]	; (800a1f8 <pick+0x38>)
 800a1e0:	0080      	lsls	r0, r0, #2
 800a1e2:	1818      	adds	r0, r3, r0
 800a1e4:	6940      	ldr	r0, [r0, #20]
 800a1e6:	f7fe fc23 	bl	8008a30 <push>
 800a1ea:	bd08      	pop	{r3, pc}
 800a1ec:	20001364 	.word	0x20001364
 800a1f0:	08013834 	.word	0x08013834
 800a1f4:	08014b10 	.word	0x08014b10
 800a1f8:	200017e4 	.word	0x200017e4

0800a1fc <roll>:
/* roll routines */
static void roll(void) { cell i; i = top(); pick(); xmemmove(dstack + sp - 1 - i - 1, dstack + sp - 1 - i, (i + 1) * sizeof * dstack); pop(); }
 800a1fc:	b510      	push	{r4, lr}
 800a1fe:	f7ff f89c 	bl	800933a <top>
 800a202:	1c04      	adds	r4, r0, #0
 800a204:	f7ff ffdc 	bl	800a1c0 <pick>
 800a208:	4b08      	ldr	r3, [pc, #32]	; (800a22c <roll+0x30>)
 800a20a:	4a09      	ldr	r2, [pc, #36]	; (800a230 <roll+0x34>)
 800a20c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a20e:	4909      	ldr	r1, [pc, #36]	; (800a234 <roll+0x38>)
 800a210:	1b1b      	subs	r3, r3, r4
 800a212:	189b      	adds	r3, r3, r2
 800a214:	009b      	lsls	r3, r3, #2
 800a216:	3114      	adds	r1, #20
 800a218:	18c8      	adds	r0, r1, r3
 800a21a:	1c62      	adds	r2, r4, #1
 800a21c:	3304      	adds	r3, #4
 800a21e:	18c9      	adds	r1, r1, r3
 800a220:	0092      	lsls	r2, r2, #2
 800a222:	f7fe fb9f 	bl	8008964 <xmemmove>
 800a226:	f7fe fd51 	bl	8008ccc <pop>
 800a22a:	bd10      	pop	{r4, pc}
 800a22c:	20001364 	.word	0x20001364
 800a230:	3ffffffe 	.word	0x3ffffffe
 800a234:	200017e4 	.word	0x200017e4

0800a238 <do_roll>:
( x_u x_{u-1} {\ldots} x_0 u -- x_{u-1) {\ldots} x_0 x_u}
	Remove 'u'. Rotate 'u'+1 items on the top of the stack.
	An ambiguous condition exists if there are less than 'u'+2
	items on the stack before 'ROLL' is executed.
*******************************************************************************/
		{ roll(); }
 800a238:	b508      	push	{r3, lr}
 800a23a:	f7ff ffdf 	bl	800a1fc <roll>
 800a23e:	bd08      	pop	{r3, pc}

0800a240 <do_pick>:
( x_u{\ldots}x_1 x_0 u -- x_u{\ldots)x_1 x_0 x_u}
	Remove 'u'. Copy the 'x_u' to the top of the stack.
	An ambiguous condition exists if there are less than 'u'+2
	items on the stack before 'PICK' is executed.
*******************************************************************************/
		{ pick(); }
 800a240:	b508      	push	{r3, lr}
 800a242:	f7ff ffbd 	bl	800a1c0 <pick>
 800a246:	bd08      	pop	{r3, pc}

0800a248 <do_two_to_r>:

/* dup routines */
static inline void ddup(void) { if (!sp) sabort("data stack empty"); if (sp == DSTACK_SIZE) sabort("data stack overflow"); dstack[sp] = dstack[sp - 1]; sp ++; }

/* return stack manipulation routines */
static inline void two_to_r(void) { if (sp < 2 || rsp > RSTACK_SIZE - 2) sabort("bad stack"); rstack[rsp] = dstack[sp - 2]; rstack[rsp + 1] = dstack[sp - 1]; sp -= 2; rsp += 2; }
 800a248:	4810      	ldr	r0, [pc, #64]	; (800a28c <do_two_to_r+0x44>)
	( x_1 x_2 -- )
	( R]{ -- x_1 x_2)
	Transfer cell pair 'x_1 x_2' to the return stack.
	Semantically equivalent to 'SWAP' 'toR' 'toR'.
*******************************************************************************/
		{ two_to_r(); }
 800a24a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a24c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800a24e:	2b01      	cmp	r3, #1
 800a250:	dd02      	ble.n	800a258 <do_two_to_r+0x10>
 800a252:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800a254:	2a1e      	cmp	r2, #30
 800a256:	dd04      	ble.n	800a262 <do_two_to_r+0x1a>
 800a258:	480d      	ldr	r0, [pc, #52]	; (800a290 <do_two_to_r+0x48>)
 800a25a:	490e      	ldr	r1, [pc, #56]	; (800a294 <do_two_to_r+0x4c>)
 800a25c:	3072      	adds	r0, #114	; 0x72
 800a25e:	f7fe fbd4 	bl	8008a0a <strabort>
 800a262:	1e9c      	subs	r4, r3, #2
 800a264:	4d0c      	ldr	r5, [pc, #48]	; (800a298 <do_two_to_r+0x50>)
 800a266:	00a1      	lsls	r1, r4, #2
 800a268:	4f0c      	ldr	r7, [pc, #48]	; (800a29c <do_two_to_r+0x54>)
 800a26a:	1869      	adds	r1, r5, r1
 800a26c:	6949      	ldr	r1, [r1, #20]
 800a26e:	0096      	lsls	r6, r2, #2
 800a270:	3b01      	subs	r3, #1
 800a272:	19be      	adds	r6, r7, r6
 800a274:	009b      	lsls	r3, r3, #2
 800a276:	62b1      	str	r1, [r6, #40]	; 0x28
 800a278:	18eb      	adds	r3, r5, r3
 800a27a:	1c51      	adds	r1, r2, #1
 800a27c:	695b      	ldr	r3, [r3, #20]
 800a27e:	0089      	lsls	r1, r1, #2
 800a280:	1879      	adds	r1, r7, r1
 800a282:	3202      	adds	r2, #2
 800a284:	628b      	str	r3, [r1, #40]	; 0x28
 800a286:	6344      	str	r4, [r0, #52]	; 0x34
 800a288:	6302      	str	r2, [r0, #48]	; 0x30
 800a28a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a28c:	20001364 	.word	0x20001364
 800a290:	08013834 	.word	0x08013834
 800a294:	08014ad1 	.word	0x08014ad1
 800a298:	200017e4 	.word	0x200017e4
 800a29c:	20001964 	.word	0x20001964

0800a2a0 <do_two_r_from>:
static inline void two_r_from(void) { if (rsp < 2 || sp > DSTACK_SIZE - 2) sabort("bad stack"); dstack[sp] = rstack[rsp - 2]; dstack[sp + 1] = rstack[rsp - 1]; rsp -= 2; sp += 2; }
 800a2a0:	4810      	ldr	r0, [pc, #64]	; (800a2e4 <do_two_r_from+0x44>)
	(  -- x_1 x_2)
	( R]{x_1 x_2 -- )
	Transfer cell pair 'x_1 x_2' from the return stack.
	Semantically equivalent to 'Rfrom' 'Rfrom' 'SWAP'.
*******************************************************************************/
		{ two_r_from(); }
 800a2a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a2a4:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800a2a6:	2b01      	cmp	r3, #1
 800a2a8:	dd02      	ble.n	800a2b0 <do_two_r_from+0x10>
 800a2aa:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800a2ac:	2a1e      	cmp	r2, #30
 800a2ae:	dd04      	ble.n	800a2ba <do_two_r_from+0x1a>
 800a2b0:	480d      	ldr	r0, [pc, #52]	; (800a2e8 <do_two_r_from+0x48>)
 800a2b2:	490e      	ldr	r1, [pc, #56]	; (800a2ec <do_two_r_from+0x4c>)
 800a2b4:	307b      	adds	r0, #123	; 0x7b
 800a2b6:	f7fe fba8 	bl	8008a0a <strabort>
 800a2ba:	1e9c      	subs	r4, r3, #2
 800a2bc:	4d0c      	ldr	r5, [pc, #48]	; (800a2f0 <do_two_r_from+0x50>)
 800a2be:	00a1      	lsls	r1, r4, #2
 800a2c0:	4f0c      	ldr	r7, [pc, #48]	; (800a2f4 <do_two_r_from+0x54>)
 800a2c2:	1869      	adds	r1, r5, r1
 800a2c4:	6a89      	ldr	r1, [r1, #40]	; 0x28
 800a2c6:	0096      	lsls	r6, r2, #2
 800a2c8:	3b01      	subs	r3, #1
 800a2ca:	19be      	adds	r6, r7, r6
 800a2cc:	009b      	lsls	r3, r3, #2
 800a2ce:	6171      	str	r1, [r6, #20]
 800a2d0:	18eb      	adds	r3, r5, r3
 800a2d2:	1c51      	adds	r1, r2, #1
 800a2d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a2d6:	0089      	lsls	r1, r1, #2
 800a2d8:	1879      	adds	r1, r7, r1
 800a2da:	3202      	adds	r2, #2
 800a2dc:	614b      	str	r3, [r1, #20]
 800a2de:	6304      	str	r4, [r0, #48]	; 0x30
 800a2e0:	6342      	str	r2, [r0, #52]	; 0x34
 800a2e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a2e4:	20001364 	.word	0x20001364
 800a2e8:	08013834 	.word	0x08013834
 800a2ec:	08014ad1 	.word	0x08014ad1
 800a2f0:	20001964 	.word	0x20001964
 800a2f4:	200017e4 	.word	0x200017e4

0800a2f8 <do_colon_no_name>:
	( i*x -- j*x)
	Execute the definition specified by 'xt'. The stack
	effects 'i*x' and 'j*x' represent arguments to
	and results from 'xt', respectively.
*******************************************************************************/
		{ struct word * w; if (state != STATE_INTERPRETING) sabort("bad state"); state = STATE_COMPILING; do_align(); w = (struct word *) here.cell; w->is_does_proper = w->is_immediate = 0; w->cfa = runtime_colon; w->name = 0; w->link = latest; latest = w; push((cell) w); here.chr += sizeof * w; do_align(); }
 800a2f8:	4b11      	ldr	r3, [pc, #68]	; (800a340 <do_colon_no_name+0x48>)
 800a2fa:	b570      	push	{r4, r5, r6, lr}
 800a2fc:	699e      	ldr	r6, [r3, #24]
 800a2fe:	2e00      	cmp	r6, #0
 800a300:	d004      	beq.n	800a30c <do_colon_no_name+0x14>
 800a302:	4810      	ldr	r0, [pc, #64]	; (800a344 <do_colon_no_name+0x4c>)
 800a304:	4910      	ldr	r1, [pc, #64]	; (800a348 <do_colon_no_name+0x50>)
 800a306:	3006      	adds	r0, #6
 800a308:	f7fe fb7f 	bl	8008a0a <strabort>
 800a30c:	2201      	movs	r2, #1
 800a30e:	4252      	negs	r2, r2
 800a310:	619a      	str	r2, [r3, #24]
 800a312:	f7fe fa43 	bl	800879c <do_align>
 800a316:	23fa      	movs	r3, #250	; 0xfa
 800a318:	4d0c      	ldr	r5, [pc, #48]	; (800a34c <do_colon_no_name+0x54>)
 800a31a:	68ac      	ldr	r4, [r5, #8]
 800a31c:	7a22      	ldrb	r2, [r4, #8]
 800a31e:	6066      	str	r6, [r4, #4]
 800a320:	4013      	ands	r3, r2
 800a322:	7223      	strb	r3, [r4, #8]
 800a324:	4b0a      	ldr	r3, [pc, #40]	; (800a350 <do_colon_no_name+0x58>)
 800a326:	1c20      	adds	r0, r4, #0
 800a328:	60e3      	str	r3, [r4, #12]
 800a32a:	4b0a      	ldr	r3, [pc, #40]	; (800a354 <do_colon_no_name+0x5c>)
 800a32c:	681a      	ldr	r2, [r3, #0]
 800a32e:	6022      	str	r2, [r4, #0]
 800a330:	601c      	str	r4, [r3, #0]
 800a332:	3410      	adds	r4, #16
 800a334:	f7fe fb7c 	bl	8008a30 <push>
 800a338:	60ac      	str	r4, [r5, #8]
 800a33a:	f7fe fa2f 	bl	800879c <do_align>
 800a33e:	bd70      	pop	{r4, r5, r6, pc}
 800a340:	20001264 	.word	0x20001264
 800a344:	080138b4 	.word	0x080138b4
 800a348:	08014a98 	.word	0x08014a98
 800a34c:	200011e4 	.word	0x200011e4
 800a350:	0800a6b9 	.word	0x0800a6b9
 800a354:	20000068 	.word	0x20000068

0800a358 <next_sym>:
	dict_end->link = latest;
	* ((const struct word **) & latest) = dict_start;
}

static uint8_t next_sym(void)
{
 800a358:	b508      	push	{r3, lr}
	while (input_spec.len == input_spec.idx) { do_refill(); if (pop() == C_FALSE) strabort(__func__, "error parsing escaped string\n"); }
 800a35a:	4b0a      	ldr	r3, [pc, #40]	; (800a384 <next_sym+0x2c>)
 800a35c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a35e:	6a99      	ldr	r1, [r3, #40]	; 0x28
 800a360:	4291      	cmp	r1, r2
 800a362:	d10a      	bne.n	800a37a <next_sym+0x22>
 800a364:	f7fe fc18 	bl	8008b98 <do_refill>
 800a368:	f7fe fcb0 	bl	8008ccc <pop>
 800a36c:	2800      	cmp	r0, #0
 800a36e:	d1f4      	bne.n	800a35a <next_sym+0x2>
 800a370:	4805      	ldr	r0, [pc, #20]	; (800a388 <next_sym+0x30>)
 800a372:	4906      	ldr	r1, [pc, #24]	; (800a38c <next_sym+0x34>)
 800a374:	3017      	adds	r0, #23
 800a376:	f7fe fb48 	bl	8008a0a <strabort>
	return input_spec.buf[input_spec.idx ++];
 800a37a:	1c50      	adds	r0, r2, #1
 800a37c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800a37e:	6258      	str	r0, [r3, #36]	; 0x24
 800a380:	5c88      	ldrb	r0, [r1, r2]
}
 800a382:	bd08      	pop	{r3, pc}
 800a384:	20001264 	.word	0x20001264
 800a388:	080138b4 	.word	0x080138b4
 800a38c:	08014b23 	.word	0x08014b23

0800a390 <postpone>:
void print_str(const char * str) { /* note that we can't simply do: 'push((cell) str); push(xstrlen(str)); do_type();', because the stack may be corrupted */ while (* str) sfputc(* (uint8_t *) str ++); }
void print_udecimal(cell x) { cell prev_base = base; base = 10; push(x); do_u_dot(); base = prev_base; }


static void postpone(const char * s)
{
 800a390:	b538      	push	{r3, r4, r5, lr}
 800a392:	1c04      	adds	r4, r0, #0
cell i;
	i = xstrlen(s);
 800a394:	f7fe facc 	bl	8008930 <xstrlen>
 800a398:	2380      	movs	r3, #128	; 0x80
 800a39a:	1c02      	adds	r2, r0, #0
 800a39c:	005b      	lsls	r3, r3, #1
 800a39e:	4298      	cmp	r0, r3
 800a3a0:	d900      	bls.n	800a3a4 <postpone+0x14>
 800a3a2:	1c1a      	adds	r2, r3, #0
	if (i > sizeof wordpad.buf)
		i = sizeof(wordpad.buf);
	wordpad.len = i;
 800a3a4:	4812      	ldr	r0, [pc, #72]	; (800a3f0 <postpone+0x60>)
	xmemcpy(wordpad.buf, s, i);
 800a3a6:	1c21      	adds	r1, r4, #0
 800a3a8:	1c05      	adds	r5, r0, #0
{
cell i;
	i = xstrlen(s);
	if (i > sizeof wordpad.buf)
		i = sizeof(wordpad.buf);
	wordpad.len = i;
 800a3aa:	1d43      	adds	r3, r0, #5
	xmemcpy(wordpad.buf, s, i);
 800a3ac:	3524      	adds	r5, #36	; 0x24
 800a3ae:	3025      	adds	r0, #37	; 0x25
{
cell i;
	i = xstrlen(s);
	if (i > sizeof wordpad.buf)
		i = sizeof(wordpad.buf);
	wordpad.len = i;
 800a3b0:	77da      	strb	r2, [r3, #31]
	xmemcpy(wordpad.buf, s, i);
 800a3b2:	f7fe fac6 	bl	8008942 <xmemcpy>
	push((cell) & wordpad);
 800a3b6:	1c28      	adds	r0, r5, #0
 800a3b8:	f7fe fb3a 	bl	8008a30 <push>
	do_find();
 800a3bc:	f7fe fd74 	bl	8008ea8 <do_find>
	switch (pop())
 800a3c0:	f7fe fc84 	bl	8008ccc <pop>
 800a3c4:	2800      	cmp	r0, #0
 800a3c6:	d10f      	bne.n	800a3e8 <postpone+0x58>
	{
		case 0:
			/* word not found */
			print_str("'");
 800a3c8:	4c0a      	ldr	r4, [pc, #40]	; (800a3f4 <postpone+0x64>)
 800a3ca:	1c20      	adds	r0, r4, #0
 800a3cc:	f7fe fb13 	bl	80089f6 <print_str>
			do_count();
 800a3d0:	f7fe fd2a 	bl	8008e28 <do_count>
			do_type();
 800a3d4:	f7fe fe08 	bl	8008fe8 <do_type>
			print_str("'");
 800a3d8:	1c20      	adds	r0, r4, #0
 800a3da:	f7fe fb0c 	bl	80089f6 <print_str>
			print_str(": cannot compile word, word not found\n");
 800a3de:	4806      	ldr	r0, [pc, #24]	; (800a3f8 <postpone+0x68>)
 800a3e0:	f7fe fb09 	bl	80089f6 <print_str>
			do_abort();
 800a3e4:	f7fe fa62 	bl	80088ac <do_abort>
	( xt -- )
	Append the execution semantics of the definition represented
	by 'xt' to the execution semantics of the current
	definition.
*******************************************************************************/
		{ do_comma(); }
 800a3e8:	f7fe fc8a 	bl	8008d00 <do_comma>
		default:
		/* compile */
			do_compile_comma();
			break;
	}
}
 800a3ec:	bd38      	pop	{r3, r4, r5, pc}
 800a3ee:	46c0      	nop			; (mov r8, r8)
 800a3f0:	20001864 	.word	0x20001864
 800a3f4:	08014c0d 	.word	0x08014c0d
 800a3f8:	08014b41 	.word	0x08014b41

0800a3fc <do_do>:
	limit 'n_1|u_1'. An ambiguous condition exists if
	'n_1|u_1' and 'n_2|u_2' are not both the same
	type. Anything already on the return stack becomes unavailable
	until the loop-control parameters are discarded.
*******************************************************************************/
		{ postpone("2>r"); do_begin(); /* initialize 'leave' counter; this will be used for resolving 'leave's by 'loop'/'+loop' */ rpush(0); }
 800a3fc:	b508      	push	{r3, lr}
 800a3fe:	4804      	ldr	r0, [pc, #16]	; (800a410 <do_do+0x14>)
 800a400:	f7ff ffc6 	bl	800a390 <postpone>
 800a404:	f7fe fb5c 	bl	8008ac0 <do_begin>
 800a408:	2000      	movs	r0, #0
 800a40a:	f7ff fc7d 	bl	8009d08 <rpush>
 800a40e:	bd08      	pop	{r3, pc}
 800a410:	08014b68 	.word	0x08014b68

0800a414 <do_loop>:
	execution immediately following the loop. Otherwise continue
	execution at the beginning of the loop.
*******************************************************************************/
/******************************************************************************/
void /* "loop" */		do_loop(void)
{
 800a414:	b510      	push	{r4, lr}
cell i;
	* here.word ++ = & xt_runtime_loop;
 800a416:	4b0d      	ldr	r3, [pc, #52]	; (800a44c <do_loop+0x38>)
 800a418:	689a      	ldr	r2, [r3, #8]
 800a41a:	1d11      	adds	r1, r2, #4
 800a41c:	6099      	str	r1, [r3, #8]
 800a41e:	4b0c      	ldr	r3, [pc, #48]	; (800a450 <do_loop+0x3c>)
 800a420:	3320      	adds	r3, #32
 800a422:	6013      	str	r3, [r2, #0]
	do_until();
 800a424:	f7fe fdf2 	bl	800900c <do_until>
	postpone("2r>");
 800a428:	480a      	ldr	r0, [pc, #40]	; (800a454 <do_loop+0x40>)
 800a42a:	f7ff ffb1 	bl	800a390 <postpone>
	postpone("2drop");
 800a42e:	480a      	ldr	r0, [pc, #40]	; (800a458 <do_loop+0x44>)
 800a430:	f7ff ffae 	bl	800a390 <postpone>
	i = rpop();
 800a434:	f7ff fb42 	bl	8009abc <rpop>
 800a438:	1c04      	adds	r4, r0, #0
	while (i --)
 800a43a:	2c00      	cmp	r4, #0
 800a43c:	d005      	beq.n	800a44a <do_loop+0x36>
	{
		do_r_from();
 800a43e:	f7ff fb57 	bl	8009af0 <do_r_from>
 800a442:	3c01      	subs	r4, #1
		do_then();
 800a444:	f7fe fdae 	bl	8008fa4 <do_then>
 800a448:	e7f7      	b.n	800a43a <do_loop+0x26>
	}
}
 800a44a:	bd10      	pop	{r4, pc}
 800a44c:	200011e4 	.word	0x200011e4
 800a450:	080138b4 	.word	0x080138b4
 800a454:	08014b6c 	.word	0x08014b6c
 800a458:	08014b70 	.word	0x08014b70

0800a45c <do_postpone>:
	'name' to the current definition. An ambiguous condition
	exists if 'name' is not found.
*******************************************************************************/
/******************************************************************************/
void /* "postpone" */	do_postpone(void)
{
 800a45c:	b508      	push	{r3, lr}
	do_bl();
 800a45e:	f7fe fb37 	bl	8008ad0 <do_bl>
	do_word();
 800a462:	f7fe fea2 	bl	80091aa <do_word>
	do_find();
 800a466:	f7fe fd1f 	bl	8008ea8 <do_find>
	switch (spop())
 800a46a:	f7ff f9fd 	bl	8009868 <spop>
 800a46e:	2800      	cmp	r0, #0
 800a470:	d009      	beq.n	800a486 <do_postpone+0x2a>
 800a472:	2801      	cmp	r0, #1
 800a474:	d010      	beq.n	800a498 <do_postpone+0x3c>
 800a476:	1c43      	adds	r3, r0, #1
 800a478:	d110      	bne.n	800a49c <do_postpone+0x40>
			/* immediate word */
			do_compile_comma();
			break;
		case -1:
			/* non immediate word */
			do_literal();
 800a47a:	f7fe fd68 	bl	8008f4e <do_literal>
			postpone("compile,");
 800a47e:	4808      	ldr	r0, [pc, #32]	; (800a4a0 <do_postpone+0x44>)
 800a480:	f7ff ff86 	bl	800a390 <postpone>
			break;
 800a484:	e00a      	b.n	800a49c <do_postpone+0x40>
	do_word();
	do_find();
	switch (spop())
	{
		case 0:
			do_count();
 800a486:	f7fe fccf 	bl	8008e28 <do_count>
			do_type();
 800a48a:	f7fe fdad 	bl	8008fe8 <do_type>
			sabort(": word not found");
 800a48e:	4805      	ldr	r0, [pc, #20]	; (800a4a4 <do_postpone+0x48>)
 800a490:	4905      	ldr	r1, [pc, #20]	; (800a4a8 <do_postpone+0x4c>)
 800a492:	3030      	adds	r0, #48	; 0x30
 800a494:	f7fe fab9 	bl	8008a0a <strabort>
	( xt -- )
	Append the execution semantics of the definition represented
	by 'xt' to the execution semantics of the current
	definition.
*******************************************************************************/
		{ do_comma(); }
 800a498:	f7fe fc32 	bl	8008d00 <do_comma>
			/* non immediate word */
			do_literal();
			postpone("compile,");
			break;
	}
}
 800a49c:	bd08      	pop	{r3, pc}
 800a49e:	46c0      	nop			; (mov r8, r8)
 800a4a0:	08014b87 	.word	0x08014b87
 800a4a4:	080138b4 	.word	0x080138b4
 800a4a8:	08014b76 	.word	0x08014b76

0800a4ac <do_s_quote>:
	(  -- c-addr u)
	Return 'c-addr' and 'u' describing a string
	consisting of the characters 'ccc'. A program shall
	not alter the returned string.
*******************************************************************************/
{ do_c_quote(); postpone("count"); }
 800a4ac:	b508      	push	{r3, lr}
 800a4ae:	f7fe fede 	bl	800926e <do_c_quote>
 800a4b2:	4802      	ldr	r0, [pc, #8]	; (800a4bc <do_s_quote+0x10>)
 800a4b4:	f7ff ff6c 	bl	800a390 <postpone>
 800a4b8:	bd08      	pop	{r3, pc}
 800a4ba:	46c0      	nop			; (mov r8, r8)
 800a4bc:	08014b90 	.word	0x08014b90

0800a4c0 <do_dot_quote>:
	definition.
\runtime
	(  -- )
	Display 'ccc'.
*******************************************************************************/
		{ do_s_quote(); postpone("type"); }
 800a4c0:	b508      	push	{r3, lr}
 800a4c2:	f7ff fff3 	bl	800a4ac <do_s_quote>
 800a4c6:	4802      	ldr	r0, [pc, #8]	; (800a4d0 <do_dot_quote+0x10>)
 800a4c8:	f7ff ff62 	bl	800a390 <postpone>
 800a4cc:	bd08      	pop	{r3, pc}
 800a4ce:	46c0      	nop			; (mov r8, r8)
 800a4d0:	08014b96 	.word	0x08014b96

0800a4d4 <do_abort_quote>:
	( R]{j*x -- | j*x)
	Remove 'x_1' from the stack. If any bit of 'x_1' is not
	zero, display 'ccc' and perform an implementation-defined
	abort sequence that includes the function of 'ABORT'.
*******************************************************************************/
		{ do_s_quote(); postpone("rot"); do_if(); postpone("type"); postpone("cr"); postpone("abort"); do_then(); postpone("2drop"); }
 800a4d4:	b508      	push	{r3, lr}
 800a4d6:	f7ff ffe9 	bl	800a4ac <do_s_quote>
 800a4da:	480a      	ldr	r0, [pc, #40]	; (800a504 <do_abort_quote+0x30>)
 800a4dc:	f7ff ff58 	bl	800a390 <postpone>
 800a4e0:	f7fe fb16 	bl	8008b10 <do_if>
 800a4e4:	4808      	ldr	r0, [pc, #32]	; (800a508 <do_abort_quote+0x34>)
 800a4e6:	f7ff ff53 	bl	800a390 <postpone>
 800a4ea:	4808      	ldr	r0, [pc, #32]	; (800a50c <do_abort_quote+0x38>)
 800a4ec:	f7ff ff50 	bl	800a390 <postpone>
 800a4f0:	4807      	ldr	r0, [pc, #28]	; (800a510 <do_abort_quote+0x3c>)
 800a4f2:	f7ff ff4d 	bl	800a390 <postpone>
 800a4f6:	f7fe fd55 	bl	8008fa4 <do_then>
 800a4fa:	4806      	ldr	r0, [pc, #24]	; (800a514 <do_abort_quote+0x40>)
 800a4fc:	f7ff ff48 	bl	800a390 <postpone>
 800a500:	bd08      	pop	{r3, pc}
 800a502:	46c0      	nop			; (mov r8, r8)
 800a504:	08014b9b 	.word	0x08014b9b
 800a508:	08014b96 	.word	0x08014b96
 800a50c:	08014b9f 	.word	0x08014b9f
 800a510:	08014ba2 	.word	0x08014ba2
 800a514:	08014b70 	.word	0x08014b70

0800a518 <do_unloop>:
	Discard the loop-control parameters for the current nesting
	level. An 'UNLOOP' is required for each nesting level
	before the definition may be 'EXIT'ed. An ambiguous
	condition exists if the loop-control parameters are unavailable.
*******************************************************************************/
		{ postpone("2r>"); postpone("2drop"); }
 800a518:	b508      	push	{r3, lr}
 800a51a:	4803      	ldr	r0, [pc, #12]	; (800a528 <do_unloop+0x10>)
 800a51c:	f7ff ff38 	bl	800a390 <postpone>
 800a520:	4802      	ldr	r0, [pc, #8]	; (800a52c <do_unloop+0x14>)
 800a522:	f7ff ff35 	bl	800a390 <postpone>
 800a526:	bd08      	pop	{r3, pc}
 800a528:	08014b6c 	.word	0x08014b6c
 800a52c:	08014b70 	.word	0x08014b70

0800a530 <do_plus_loop>:
	one and the loop limit, continue execution at the beginning
	of the loop. Otherwise, discard the current loop control
	parameters and continue execution immediately following the
	loop.
*******************************************************************************/
{
 800a530:	b510      	push	{r4, lr}
int i;
	* here.word ++ = & xt_runtime_plus_loop;
 800a532:	4b0c      	ldr	r3, [pc, #48]	; (800a564 <do_plus_loop+0x34>)
 800a534:	689a      	ldr	r2, [r3, #8]
 800a536:	1d11      	adds	r1, r2, #4
 800a538:	6099      	str	r1, [r3, #8]
 800a53a:	4b0b      	ldr	r3, [pc, #44]	; (800a568 <do_plus_loop+0x38>)
 800a53c:	333c      	adds	r3, #60	; 0x3c
 800a53e:	6013      	str	r3, [r2, #0]
	do_until();
 800a540:	f7fe fd64 	bl	800900c <do_until>
	do_unloop();
 800a544:	f7ff ffe8 	bl	800a518 <do_unloop>
	/* resolve any 'leave's */
	i = rpop();
 800a548:	f7ff fab8 	bl	8009abc <rpop>
 800a54c:	1c04      	adds	r4, r0, #0
	while (i --)
 800a54e:	2c00      	cmp	r4, #0
 800a550:	d007      	beq.n	800a562 <do_plus_loop+0x32>

/* rot routines */
static inline void rot(void) { if (sp < 3) sabort("cannot execute rot in data stack"); cell x; x = dstack[sp - 3]; dstack[sp - 3] = dstack[sp - 2]; dstack[sp - 2] = dstack[sp - 1]; dstack[sp - 1] = x; }

/* r-from */
static inline void rfrom(void) { push(rpop()); }
 800a552:	f7ff fab3 	bl	8009abc <rpop>
 800a556:	f7fe fa6b 	bl	8008a30 <push>
 800a55a:	3c01      	subs	r4, #1
		rfrom(), do_then();
 800a55c:	f7fe fd22 	bl	8008fa4 <do_then>
 800a560:	e7f5      	b.n	800a54e <do_plus_loop+0x1e>
}
 800a562:	bd10      	pop	{r4, pc}
 800a564:	200011e4 	.word	0x200011e4
 800a568:	080138b4 	.word	0x080138b4

0800a56c <do_leave>:
	following the innermost syntactically enclosing
	'DO'\ldots'LOOP' or 'DO'\ldots'+LOOP'.
*******************************************************************************/
/******************************************************************************/
void /* "leave" */	do_leave(void)
{
 800a56c:	b510      	push	{r4, lr}
	cell x = rpop();
 800a56e:	f7ff faa5 	bl	8009abc <rpop>
 800a572:	1c04      	adds	r4, r0, #0
	do_unloop();
 800a574:	f7ff ffd0 	bl	800a518 <do_unloop>
	do_ahead();
 800a578:	f7fe fb76 	bl	8008c68 <do_ahead>
	do_to_r();
 800a57c:	f7ff fbde 	bl	8009d3c <do_to_r>
	rpush(x + 1);
 800a580:	1c60      	adds	r0, r4, #1
 800a582:	f7ff fbc1 	bl	8009d08 <rpush>
}
 800a586:	bd10      	pop	{r4, pc}

0800a588 <do_while>:
\runtime
	( x -- )
	If all bits of 'x' are zero, continue execution at the
	location specified by the resolution of 'orig'.
*******************************************************************************/
		{ push(0); do_literal(); postpone("<>"); do_if(); push(1); roll(); }
 800a588:	b508      	push	{r3, lr}
 800a58a:	2000      	movs	r0, #0
 800a58c:	f7fe fa50 	bl	8008a30 <push>
 800a590:	f7fe fcdd 	bl	8008f4e <do_literal>
 800a594:	4805      	ldr	r0, [pc, #20]	; (800a5ac <do_while+0x24>)
 800a596:	f7ff fefb 	bl	800a390 <postpone>
 800a59a:	f7fe fab9 	bl	8008b10 <do_if>
 800a59e:	2001      	movs	r0, #1
 800a5a0:	f7fe fa46 	bl	8008a30 <push>
 800a5a4:	f7ff fe2a 	bl	800a1fc <roll>
 800a5a8:	bd08      	pop	{r3, pc}
 800a5aa:	46c0      	nop			; (mov r8, r8)
 800a5ac:	08014ba8 	.word	0x08014ba8

0800a5b0 <do_question_do>:
	on the return stack becomes unavailable until the loop
	control parameters are discarded. An ambiguous condition
	exists if 'n_1|u_1' and 'n_2|u_2' are not both of
	the same type.
*******************************************************************************/
		{ postpone("over"); postpone("over"); postpone("="); do_if(); postpone("drop"); postpone("drop"); do_ahead(); push(1); do_roll(); do_then(); do_do(); rpop(); swap(); do_to_r(); rpush(1); }
 800a5b0:	b510      	push	{r4, lr}
 800a5b2:	4c14      	ldr	r4, [pc, #80]	; (800a604 <do_question_do+0x54>)
 800a5b4:	1c20      	adds	r0, r4, #0
 800a5b6:	f7ff feeb 	bl	800a390 <postpone>
 800a5ba:	1c20      	adds	r0, r4, #0
 800a5bc:	f7ff fee8 	bl	800a390 <postpone>
 800a5c0:	4811      	ldr	r0, [pc, #68]	; (800a608 <do_question_do+0x58>)
 800a5c2:	f7ff fee5 	bl	800a390 <postpone>
 800a5c6:	f7fe faa3 	bl	8008b10 <do_if>
 800a5ca:	4c10      	ldr	r4, [pc, #64]	; (800a60c <do_question_do+0x5c>)
 800a5cc:	1c20      	adds	r0, r4, #0
 800a5ce:	f7ff fedf 	bl	800a390 <postpone>
 800a5d2:	1c20      	adds	r0, r4, #0
 800a5d4:	f7ff fedc 	bl	800a390 <postpone>
 800a5d8:	f7fe fb46 	bl	8008c68 <do_ahead>
 800a5dc:	2001      	movs	r0, #1
 800a5de:	f7fe fa27 	bl	8008a30 <push>
( x_u x_{u-1} {\ldots} x_0 u -- x_{u-1) {\ldots} x_0 x_u}
	Remove 'u'. Rotate 'u'+1 items on the top of the stack.
	An ambiguous condition exists if there are less than 'u'+2
	items on the stack before 'ROLL' is executed.
*******************************************************************************/
		{ roll(); }
 800a5e2:	f7ff fe0b 	bl	800a1fc <roll>
	on the return stack becomes unavailable until the loop
	control parameters are discarded. An ambiguous condition
	exists if 'n_1|u_1' and 'n_2|u_2' are not both of
	the same type.
*******************************************************************************/
		{ postpone("over"); postpone("over"); postpone("="); do_if(); postpone("drop"); postpone("drop"); do_ahead(); push(1); do_roll(); do_then(); do_do(); rpop(); swap(); do_to_r(); rpush(1); }
 800a5e6:	f7fe fcdd 	bl	8008fa4 <do_then>
 800a5ea:	f7ff ff07 	bl	800a3fc <do_do>
 800a5ee:	f7ff fa65 	bl	8009abc <rpop>
 800a5f2:	f7ff fc7b 	bl	8009eec <swap>
 800a5f6:	f7ff fba1 	bl	8009d3c <do_to_r>
 800a5fa:	2001      	movs	r0, #1
 800a5fc:	f7ff fb84 	bl	8009d08 <rpush>
 800a600:	bd10      	pop	{r4, pc}
 800a602:	46c0      	nop			; (mov r8, r8)
 800a604:	08014bab 	.word	0x08014bab
 800a608:	08014bb0 	.word	0x08014bb0
 800a60c:	08014b71 	.word	0x08014b71

0800a610 <do_endcase>:
	definition.
\runtime
	( x -- )
	Discard the case selector 'x' and continue execution.
*******************************************************************************/
		{ int i = pop(); postpone("drop"); while (i --) do_then(); }
 800a610:	b510      	push	{r4, lr}
 800a612:	f7fe fb5b 	bl	8008ccc <pop>
 800a616:	1c04      	adds	r4, r0, #0
 800a618:	4804      	ldr	r0, [pc, #16]	; (800a62c <do_endcase+0x1c>)
 800a61a:	f7ff feb9 	bl	800a390 <postpone>
 800a61e:	2c00      	cmp	r4, #0
 800a620:	d003      	beq.n	800a62a <do_endcase+0x1a>
 800a622:	f7fe fcbf 	bl	8008fa4 <do_then>
 800a626:	3c01      	subs	r4, #1
 800a628:	e7f9      	b.n	800a61e <do_endcase+0xe>
 800a62a:	bd10      	pop	{r4, pc}
 800a62c:	08014b71 	.word	0x08014b71

0800a630 <do_of>:
	top value and continue execution at the location specified
	by the consumer of 'of-sys', e.g., following the next
	'ENDOF'. Otherwise, discard both values and continue
	execution in line.
*******************************************************************************/
		{ postpone("over"); postpone("="); do_if(); postpone("drop"); }
 800a630:	b508      	push	{r3, lr}
 800a632:	4806      	ldr	r0, [pc, #24]	; (800a64c <do_of+0x1c>)
 800a634:	f7ff feac 	bl	800a390 <postpone>
 800a638:	4805      	ldr	r0, [pc, #20]	; (800a650 <do_of+0x20>)
 800a63a:	f7ff fea9 	bl	800a390 <postpone>
 800a63e:	f7fe fa67 	bl	8008b10 <do_if>
 800a642:	4804      	ldr	r0, [pc, #16]	; (800a654 <do_of+0x24>)
 800a644:	f7ff fea4 	bl	800a390 <postpone>
 800a648:	bd08      	pop	{r3, pc}
 800a64a:	46c0      	nop			; (mov r8, r8)
 800a64c:	08014bab 	.word	0x08014bab
 800a650:	08014bb0 	.word	0x08014bb0
 800a654:	08014b71 	.word	0x08014b71

0800a658 <do_to>:
\note
	An ambiguous condition exists if any of	'POSTPONE',
	'[COMPILE]', ''' or '[']' are applied to
	'TO'.
*******************************************************************************/
{
 800a658:	b510      	push	{r4, lr}
/* : xto bl word find drop >body state @ 0 = if ( interpreting) ! else ( compiling) postpone literal postpone ! then ; immediate */
	do_bl(); do_word(); do_find(); if (!pop()) { do_count(); do_type(); sabort(": word not found"); }
 800a65a:	f7fe fa39 	bl	8008ad0 <do_bl>
 800a65e:	f7fe fda4 	bl	80091aa <do_word>
 800a662:	f7fe fc21 	bl	8008ea8 <do_find>
 800a666:	f7fe fb31 	bl	8008ccc <pop>
 800a66a:	2800      	cmp	r0, #0
 800a66c:	d108      	bne.n	800a680 <do_to+0x28>
 800a66e:	f7fe fbdb 	bl	8008e28 <do_count>
 800a672:	f7fe fcb9 	bl	8008fe8 <do_type>
 800a676:	480c      	ldr	r0, [pc, #48]	; (800a6a8 <do_to+0x50>)
 800a678:	490c      	ldr	r1, [pc, #48]	; (800a6ac <do_to+0x54>)
 800a67a:	304c      	adds	r0, #76	; 0x4c
 800a67c:	f7fe f9c5 	bl	8008a0a <strabort>
	do_to_body();
 800a680:	f7fe fb82 	bl	8008d88 <do_to_body>
	if (state == STATE_INTERPRETING)
 800a684:	4b0a      	ldr	r3, [pc, #40]	; (800a6b0 <do_to+0x58>)
 800a686:	699b      	ldr	r3, [r3, #24]
 800a688:	2b00      	cmp	r3, #0
 800a68a:	d106      	bne.n	800a69a <do_to+0x42>
	{
		cell * x = (cell *) pop();
 800a68c:	f7fe fb1e 	bl	8008ccc <pop>
 800a690:	1c04      	adds	r4, r0, #0
		* x = pop();
 800a692:	f7fe fb1b 	bl	8008ccc <pop>
 800a696:	6020      	str	r0, [r4, #0]
 800a698:	e004      	b.n	800a6a4 <do_to+0x4c>
	}
	else
		/* compiling */
		do_literal(), postpone("!");
 800a69a:	f7fe fc58 	bl	8008f4e <do_literal>
 800a69e:	4805      	ldr	r0, [pc, #20]	; (800a6b4 <do_to+0x5c>)
 800a6a0:	f7ff fe76 	bl	800a390 <postpone>
}
 800a6a4:	bd10      	pop	{r4, pc}
 800a6a6:	46c0      	nop			; (mov r8, r8)
 800a6a8:	080138b4 	.word	0x080138b4
 800a6ac:	08014b76 	.word	0x08014b76
 800a6b0:	20001264 	.word	0x20001264
 800a6b4:	08011b94 	.word	0x08011b94

0800a6b8 <runtime_colon>:
	}
	sp ++;
	rstack[rsp - 1] = i;
}
static void runtime_colon(void)
{
 800a6b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
struct word * w;
int nest;

	nest = 0;
 800a6ba:	2500      	movs	r5, #0
reenter:
	rpush((cell) IP.word);
 800a6bc:	4e2b      	ldr	r6, [pc, #172]	; (800a76c <runtime_colon+0xb4>)
 800a6be:	6830      	ldr	r0, [r6, #0]
 800a6c0:	f7ff fb22 	bl	8009d08 <rpush>

	if (env.colon_debug_enabled)
 800a6c4:	4f2a      	ldr	r7, [pc, #168]	; (800a770 <runtime_colon+0xb8>)
 800a6c6:	1c34      	adds	r4, r6, #0
 800a6c8:	6a3b      	ldr	r3, [r7, #32]
 800a6ca:	2b00      	cmp	r3, #0
 800a6cc:	d010      	beq.n	800a6f0 <runtime_colon+0x38>
	{
		print_str(__func__);
 800a6ce:	4829      	ldr	r0, [pc, #164]	; (800a774 <runtime_colon+0xbc>)
 800a6d0:	3052      	adds	r0, #82	; 0x52
 800a6d2:	f7fe f990 	bl	80089f6 <print_str>
		print_str("(): starting execution of colon word: ");
 800a6d6:	4828      	ldr	r0, [pc, #160]	; (800a778 <runtime_colon+0xc0>)
 800a6d8:	f7fe f98d 	bl	80089f6 <print_str>
		push((cell) WP->name); do_count(); do_type(); do_cr();
 800a6dc:	6873      	ldr	r3, [r6, #4]
 800a6de:	6858      	ldr	r0, [r3, #4]
 800a6e0:	f7fe f9a6 	bl	8008a30 <push>
 800a6e4:	f7fe fba0 	bl	8008e28 <do_count>
 800a6e8:	f7fe fc7e 	bl	8008fe8 <do_type>
 800a6ec:	f7fe fbb1 	bl	8008e52 <do_cr>
	}
	IP.word = (struct word **) & WP->pfa;
 800a6f0:	6873      	ldr	r3, [r6, #4]
 800a6f2:	3310      	adds	r3, #16
 800a6f4:	6033      	str	r3, [r6, #0]
back:
	while ((w = * IP.word ++))
 800a6f6:	6823      	ldr	r3, [r4, #0]
 800a6f8:	1d1a      	adds	r2, r3, #4
 800a6fa:	681b      	ldr	r3, [r3, #0]
 800a6fc:	6022      	str	r2, [r4, #0]
 800a6fe:	2b00      	cmp	r3, #0
 800a700:	d02a      	beq.n	800a758 <runtime_colon+0xa0>
	{
		WP = w;
		if (! w->is_does_proper)
 800a702:	7a1a      	ldrb	r2, [r3, #8]
	}
	IP.word = (struct word **) & WP->pfa;
back:
	while ((w = * IP.word ++))
	{
		WP = w;
 800a704:	6063      	str	r3, [r4, #4]
		if (! w->is_does_proper)
 800a706:	0752      	lsls	r2, r2, #29
 800a708:	d423      	bmi.n	800a752 <runtime_colon+0x9a>
		{
			if (WP->cfa == runtime_colon)
 800a70a:	68da      	ldr	r2, [r3, #12]
 800a70c:	4b1b      	ldr	r3, [pc, #108]	; (800a77c <runtime_colon+0xc4>)
 800a70e:	429a      	cmp	r2, r3
 800a710:	d101      	bne.n	800a716 <runtime_colon+0x5e>
			{
				nest ++;
 800a712:	3501      	adds	r5, #1
				goto reenter;
 800a714:	e7d2      	b.n	800a6bc <runtime_colon+0x4>
			}
			else
			{
				if (env.colon_debug_enabled)
 800a716:	6a3b      	ldr	r3, [r7, #32]
 800a718:	2b00      	cmp	r3, #0
 800a71a:	d016      	beq.n	800a74a <runtime_colon+0x92>
				{
					print_str(__func__);
 800a71c:	4815      	ldr	r0, [pc, #84]	; (800a774 <runtime_colon+0xbc>)
 800a71e:	3052      	adds	r0, #82	; 0x52
 800a720:	f7fe f969 	bl	80089f6 <print_str>
					print_str("(): natively executing word: ");
 800a724:	4816      	ldr	r0, [pc, #88]	; (800a780 <runtime_colon+0xc8>)
 800a726:	f7fe f966 	bl	80089f6 <print_str>
					if (WP->name)
 800a72a:	6863      	ldr	r3, [r4, #4]
 800a72c:	6858      	ldr	r0, [r3, #4]
 800a72e:	2800      	cmp	r0, #0
 800a730:	d006      	beq.n	800a740 <runtime_colon+0x88>
						push((cell) WP->name), do_count(), do_type(), do_cr();
 800a732:	f7fe f97d 	bl	8008a30 <push>
 800a736:	f7fe fb77 	bl	8008e28 <do_count>
 800a73a:	f7fe fc55 	bl	8008fe8 <do_type>
 800a73e:	e002      	b.n	800a746 <runtime_colon+0x8e>
					else
						print_str("<<< internal >>>"), do_cr();
 800a740:	4810      	ldr	r0, [pc, #64]	; (800a784 <runtime_colon+0xcc>)
 800a742:	f7fe f958 	bl	80089f6 <print_str>
 800a746:	f7fe fb84 	bl	8008e52 <do_cr>
				}
				WP->cfa();
 800a74a:	6863      	ldr	r3, [r4, #4]
 800a74c:	68db      	ldr	r3, [r3, #12]
 800a74e:	4798      	blx	r3
 800a750:	e7d1      	b.n	800a6f6 <runtime_colon+0x3e>
			}
		}
		else
			exec_does();
 800a752:	f7fe f987 	bl	8008a64 <exec_does>
 800a756:	e7ce      	b.n	800a6f6 <runtime_colon+0x3e>
	}
	IP.word = (struct word **) rpop();
 800a758:	f7ff f9b0 	bl	8009abc <rpop>
	if (nest --)
 800a75c:	1e6b      	subs	r3, r5, #1
			}
		}
		else
			exec_does();
	}
	IP.word = (struct word **) rpop();
 800a75e:	6020      	str	r0, [r4, #0]
	if (nest --)
 800a760:	2d00      	cmp	r5, #0
 800a762:	d001      	beq.n	800a768 <runtime_colon+0xb0>
 800a764:	1c1d      	adds	r5, r3, #0
 800a766:	e7c6      	b.n	800a6f6 <runtime_colon+0x3e>
		goto back;
}
 800a768:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a76a:	46c0      	nop			; (mov r8, r8)
 800a76c:	200011e4 	.word	0x200011e4
 800a770:	20001864 	.word	0x20001864
 800a774:	080138b4 	.word	0x080138b4
 800a778:	08014bb2 	.word	0x08014bb2
 800a77c:	0800a6b9 	.word	0x0800a6b9
 800a780:	08014bd9 	.word	0x08014bd9
 800a784:	08014bf7 	.word	0x08014bf7

0800a788 <interpret>:
	push((cell) & WP->pfa);
}
static void runtime_constant(void)
{ push(* WP->cells); }
static void interpret(void)
{
 800a788:	b510      	push	{r4, lr}
scell i;
struct word * xt;

	while (1)
	{
		push(' ');
 800a78a:	2020      	movs	r0, #32
 800a78c:	f7fe f950 	bl	8008a30 <push>
		do_word();
 800a790:	f7fe fd0b 	bl	80091aa <do_word>
		ddup();
 800a794:	f7ff f9b2 	bl	8009afc <ddup>
		do_count();
 800a798:	f7fe fb46 	bl	8008e28 <do_count>
		if (!pop())
 800a79c:	f7fe fa96 	bl	8008ccc <pop>
 800a7a0:	2800      	cmp	r0, #0
 800a7a2:	d104      	bne.n	800a7ae <interpret+0x26>
		{
			pop();
 800a7a4:	f7fe fa92 	bl	8008ccc <pop>
			pop();
 800a7a8:	f7fe fa90 	bl	8008ccc <pop>
					exec_does();
				break;

		}
	}
}
 800a7ac:	bd10      	pop	{r4, pc}
		{
			pop();
			pop();
			break;
		}
		pop();
 800a7ae:	f7fe fa8d 	bl	8008ccc <pop>
		do_find();
 800a7b2:	f7fe fb79 	bl	8008ea8 <do_find>
		switch (spop())
 800a7b6:	f7ff f857 	bl	8009868 <spop>
 800a7ba:	2800      	cmp	r0, #0
 800a7bc:	d004      	beq.n	800a7c8 <interpret+0x40>
 800a7be:	2801      	cmp	r0, #1
 800a7c0:	d037      	beq.n	800a832 <interpret+0xaa>
 800a7c2:	1c43      	adds	r3, r0, #1
 800a7c4:	d1e1      	bne.n	800a78a <interpret+0x2>
 800a7c6:	e02d      	b.n	800a824 <interpret+0x9c>
		{
			case 0:
				/* attempt to recognize a number */
				i = pop();
 800a7c8:	f7fe fa80 	bl	8008ccc <pop>
 800a7cc:	1c04      	adds	r4, r0, #0
				pushd(0);
 800a7ce:	2100      	movs	r1, #0
 800a7d0:	2000      	movs	r0, #0
 800a7d2:	f7fe feba 	bl	800954a <pushd>
				push(i);
 800a7d6:	1c20      	adds	r0, r4, #0
 800a7d8:	f7fe f92a 	bl	8008a30 <push>
				do_count();
 800a7dc:	f7fe fb24 	bl	8008e28 <do_count>
				do_to_number();
 800a7e0:	f7fe fee2 	bl	80095a8 <do_to_number>

				if (!pop())
 800a7e4:	f7fe fa72 	bl	8008ccc <pop>
 800a7e8:	2800      	cmp	r0, #0
 800a7ea:	d10c      	bne.n	800a806 <interpret+0x7e>
				{
					pop();
 800a7ec:	f7fe fa6e 	bl	8008ccc <pop>
					/* number detected */
					push(popd());
 800a7f0:	f7fe fdc4 	bl	800937c <popd>
 800a7f4:	f7fe f91c 	bl	8008a30 <push>
					if (state == STATE_COMPILING)
 800a7f8:	4b14      	ldr	r3, [pc, #80]	; (800a84c <interpret+0xc4>)
 800a7fa:	699b      	ldr	r3, [r3, #24]
 800a7fc:	3301      	adds	r3, #1
 800a7fe:	d1c4      	bne.n	800a78a <interpret+0x2>
						do_literal();
 800a800:	f7fe fba5 	bl	8008f4e <do_literal>
 800a804:	e7c1      	b.n	800a78a <interpret+0x2>
				}
				else
				{
					/* no number detected and word not found */
					print_str("word '");
 800a806:	4812      	ldr	r0, [pc, #72]	; (800a850 <interpret+0xc8>)
 800a808:	f7fe f8f5 	bl	80089f6 <print_str>
					push(i);
 800a80c:	1c20      	adds	r0, r4, #0
 800a80e:	f7fe f90f 	bl	8008a30 <push>
					do_count();
 800a812:	f7fe fb09 	bl	8008e28 <do_count>
					do_type();
 800a816:	f7fe fbe7 	bl	8008fe8 <do_type>
					print_str("' not found\n");
 800a81a:	480e      	ldr	r0, [pc, #56]	; (800a854 <interpret+0xcc>)
 800a81c:	f7fe f8eb 	bl	80089f6 <print_str>
					if (0 /* the 'abort' below will clean the stacks */) pop(), popd();
					do_abort();
 800a820:	f7fe f844 	bl	80088ac <do_abort>
				}
				break;
			case -1:
				/* non-immediate word */
				if (state == STATE_COMPILING)
 800a824:	4b09      	ldr	r3, [pc, #36]	; (800a84c <interpret+0xc4>)
 800a826:	699b      	ldr	r3, [r3, #24]
 800a828:	3301      	adds	r3, #1
 800a82a:	d102      	bne.n	800a832 <interpret+0xaa>
	( xt -- )
	Append the execution semantics of the definition represented
	by 'xt' to the execution semantics of the current
	definition.
*******************************************************************************/
		{ do_comma(); }
 800a82c:	f7fe fa68 	bl	8008d00 <do_comma>
 800a830:	e7ab      	b.n	800a78a <interpret+0x2>
					break;
				}
				/* fallout */
			case 1:
				/* immediate word, or interpreting */
				xt = (struct word *) pop();
 800a832:	f7fe fa4b 	bl	8008ccc <pop>
				WP = xt;
 800a836:	4b08      	ldr	r3, [pc, #32]	; (800a858 <interpret+0xd0>)
 800a838:	6058      	str	r0, [r3, #4]
				if (!xt->is_does_proper)
 800a83a:	7a03      	ldrb	r3, [r0, #8]
 800a83c:	075b      	lsls	r3, r3, #29
 800a83e:	d402      	bmi.n	800a846 <interpret+0xbe>
					xt->cfa();
 800a840:	68c3      	ldr	r3, [r0, #12]
 800a842:	4798      	blx	r3
 800a844:	e7a1      	b.n	800a78a <interpret+0x2>
				else
					exec_does();
 800a846:	f7fe f90d 	bl	8008a64 <exec_does>
 800a84a:	e79e      	b.n	800a78a <interpret+0x2>
 800a84c:	20001264 	.word	0x20001264
 800a850:	08014c08 	.word	0x08014c08
 800a854:	08014c0f 	.word	0x08014c0f
 800a858:	200011e4 	.word	0x200011e4

0800a85c <do_evaluate>:
	and input buffer, set 'toIN' to zero, and interpret. When
	the parse area is empty, restore the prior input source
	specification. Other stack effects are due to the words
	'EVALUATE'd.
*******************************************************************************/
{
 800a85c:	b510      	push	{r4, lr}
struct input_spec prev_input_spec = input_spec;
 800a85e:	4b1c      	ldr	r3, [pc, #112]	; (800a8d0 <do_evaluate+0x74>)
	and input buffer, set 'toIN' to zero, and interpret. When
	the parse area is empty, restore the prior input source
	specification. Other stack effects are due to the words
	'EVALUATE'd.
*******************************************************************************/
{
 800a860:	b086      	sub	sp, #24
struct input_spec prev_input_spec = input_spec;
 800a862:	aa02      	add	r2, sp, #8
 800a864:	3320      	adds	r3, #32
 800a866:	cb13      	ldmia	r3!, {r0, r1, r4}
 800a868:	c213      	stmia	r2!, {r0, r1, r4}
 800a86a:	681b      	ldr	r3, [r3, #0]
 800a86c:	6013      	str	r3, [r2, #0]
bool x;
	if (!(x = is_jmpenv_valid))
 800a86e:	4b19      	ldr	r3, [pc, #100]	; (800a8d4 <do_evaluate+0x78>)
 800a870:	3328      	adds	r3, #40	; 0x28
 800a872:	781b      	ldrb	r3, [r3, #0]
 800a874:	9301      	str	r3, [sp, #4]
 800a876:	2b00      	cmp	r3, #0
 800a878:	d10d      	bne.n	800a896 <do_evaluate+0x3a>
	{
		if (setjmp(jmpenv))
 800a87a:	4817      	ldr	r0, [pc, #92]	; (800a8d8 <do_evaluate+0x7c>)
 800a87c:	3038      	adds	r0, #56	; 0x38
 800a87e:	f002 f999 	bl	800cbb4 <setjmp>
 800a882:	2800      	cmp	r0, #0
 800a884:	d003      	beq.n	800a88e <do_evaluate+0x32>
		{
			/* exception taken */
			is_jmpenv_valid = false;
 800a886:	4b13      	ldr	r3, [pc, #76]	; (800a8d4 <do_evaluate+0x78>)
 800a888:	2200      	movs	r2, #0
 800a88a:	3328      	adds	r3, #40	; 0x28
 800a88c:	e01c      	b.n	800a8c8 <do_evaluate+0x6c>
			return;
		}
		is_jmpenv_valid = true;
 800a88e:	2201      	movs	r2, #1
 800a890:	4b10      	ldr	r3, [pc, #64]	; (800a8d4 <do_evaluate+0x78>)
 800a892:	3328      	adds	r3, #40	; 0x28
 800a894:	701a      	strb	r2, [r3, #0]
	}
	input_spec.source_id = SOURCE_ID_STRING; input_spec.idx = 0; input_spec.len = pop(); input_spec.str = (const uint8_t *) pop();
 800a896:	2301      	movs	r3, #1
 800a898:	4c0d      	ldr	r4, [pc, #52]	; (800a8d0 <do_evaluate+0x74>)
 800a89a:	425b      	negs	r3, r3
 800a89c:	6223      	str	r3, [r4, #32]
 800a89e:	2300      	movs	r3, #0
 800a8a0:	6263      	str	r3, [r4, #36]	; 0x24
 800a8a2:	f7fe fa13 	bl	8008ccc <pop>
 800a8a6:	62a0      	str	r0, [r4, #40]	; 0x28
 800a8a8:	f7fe fa10 	bl	8008ccc <pop>
 800a8ac:	62e0      	str	r0, [r4, #44]	; 0x2c
	interpret();
 800a8ae:	f7ff ff6b 	bl	800a788 <interpret>
	input_spec = prev_input_spec;
 800a8b2:	1c23      	adds	r3, r4, #0
 800a8b4:	aa02      	add	r2, sp, #8
 800a8b6:	3320      	adds	r3, #32
 800a8b8:	ca13      	ldmia	r2!, {r0, r1, r4}
 800a8ba:	c313      	stmia	r3!, {r0, r1, r4}
 800a8bc:	6812      	ldr	r2, [r2, #0]
 800a8be:	601a      	str	r2, [r3, #0]
	is_jmpenv_valid = x;
 800a8c0:	466a      	mov	r2, sp
 800a8c2:	4b04      	ldr	r3, [pc, #16]	; (800a8d4 <do_evaluate+0x78>)
 800a8c4:	7912      	ldrb	r2, [r2, #4]
 800a8c6:	3328      	adds	r3, #40	; 0x28
 800a8c8:	701a      	strb	r2, [r3, #0]
}
 800a8ca:	b006      	add	sp, #24
 800a8cc:	bd10      	pop	{r4, pc}
 800a8ce:	46c0      	nop			; (mov r8, r8)
 800a8d0:	20001264 	.word	0x20001264
 800a8d4:	200019e4 	.word	0x200019e4
 800a8d8:	20001764 	.word	0x20001764

0800a8dc <do_s_backslash_quote>:
\runtime (  -- c-addr u) \\
	Return 'c-addr' and 'u' describing a string consisting of
	the translation of the characters 'ccc'.  A program shall not
	alter the returned string.
*******************************************************************************/
{
 800a8dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	postpone then
	r> postpone literal postpone count ; immediate
*/
uint8_t * s, c;
int i;
	if (state == STATE_COMPILING)
 800a8de:	4f39      	ldr	r7, [pc, #228]	; (800a9c4 <do_s_backslash_quote+0xe8>)
 800a8e0:	69bb      	ldr	r3, [r7, #24]
 800a8e2:	3301      	adds	r3, #1
 800a8e4:	d101      	bne.n	800a8ea <do_s_backslash_quote+0xe>
		do_ahead();
 800a8e6:	f7fe f9bf 	bl	8008c68 <do_ahead>
	s = here.chr + 1;
 800a8ea:	4e37      	ldr	r6, [pc, #220]	; (800a9c8 <do_s_backslash_quote+0xec>)
 800a8ec:	68b3      	ldr	r3, [r6, #8]
 800a8ee:	1c5d      	adds	r5, r3, #1
	while (1) switch (c = next_sym())
 800a8f0:	f7ff fd32 	bl	800a358 <next_sym>
 800a8f4:	1e04      	subs	r4, r0, #0
 800a8f6:	2c22      	cmp	r4, #34	; 0x22
 800a8f8:	d041      	beq.n	800a97e <do_s_backslash_quote+0xa2>
 800a8fa:	285c      	cmp	r0, #92	; 0x5c
 800a8fc:	d13c      	bne.n	800a978 <do_s_backslash_quote+0x9c>
	{
		case '"': goto end_of_string;
		case '\\': switch (c = next_sym())
 800a8fe:	f7ff fd2b 	bl	800a358 <next_sym>
 800a902:	1e04      	subs	r4, r0, #0
 800a904:	2c6c      	cmp	r4, #108	; 0x6c
 800a906:	d028      	beq.n	800a95a <do_s_backslash_quote+0x7e>
 800a908:	286c      	cmp	r0, #108	; 0x6c
 800a90a:	d80f      	bhi.n	800a92c <do_s_backslash_quote+0x50>
 800a90c:	2861      	cmp	r0, #97	; 0x61
 800a90e:	d032      	beq.n	800a976 <do_s_backslash_quote+0x9a>
 800a910:	d804      	bhi.n	800a91c <do_s_backslash_quote+0x40>
 800a912:	2822      	cmp	r0, #34	; 0x22
 800a914:	d025      	beq.n	800a962 <do_s_backslash_quote+0x86>
 800a916:	285c      	cmp	r0, #92	; 0x5c
 800a918:	d02e      	beq.n	800a978 <do_s_backslash_quote+0x9c>
 800a91a:	e028      	b.n	800a96e <do_s_backslash_quote+0x92>
 800a91c:	2865      	cmp	r0, #101	; 0x65
 800a91e:	d015      	beq.n	800a94c <do_s_backslash_quote+0x70>
 800a920:	2866      	cmp	r0, #102	; 0x66
 800a922:	d015      	beq.n	800a950 <do_s_backslash_quote+0x74>
 800a924:	2862      	cmp	r0, #98	; 0x62
 800a926:	d122      	bne.n	800a96e <do_s_backslash_quote+0x92>
			   {
				   case 'a': c = '\a'; break;
				   case 'b': c = '\b'; break;
 800a928:	2408      	movs	r4, #8
 800a92a:	e025      	b.n	800a978 <do_s_backslash_quote+0x9c>
		do_ahead();
	s = here.chr + 1;
	while (1) switch (c = next_sym())
	{
		case '"': goto end_of_string;
		case '\\': switch (c = next_sym())
 800a92c:	2872      	cmp	r0, #114	; 0x72
 800a92e:	d016      	beq.n	800a95e <do_s_backslash_quote+0x82>
 800a930:	d804      	bhi.n	800a93c <do_s_backslash_quote+0x60>
 800a932:	286d      	cmp	r0, #109	; 0x6d
 800a934:	d00e      	beq.n	800a954 <do_s_backslash_quote+0x78>
 800a936:	2871      	cmp	r0, #113	; 0x71
 800a938:	d013      	beq.n	800a962 <do_s_backslash_quote+0x86>
 800a93a:	e018      	b.n	800a96e <do_s_backslash_quote+0x92>
 800a93c:	2876      	cmp	r0, #118	; 0x76
 800a93e:	d012      	beq.n	800a966 <do_s_backslash_quote+0x8a>
 800a940:	287a      	cmp	r0, #122	; 0x7a
 800a942:	d012      	beq.n	800a96a <do_s_backslash_quote+0x8e>
 800a944:	2874      	cmp	r0, #116	; 0x74
 800a946:	d112      	bne.n	800a96e <do_s_backslash_quote+0x92>
				   case 'l': c = 10; break;
				   case 'm': * s ++ = 13; c = 10; break;
				   case 'r': c = 13; break;
				   case '"':
				   case 'q': c = '"'; break;
				   case 't': c = 9; break;
 800a948:	2409      	movs	r4, #9
 800a94a:	e015      	b.n	800a978 <do_s_backslash_quote+0x9c>
		case '"': goto end_of_string;
		case '\\': switch (c = next_sym())
			   {
				   case 'a': c = '\a'; break;
				   case 'b': c = '\b'; break;
				   case 'e': c = 27; break;
 800a94c:	241b      	movs	r4, #27
 800a94e:	e013      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case 'f': c = '\f'; break;
 800a950:	240c      	movs	r4, #12
 800a952:	e011      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case 'l': c = 10; break;
				   case 'm': * s ++ = 13; c = 10; break;
 800a954:	230d      	movs	r3, #13
 800a956:	702b      	strb	r3, [r5, #0]
 800a958:	3501      	adds	r5, #1
 800a95a:	240a      	movs	r4, #10
 800a95c:	e00c      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case 'r': c = 13; break;
 800a95e:	240d      	movs	r4, #13
 800a960:	e00a      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case '"':
				   case 'q': c = '"'; break;
 800a962:	2422      	movs	r4, #34	; 0x22
 800a964:	e008      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case 't': c = 9; break;
				   case 'v': c = 11; break;
 800a966:	240b      	movs	r4, #11
 800a968:	e006      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case 'z': c = 0; break;
 800a96a:	2400      	movs	r4, #0
 800a96c:	e004      	b.n	800a978 <do_s_backslash_quote+0x9c>
				   case '\\': c = '\\'; break;
				   default: print_str("warning: unknown/invalid escape sequence in escaped string requested, ignoring\n");
 800a96e:	4817      	ldr	r0, [pc, #92]	; (800a9cc <do_s_backslash_quote+0xf0>)
 800a970:	f7fe f841 	bl	80089f6 <print_str>
 800a974:	e000      	b.n	800a978 <do_s_backslash_quote+0x9c>
	while (1) switch (c = next_sym())
	{
		case '"': goto end_of_string;
		case '\\': switch (c = next_sym())
			   {
				   case 'a': c = '\a'; break;
 800a976:	2407      	movs	r4, #7
				   case '\\': c = '\\'; break;
				   default: print_str("warning: unknown/invalid escape sequence in escaped string requested, ignoring\n");
			   }
			   /* fall out */
		default:
			   * s ++ = c;
 800a978:	702c      	strb	r4, [r5, #0]
 800a97a:	3501      	adds	r5, #1
			   continue;
	}
 800a97c:	e7b8      	b.n	800a8f0 <do_s_backslash_quote+0x14>
end_of_string:
	if ((i = s - here.chr - 1) > 255)
 800a97e:	68b0      	ldr	r0, [r6, #8]
 800a980:	1a2b      	subs	r3, r5, r0
 800a982:	3b01      	subs	r3, #1
 800a984:	2bff      	cmp	r3, #255	; 0xff
 800a986:	dd04      	ble.n	800a992 <do_s_backslash_quote+0xb6>
		strabort(__func__, "escaped string too large\n");
 800a988:	4811      	ldr	r0, [pc, #68]	; (800a9d0 <do_s_backslash_quote+0xf4>)
 800a98a:	4912      	ldr	r1, [pc, #72]	; (800a9d4 <do_s_backslash_quote+0xf8>)
 800a98c:	3060      	adds	r0, #96	; 0x60
 800a98e:	f7fe f83c 	bl	8008a0a <strabort>
	* here.chr = i;
 800a992:	7003      	strb	r3, [r0, #0]
	if (state == STATE_COMPILING)
 800a994:	69bb      	ldr	r3, [r7, #24]
 800a996:	3301      	adds	r3, #1
 800a998:	d10e      	bne.n	800a9b8 <do_s_backslash_quote+0xdc>
	{
		push((cell) here.chr);
 800a99a:	f7fe f849 	bl	8008a30 <push>
		here.chr = s;
 800a99e:	60b5      	str	r5, [r6, #8]
		do_align();
 800a9a0:	f7fd fefc 	bl	800879c <do_align>
/*******************************************************************************
	SWAP	 
( x_1 x_2 -- x_2 x_1)
	Exchange the top two stack items.
*******************************************************************************/
		{ swap(); }
 800a9a4:	f7ff faa2 	bl	8009eec <swap>
	if (state == STATE_COMPILING)
	{
		push((cell) here.chr);
		here.chr = s;
		do_align();
		do_swap(); do_then();
 800a9a8:	f7fe fafc 	bl	8008fa4 <do_then>
		do_literal(); postpone("count");
 800a9ac:	f7fe facf 	bl	8008f4e <do_literal>
 800a9b0:	4809      	ldr	r0, [pc, #36]	; (800a9d8 <do_s_backslash_quote+0xfc>)
 800a9b2:	f7ff fced 	bl	800a390 <postpone>
 800a9b6:	e003      	b.n	800a9c0 <do_s_backslash_quote+0xe4>
	}
	else
		push((cell) here.chr), do_count();
 800a9b8:	f7fe f83a 	bl	8008a30 <push>
 800a9bc:	f7fe fa34 	bl	8008e28 <do_count>
}
 800a9c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a9c2:	46c0      	nop			; (mov r8, r8)
 800a9c4:	20001264 	.word	0x20001264
 800a9c8:	200011e4 	.word	0x200011e4
 800a9cc:	08014c1c 	.word	0x08014c1c
 800a9d0:	080138b4 	.word	0x080138b4
 800a9d4:	08014c6c 	.word	0x08014c6c
 800a9d8:	08014b90 	.word	0x08014b90

0800a9dc <do_included>:

void /* "jmpenv" */	do_jmpenv(void)
		{ push((cell) &jmpenv); }

void /* "included" */	do_included(void)
{
 800a9dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	cell fd;
	struct input_spec saved_inspec;
	uint8_t	fname[MAX_FNAME_LEN];
}
istack[MAX_FILE_INCLUSION_DEPTH];
unsigned int fname_len = pop();
 800a9de:	f7fe f975 	bl	8008ccc <pop>
 800a9e2:	1c04      	adds	r4, r0, #0
const uint8_t * s = (const uint8_t *) pop();
 800a9e4:	f7fe f972 	bl	8008ccc <pop>
int exc_code;
#ifdef PETIT_FS
int filepos;
	filepos = pf_getpos();
#endif
	if (isp == MAX_FILE_INCLUSION_DEPTH)
 800a9e8:	4b4d      	ldr	r3, [pc, #308]	; (800ab20 <do_included+0x144>)
	struct input_spec saved_inspec;
	uint8_t	fname[MAX_FNAME_LEN];
}
istack[MAX_FILE_INCLUSION_DEPTH];
unsigned int fname_len = pop();
const uint8_t * s = (const uint8_t *) pop();
 800a9ea:	1c01      	adds	r1, r0, #0
int exc_code;
#ifdef PETIT_FS
int filepos;
	filepos = pf_getpos();
#endif
	if (isp == MAX_FILE_INCLUSION_DEPTH)
 800a9ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		print_str("inclusion level too deep, aborting\n");
 800a9ee:	484d      	ldr	r0, [pc, #308]	; (800ab24 <do_included+0x148>)
int exc_code;
#ifdef PETIT_FS
int filepos;
	filepos = pf_getpos();
#endif
	if (isp == MAX_FILE_INCLUSION_DEPTH)
 800a9f0:	2b05      	cmp	r3, #5
 800a9f2:	d01a      	beq.n	800aa2a <do_included+0x4e>
 800a9f4:	2c1f      	cmp	r4, #31
 800a9f6:	d900      	bls.n	800a9fa <do_included+0x1e>
 800a9f8:	241f      	movs	r4, #31
		print_str("inclusion level too deep, aborting\n");
		do_abort();
	}
	if (fname_len > sizeof istack[0].fname - 1)
		fname_len = sizeof istack[0].fname - 1;
	xmemcpy(istack[isp].fname, s, fname_len);
 800a9fa:	2534      	movs	r5, #52	; 0x34
 800a9fc:	435d      	muls	r5, r3
 800a9fe:	4b4a      	ldr	r3, [pc, #296]	; (800ab28 <do_included+0x14c>)
 800aa00:	1c22      	adds	r2, r4, #0
 800aa02:	195f      	adds	r7, r3, r5
 800aa04:	3714      	adds	r7, #20
 800aa06:	1c38      	adds	r0, r7, #0
 800aa08:	4e45      	ldr	r6, [pc, #276]	; (800ab20 <do_included+0x144>)
 800aa0a:	f7fd ff9a 	bl	8008942 <xmemcpy>
	istack[isp].fname[fname_len] = 0;
 800aa0e:	2100      	movs	r1, #0
 800aa10:	4b45      	ldr	r3, [pc, #276]	; (800ab28 <do_included+0x14c>)
	/*! \todo	define file open mode flags */
	if ((istack[isp].fd = sfopen((char *) istack[isp].fname, 0)) == EOF)
 800aa12:	1c38      	adds	r0, r7, #0
		do_abort();
	}
	if (fname_len > sizeof istack[0].fname - 1)
		fname_len = sizeof istack[0].fname - 1;
	xmemcpy(istack[isp].fname, s, fname_len);
	istack[isp].fname[fname_len] = 0;
 800aa14:	195b      	adds	r3, r3, r5
 800aa16:	191c      	adds	r4, r3, r4
 800aa18:	3410      	adds	r4, #16
 800aa1a:	7121      	strb	r1, [r4, #4]
	/*! \todo	define file open mode flags */
	if ((istack[isp].fd = sfopen((char *) istack[isp].fname, 0)) == EOF)
 800aa1c:	f000 f9e0 	bl	800ade0 <sfopen>
 800aa20:	1975      	adds	r5, r6, r5
 800aa22:	6328      	str	r0, [r5, #48]	; 0x30
 800aa24:	1c43      	adds	r3, r0, #1
 800aa26:	d104      	bne.n	800aa32 <do_included+0x56>
	{
		print_str("could not open included file\n");
 800aa28:	4840      	ldr	r0, [pc, #256]	; (800ab2c <do_included+0x150>)
 800aa2a:	f7fd ffe4 	bl	80089f6 <print_str>
		do_abort();
 800aa2e:	f7fd ff3d 	bl	80088ac <do_abort>
	}
	isp ++;
 800aa32:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800aa34:	3301      	adds	r3, #1
 800aa36:	62f3      	str	r3, [r6, #44]	; 0x2c
	if (isp == 1)
 800aa38:	2b01      	cmp	r3, #1
 800aa3a:	d12d      	bne.n	800aa98 <do_included+0xbc>
	{
		/* first entry in this function (not a nested invocation) -
		 * set-up the local jmpenv exception handler */
		xmemcpy(ijmpenv, jmpenv, sizeof jmpenv);
 800aa3c:	4c3c      	ldr	r4, [pc, #240]	; (800ab30 <do_included+0x154>)
 800aa3e:	483d      	ldr	r0, [pc, #244]	; (800ab34 <do_included+0x158>)
 800aa40:	3438      	adds	r4, #56	; 0x38
 800aa42:	1c21      	adds	r1, r4, #0
 800aa44:	225c      	movs	r2, #92	; 0x5c
 800aa46:	3034      	adds	r0, #52	; 0x34
 800aa48:	f7fd ff7b 	bl	8008942 <xmemcpy>
		if ((exc_code = setjmp(jmpenv)))
 800aa4c:	1c20      	adds	r0, r4, #0
 800aa4e:	f002 f8b1 	bl	800cbb4 <setjmp>
 800aa52:	1e05      	subs	r5, r0, #0
 800aa54:	d020      	beq.n	800aa98 <do_included+0xbc>
		{
			print_str("exception taken\n");
 800aa56:	4838      	ldr	r0, [pc, #224]	; (800ab38 <do_included+0x15c>)
 800aa58:	f7fd ffcd 	bl	80089f6 <print_str>
			while (isp --)
 800aa5c:	4c30      	ldr	r4, [pc, #192]	; (800ab20 <do_included+0x144>)
 800aa5e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800aa60:	1e5a      	subs	r2, r3, #1
 800aa62:	62e2      	str	r2, [r4, #44]	; 0x2c
 800aa64:	2b00      	cmp	r3, #0
 800aa66:	d00a      	beq.n	800aa7e <do_included+0xa2>
			{
				print_str("closing one file\n");
 800aa68:	4834      	ldr	r0, [pc, #208]	; (800ab3c <do_included+0x160>)
 800aa6a:	f7fd ffc4 	bl	80089f6 <print_str>
				sfclose(istack[isp].fd);
 800aa6e:	2334      	movs	r3, #52	; 0x34
 800aa70:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800aa72:	4353      	muls	r3, r2
 800aa74:	18e4      	adds	r4, r4, r3
 800aa76:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800aa78:	f000 f9b4 	bl	800ade4 <sfclose>
 800aa7c:	e7ee      	b.n	800aa5c <do_included+0x80>
			}
			isp = 0;
 800aa7e:	62e3      	str	r3, [r4, #44]	; 0x2c
			xmemcpy(jmpenv, ijmpenv, sizeof jmpenv);
 800aa80:	4c2b      	ldr	r4, [pc, #172]	; (800ab30 <do_included+0x154>)
 800aa82:	492c      	ldr	r1, [pc, #176]	; (800ab34 <do_included+0x158>)
 800aa84:	3438      	adds	r4, #56	; 0x38
 800aa86:	3134      	adds	r1, #52	; 0x34
 800aa88:	1c20      	adds	r0, r4, #0
 800aa8a:	225c      	movs	r2, #92	; 0x5c
 800aa8c:	f7fd ff59 	bl	8008942 <xmemcpy>
			/* rethrow exception */
			longjmp(jmpenv, exc_code);
 800aa90:	1c20      	adds	r0, r4, #0
 800aa92:	1c29      	adds	r1, r5, #0
 800aa94:	f002 f89a 	bl	800cbcc <longjmp>
		}
	}
	istack[isp - 1].saved_inspec = input_spec;
 800aa98:	4921      	ldr	r1, [pc, #132]	; (800ab20 <do_included+0x144>)
 800aa9a:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 800aa9c:	1e5a      	subs	r2, r3, #1
 800aa9e:	2334      	movs	r3, #52	; 0x34
 800aaa0:	435a      	muls	r2, r3
 800aaa2:	4b27      	ldr	r3, [pc, #156]	; (800ab40 <do_included+0x164>)
 800aaa4:	188a      	adds	r2, r1, r2
 800aaa6:	1c11      	adds	r1, r2, #0
 800aaa8:	1c18      	adds	r0, r3, #0
 800aaaa:	3134      	adds	r1, #52	; 0x34
 800aaac:	3020      	adds	r0, #32
 800aaae:	c870      	ldmia	r0!, {r4, r5, r6}
 800aab0:	c170      	stmia	r1!, {r4, r5, r6}
 800aab2:	6800      	ldr	r0, [r0, #0]
 800aab4:	6008      	str	r0, [r1, #0]
	input_spec.idx = input_spec.len = 0;
	input_spec.file_id = istack[isp - 1].fd;
 800aab6:	6b12      	ldr	r2, [r2, #48]	; 0x30
			/* rethrow exception */
			longjmp(jmpenv, exc_code);
		}
	}
	istack[isp - 1].saved_inspec = input_spec;
	input_spec.idx = input_spec.len = 0;
 800aab8:	2100      	movs	r1, #0
	input_spec.file_id = istack[isp - 1].fd;
 800aaba:	621a      	str	r2, [r3, #32]
	input_spec.buf = inbuf_area;
 800aabc:	1c1a      	adds	r2, r3, #0
 800aabe:	3230      	adds	r2, #48	; 0x30
			/* rethrow exception */
			longjmp(jmpenv, exc_code);
		}
	}
	istack[isp - 1].saved_inspec = input_spec;
	input_spec.idx = input_spec.len = 0;
 800aac0:	6299      	str	r1, [r3, #40]	; 0x28
 800aac2:	6259      	str	r1, [r3, #36]	; 0x24
	input_spec.file_id = istack[isp - 1].fd;
	input_spec.buf = inbuf_area;
 800aac4:	62da      	str	r2, [r3, #44]	; 0x2c
	while (1)
	{
		if (input_spec.idx == input_spec.len)
 800aac6:	4d1e      	ldr	r5, [pc, #120]	; (800ab40 <do_included+0x164>)
 800aac8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800aaca:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 800aacc:	4293      	cmp	r3, r2
 800aace:	d002      	beq.n	800aad6 <do_included+0xfa>
			do_refill();
			if (!pop())
				/* end of input */
				break;
		}
		interpret();
 800aad0:	f7ff fe5a 	bl	800a788 <interpret>
 800aad4:	e7f7      	b.n	800aac6 <do_included+0xea>
	input_spec.buf = inbuf_area;
	while (1)
	{
		if (input_spec.idx == input_spec.len)
		{
			do_refill();
 800aad6:	f7fe f85f 	bl	8008b98 <do_refill>
			if (!pop())
 800aada:	f7fe f8f7 	bl	8008ccc <pop>
 800aade:	2800      	cmp	r0, #0
 800aae0:	d1f6      	bne.n	800aad0 <do_included+0xf4>
				/* end of input */
				break;
		}
		interpret();
	}
	sfclose(istack[-- isp].fd);
 800aae2:	2434      	movs	r4, #52	; 0x34
 800aae4:	4e0e      	ldr	r6, [pc, #56]	; (800ab20 <do_included+0x144>)
 800aae6:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 800aae8:	3b01      	subs	r3, #1
 800aaea:	62f3      	str	r3, [r6, #44]	; 0x2c
 800aaec:	4363      	muls	r3, r4
 800aaee:	18f3      	adds	r3, r6, r3
 800aaf0:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800aaf2:	f000 f977 	bl	800ade4 <sfclose>
	input_spec = istack[isp].saved_inspec;
 800aaf6:	1c2a      	adds	r2, r5, #0
 800aaf8:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 800aafa:	3220      	adds	r2, #32
 800aafc:	434c      	muls	r4, r1
 800aafe:	1933      	adds	r3, r6, r4
 800ab00:	3334      	adds	r3, #52	; 0x34
 800ab02:	cb31      	ldmia	r3!, {r0, r4, r5}
 800ab04:	c231      	stmia	r2!, {r0, r4, r5}
 800ab06:	681b      	ldr	r3, [r3, #0]
 800ab08:	6013      	str	r3, [r2, #0]
	if (isp)
 800ab0a:	2900      	cmp	r1, #0
 800ab0c:	d106      	bne.n	800ab1c <do_included+0x140>
	;
#endif
	else
		/* leaving the chain of nested 'included' calls,
		 * restore the longjmp exception handling environment */
		xmemcpy(jmpenv, ijmpenv, sizeof jmpenv);
 800ab0e:	4808      	ldr	r0, [pc, #32]	; (800ab30 <do_included+0x154>)
 800ab10:	4908      	ldr	r1, [pc, #32]	; (800ab34 <do_included+0x158>)
 800ab12:	3038      	adds	r0, #56	; 0x38
 800ab14:	3134      	adds	r1, #52	; 0x34
 800ab16:	225c      	movs	r2, #92	; 0x5c
 800ab18:	f7fd ff13 	bl	8008942 <xmemcpy>
}
 800ab1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab1e:	46c0      	nop			; (mov r8, r8)
 800ab20:	200019e4 	.word	0x200019e4
 800ab24:	08014c86 	.word	0x08014c86
 800ab28:	20001a14 	.word	0x20001a14
 800ab2c:	08014caa 	.word	0x08014caa
 800ab30:	20001764 	.word	0x20001764
 800ab34:	20001ae4 	.word	0x20001ae4
 800ab38:	08014cc8 	.word	0x08014cc8
 800ab3c:	08014cd9 	.word	0x08014cd9
 800ab40:	20001264 	.word	0x20001264

0800ab44 <do_dot_s>:

void /* ".s" */		do_dot_s(void)
{
 800ab44:	b538      	push	{r3, r4, r5, lr}
 800ab46:	2400      	movs	r4, #0
int i;
	if (!sp)
 800ab48:	4b0c      	ldr	r3, [pc, #48]	; (800ab7c <do_dot_s+0x38>)
 800ab4a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ab4c:	1c1d      	adds	r5, r3, #0
 800ab4e:	42a2      	cmp	r2, r4
 800ab50:	d103      	bne.n	800ab5a <do_dot_s+0x16>
	{
		print_str("stack empty"); do_cr();
 800ab52:	480b      	ldr	r0, [pc, #44]	; (800ab80 <do_dot_s+0x3c>)
 800ab54:	f7fd ff4f 	bl	80089f6 <print_str>
 800ab58:	e00c      	b.n	800ab74 <do_dot_s+0x30>
	}
	else
	{
		for (i = 0; i < sp; i ++)
 800ab5a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800ab5c:	429c      	cmp	r4, r3
 800ab5e:	da09      	bge.n	800ab74 <do_dot_s+0x30>
			push(dstack[i]), do_dot();
 800ab60:	4b08      	ldr	r3, [pc, #32]	; (800ab84 <do_dot_s+0x40>)
 800ab62:	00a2      	lsls	r2, r4, #2
 800ab64:	3314      	adds	r3, #20
 800ab66:	58d0      	ldr	r0, [r2, r3]
 800ab68:	f7fd ff62 	bl	8008a30 <push>
	{
		print_str("stack empty"); do_cr();
	}
	else
	{
		for (i = 0; i < sp; i ++)
 800ab6c:	3401      	adds	r4, #1
			push(dstack[i]), do_dot();
 800ab6e:	f7ff f813 	bl	8009b98 <do_dot>
 800ab72:	e7f2      	b.n	800ab5a <do_dot_s+0x16>
		do_cr();
 800ab74:	f7fe f96d 	bl	8008e52 <do_cr>
	}
}
 800ab78:	bd38      	pop	{r3, r4, r5, pc}
 800ab7a:	46c0      	nop			; (mov r8, r8)
 800ab7c:	20001364 	.word	0x20001364
 800ab80:	08014a1e 	.word	0x08014a1e
 800ab84:	200017e4 	.word	0x200017e4

0800ab88 <do_dump>:

void /* "?" */		do_question(void)
		{ do_dup(), do_fetch(), do_dot(); }

void /* "dump" */		do_dump(void)
{
 800ab88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
int cnt = pop();
 800ab8a:	f7fe f89f 	bl	8008ccc <pop>
 800ab8e:	1c05      	adds	r5, r0, #0
unsigned int addr = pop();
 800ab90:	f7fe f89c 	bl	8008ccc <pop>
int i;
int saved_base = base;
 800ab94:	4b2f      	ldr	r3, [pc, #188]	; (800ac54 <do_dump+0xcc>)
		{ do_dup(), do_fetch(), do_dot(); }

void /* "dump" */		do_dump(void)
{
int cnt = pop();
unsigned int addr = pop();
 800ab96:	1c04      	adds	r4, r0, #0
int i;
int saved_base = base;
 800ab98:	695a      	ldr	r2, [r3, #20]
 800ab9a:	9301      	str	r3, [sp, #4]
 800ab9c:	9200      	str	r2, [sp, #0]
	/* dump header */
	base = 16;
 800ab9e:	2210      	movs	r2, #16
 800aba0:	615a      	str	r2, [r3, #20]
	if (cnt && (addr & 15))
 800aba2:	2d00      	cmp	r5, #0
 800aba4:	d02a      	beq.n	800abfc <do_dump+0x74>
 800aba6:	230f      	movs	r3, #15
 800aba8:	1c07      	adds	r7, r0, #0
 800abaa:	401f      	ands	r7, r3
 800abac:	d026      	beq.n	800abfc <do_dump+0x74>
	{
		push(addr & ~ 15);
 800abae:	4398      	bics	r0, r3
 800abb0:	f7fd ff3e 	bl	8008a30 <push>
		do_dot(), print_str(":\t");
 800abb4:	f7fe fff0 	bl	8009b98 <do_dot>
 800abb8:	4827      	ldr	r0, [pc, #156]	; (800ac58 <do_dump+0xd0>)
 800abba:	f7fd ff1c 	bl	80089f6 <print_str>
		for (i = 0; i < (addr & 15); i ++)
 800abbe:	2600      	movs	r6, #0
			print_str(".. ");
 800abc0:	4826      	ldr	r0, [pc, #152]	; (800ac5c <do_dump+0xd4>)
	base = 16;
	if (cnt && (addr & 15))
	{
		push(addr & ~ 15);
		do_dot(), print_str(":\t");
		for (i = 0; i < (addr & 15); i ++)
 800abc2:	3601      	adds	r6, #1
			print_str(".. ");
 800abc4:	f7fd ff17 	bl	80089f6 <print_str>
	base = 16;
	if (cnt && (addr & 15))
	{
		push(addr & ~ 15);
		do_dot(), print_str(":\t");
		for (i = 0; i < (addr & 15); i ++)
 800abc8:	42be      	cmp	r6, r7
 800abca:	d1f9      	bne.n	800abc0 <do_dump+0x38>
 800abcc:	1c26      	adds	r6, r4, #0
 800abce:	1b3b      	subs	r3, r7, r4
 800abd0:	199b      	adds	r3, r3, r6
			print_str(".. ");
		for (; i < 16 && cnt; i ++, cnt --)
 800abd2:	2b0f      	cmp	r3, #15
 800abd4:	dc32      	bgt.n	800ac3c <do_dump+0xb4>
 800abd6:	2d00      	cmp	r5, #0
 800abd8:	d030      	beq.n	800ac3c <do_dump+0xb4>
		{
			push(addr); do_c_fetch(); if (top() < 16) print_str("0");
 800abda:	1c30      	adds	r0, r6, #0
 800abdc:	f7fd ff28 	bl	8008a30 <push>
 800abe0:	f7fe f900 	bl	8008de4 <do_c_fetch>
 800abe4:	f7fe fba9 	bl	800933a <top>
 800abe8:	280f      	cmp	r0, #15
 800abea:	d802      	bhi.n	800abf2 <do_dump+0x6a>
 800abec:	481c      	ldr	r0, [pc, #112]	; (800ac60 <do_dump+0xd8>)
 800abee:	f7fd ff02 	bl	80089f6 <print_str>
			do_dot(); addr ++;
 800abf2:	f7fe ffd1 	bl	8009b98 <do_dot>
 800abf6:	3601      	adds	r6, #1
	{
		push(addr & ~ 15);
		do_dot(), print_str(":\t");
		for (i = 0; i < (addr & 15); i ++)
			print_str(".. ");
		for (; i < 16 && cnt; i ++, cnt --)
 800abf8:	3d01      	subs	r5, #1
 800abfa:	e7e8      	b.n	800abce <do_dump+0x46>
			push(addr); do_c_fetch(); if (top() < 16) print_str("0");
			do_dot(); addr ++;
		}
		do_cr();
	}
	while (cnt)
 800abfc:	2d00      	cmp	r5, #0
 800abfe:	d025      	beq.n	800ac4c <do_dump+0xc4>
	{
		push(addr & ~ 15);
 800ac00:	230f      	movs	r3, #15
 800ac02:	1c20      	adds	r0, r4, #0
 800ac04:	4398      	bics	r0, r3
 800ac06:	f7fd ff13 	bl	8008a30 <push>
 800ac0a:	1c26      	adds	r6, r4, #0
		do_dot(), print_str(":\t");
 800ac0c:	f7fe ffc4 	bl	8009b98 <do_dot>
 800ac10:	4811      	ldr	r0, [pc, #68]	; (800ac58 <do_dump+0xd0>)
 800ac12:	f7fd fef0 	bl	80089f6 <print_str>
 800ac16:	3610      	adds	r6, #16
		for (i = 0; i < 16 && cnt; i ++, cnt --)
		{
			push(addr); do_c_fetch(); if (top() < 16) print_str("0");
 800ac18:	1c20      	adds	r0, r4, #0
 800ac1a:	f7fd ff09 	bl	8008a30 <push>
 800ac1e:	f7fe f8e1 	bl	8008de4 <do_c_fetch>
 800ac22:	f7fe fb8a 	bl	800933a <top>
 800ac26:	280f      	cmp	r0, #15
 800ac28:	d802      	bhi.n	800ac30 <do_dump+0xa8>
 800ac2a:	480d      	ldr	r0, [pc, #52]	; (800ac60 <do_dump+0xd8>)
 800ac2c:	f7fd fee3 	bl	80089f6 <print_str>
			do_dot(); addr ++;
 800ac30:	3401      	adds	r4, #1
 800ac32:	f7fe ffb1 	bl	8009b98 <do_dot>
	}
	while (cnt)
	{
		push(addr & ~ 15);
		do_dot(), print_str(":\t");
		for (i = 0; i < 16 && cnt; i ++, cnt --)
 800ac36:	3d01      	subs	r5, #1
 800ac38:	42b4      	cmp	r4, r6
 800ac3a:	d103      	bne.n	800ac44 <do_dump+0xbc>
		{
			push(addr); do_c_fetch(); if (top() < 16) print_str("0");
			do_dot(); addr ++;
		}
		do_cr();
 800ac3c:	f7fe f909 	bl	8008e52 <do_cr>
 800ac40:	1c34      	adds	r4, r6, #0
 800ac42:	e7db      	b.n	800abfc <do_dump+0x74>
	}
	while (cnt)
	{
		push(addr & ~ 15);
		do_dot(), print_str(":\t");
		for (i = 0; i < 16 && cnt; i ++, cnt --)
 800ac44:	2d00      	cmp	r5, #0
 800ac46:	d1e7      	bne.n	800ac18 <do_dump+0x90>
 800ac48:	1c26      	adds	r6, r4, #0
 800ac4a:	e7f7      	b.n	800ac3c <do_dump+0xb4>
			push(addr); do_c_fetch(); if (top() < 16) print_str("0");
			do_dot(); addr ++;
		}
		do_cr();
	}
	base = saved_base;
 800ac4c:	9b01      	ldr	r3, [sp, #4]
 800ac4e:	9a00      	ldr	r2, [sp, #0]
 800ac50:	615a      	str	r2, [r3, #20]
}
 800ac52:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800ac54:	20001264 	.word	0x20001264
 800ac58:	08014ceb 	.word	0x08014ceb
 800ac5c:	08014cee 	.word	0x08014cee
 800ac60:	08012127 	.word	0x08012127

0800ac64 <print_udecimal>:
	if (d <= s) while (len --) * d ++ = * s ++; else { d += len; s += len; while (len --) * -- d = * -- s; } return dest; }
int xmemcmp(const void *s1, const void *s2, int len) { unsigned const char * c1 = (unsigned const char *) s1, * c2 = (unsigned const char *) s2; while (len) { if (* c1 < * c2) return -1; if (* c1 ++ > * c2 ++) return 1; len --; } return 0; }
int xstrncasecmp(const char * s1, const char * s2, int n) { int i; while (n --) { i = xtolower(* (uint8_t *) s1); i -= xtolower(* (uint8_t *) s2); if (! i) { s1 ++, s2 ++; continue; } if (i < 0) return -1; return 1; } return 0; }
int xstrncmp(const char * s1, const char * s2, int n) { int i; while (n --) { i = * (uint8_t *) s1; i -= * (uint8_t *) s2; if (! i) { s1 ++, s2 ++; continue; } if (i < 0) return -1; return 1; } return 0; }
void print_str(const char * str) { /* note that we can't simply do: 'push((cell) str); push(xstrlen(str)); do_type();', because the stack may be corrupted */ while (* str) sfputc(* (uint8_t *) str ++); }
void print_udecimal(cell x) { cell prev_base = base; base = 10; push(x); do_u_dot(); base = prev_base; }
 800ac64:	b538      	push	{r3, r4, r5, lr}
 800ac66:	230a      	movs	r3, #10
 800ac68:	4c04      	ldr	r4, [pc, #16]	; (800ac7c <print_udecimal+0x18>)
 800ac6a:	6965      	ldr	r5, [r4, #20]
 800ac6c:	6163      	str	r3, [r4, #20]
 800ac6e:	f7fd fedf 	bl	8008a30 <push>
 800ac72:	f7fe fd7d 	bl	8009770 <do_u_dot>
 800ac76:	6165      	str	r5, [r4, #20]
 800ac78:	bd38      	pop	{r3, r4, r5, pc}
 800ac7a:	46c0      	nop			; (mov r8, r8)
 800ac7c:	20001264 	.word	0x20001264

0800ac80 <do_quit>:
		This assumes the existence of a system-implementation word
		{\tt INTERPRET} that embodies the text interpreter semantics described in}
\cbend
	\end{implement}
*******************************************************************************/
{
 800ac80:	b513      	push	{r0, r1, r4, lr}
bool x;
	if (!(x = is_jmpenv_valid))
 800ac82:	4b26      	ldr	r3, [pc, #152]	; (800ad1c <do_quit+0x9c>)
 800ac84:	3328      	adds	r3, #40	; 0x28
 800ac86:	781b      	ldrb	r3, [r3, #0]
 800ac88:	9301      	str	r3, [sp, #4]
 800ac8a:	2b00      	cmp	r3, #0
 800ac8c:	d10d      	bne.n	800acaa <do_quit+0x2a>
	{
		int exc_code;
		if ((exc_code = setjmp(jmpenv)))
 800ac8e:	4824      	ldr	r0, [pc, #144]	; (800ad20 <do_quit+0xa0>)
 800ac90:	3038      	adds	r0, #56	; 0x38
 800ac92:	f001 ff8f 	bl	800cbb4 <setjmp>
		{
			/* exception taken - check reason */
			if (exc_code == SF_EXC_CODE_BYE)
 800ac96:	2802      	cmp	r0, #2
 800ac98:	d103      	bne.n	800aca2 <do_quit+0x22>
			{
				/* the 'bye' word was executed - abort the 'quit' interpreter */
				is_jmpenv_valid = false;
 800ac9a:	4b20      	ldr	r3, [pc, #128]	; (800ad1c <do_quit+0x9c>)
 800ac9c:	2200      	movs	r2, #0
 800ac9e:	3328      	adds	r3, #40	; 0x28
 800aca0:	e03a      	b.n	800ad18 <do_quit+0x98>
				return;
			}
			/* for other exception reasons - continue interpreting */
		}
		is_jmpenv_valid = true;
 800aca2:	2201      	movs	r2, #1
 800aca4:	4b1d      	ldr	r3, [pc, #116]	; (800ad1c <do_quit+0x9c>)
 800aca6:	3328      	adds	r3, #40	; 0x28
 800aca8:	701a      	strb	r2, [r3, #0]
	}
	rsp = 0;
 800acaa:	2200      	movs	r2, #0
 800acac:	4b1d      	ldr	r3, [pc, #116]	; (800ad24 <do_quit+0xa4>)
 800acae:	631a      	str	r2, [r3, #48]	; 0x30
	input_spec.source_id = SOURCE_ID_USER_INPUT_DEVICE;
 800acb0:	4b1d      	ldr	r3, [pc, #116]	; (800ad28 <do_quit+0xa8>)
	input_spec.buf = inbuf_area;
 800acb2:	1c19      	adds	r1, r3, #0
 800acb4:	3130      	adds	r1, #48	; 0x30
			/* for other exception reasons - continue interpreting */
		}
		is_jmpenv_valid = true;
	}
	rsp = 0;
	input_spec.source_id = SOURCE_ID_USER_INPUT_DEVICE;
 800acb6:	621a      	str	r2, [r3, #32]
	input_spec.buf = inbuf_area;
 800acb8:	62d9      	str	r1, [r3, #44]	; 0x2c
	input_spec.idx = input_spec.len = 0;
 800acba:	629a      	str	r2, [r3, #40]	; 0x28
 800acbc:	625a      	str	r2, [r3, #36]	; 0x24
	state = STATE_INTERPRETING;
 800acbe:	619a      	str	r2, [r3, #24]
	while (1)
	{
		if (input_spec.idx == input_spec.len)
 800acc0:	4b19      	ldr	r3, [pc, #100]	; (800ad28 <do_quit+0xa8>)
 800acc2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800acc4:	6a99      	ldr	r1, [r3, #40]	; 0x28
 800acc6:	428a      	cmp	r2, r1
 800acc8:	d002      	beq.n	800acd0 <do_quit+0x50>
			do_refill();
			if (!pop())
				/* end of input */
				break;
		}
		interpret();
 800acca:	f7ff fd5d 	bl	800a788 <interpret>
 800acce:	e7f7      	b.n	800acc0 <do_quit+0x40>
	state = STATE_INTERPRETING;
	while (1)
	{
		if (input_spec.idx == input_spec.len)
		{
			if (state == STATE_INTERPRETING)
 800acd0:	699b      	ldr	r3, [r3, #24]
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d00d      	beq.n	800acf2 <do_quit+0x72>
				print_str(":rsp:");
				print_udecimal(rsp);
				print_str("> ");
				sfsync();
			}
			do_refill();
 800acd6:	f7fd ff5f 	bl	8008b98 <do_refill>
			if (!pop())
 800acda:	f7fd fff7 	bl	8008ccc <pop>
 800acde:	2800      	cmp	r0, #0
 800ace0:	d1f3      	bne.n	800acca <do_quit+0x4a>
				/* end of input */
				break;
		}
		interpret();
	}
	print_str("aborting quit: input exhausted\n");
 800ace2:	4812      	ldr	r0, [pc, #72]	; (800ad2c <do_quit+0xac>)
 800ace4:	f7fd fe87 	bl	80089f6 <print_str>
	is_jmpenv_valid = x;
 800ace8:	466a      	mov	r2, sp
 800acea:	4b0c      	ldr	r3, [pc, #48]	; (800ad1c <do_quit+0x9c>)
 800acec:	7912      	ldrb	r2, [r2, #4]
 800acee:	3328      	adds	r3, #40	; 0x28
 800acf0:	e012      	b.n	800ad18 <do_quit+0x98>
	{
		if (input_spec.idx == input_spec.len)
		{
			if (state == STATE_INTERPRETING)
			{
				print_str("sforth:sp:");
 800acf2:	480f      	ldr	r0, [pc, #60]	; (800ad30 <do_quit+0xb0>)
 800acf4:	f7fd fe7f 	bl	80089f6 <print_str>
				print_udecimal(sp);
 800acf8:	4c0a      	ldr	r4, [pc, #40]	; (800ad24 <do_quit+0xa4>)
 800acfa:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800acfc:	f7ff ffb2 	bl	800ac64 <print_udecimal>
				print_str(":rsp:");
 800ad00:	480c      	ldr	r0, [pc, #48]	; (800ad34 <do_quit+0xb4>)
 800ad02:	f7fd fe78 	bl	80089f6 <print_str>
				print_udecimal(rsp);
 800ad06:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800ad08:	f7ff ffac 	bl	800ac64 <print_udecimal>
				print_str("> ");
 800ad0c:	480a      	ldr	r0, [pc, #40]	; (800ad38 <do_quit+0xb8>)
 800ad0e:	f7fd fe72 	bl	80089f6 <print_str>
				sfsync();
 800ad12:	f7f8 f911 	bl	8002f38 <sfsync>
 800ad16:	e7de      	b.n	800acd6 <do_quit+0x56>
				break;
		}
		interpret();
	}
	print_str("aborting quit: input exhausted\n");
	is_jmpenv_valid = x;
 800ad18:	701a      	strb	r2, [r3, #0]
}
 800ad1a:	bd13      	pop	{r0, r1, r4, pc}
 800ad1c:	200019e4 	.word	0x200019e4
 800ad20:	20001764 	.word	0x20001764
 800ad24:	20001364 	.word	0x20001364
 800ad28:	20001264 	.word	0x20001264
 800ad2c:	08014d06 	.word	0x08014d06
 800ad30:	08014cf2 	.word	0x08014cf2
 800ad34:	08014cfd 	.word	0x08014cfd
 800ad38:	08014d03 	.word	0x08014d03

0800ad3c <sf_get_results>:
 * exported routines for manipulation of the sforth engine
 *
 */

int sf_get_results(cell results[], int nr_results)
{
 800ad3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ad3e:	1c07      	adds	r7, r0, #0
 800ad40:	1c0d      	adds	r5, r1, #0
int i, j;

	i = nr_results;
	j = 0;
 800ad42:	2400      	movs	r4, #0
 800ad44:	008e      	lsls	r6, r1, #2
	while (sp && nr_results --)
 800ad46:	4b09      	ldr	r3, [pc, #36]	; (800ad6c <sf_get_results+0x30>)
 800ad48:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800ad4a:	2b00      	cmp	r3, #0
 800ad4c:	d101      	bne.n	800ad52 <sf_get_results+0x16>
 800ad4e:	1c25      	adds	r5, r4, #0
 800ad50:	e009      	b.n	800ad66 <sf_get_results+0x2a>
 800ad52:	42ac      	cmp	r4, r5
 800ad54:	d007      	beq.n	800ad66 <sf_get_results+0x2a>
int sf_get_depth(void)
{
	return sp;
}

cell sf_pop(void) { return pop(); }
 800ad56:	f7fd ffb9 	bl	8008ccc <pop>
 800ad5a:	00a3      	lsls	r3, r4, #2
 800ad5c:	1af3      	subs	r3, r6, r3
 800ad5e:	3b04      	subs	r3, #4
int i, j;

	i = nr_results;
	j = 0;
	while (sp && nr_results --)
		results[-- i] = sf_pop(), j ++;
 800ad60:	50f8      	str	r0, [r7, r3]
 800ad62:	3401      	adds	r4, #1
 800ad64:	e7ef      	b.n	800ad46 <sf_get_results+0xa>
	return j;
}
 800ad66:	1c28      	adds	r0, r5, #0
 800ad68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ad6a:	46c0      	nop			; (mov r8, r8)
 800ad6c:	20001364 	.word	0x20001364

0800ad70 <sf_get_depth>:

int sf_get_depth(void)
{
	return sp;
 800ad70:	4b01      	ldr	r3, [pc, #4]	; (800ad78 <sf_get_depth+0x8>)
 800ad72:	6b58      	ldr	r0, [r3, #52]	; 0x34
}
 800ad74:	4770      	bx	lr
 800ad76:	46c0      	nop			; (mov r8, r8)
 800ad78:	20001364 	.word	0x20001364

0800ad7c <sf_pop>:

cell sf_pop(void) { return pop(); }
 800ad7c:	b508      	push	{r3, lr}
 800ad7e:	f7fd ffa5 	bl	8008ccc <pop>
 800ad82:	bd08      	pop	{r3, pc}

0800ad84 <sf_top>:
cell sf_top(void) { return top(); }
 800ad84:	b508      	push	{r3, lr}
 800ad86:	f7fe fad8 	bl	800933a <top>
 800ad8a:	bd08      	pop	{r3, pc}

0800ad8c <sf_push>:
void sf_push(cell x) { push(x); }
 800ad8c:	b508      	push	{r3, lr}
 800ad8e:	f7fd fe4f 	bl	8008a30 <push>
 800ad92:	bd08      	pop	{r3, pc}

0800ad94 <sf_eval>:
void sf_eval(const char * sfcode)
{
 800ad94:	b538      	push	{r3, r4, r5, lr}
 800ad96:	1c04      	adds	r4, r0, #0
int i;
	i = xstrlen(sfcode);
 800ad98:	f7fd fdca 	bl	8008930 <xstrlen>
 800ad9c:	1c05      	adds	r5, r0, #0
	push((cell) sfcode);
 800ad9e:	1c20      	adds	r0, r4, #0
 800ada0:	f7fd fe46 	bl	8008a30 <push>
	push(i);
 800ada4:	1c28      	adds	r0, r5, #0
 800ada6:	f7fd fe43 	bl	8008a30 <push>
	do_evaluate();
 800adaa:	f7ff fd57 	bl	800a85c <do_evaluate>
}
 800adae:	bd38      	pop	{r3, r4, r5, pc}

0800adb0 <sf_merge_custom_dictionary>:
void sf_merge_custom_dictionary(struct word * dict_end, const struct word * dict_start)
{
	dict_end->link = latest;
 800adb0:	4b02      	ldr	r3, [pc, #8]	; (800adbc <sf_merge_custom_dictionary+0xc>)
 800adb2:	681a      	ldr	r2, [r3, #0]
 800adb4:	6002      	str	r2, [r0, #0]
	* ((const struct word **) & latest) = dict_start;
 800adb6:	6019      	str	r1, [r3, #0]
}
 800adb8:	4770      	bx	lr
 800adba:	46c0      	nop			; (mov r8, r8)
 800adbc:	20000068 	.word	0x20000068

0800adc0 <sf_init>:
	return input_spec.buf[input_spec.idx ++];
}
#include "dictionary.c"

void sf_init(void)
{
 800adc0:	b508      	push	{r3, lr}
	sf_reset();
 800adc2:	f7fd fd51 	bl	8008868 <sf_reset>
}
 800adc6:	bd08      	pop	{r3, pc}
int sfsync(void) __attribute__((weak));
cell sfopen(const char * pathname, int flags) __attribute__((weak));
int sfclose(cell file_id) __attribute__((weak));
int sffseek(cell stream, long offset) __attribute__((weak));

int sfgetc(void) { return EOF; }
 800adc8:	2001      	movs	r0, #1
 800adca:	4240      	negs	r0, r0
 800adcc:	4770      	bx	lr

0800adce <sffgetc>:
int sffgetc(cell file_id) { return EOF; }
 800adce:	2001      	movs	r0, #1
 800add0:	4240      	negs	r0, r0
 800add2:	4770      	bx	lr
int sfputc(int c) { return EOF; }
 800add4:	2001      	movs	r0, #1
 800add6:	4240      	negs	r0, r0
 800add8:	4770      	bx	lr
int sfsync(void) { return EOF; }
 800adda:	2001      	movs	r0, #1
 800addc:	4240      	negs	r0, r0
 800adde:	4770      	bx	lr

0800ade0 <sfopen>:
cell sfopen(const char * pathname, int flags) { return 0; }
 800ade0:	2000      	movs	r0, #0
 800ade2:	4770      	bx	lr

0800ade4 <sfclose>:
int sfclose(cell file_id) { return EOF; }
 800ade4:	2001      	movs	r0, #1
 800ade6:	4240      	negs	r0, r0
 800ade8:	4770      	bx	lr

0800adea <sffseek>:
int sffseek(cell stream, long offset) { return -1; }
 800adea:	2001      	movs	r0, #1
 800adec:	4240      	negs	r0, r0
 800adee:	4770      	bx	lr

0800adf0 <do_cmove_up>:
If u is greater than zero, copy u consecutive characters from the data space starting at
c-addr1 to that starting at c-addr2, proceeding character-by-character from higher ad-
dresses to lower addresses.
See: 17.6.1.0910 CMOVE, A.17.6.1.0920 CMOVE>.
*/
static void do_cmove_up(void) { cell u = sf_pop(); uint8_t * dest = (uint8_t *) sf_pop() + u, * src = (uint8_t *) sf_pop() + u; while (u --) * -- dest = * -- src; }
 800adf0:	b538      	push	{r3, r4, r5, lr}
 800adf2:	f7ff ffc3 	bl	800ad7c <sf_pop>
 800adf6:	1c04      	adds	r4, r0, #0
 800adf8:	f7ff ffc0 	bl	800ad7c <sf_pop>
 800adfc:	1c05      	adds	r5, r0, #0
 800adfe:	f7ff ffbd 	bl	800ad7c <sf_pop>
 800ae02:	3c01      	subs	r4, #1
 800ae04:	d302      	bcc.n	800ae0c <do_cmove_up+0x1c>
 800ae06:	5d03      	ldrb	r3, [r0, r4]
 800ae08:	552b      	strb	r3, [r5, r4]
 800ae0a:	e7fa      	b.n	800ae02 <do_cmove_up+0x12>
 800ae0c:	bd38      	pop	{r3, r4, r5, pc}

0800ae0e <do_search>:
true, a match was found at c-addr3 with u3 characters remaining. If flag is false there was
no match and c-addr3 is c-addr1 and u3 is u1.
See: A.17.6.1.2191 SEARCH.
*/
static void do_search(void)
{ cell u1, u2, f; int i; uint8_t * s1, * s2; u2 = sf_pop(); s2 = (uint8_t *) sf_pop(); u1 = sf_pop(); s1 = (uint8_t *) sf_pop(); f = C_FALSE; for (i = 0; i <= u1 - u2; i ++) if (!xstrncmp((void *) (s1 + i), (void *) s2, u2)) { s1 += i; u1 -= i; f = C_TRUE; break; } sf_push((cell) s1); sf_push(u1); sf_push(f); }
 800ae0e:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae10:	b085      	sub	sp, #20
 800ae12:	f7ff ffb3 	bl	800ad7c <sf_pop>
 800ae16:	9002      	str	r0, [sp, #8]
 800ae18:	f7ff ffb0 	bl	800ad7c <sf_pop>
 800ae1c:	9003      	str	r0, [sp, #12]
 800ae1e:	f7ff ffad 	bl	800ad7c <sf_pop>
 800ae22:	1c05      	adds	r5, r0, #0
 800ae24:	f7ff ffaa 	bl	800ad7c <sf_pop>
 800ae28:	2400      	movs	r4, #0
 800ae2a:	1c06      	adds	r6, r0, #0
 800ae2c:	9001      	str	r0, [sp, #4]
 800ae2e:	9b02      	ldr	r3, [sp, #8]
 800ae30:	1aeb      	subs	r3, r5, r3
 800ae32:	429c      	cmp	r4, r3
 800ae34:	d80e      	bhi.n	800ae54 <do_search+0x46>
 800ae36:	19a7      	adds	r7, r4, r6
 800ae38:	1c38      	adds	r0, r7, #0
 800ae3a:	9903      	ldr	r1, [sp, #12]
 800ae3c:	9a02      	ldr	r2, [sp, #8]
 800ae3e:	f7fd fdcb 	bl	80089d8 <xstrncmp>
 800ae42:	2800      	cmp	r0, #0
 800ae44:	d104      	bne.n	800ae50 <do_search+0x42>
 800ae46:	1b2d      	subs	r5, r5, r4
 800ae48:	2401      	movs	r4, #1
 800ae4a:	9701      	str	r7, [sp, #4]
 800ae4c:	4264      	negs	r4, r4
 800ae4e:	e002      	b.n	800ae56 <do_search+0x48>
 800ae50:	3401      	adds	r4, #1
 800ae52:	e7ec      	b.n	800ae2e <do_search+0x20>
 800ae54:	2400      	movs	r4, #0
 800ae56:	9801      	ldr	r0, [sp, #4]
 800ae58:	f7ff ff98 	bl	800ad8c <sf_push>
 800ae5c:	1c28      	adds	r0, r5, #0
 800ae5e:	f7ff ff95 	bl	800ad8c <sf_push>
 800ae62:	1c20      	adds	r0, r4, #0
 800ae64:	f7ff ff92 	bl	800ad8c <sf_push>
 800ae68:	b005      	add	sp, #20
 800ae6a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800ae6c <do_compare>:
in the string specified by c-addr1 u1 has a lesser numeric value than the corresponding
character in the string specified by c-addr2 u2 and one (1) otherwise.
See: A.17.6.1.0935 COMPARE.
*/
static void do_compare(void)
{ cell u1, u2, x; int res; uint8_t * s1, * s2; u2 = sf_pop(); s2 = (uint8_t *) sf_pop(); u1 = sf_pop(); s1 = (uint8_t *) sf_pop(); if (u1 == u2) { sf_push(xstrncmp((void *) s1, (void *) s2, u1)); return; } x = (u1 < u2) ? u1 : u2; u1 -=x; u2 -= x; res = xstrncmp((void *) s1, (void *) s2, x); if (res) sf_push(res); else sf_push(u1 ? 1 : -1); }
 800ae6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ae6e:	f7ff ff85 	bl	800ad7c <sf_pop>
 800ae72:	1c06      	adds	r6, r0, #0
 800ae74:	f7ff ff82 	bl	800ad7c <sf_pop>
 800ae78:	1c07      	adds	r7, r0, #0
 800ae7a:	f7ff ff7f 	bl	800ad7c <sf_pop>
 800ae7e:	1c04      	adds	r4, r0, #0
 800ae80:	f7ff ff7c 	bl	800ad7c <sf_pop>
 800ae84:	42b4      	cmp	r4, r6
 800ae86:	d104      	bne.n	800ae92 <do_compare+0x26>
 800ae88:	1c39      	adds	r1, r7, #0
 800ae8a:	1c22      	adds	r2, r4, #0
 800ae8c:	f7fd fda4 	bl	80089d8 <xstrncmp>
 800ae90:	e00f      	b.n	800aeb2 <do_compare+0x46>
 800ae92:	1e25      	subs	r5, r4, #0
 800ae94:	42b5      	cmp	r5, r6
 800ae96:	d900      	bls.n	800ae9a <do_compare+0x2e>
 800ae98:	1c35      	adds	r5, r6, #0
 800ae9a:	1c39      	adds	r1, r7, #0
 800ae9c:	1c2a      	adds	r2, r5, #0
 800ae9e:	f7fd fd9b 	bl	80089d8 <xstrncmp>
 800aea2:	2800      	cmp	r0, #0
 800aea4:	d105      	bne.n	800aeb2 <do_compare+0x46>
 800aea6:	1b64      	subs	r4, r4, r5
 800aea8:	4260      	negs	r0, r4
 800aeaa:	4160      	adcs	r0, r4
 800aeac:	4244      	negs	r4, r0
 800aeae:	2001      	movs	r0, #1
 800aeb0:	4320      	orrs	r0, r4
 800aeb2:	f7ff ff6b 	bl	800ad8c <sf_push>
 800aeb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800aeb8 <do_slash_string>:
specified by c-addr2 u2, begins at c-addr1 plus n characters and is u1 minus n characters
long.
See: A.17.6.1.0245 /STRING.
*/
static void do_slash_string(void)
{ scell n = sf_pop(); cell u = sf_pop(); uint8_t * p = (uint8_t *) sf_pop(); sf_push((cell)(p + n)); sf_push(u - n); }
 800aeb8:	b538      	push	{r3, r4, r5, lr}
 800aeba:	f7ff ff5f 	bl	800ad7c <sf_pop>
 800aebe:	1c05      	adds	r5, r0, #0
 800aec0:	f7ff ff5c 	bl	800ad7c <sf_pop>
 800aec4:	1c04      	adds	r4, r0, #0
 800aec6:	f7ff ff59 	bl	800ad7c <sf_pop>
 800aeca:	1940      	adds	r0, r0, r5
 800aecc:	f7ff ff5e 	bl	800ad8c <sf_push>
 800aed0:	1b60      	subs	r0, r4, r5
 800aed2:	f7ff ff5b 	bl	800ad8c <sf_push>
 800aed6:	bd38      	pop	{r3, r4, r5, pc}

0800aed8 <do_cmove>:
If u is greater than zero, copy u consecutive characters from the data space starting at c-
addr1 to that starting at c-addr2, proceeding character-by-character from lower addresses
to higher addresses.
See: 17.6.1.0920 CMOVE>, A.17.6.1.0910 CMOVE.
*/
static void do_cmove(void) { cell u = sf_pop(); uint8_t * dest = (uint8_t *) sf_pop(), * src = (uint8_t *) sf_pop(); xmemcpy(dest, src, u); }
 800aed8:	b538      	push	{r3, r4, r5, lr}
 800aeda:	f7ff ff4f 	bl	800ad7c <sf_pop>
 800aede:	1c04      	adds	r4, r0, #0
 800aee0:	f7ff ff4c 	bl	800ad7c <sf_pop>
 800aee4:	1c05      	adds	r5, r0, #0
 800aee6:	f7ff ff49 	bl	800ad7c <sf_pop>
 800aeea:	1c22      	adds	r2, r4, #0
 800aeec:	1c01      	adds	r1, r0, #0
 800aeee:	1c28      	adds	r0, r5, #0
 800aef0:	f7fd fd27 	bl	8008942 <xmemcpy>
 800aef4:	bd38      	pop	{r3, r4, r5, pc}

0800aef6 <do_sliteral>:
Return c-addr2u describing a string consisting of the characters specified by c-addr1 u
during compilation. A program shall not alter the returned string.
See: A.17.6.112.0 SLITERAL.
*/
static void do_sliteral(void)
{
 800aef6:	b508      	push	{r3, lr}
str type cr cr
: stest [ str ] sliteral ;
: stest [ str ] sliteral 1- swap 1+ swap ." string is:" cr cr type cr cr ;

 */
do_ahead(); do_rot(); do_rot();
 800aef8:	f7fd feb6 	bl	8008c68 <do_ahead>
 800aefc:	f7fe fe6e 	bl	8009bdc <do_rot>
 800af00:	f7fe fe6c 	bl	8009bdc <do_rot>
do_here(); do_to_r();
 800af04:	f7fd fdfc 	bl	8008b00 <do_here>
 800af08:	f7fe ff18 	bl	8009d3c <do_to_r>
do_two_dup(); do_here(); do_swap(); do_cmove();
 800af0c:	f7fe fc60 	bl	80097d0 <do_two_dup>
 800af10:	f7fd fdf6 	bl	8008b00 <do_here>
 800af14:	f7ff f810 	bl	8009f38 <do_swap>
 800af18:	f7ff ffde 	bl	800aed8 <do_cmove>
do_dup(); do_allot(); do_align();
 800af1c:	f7fe fe14 	bl	8009b48 <do_dup>
 800af20:	f7fd ff49 	bl	8008db6 <do_allot>
 800af24:	f7fd fc3a 	bl	800879c <do_align>
do_rot(); do_then();
 800af28:	f7fe fe58 	bl	8009bdc <do_rot>
 800af2c:	f7fe f83a 	bl	8008fa4 <do_then>
do_r_from(); do_literal();
 800af30:	f7fe fdde 	bl	8009af0 <do_r_from>
 800af34:	f7fe f80b 	bl	8008f4e <do_literal>
do_literal();
 800af38:	f7fe f809 	bl	8008f4e <do_literal>
do_drop();
 800af3c:	f7fd ff7f 	bl	8008e3e <do_drop>

}
 800af40:	bd08      	pop	{r3, pc}

0800af42 <do_blank>:
STRING
( c-addr u -- )
If u is greater than zero, store the character value for space in u consecutive character
positions beginning at c-addr.
*/
static void do_blank(void) { cell u = sf_pop(); xmemset((uint8_t *) sf_pop(), ' ', u); }
 800af42:	b510      	push	{r4, lr}
 800af44:	f7ff ff1a 	bl	800ad7c <sf_pop>
 800af48:	1c04      	adds	r4, r0, #0
 800af4a:	f7ff ff17 	bl	800ad7c <sf_pop>
 800af4e:	2120      	movs	r1, #32
 800af50:	1c22      	adds	r2, r4, #0
 800af52:	f7fd fcff 	bl	8008954 <xmemset>
 800af56:	bd10      	pop	{r4, pc}

0800af58 <do_dash_trailing>:
character string specified by c-addr u1. If u1 is zero or the entire string consists of spaces,
u2 is zero.

*/
static void do_dash_trailing(void)
{ cell u = sf_pop(); uint8_t * s = (uint8_t *) sf_top() + u; while (u) if (* -- s != ' ') break; else u --; sf_push(u); }
 800af58:	b510      	push	{r4, lr}
 800af5a:	f7ff ff0f 	bl	800ad7c <sf_pop>
 800af5e:	1c04      	adds	r4, r0, #0
 800af60:	f7ff ff10 	bl	800ad84 <sf_top>
 800af64:	2c00      	cmp	r4, #0
 800af66:	d005      	beq.n	800af74 <do_dash_trailing+0x1c>
 800af68:	1e43      	subs	r3, r0, #1
 800af6a:	5d1b      	ldrb	r3, [r3, r4]
 800af6c:	2b20      	cmp	r3, #32
 800af6e:	d101      	bne.n	800af74 <do_dash_trailing+0x1c>
 800af70:	3c01      	subs	r4, #1
 800af72:	e7f7      	b.n	800af64 <do_dash_trailing+0xc>
 800af74:	1c20      	adds	r0, r4, #0
 800af76:	f7ff ff09 	bl	800ad8c <sf_push>
 800af7a:	bd10      	pop	{r4, pc}

0800af7c <sf_opt_string_init>:

}, * custom_dict_start = custom_dict + __COUNTER__;

static void sf_opt_string_init(void) __attribute__((constructor));
static void sf_opt_string_init(void)
{
 800af7c:	b508      	push	{r3, lr}
	sf_merge_custom_dictionary(dict_base_dummy_word, custom_dict_start);
 800af7e:	4903      	ldr	r1, [pc, #12]	; (800af8c <sf_opt_string_init+0x10>)
 800af80:	4803      	ldr	r0, [pc, #12]	; (800af90 <sf_opt_string_init+0x14>)
 800af82:	3170      	adds	r1, #112	; 0x70
 800af84:	f7ff ff14 	bl	800adb0 <sf_merge_custom_dictionary>
}
 800af88:	bd08      	pop	{r3, pc}
 800af8a:	46c0      	nop			; (mov r8, r8)
 800af8c:	08014d28 	.word	0x08014d28
 800af90:	2000006c 	.word	0x2000006c

0800af94 <do_bracket_then>:
Execution: ( -- )
Does nothing. [THEN] is an immediate word.
See: A.15.6.2.2533 [THEN].

*/
static void do_bracket_then(void) { /*: [then] ; immediate */ }
 800af94:	4770      	bx	lr

0800af96 <do_bracket_defined>:
static void do_bracket_defined(void)
{
 800af96:	b508      	push	{r3, lr}
	/*: [defined] bl word find swap drop 0<> ; immediate */
	do_bl(); do_word(); do_find(); do_swap(); do_drop(); do_zero_not_equals();
 800af98:	f7fd fd9a 	bl	8008ad0 <do_bl>
 800af9c:	f7fe f905 	bl	80091aa <do_word>
 800afa0:	f7fd ff82 	bl	8008ea8 <do_find>
 800afa4:	f7fe ffc8 	bl	8009f38 <do_swap>
 800afa8:	f7fd ff49 	bl	8008e3e <do_drop>
 800afac:	f7fe f842 	bl	8009034 <do_zero_not_equals>
}
 800afb0:	bd08      	pop	{r3, pc}

0800afb2 <do_bracket_undefined>:
static void do_bracket_undefined(void) { /* : [undefined] [defined] invert ; immediate */ do_bracket_defined(); do_invert(); }
 800afb2:	b508      	push	{r3, lr}
 800afb4:	f7ff ffef 	bl	800af96 <do_bracket_defined>
 800afb8:	f7fd ffc2 	bl	8008f40 <do_invert>
 800afbc:	bd08      	pop	{r3, pc}

0800afbe <do_bracket_else>:
15.6.2.2532 [IF]
bracket-if
TOOLS EXT
*/
static void do_bracket_else(void)
{
 800afbe:	b510      	push	{r4, lr}
: [if] 0= if postpone [else] then ; immediate

: [then] ; immediate
*/
	/* initialize [if]/[else]/[then] nesting level */
	sf_push(1);
 800afc0:	2001      	movs	r0, #1
 800afc2:	f7ff fee3 	bl	800ad8c <sf_push>
	do
	{
		do_bl(); do_word(); do_count();
 800afc6:	f7fd fd83 	bl	8008ad0 <do_bl>
 800afca:	f7fe f8ee 	bl	80091aa <do_word>
 800afce:	f7fd ff2b 	bl	8008e28 <do_count>
		if (!sf_top())
 800afd2:	f7ff fed7 	bl	800ad84 <sf_top>
 800afd6:	2800      	cmp	r0, #0
 800afd8:	d114      	bne.n	800b004 <do_bracket_else+0x46>
		{
			/* input exhausted, refill input buffer */
			do_drop(); do_drop(); do_refill();
 800afda:	f7fd ff30 	bl	8008e3e <do_drop>
 800afde:	f7fd ff2e 	bl	8008e3e <do_drop>
 800afe2:	f7fd fdd9 	bl	8008b98 <do_refill>
			if (!sf_pop()) { /* 'refill' failed */ /* drop nesting level */ do_drop(); print_str(__func__);
 800afe6:	f7ff fec9 	bl	800ad7c <sf_pop>
 800afea:	2800      	cmp	r0, #0
 800afec:	d14c      	bne.n	800b088 <do_bracket_else+0xca>
 800afee:	f7fd ff26 	bl	8008e3e <do_drop>
 800aff2:	4829      	ldr	r0, [pc, #164]	; (800b098 <do_bracket_else+0xda>)
 800aff4:	f7fd fcff 	bl	80089f6 <print_str>
				print_str("(): input exhausted; aborting\n"); do_abort(); }
 800aff8:	4828      	ldr	r0, [pc, #160]	; (800b09c <do_bracket_else+0xde>)
 800affa:	f7fd fcfc 	bl	80089f6 <print_str>
 800affe:	f7fd fc55 	bl	80088ac <do_abort>
 800b002:	e041      	b.n	800b088 <do_bracket_else+0xca>
			continue;
		}

		do_two_to_r();
 800b004:	f7ff f920 	bl	800a248 <do_two_to_r>

		do_two_r_fetch();
 800b008:	f7ff f863 	bl	800a0d2 <do_two_r_fetch>
		//sf_push((cell) "\04[if]"); do_count(); sf_push((cell) compare_word_xt); do_execute();
		if (sf_pop() == 4) { if (!xmemcmp((void *) sf_pop(), "[if]", 4)) /* increase nesting level */ do_one_plus(); }
 800b00c:	f7ff feb6 	bl	800ad7c <sf_pop>
 800b010:	1e04      	subs	r4, r0, #0
 800b012:	2c04      	cmp	r4, #4
 800b014:	d10a      	bne.n	800b02c <do_bracket_else+0x6e>
 800b016:	f7ff feb1 	bl	800ad7c <sf_pop>
 800b01a:	4921      	ldr	r1, [pc, #132]	; (800b0a0 <do_bracket_else+0xe2>)
 800b01c:	1c22      	adds	r2, r4, #0
 800b01e:	f7fd fcb1 	bl	8008984 <xmemcmp>
 800b022:	2800      	cmp	r0, #0
 800b024:	d104      	bne.n	800b030 <do_bracket_else+0x72>
 800b026:	f7fd fe84 	bl	8008d32 <do_one_plus>
 800b02a:	e001      	b.n	800b030 <do_bracket_else+0x72>
		else do_drop();
 800b02c:	f7fd ff07 	bl	8008e3e <do_drop>

		do_two_r_fetch();
 800b030:	f7ff f84f 	bl	800a0d2 <do_two_r_fetch>
		//sf_push((cell) "\06[else]"); do_count(); sf_push((cell) compare_word_xt); do_execute();
		if (sf_pop() == 6) { if (!xmemcmp((void *) sf_pop(), "[else]", 6)) /* see if an [if] block should be terminated */ if (sf_top() == 1) do_one_minus(); }
 800b034:	f7ff fea2 	bl	800ad7c <sf_pop>
 800b038:	1e04      	subs	r4, r0, #0
 800b03a:	2c06      	cmp	r4, #6
 800b03c:	d10e      	bne.n	800b05c <do_bracket_else+0x9e>
 800b03e:	f7ff fe9d 	bl	800ad7c <sf_pop>
 800b042:	4918      	ldr	r1, [pc, #96]	; (800b0a4 <do_bracket_else+0xe6>)
 800b044:	1c22      	adds	r2, r4, #0
 800b046:	f7fd fc9d 	bl	8008984 <xmemcmp>
 800b04a:	2800      	cmp	r0, #0
 800b04c:	d108      	bne.n	800b060 <do_bracket_else+0xa2>
 800b04e:	f7ff fe99 	bl	800ad84 <sf_top>
 800b052:	2801      	cmp	r0, #1
 800b054:	d104      	bne.n	800b060 <do_bracket_else+0xa2>
 800b056:	f7fd fe73 	bl	8008d40 <do_one_minus>
 800b05a:	e001      	b.n	800b060 <do_bracket_else+0xa2>
		else do_drop();
 800b05c:	f7fd feef 	bl	8008e3e <do_drop>

		do_two_r_from();
 800b060:	f7ff f91e 	bl	800a2a0 <do_two_r_from>
		//sf_push((cell) "\06[then]"); do_count(); sf_push((cell) compare_word_xt); do_execute();
		if (sf_pop() == 6) { if (!xmemcmp((void *) sf_pop(), "[then]", 6)) /* decrease nesting level */ do_one_minus(); }
 800b064:	f7ff fe8a 	bl	800ad7c <sf_pop>
 800b068:	1e04      	subs	r4, r0, #0
 800b06a:	2c06      	cmp	r4, #6
 800b06c:	d10a      	bne.n	800b084 <do_bracket_else+0xc6>
 800b06e:	f7ff fe85 	bl	800ad7c <sf_pop>
 800b072:	490d      	ldr	r1, [pc, #52]	; (800b0a8 <do_bracket_else+0xea>)
 800b074:	1c22      	adds	r2, r4, #0
 800b076:	f7fd fc85 	bl	8008984 <xmemcmp>
 800b07a:	2800      	cmp	r0, #0
 800b07c:	d104      	bne.n	800b088 <do_bracket_else+0xca>
 800b07e:	f7fd fe5f 	bl	8008d40 <do_one_minus>
 800b082:	e001      	b.n	800b088 <do_bracket_else+0xca>
		else do_drop();
 800b084:	f7fd fedb 	bl	8008e3e <do_drop>
	}
	while (sf_top());
 800b088:	f7ff fe7c 	bl	800ad84 <sf_top>
 800b08c:	2800      	cmp	r0, #0
 800b08e:	d19a      	bne.n	800afc6 <do_bracket_else+0x8>
	/* drop nesting level */
	do_drop();
 800b090:	f7fd fed5 	bl	8008e3e <do_drop>

}
 800b094:	bd10      	pop	{r4, pc}
 800b096:	46c0      	nop			; (mov r8, r8)
 800b098:	08014df0 	.word	0x08014df0
 800b09c:	08014e80 	.word	0x08014e80
 800b0a0:	08014e9f 	.word	0x08014e9f
 800b0a4:	08014ea4 	.word	0x08014ea4
 800b0a8:	08014eab 	.word	0x08014eab

0800b0ac <do_bracket_if>:
An ambiguous condition exists if [IF] is POSTPONEd, or if the end of the input buffer
is reached and cannot be refilled before the terminating [ELSE] or [THEN] is parsed.
See: 3.4.1 Parsing, A.15.6.2.2532 [IF].

*/
static void do_bracket_if(void) { /*: [if] 0= if postpone [else] then ; immediate */ if (!sf_pop()) do_bracket_else(); }
 800b0ac:	b508      	push	{r3, lr}
 800b0ae:	f7ff fe65 	bl	800ad7c <sf_pop>
 800b0b2:	2800      	cmp	r0, #0
 800b0b4:	d101      	bne.n	800b0ba <do_bracket_if+0xe>
 800b0b6:	f7ff ff82 	bl	800afbe <do_bracket_else>
 800b0ba:	bd08      	pop	{r3, pc}

0800b0bc <sf_opt_prog_tools_init>:

}, * custom_dict_start = custom_dict + __COUNTER__;

static void sf_opt_prog_tools_init(void) __attribute__((constructor));
static void sf_opt_prog_tools_init(void)
{
 800b0bc:	b508      	push	{r3, lr}
	sf_merge_custom_dictionary(dict_base_dummy_word, custom_dict_start);
 800b0be:	4903      	ldr	r1, [pc, #12]	; (800b0cc <sf_opt_prog_tools_init+0x10>)
 800b0c0:	4803      	ldr	r0, [pc, #12]	; (800b0d0 <sf_opt_prog_tools_init+0x14>)
 800b0c2:	3150      	adds	r1, #80	; 0x50
 800b0c4:	f7ff fe74 	bl	800adb0 <sf_merge_custom_dictionary>
}
 800b0c8:	bd08      	pop	{r3, pc}
 800b0ca:	46c0      	nop			; (mov r8, r8)
 800b0cc:	08014df0 	.word	0x08014df0
 800b0d0:	2000007c 	.word	0x2000007c

0800b0d4 <do_reposition_file>:
( ud fileid -- ior )
Reposition the file identified by fileid to ud. ior is the implementation-defined I/O result
code. An ambiguous condition exists if the file is positioned outside the file boundaries.
At the conclusion of the operation, FILE-POSITION returns the value ud.
*/
static void do_reposition_file(void) { cell fd, offset; offset = sf_pop(); fd = sf_pop(); sffseek(fd, offset); }
 800b0d4:	b510      	push	{r4, lr}
 800b0d6:	f7ff fe51 	bl	800ad7c <sf_pop>
 800b0da:	1c04      	adds	r4, r0, #0
 800b0dc:	f7ff fe4e 	bl	800ad7c <sf_pop>
 800b0e0:	1c21      	adds	r1, r4, #0
 800b0e2:	f7ff fe82 	bl	800adea <sffseek>
 800b0e6:	bd10      	pop	{r4, pc}

0800b0e8 <do_include>:
		sf_push((cell)strbuf);
		do_count();
	}
}

static void do_include(void) { /* : include bl parse included ; */ do_bl(); do_parse(); do_included(); }
 800b0e8:	b508      	push	{r3, lr}
 800b0ea:	f7fd fcf1 	bl	8008ad0 <do_bl>
 800b0ee:	f7fd ffca 	bl	8009086 <do_parse>
 800b0f2:	f7ff fc73 	bl	800a9dc <do_included>
 800b0f6:	bd08      	pop	{r3, pc}

0800b0f8 <do_opt_file_s_quote>:
};
/* buffer for use by 's"'; the string is stored as a counted string (the first byte equals the string length) */
static uint8_t strbuf[STRBUF_SIZE + 1];

static void do_opt_file_s_quote(void)
{
 800b0f8:	b538      	push	{r3, r4, r5, lr}
	/* state-smart extension of the 's"' word from the core wordset */
	do_state(); do_fetch();
 800b0fa:	f7fd fd33 	bl	8008b64 <do_state>
 800b0fe:	f7fd fe4a 	bl	8008d96 <do_fetch>
	if (sf_pop() == STATE_COMPILING)
 800b102:	f7ff fe3b 	bl	800ad7c <sf_pop>
 800b106:	1c43      	adds	r3, r0, #1
 800b108:	d102      	bne.n	800b110 <do_opt_file_s_quote+0x18>
		do_s_quote();
 800b10a:	f7ff f9cf 	bl	800a4ac <do_s_quote>
 800b10e:	e018      	b.n	800b142 <do_opt_file_s_quote+0x4a>
	else
	{
		cell len;
		/* interpreting */
		sf_push('"');
 800b110:	2022      	movs	r0, #34	; 0x22
 800b112:	f7ff fe3b 	bl	800ad8c <sf_push>
		do_parse();
 800b116:	f7fd ffb6 	bl	8009086 <do_parse>
		len = (cell) sf_pop();
 800b11a:	f7ff fe2f 	bl	800ad7c <sf_pop>
 800b11e:	1e04      	subs	r4, r0, #0
		len = (len > sizeof strbuf - 1) ? sizeof strbuf - 1 : len;
 800b120:	2c80      	cmp	r4, #128	; 0x80
 800b122:	d900      	bls.n	800b126 <do_opt_file_s_quote+0x2e>
 800b124:	2480      	movs	r4, #128	; 0x80
		* strbuf = len;
 800b126:	4d07      	ldr	r5, [pc, #28]	; (800b144 <do_opt_file_s_quote+0x4c>)
 800b128:	702c      	strb	r4, [r5, #0]
		xmemcpy(strbuf + 1, (void *) sf_pop(), len);
 800b12a:	f7ff fe27 	bl	800ad7c <sf_pop>
 800b12e:	1c22      	adds	r2, r4, #0
 800b130:	1c01      	adds	r1, r0, #0
 800b132:	1c68      	adds	r0, r5, #1
 800b134:	f7fd fc05 	bl	8008942 <xmemcpy>
		sf_push((cell)strbuf);
 800b138:	1c28      	adds	r0, r5, #0
 800b13a:	f7ff fe27 	bl	800ad8c <sf_push>
		do_count();
 800b13e:	f7fd fe73 	bl	8008e28 <do_count>
	}
}
 800b142:	bd38      	pop	{r3, r4, r5, pc}
 800b144:	20001b74 	.word	0x20001b74

0800b148 <sf_opt_file_init>:

}, * custom_dict_start = custom_dict + __COUNTER__;

static void sf_opt_file_init(void) __attribute__((constructor));
static void sf_opt_file_init(void)
{
 800b148:	b508      	push	{r3, lr}
	sf_merge_custom_dictionary(dict_base_dummy_word, custom_dict_start);
 800b14a:	4903      	ldr	r1, [pc, #12]	; (800b158 <sf_opt_file_init+0x10>)
 800b14c:	4803      	ldr	r0, [pc, #12]	; (800b15c <sf_opt_file_init+0x14>)
 800b14e:	3120      	adds	r1, #32
 800b150:	f7ff fe2e 	bl	800adb0 <sf_merge_custom_dictionary>
}
 800b154:	bd08      	pop	{r3, pc}
 800b156:	46c0      	nop			; (mov r8, r8)
 800b158:	08014eb4 	.word	0x08014eb4
 800b15c:	2000008c 	.word	0x2000008c

0800b160 <do_gcd>:
static void do_squared(void) { cell x = sf_pop(); sf_push(x * x); }
static void do_gcd(void)
/* implements the FORTH word:
: gcd ( n1 n2 | n) begin over mod swap over 0= until nip ;
*/
{ do { do_over(); do_mod(); do_swap(); do_over(); do_zero_not_equals(); } while (sf_pop()); do_nip(); }
 800b160:	b508      	push	{r3, lr}
 800b162:	f7fe ffcf 	bl	800a104 <do_over>
 800b166:	f7fe ffb8 	bl	800a0da <do_mod>
 800b16a:	f7fe fee5 	bl	8009f38 <do_swap>
 800b16e:	f7fe ffc9 	bl	800a104 <do_over>
 800b172:	f7fd ff5f 	bl	8009034 <do_zero_not_equals>
 800b176:	f7ff fe01 	bl	800ad7c <sf_pop>
 800b17a:	2800      	cmp	r0, #0
 800b17c:	d1f1      	bne.n	800b162 <do_gcd+0x2>
 800b17e:	f7fe fedf 	bl	8009f40 <do_nip>
 800b182:	bd08      	pop	{r3, pc}

0800b184 <do_squared>:
THE SOFTWARE.
*/
#include "engine.h"
#include "sf-word-wizard.h"

static void do_squared(void) { cell x = sf_pop(); sf_push(x * x); }
 800b184:	b508      	push	{r3, lr}
 800b186:	f7ff fdf9 	bl	800ad7c <sf_pop>
 800b18a:	4340      	muls	r0, r0
 800b18c:	f7ff fdfe 	bl	800ad8c <sf_push>
 800b190:	bd08      	pop	{r3, pc}
	...

0800b194 <sf_opt_sample_init>:

}, * custom_dict_start = custom_dict + __COUNTER__;

static void sf_opt_sample_init(void) __attribute__((constructor));
static void sf_opt_sample_init(void)
{
 800b194:	b508      	push	{r3, lr}
	sf_merge_custom_dictionary(dict_base_dummy_word, custom_dict_start);
 800b196:	4903      	ldr	r1, [pc, #12]	; (800b1a4 <sf_opt_sample_init+0x10>)
 800b198:	4803      	ldr	r0, [pc, #12]	; (800b1a8 <sf_opt_sample_init+0x14>)
 800b19a:	3110      	adds	r1, #16
 800b19c:	f7ff fe08 	bl	800adb0 <sf_merge_custom_dictionary>
}
 800b1a0:	bd08      	pop	{r3, pc}
 800b1a2:	46c0      	nop			; (mov r8, r8)
 800b1a4:	08014f04 	.word	0x08014f04
 800b1a8:	2000009c 	.word	0x2000009c

0800b1ac <dfu_detach_complete>:
	"Black Magic Trace Capture",
#endif
};

static void dfu_detach_complete(usbd_device *dev, struct usb_setup_data *req)
{
 800b1ac:	b508      	push	{r3, lr}
	(void)dev;
	(void)req;

	platform_request_boot();
 800b1ae:	f7fa fa8f 	bl	80056d0 <platform_request_boot>

	/* Reset core to enter bootloader */
	//scb_reset_system();
}
 800b1b2:	bd08      	pop	{r3, pc}

0800b1b4 <cdcacm_set_modem_state.constprop.0>:
int cdcacm_get_dtr(void)
{
	return cdcacm_gdb_dtr;
}

static void cdcacm_set_modem_state(usbd_device *dev, int iface, bool dsr, bool dcd)
 800b1b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
{
	char buf[10];
	struct usb_cdc_notification *notif = (void*)buf;
	/* We echo signals back to host as notification */
	notif->bmRequestType = 0xA1;
 800b1b6:	23a1      	movs	r3, #161	; 0xa1
 800b1b8:	aa01      	add	r2, sp, #4
 800b1ba:	7013      	strb	r3, [r2, #0]
	notif->bNotification = USB_CDC_NOTIFY_SERIAL_STATE;
 800b1bc:	3b81      	subs	r3, #129	; 0x81
 800b1be:	7053      	strb	r3, [r2, #1]
	notif->wValue = 0;
	notif->wIndex = iface;
	notif->wLength = 2;
 800b1c0:	2402      	movs	r4, #2
	char buf[10];
	struct usb_cdc_notification *notif = (void*)buf;
	/* We echo signals back to host as notification */
	notif->bmRequestType = 0xA1;
	notif->bNotification = USB_CDC_NOTIFY_SERIAL_STATE;
	notif->wValue = 0;
 800b1c2:	2300      	movs	r3, #0
	notif->wIndex = iface;
 800b1c4:	8091      	strh	r1, [r2, #4]
	notif->wLength = 2;
	buf[8] = (dsr ? 2 : 0) | (dcd ? 1 : 0);
	buf[9] = 0;
	usbd_ep_write_packet(dev, 0x82 + iface, buf, 10);
 800b1c6:	397e      	subs	r1, #126	; 0x7e
	char buf[10];
	struct usb_cdc_notification *notif = (void*)buf;
	/* We echo signals back to host as notification */
	notif->bmRequestType = 0xA1;
	notif->bNotification = USB_CDC_NOTIFY_SERIAL_STATE;
	notif->wValue = 0;
 800b1c8:	8053      	strh	r3, [r2, #2]
	notif->wIndex = iface;
	notif->wLength = 2;
 800b1ca:	80d4      	strh	r4, [r2, #6]
	buf[8] = (dsr ? 2 : 0) | (dcd ? 1 : 0);
	buf[9] = 0;
 800b1cc:	7253      	strb	r3, [r2, #9]
	notif->bmRequestType = 0xA1;
	notif->bNotification = USB_CDC_NOTIFY_SERIAL_STATE;
	notif->wValue = 0;
	notif->wIndex = iface;
	notif->wLength = 2;
	buf[8] = (dsr ? 2 : 0) | (dcd ? 1 : 0);
 800b1ce:	3401      	adds	r4, #1
	buf[9] = 0;
	usbd_ep_write_packet(dev, 0x82 + iface, buf, 10);
 800b1d0:	b2c9      	uxtb	r1, r1
 800b1d2:	330a      	adds	r3, #10
	notif->bmRequestType = 0xA1;
	notif->bNotification = USB_CDC_NOTIFY_SERIAL_STATE;
	notif->wValue = 0;
	notif->wIndex = iface;
	notif->wLength = 2;
	buf[8] = (dsr ? 2 : 0) | (dcd ? 1 : 0);
 800b1d4:	7214      	strb	r4, [r2, #8]
	buf[9] = 0;
	usbd_ep_write_packet(dev, 0x82 + iface, buf, 10);
 800b1d6:	f000 fb29 	bl	800b82c <usbd_ep_write_packet>
}
 800b1da:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

0800b1dc <cdcacm_control_request>:
}

static int cdcacm_control_request(usbd_device *dev,
		struct usb_setup_data *req, uint8_t **buf, uint16_t *len,
		void (**complete)(usbd_device *dev, struct usb_setup_data *req))
{
 800b1dc:	b538      	push	{r3, r4, r5, lr}
	(void)dev;
	(void)complete;
	(void)buf;
	(void)len;

	switch(req->bRequest) {
 800b1de:	784d      	ldrb	r5, [r1, #1]
 800b1e0:	2d03      	cmp	r5, #3
 800b1e2:	d02e      	beq.n	800b242 <cdcacm_control_request+0x66>
 800b1e4:	d802      	bhi.n	800b1ec <cdcacm_control_request+0x10>
 800b1e6:	2d00      	cmp	r5, #0
 800b1e8:	d041      	beq.n	800b26e <cdcacm_control_request+0x92>
 800b1ea:	e04b      	b.n	800b284 <cdcacm_control_request+0xa8>
 800b1ec:	1c0c      	adds	r4, r1, #0
 800b1ee:	2d20      	cmp	r5, #32
 800b1f0:	d016      	beq.n	800b220 <cdcacm_control_request+0x44>
 800b1f2:	2d22      	cmp	r5, #34	; 0x22
 800b1f4:	d146      	bne.n	800b284 <cdcacm_control_request+0xa8>
	case USB_CDC_REQ_SET_CONTROL_LINE_STATE:
		cdcacm_set_modem_state(dev, req->wIndex, true, true);
 800b1f6:	790b      	ldrb	r3, [r1, #4]
 800b1f8:	7949      	ldrb	r1, [r1, #5]
 800b1fa:	0209      	lsls	r1, r1, #8
 800b1fc:	4319      	orrs	r1, r3
 800b1fe:	f7ff ffd9 	bl	800b1b4 <cdcacm_set_modem_state.constprop.0>
		/* Ignore if not for GDB interface */
		if(req->wIndex != 0)
 800b202:	7963      	ldrb	r3, [r4, #5]
 800b204:	7922      	ldrb	r2, [r4, #4]
 800b206:	021b      	lsls	r3, r3, #8
 800b208:	4313      	orrs	r3, r2
			return 1;
 800b20a:	2001      	movs	r0, #1

	switch(req->bRequest) {
	case USB_CDC_REQ_SET_CONTROL_LINE_STATE:
		cdcacm_set_modem_state(dev, req->wIndex, true, true);
		/* Ignore if not for GDB interface */
		if(req->wIndex != 0)
 800b20c:	2b00      	cmp	r3, #0
 800b20e:	d13a      	bne.n	800b286 <cdcacm_control_request+0xaa>
			return 1;

		cdcacm_gdb_dtr = req->wValue & 1;
 800b210:	78e3      	ldrb	r3, [r4, #3]
 800b212:	78a2      	ldrb	r2, [r4, #2]
 800b214:	021b      	lsls	r3, r3, #8
 800b216:	4313      	orrs	r3, r2
 800b218:	4a1b      	ldr	r2, [pc, #108]	; (800b288 <cdcacm_control_request+0xac>)
 800b21a:	4003      	ands	r3, r0
 800b21c:	6013      	str	r3, [r2, #0]

		return 1;
 800b21e:	e032      	b.n	800b286 <cdcacm_control_request+0xaa>
	case USB_CDC_REQ_SET_LINE_CODING:
		if(*len < sizeof(struct usb_cdc_line_coding))
 800b220:	881b      	ldrh	r3, [r3, #0]
			return 0;
 800b222:	2000      	movs	r0, #0

		cdcacm_gdb_dtr = req->wValue & 1;

		return 1;
	case USB_CDC_REQ_SET_LINE_CODING:
		if(*len < sizeof(struct usb_cdc_line_coding))
 800b224:	2b06      	cmp	r3, #6
 800b226:	d92e      	bls.n	800b286 <cdcacm_control_request+0xaa>
			return 0;

		switch(req->wIndex) {
 800b228:	7963      	ldrb	r3, [r4, #5]
 800b22a:	7909      	ldrb	r1, [r1, #4]
 800b22c:	021b      	lsls	r3, r3, #8
 800b22e:	430b      	orrs	r3, r1
 800b230:	4283      	cmp	r3, r0
 800b232:	d004      	beq.n	800b23e <cdcacm_control_request+0x62>
 800b234:	2b02      	cmp	r3, #2
 800b236:	d126      	bne.n	800b286 <cdcacm_control_request+0xaa>
		case 2:
			usbuart_set_line_coding((struct usb_cdc_line_coding*)*buf);
 800b238:	6810      	ldr	r0, [r2, #0]
 800b23a:	f000 f8b6 	bl	800b3aa <usbuart_set_line_coding>
		case 0:
			return 1; /* Ignore on GDB Port */
 800b23e:	2001      	movs	r0, #1
 800b240:	e021      	b.n	800b286 <cdcacm_control_request+0xaa>
		default:
			return 0;
		}
	case DFU_GETSTATUS:
		if(req->wIndex == DFU_IF_NO) {
 800b242:	7948      	ldrb	r0, [r1, #5]
 800b244:	790c      	ldrb	r4, [r1, #4]
 800b246:	0200      	lsls	r0, r0, #8
 800b248:	4320      	orrs	r0, r4
 800b24a:	2804      	cmp	r0, #4
 800b24c:	d10f      	bne.n	800b26e <cdcacm_control_request+0x92>
			(*buf)[0] = DFU_STATUS_OK;
 800b24e:	2100      	movs	r1, #0
 800b250:	6810      	ldr	r0, [r2, #0]
 800b252:	7001      	strb	r1, [r0, #0]
			(*buf)[1] = 0;
 800b254:	6810      	ldr	r0, [r2, #0]
 800b256:	7041      	strb	r1, [r0, #1]
			(*buf)[2] = 0;
 800b258:	6810      	ldr	r0, [r2, #0]
 800b25a:	7081      	strb	r1, [r0, #2]
			(*buf)[3] = 0;
 800b25c:	6810      	ldr	r0, [r2, #0]
 800b25e:	70c1      	strb	r1, [r0, #3]
			(*buf)[4] = STATE_APP_IDLE;
 800b260:	6810      	ldr	r0, [r2, #0]
 800b262:	7101      	strb	r1, [r0, #4]
			(*buf)[5] = 0;	/* iString not used here */
 800b264:	6812      	ldr	r2, [r2, #0]
 800b266:	7151      	strb	r1, [r2, #5]
			*len = 6;
 800b268:	2206      	movs	r2, #6
 800b26a:	801a      	strh	r2, [r3, #0]
 800b26c:	e7e7      	b.n	800b23e <cdcacm_control_request+0x62>

			return 1;
		}
	case DFU_DETACH:
		if(req->wIndex == DFU_IF_NO) {
 800b26e:	794b      	ldrb	r3, [r1, #5]
 800b270:	790a      	ldrb	r2, [r1, #4]
 800b272:	021b      	lsls	r3, r3, #8
 800b274:	4313      	orrs	r3, r2
		cdcacm_gdb_dtr = req->wValue & 1;

		return 1;
	case USB_CDC_REQ_SET_LINE_CODING:
		if(*len < sizeof(struct usb_cdc_line_coding))
			return 0;
 800b276:	2000      	movs	r0, #0
			*len = 6;

			return 1;
		}
	case DFU_DETACH:
		if(req->wIndex == DFU_IF_NO) {
 800b278:	2b04      	cmp	r3, #4
 800b27a:	d104      	bne.n	800b286 <cdcacm_control_request+0xaa>
			*complete = dfu_detach_complete;
 800b27c:	4a03      	ldr	r2, [pc, #12]	; (800b28c <cdcacm_control_request+0xb0>)
 800b27e:	9b04      	ldr	r3, [sp, #16]
 800b280:	601a      	str	r2, [r3, #0]
 800b282:	e7dc      	b.n	800b23e <cdcacm_control_request+0x62>
			return 1;
		}
		return 0;
	}
	return 0;
 800b284:	2000      	movs	r0, #0
}
 800b286:	bd38      	pop	{r3, r4, r5, pc}
 800b288:	200000ac 	.word	0x200000ac
 800b28c:	0800b1ad 	.word	0x0800b1ad

0800b290 <cdcacm_set_config>:
	buf[9] = 0;
	usbd_ep_write_packet(dev, 0x82 + iface, buf, 10);
}

static void cdcacm_set_config(usbd_device *dev, uint16_t wValue)
{
 800b290:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* GDB interface */
#if defined(STM32F4) || defined(LM4F)
	usbd_ep_setup(dev, 0x01, USB_ENDPOINT_ATTR_BULK,
	              CDCACM_PACKET_SIZE, gdb_usb_out_cb);
#else
	usbd_ep_setup(dev, 0x01, USB_ENDPOINT_ATTR_BULK,
 800b292:	2500      	movs	r5, #0
	buf[9] = 0;
	usbd_ep_write_packet(dev, 0x82 + iface, buf, 10);
}

static void cdcacm_set_config(usbd_device *dev, uint16_t wValue)
{
 800b294:	1c04      	adds	r4, r0, #0
	configured = wValue;
 800b296:	4b1e      	ldr	r3, [pc, #120]	; (800b310 <cdcacm_set_config+0x80>)
	/* GDB interface */
#if defined(STM32F4) || defined(LM4F)
	usbd_ep_setup(dev, 0x01, USB_ENDPOINT_ATTR_BULK,
	              CDCACM_PACKET_SIZE, gdb_usb_out_cb);
#else
	usbd_ep_setup(dev, 0x01, USB_ENDPOINT_ATTR_BULK,
 800b298:	2202      	movs	r2, #2
	usbd_ep_write_packet(dev, 0x82 + iface, buf, 10);
}

static void cdcacm_set_config(usbd_device *dev, uint16_t wValue)
{
	configured = wValue;
 800b29a:	6019      	str	r1, [r3, #0]
	/* GDB interface */
#if defined(STM32F4) || defined(LM4F)
	usbd_ep_setup(dev, 0x01, USB_ENDPOINT_ATTR_BULK,
	              CDCACM_PACKET_SIZE, gdb_usb_out_cb);
#else
	usbd_ep_setup(dev, 0x01, USB_ENDPOINT_ATTR_BULK,
 800b29c:	9500      	str	r5, [sp, #0]
 800b29e:	2101      	movs	r1, #1
 800b2a0:	2340      	movs	r3, #64	; 0x40
 800b2a2:	f000 faa2 	bl	800b7ea <usbd_ep_setup>
	              CDCACM_PACKET_SIZE, NULL);
#endif
	usbd_ep_setup(dev, 0x81, USB_ENDPOINT_ATTR_BULK,
 800b2a6:	9500      	str	r5, [sp, #0]
 800b2a8:	1c20      	adds	r0, r4, #0
 800b2aa:	2181      	movs	r1, #129	; 0x81
 800b2ac:	2202      	movs	r2, #2
 800b2ae:	2340      	movs	r3, #64	; 0x40
 800b2b0:	f000 fa9b 	bl	800b7ea <usbd_ep_setup>
	              CDCACM_PACKET_SIZE, NULL);
	usbd_ep_setup(dev, 0x82, USB_ENDPOINT_ATTR_INTERRUPT, 16, NULL);
 800b2b4:	9500      	str	r5, [sp, #0]
 800b2b6:	1c20      	adds	r0, r4, #0
 800b2b8:	2182      	movs	r1, #130	; 0x82
 800b2ba:	2203      	movs	r2, #3
 800b2bc:	2310      	movs	r3, #16
 800b2be:	f000 fa94 	bl	800b7ea <usbd_ep_setup>

	/* Serial interface */
	usbd_ep_setup(dev, 0x03, USB_ENDPOINT_ATTR_BULK,
 800b2c2:	4b14      	ldr	r3, [pc, #80]	; (800b314 <cdcacm_set_config+0x84>)
 800b2c4:	1c20      	adds	r0, r4, #0
 800b2c6:	9300      	str	r3, [sp, #0]
 800b2c8:	2103      	movs	r1, #3
 800b2ca:	2202      	movs	r2, #2
 800b2cc:	2340      	movs	r3, #64	; 0x40
 800b2ce:	f000 fa8c 	bl	800b7ea <usbd_ep_setup>
	              CDCACM_PACKET_SIZE, usbuart_usb_out_cb);
	usbd_ep_setup(dev, 0x83, USB_ENDPOINT_ATTR_BULK,
 800b2d2:	4b11      	ldr	r3, [pc, #68]	; (800b318 <cdcacm_set_config+0x88>)
 800b2d4:	1c20      	adds	r0, r4, #0
 800b2d6:	9300      	str	r3, [sp, #0]
 800b2d8:	2183      	movs	r1, #131	; 0x83
 800b2da:	2202      	movs	r2, #2
 800b2dc:	2340      	movs	r3, #64	; 0x40
 800b2de:	f000 fa84 	bl	800b7ea <usbd_ep_setup>
	              CDCACM_PACKET_SIZE, usbuart_usb_in_cb);
	usbd_ep_setup(dev, 0x84, USB_ENDPOINT_ATTR_INTERRUPT, 16, NULL);
 800b2e2:	9500      	str	r5, [sp, #0]
 800b2e4:	1c20      	adds	r0, r4, #0
 800b2e6:	2184      	movs	r1, #132	; 0x84
 800b2e8:	2203      	movs	r2, #3
 800b2ea:	2310      	movs	r3, #16
 800b2ec:	f000 fa7d 	bl	800b7ea <usbd_ep_setup>
	/* Trace interface */
	usbd_ep_setup(dev, 0x85, USB_ENDPOINT_ATTR_BULK,
					64, trace_buf_drain);
#endif

	usbd_register_control_callback(dev,
 800b2f0:	227f      	movs	r2, #127	; 0x7f
 800b2f2:	4b0a      	ldr	r3, [pc, #40]	; (800b31c <cdcacm_set_config+0x8c>)
 800b2f4:	1c20      	adds	r0, r4, #0
 800b2f6:	2121      	movs	r1, #33	; 0x21
 800b2f8:	f000 fb64 	bl	800b9c4 <usbd_register_control_callback>
			cdcacm_control_request);

	/* Notify the host that DCD is asserted.
	 * Allows the use of /dev/tty* devices on *BSD/MacOS
	 */
	cdcacm_set_modem_state(dev, 0, true, true);
 800b2fc:	1c29      	adds	r1, r5, #0
 800b2fe:	1c20      	adds	r0, r4, #0
 800b300:	f7ff ff58 	bl	800b1b4 <cdcacm_set_modem_state.constprop.0>
	cdcacm_set_modem_state(dev, 2, true, true);
 800b304:	1c20      	adds	r0, r4, #0
 800b306:	2102      	movs	r1, #2
 800b308:	f7ff ff54 	bl	800b1b4 <cdcacm_set_modem_state.constprop.0>
}
 800b30c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 800b30e:	46c0      	nop			; (mov r8, r8)
 800b310:	20001bf8 	.word	0x20001bf8
 800b314:	0800b3ad 	.word	0x0800b3ad
 800b318:	0800b431 	.word	0x0800b431
 800b31c:	0800b1dd 	.word	0x0800b1dd

0800b320 <cdcacm_get_config>:
	return 0;
}

int cdcacm_get_config(void)
{
	return configured;
 800b320:	4b01      	ldr	r3, [pc, #4]	; (800b328 <cdcacm_get_config+0x8>)
 800b322:	6818      	ldr	r0, [r3, #0]
}
 800b324:	4770      	bx	lr
 800b326:	46c0      	nop			; (mov r8, r8)
 800b328:	20001bf8 	.word	0x20001bf8

0800b32c <cdcacm_get_dtr>:

int cdcacm_get_dtr(void)
{
	return cdcacm_gdb_dtr;
 800b32c:	4b01      	ldr	r3, [pc, #4]	; (800b334 <cdcacm_get_dtr+0x8>)
 800b32e:	6818      	ldr	r0, [r3, #0]
}
 800b330:	4770      	bx	lr
 800b332:	46c0      	nop			; (mov r8, r8)
 800b334:	200000ac 	.word	0x200000ac

0800b338 <cdcacm_init>:

/* We need a special large control buffer for this device: */
uint8_t usbd_control_buffer[256];

void cdcacm_init(void)
{
 800b338:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	void exti15_10_isr(void);

	serialno_read(serial_no);
 800b33a:	4810      	ldr	r0, [pc, #64]	; (800b37c <cdcacm_init+0x44>)
 800b33c:	f000 f87c 	bl	800b438 <serialno_read>

	usbdev = usbd_init(&USB_DRIVER, &dev, &config, usb_strings,
 800b340:	2306      	movs	r3, #6
 800b342:	9300      	str	r3, [sp, #0]
 800b344:	4b0e      	ldr	r3, [pc, #56]	; (800b380 <cdcacm_init+0x48>)
 800b346:	490f      	ldr	r1, [pc, #60]	; (800b384 <cdcacm_init+0x4c>)
 800b348:	9301      	str	r3, [sp, #4]
 800b34a:	2380      	movs	r3, #128	; 0x80
 800b34c:	1c0a      	adds	r2, r1, #0
 800b34e:	005b      	lsls	r3, r3, #1
 800b350:	9302      	str	r3, [sp, #8]
 800b352:	4b0d      	ldr	r3, [pc, #52]	; (800b388 <cdcacm_init+0x50>)
 800b354:	3212      	adds	r2, #18
 800b356:	3304      	adds	r3, #4
 800b358:	480c      	ldr	r0, [pc, #48]	; (800b38c <cdcacm_init+0x54>)
 800b35a:	f000 fa13 	bl	800b784 <usbd_init>
 800b35e:	4b0c      	ldr	r3, [pc, #48]	; (800b390 <cdcacm_init+0x58>)
			    sizeof(usb_strings)/sizeof(char *),
			    usbd_control_buffer, sizeof(usbd_control_buffer));

	usbd_register_set_config_callback(usbdev, cdcacm_set_config);
 800b360:	490c      	ldr	r1, [pc, #48]	; (800b394 <cdcacm_init+0x5c>)
{
	void exti15_10_isr(void);

	serialno_read(serial_no);

	usbdev = usbd_init(&USB_DRIVER, &dev, &config, usb_strings,
 800b362:	6018      	str	r0, [r3, #0]
			    sizeof(usb_strings)/sizeof(char *),
			    usbd_control_buffer, sizeof(usbd_control_buffer));

	usbd_register_set_config_callback(usbdev, cdcacm_set_config);
 800b364:	f000 feac 	bl	800c0c0 <usbd_register_set_config_callback>

	nvic_set_priority(USB_IRQ, IRQ_PRI_USB);
 800b368:	2120      	movs	r1, #32
 800b36a:	201f      	movs	r0, #31
 800b36c:	f000 ffec 	bl	800c348 <nvic_set_priority>
	nvic_enable_irq(USB_IRQ);
 800b370:	201f      	movs	r0, #31
 800b372:	f000 ffdd 	bl	800c330 <nvic_enable_irq>
}
 800b376:	b005      	add	sp, #20
 800b378:	bd00      	pop	{pc}
 800b37a:	46c0      	nop			; (mov r8, r8)
 800b37c:	20002184 	.word	0x20002184
 800b380:	20002084 	.word	0x20002084
 800b384:	08014f34 	.word	0x08014f34
 800b388:	200000ac 	.word	0x200000ac
 800b38c:	080151b4 	.word	0x080151b4
 800b390:	20002080 	.word	0x20002080
 800b394:	0800b291 	.word	0x0800b291

0800b398 <usb_isr>:

void USB_ISR(void)
{
 800b398:	b508      	push	{r3, lr}
	usbd_poll(usbdev);
 800b39a:	4b02      	ldr	r3, [pc, #8]	; (800b3a4 <usb_isr+0xc>)
 800b39c:	6818      	ldr	r0, [r3, #0]
 800b39e:	f000 fa1d 	bl	800b7dc <usbd_poll>
}
 800b3a2:	bd08      	pop	{r3, pc}
 800b3a4:	20002080 	.word	0x20002080

0800b3a8 <usbuart_init>:
	nvic_enable_irq(USBUSART_TIM_IRQ);

	/* turn the timer on */
	timer_enable_counter(USBUSART_TIM);
#endif
}
 800b3a8:	4770      	bx	lr

0800b3aa <usbuart_set_line_coding>:
	case 2:
		usart_set_parity(USBUSART, USART_PARITY_EVEN);
		break;
	}
#endif
}
 800b3aa:	4770      	bx	lr

0800b3ac <usbuart_usb_out_cb>:

void usbuart_usb_out_cb(usbd_device *dev, uint8_t ep)
{
 800b3ac:	b530      	push	{r4, r5, lr}
 800b3ae:	b091      	sub	sp, #68	; 0x44
	(void)ep;

	char buf[CDCACM_PACKET_SIZE];
	int len = usbd_ep_read_packet(dev, CDCACM_UART_ENDPOINT,
 800b3b0:	2103      	movs	r1, #3
 800b3b2:	466a      	mov	r2, sp
 800b3b4:	2340      	movs	r3, #64	; 0x40
 800b3b6:	f000 fa40 	bl	800b83a <usbd_ep_read_packet>
 800b3ba:	1c05      	adds	r5, r0, #0
	 */
	if(!(RCC_APB2ENR & RCC_APB2ENR_USART1EN))
		return;
#endif

	gpio_set(LED_PORT_UART, LED_UART);
 800b3bc:	2090      	movs	r0, #144	; 0x90
 800b3be:	2101      	movs	r1, #1
 800b3c0:	05c0      	lsls	r0, r0, #23
 800b3c2:	f000 f977 	bl	800b6b4 <gpio_set>
	for(int i = 0; i < len; i++)
 800b3c6:	2400      	movs	r4, #0
 800b3c8:	42ac      	cmp	r4, r5
 800b3ca:	da06      	bge.n	800b3da <usbuart_usb_out_cb+0x2e>
		usart_send_blocking(USBUSART, buf[i]);
 800b3cc:	466b      	mov	r3, sp
 800b3ce:	4806      	ldr	r0, [pc, #24]	; (800b3e8 <usbuart_usb_out_cb+0x3c>)
 800b3d0:	5d19      	ldrb	r1, [r3, r4]
 800b3d2:	f000 f967 	bl	800b6a4 <usart_send_blocking>
	if(!(RCC_APB2ENR & RCC_APB2ENR_USART1EN))
		return;
#endif

	gpio_set(LED_PORT_UART, LED_UART);
	for(int i = 0; i < len; i++)
 800b3d6:	3401      	adds	r4, #1
 800b3d8:	e7f6      	b.n	800b3c8 <usbuart_usb_out_cb+0x1c>
		usart_send_blocking(USBUSART, buf[i]);
	gpio_clear(LED_PORT_UART, LED_UART);
 800b3da:	2090      	movs	r0, #144	; 0x90
 800b3dc:	2101      	movs	r1, #1
 800b3de:	05c0      	lsls	r0, r0, #23
 800b3e0:	f000 f96a 	bl	800b6b8 <gpio_clear>
}
 800b3e4:	b011      	add	sp, #68	; 0x44
 800b3e6:	bd30      	pop	{r4, r5, pc}
 800b3e8:	40004400 	.word	0x40004400

0800b3ec <usbuart_debug_write>:

#ifdef USBUART_DEBUG
int usbuart_debug_write(const char *buf, size_t len)
{
 800b3ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b3ee:	1c0c      	adds	r4, r1, #0
 800b3f0:	4a0d      	ldr	r2, [pc, #52]	; (800b428 <usbuart_debug_write+0x3c>)
 800b3f2:	1845      	adds	r5, r0, r1
 800b3f4:	7813      	ldrb	r3, [r2, #0]
	for (size_t i = 0; i < len; i++) {
 800b3f6:	42a8      	cmp	r0, r5
 800b3f8:	d00f      	beq.n	800b41a <usbuart_debug_write+0x2e>
		if (buf[i] == '\n') {
 800b3fa:	7806      	ldrb	r6, [r0, #0]
 800b3fc:	2e0a      	cmp	r6, #10
 800b3fe:	d105      	bne.n	800b40c <usbuart_debug_write+0x20>
			buf_rx[buf_rx_in++] = '\r';
 800b400:	270d      	movs	r7, #13
 800b402:	1c51      	adds	r1, r2, #1
 800b404:	54cf      	strb	r7, [r1, r3]
			buf_rx_in %= FIFO_SIZE;
 800b406:	217f      	movs	r1, #127	; 0x7f
#ifdef USBUART_DEBUG
int usbuart_debug_write(const char *buf, size_t len)
{
	for (size_t i = 0; i < len; i++) {
		if (buf[i] == '\n') {
			buf_rx[buf_rx_in++] = '\r';
 800b408:	3301      	adds	r3, #1
			buf_rx_in %= FIFO_SIZE;
 800b40a:	400b      	ands	r3, r1
		}
		buf_rx[buf_rx_in++] = buf[i];
 800b40c:	1c51      	adds	r1, r2, #1
 800b40e:	54ce      	strb	r6, [r1, r3]
		buf_rx_in %= FIFO_SIZE;
 800b410:	217f      	movs	r1, #127	; 0x7f
	for (size_t i = 0; i < len; i++) {
		if (buf[i] == '\n') {
			buf_rx[buf_rx_in++] = '\r';
			buf_rx_in %= FIFO_SIZE;
		}
		buf_rx[buf_rx_in++] = buf[i];
 800b412:	3301      	adds	r3, #1
		buf_rx_in %= FIFO_SIZE;
 800b414:	400b      	ands	r3, r1
 800b416:	3001      	adds	r0, #1
 800b418:	e7ed      	b.n	800b3f6 <usbuart_debug_write+0xa>
	}
	/* enable deferred processing if we put data in the FIFO */
	timer_enable_irq(USBUSART_TIM, TIM_DIER_UIE);
 800b41a:	4804      	ldr	r0, [pc, #16]	; (800b42c <usbuart_debug_write+0x40>)
 800b41c:	2101      	movs	r1, #1
 800b41e:	7013      	strb	r3, [r2, #0]
 800b420:	f000 f99c 	bl	800b75c <timer_enable_irq>
	return len;
}
 800b424:	1c20      	adds	r0, r4, #0
 800b426:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b428:	20001bfc 	.word	0x20001bfc
 800b42c:	40000400 	.word	0x40000400

0800b430 <usbuart_usb_in_cb>:

void usbuart_usb_in_cb(usbd_device *dev, uint8_t ep)
{
	(void) dev;
	(void) ep;
}
 800b430:	4770      	bx	lr

0800b432 <usart2_isr>:

		/* enable deferred processing if we put data in the FIFO */
		timer_enable_irq(USBUSART_TIM, TIM_DIER_UIE);
	}
#endif
}
 800b432:	4770      	bx	lr

0800b434 <tim3_isr>:
	timer_clear_flag(USBUSART_TIM, TIM_SR_UIF);

	/* process FIFO */
	usbuart_run();
#endif
}
 800b434:	4770      	bx	lr
 800b436:	46c0      	nop			; (mov r8, r8)

0800b438 <serialno_read>:
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFF7A10;
#else
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFFF7E8;
#endif
	uint32_t unique_id = *unique_id_p +
			*(unique_id_p + 1) +
 800b438:	4a12      	ldr	r2, [pc, #72]	; (800b484 <serialno_read+0x4c>)
#if defined(STM32F4)
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFF7A10;
#else
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFFF7E8;
#endif
	uint32_t unique_id = *unique_id_p +
 800b43a:	4b13      	ldr	r3, [pc, #76]	; (800b488 <serialno_read+0x50>)
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "general.h"

char *serialno_read(char *s)
{
 800b43c:	b530      	push	{r4, r5, lr}
#if defined(STM32F4)
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFF7A10;
#else
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFFF7E8;
#endif
	uint32_t unique_id = *unique_id_p +
 800b43e:	681b      	ldr	r3, [r3, #0]
			*(unique_id_p + 1) +
 800b440:	6814      	ldr	r4, [r2, #0]
			*(unique_id_p + 2);
 800b442:	4a12      	ldr	r2, [pc, #72]	; (800b48c <serialno_read+0x54>)
#if defined(STM32F4)
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFF7A10;
#else
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFFF7E8;
#endif
	uint32_t unique_id = *unique_id_p +
 800b444:	18e4      	adds	r4, r4, r3
 800b446:	2300      	movs	r3, #0
			*(unique_id_p + 1) +
			*(unique_id_p + 2);
 800b448:	6812      	ldr	r2, [r2, #0]
#if defined(STM32F4)
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFF7A10;
#else
	volatile uint32_t *unique_id_p = (volatile uint32_t *)0x1FFFF7E8;
#endif
	uint32_t unique_id = *unique_id_p +
 800b44a:	18a4      	adds	r4, r4, r2
			*(unique_id_p + 2);
	int i;

	/* Fetch serial number from chip's unique ID */
	for(i = 0; i < 8; i++) {
		s[7-i] = ((unique_id >> (4*i)) & 0xF) + '0';
 800b44c:	1c21      	adds	r1, r4, #0
 800b44e:	009a      	lsls	r2, r3, #2
 800b450:	4252      	negs	r2, r2
 800b452:	40d1      	lsrs	r1, r2
 800b454:	1c0a      	adds	r2, r1, #0
 800b456:	210f      	movs	r1, #15
 800b458:	400a      	ands	r2, r1
 800b45a:	18c5      	adds	r5, r0, r3
 800b45c:	3230      	adds	r2, #48	; 0x30
 800b45e:	3b01      	subs	r3, #1
 800b460:	71ea      	strb	r2, [r5, #7]
			*(unique_id_p + 1) +
			*(unique_id_p + 2);
	int i;

	/* Fetch serial number from chip's unique ID */
	for(i = 0; i < 8; i++) {
 800b462:	1c1a      	adds	r2, r3, #0
 800b464:	3208      	adds	r2, #8
 800b466:	d1f1      	bne.n	800b44c <serialno_read+0x14>
 800b468:	1c01      	adds	r1, r0, #0
 800b46a:	1c03      	adds	r3, r0, #0
 800b46c:	3108      	adds	r1, #8
		s[7-i] = ((unique_id >> (4*i)) & 0xF) + '0';
	}
	for(i = 0; i < 8; i++)
		if(s[i] > '9')
 800b46e:	781a      	ldrb	r2, [r3, #0]
 800b470:	2a39      	cmp	r2, #57	; 0x39
 800b472:	d901      	bls.n	800b478 <serialno_read+0x40>
			s[i] += 'A' - '9' - 1;
 800b474:	3207      	adds	r2, #7
 800b476:	701a      	strb	r2, [r3, #0]
 800b478:	3301      	adds	r3, #1

	/* Fetch serial number from chip's unique ID */
	for(i = 0; i < 8; i++) {
		s[7-i] = ((unique_id >> (4*i)) & 0xF) + '0';
	}
	for(i = 0; i < 8; i++)
 800b47a:	428b      	cmp	r3, r1
 800b47c:	d1f7      	bne.n	800b46e <serialno_read+0x36>
		if(s[i] > '9')
			s[i] += 'A' - '9' - 1;
	s[8] = 0;
 800b47e:	2300      	movs	r3, #0
 800b480:	7203      	strb	r3, [r0, #8]

	return s;
}
 800b482:	bd30      	pop	{r4, r5, pc}
 800b484:	1ffff7ec 	.word	0x1ffff7ec
 800b488:	1ffff7e8 	.word	0x1ffff7e8
 800b48c:	1ffff7f0 	.word	0x1ffff7f0

0800b490 <platform_timeout_set>:
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include "general.h"

void platform_timeout_set(platform_timeout *t, uint32_t ms)
{
 800b490:	b538      	push	{r3, r4, r5, lr}
 800b492:	1c05      	adds	r5, r0, #0
 800b494:	1c0c      	adds	r4, r1, #0
	t->time = platform_time_ms() + ms;
 800b496:	f000 f849 	bl	800b52c <platform_time_ms>
 800b49a:	1904      	adds	r4, r0, r4
 800b49c:	602c      	str	r4, [r5, #0]
}
 800b49e:	bd38      	pop	{r3, r4, r5, pc}

0800b4a0 <platform_timeout_is_expired>:

bool platform_timeout_is_expired(platform_timeout *t)
{
 800b4a0:	b510      	push	{r4, lr}
 800b4a2:	1c04      	adds	r4, r0, #0
	return platform_time_ms() > t->time;
 800b4a4:	f000 f842 	bl	800b52c <platform_time_ms>
 800b4a8:	6823      	ldr	r3, [r4, #0]
 800b4aa:	4283      	cmp	r3, r0
 800b4ac:	4180      	sbcs	r0, r0
 800b4ae:	4240      	negs	r0, r0
}
 800b4b0:	bd10      	pop	{r4, pc}
	...

0800b4b4 <platform_timing_init>:

uint8_t running_status;
static volatile uint32_t time_ms;

void platform_timing_init(void)
{
 800b4b4:	b508      	push	{r3, lr}
	/* Setup heartbeat timer */
	systick_set_clocksource(STK_CSR_CLKSOURCE_EXT);
 800b4b6:	2000      	movs	r0, #0
 800b4b8:	f000 ff20 	bl	800c2fc <systick_set_clocksource>
	systick_set_reload(600000);	/* Interrupt us at 10 Hz */
 800b4bc:	4808      	ldr	r0, [pc, #32]	; (800b4e0 <platform_timing_init+0x2c>)
 800b4be:	f000 ff15 	bl	800c2ec <systick_set_reload>
	SCB_SHPR(11) &= ~((15 << 4) & 0xff);
 800b4c2:	220f      	movs	r2, #15
 800b4c4:	4b07      	ldr	r3, [pc, #28]	; (800b4e4 <platform_timing_init+0x30>)
 800b4c6:	7819      	ldrb	r1, [r3, #0]
 800b4c8:	400a      	ands	r2, r1
 800b4ca:	701a      	strb	r2, [r3, #0]
	SCB_SHPR(11) |= ((14 << 4) & 0xff);
 800b4cc:	22e0      	movs	r2, #224	; 0xe0
 800b4ce:	7819      	ldrb	r1, [r3, #0]
 800b4d0:	430a      	orrs	r2, r1
 800b4d2:	701a      	strb	r2, [r3, #0]
	systick_interrupt_enable();
 800b4d4:	f000 ff1c 	bl	800c310 <systick_interrupt_enable>
	systick_counter_enable();
 800b4d8:	f000 ff22 	bl	800c320 <systick_counter_enable>
}
 800b4dc:	bd08      	pop	{r3, pc}
 800b4de:	46c0      	nop			; (mov r8, r8)
 800b4e0:	000927c0 	.word	0x000927c0
 800b4e4:	e000ed23 	.word	0xe000ed23

0800b4e8 <platform_delay>:

void platform_delay(uint32_t ms)
{
 800b4e8:	b507      	push	{r0, r1, r2, lr}
 800b4ea:	1c01      	adds	r1, r0, #0
	platform_timeout timeout;
	platform_timeout_set(&timeout, ms);
 800b4ec:	a801      	add	r0, sp, #4
 800b4ee:	f7ff ffcf 	bl	800b490 <platform_timeout_set>
	while (!platform_timeout_is_expired(&timeout));
 800b4f2:	a801      	add	r0, sp, #4
 800b4f4:	f7ff ffd4 	bl	800b4a0 <platform_timeout_is_expired>
 800b4f8:	2800      	cmp	r0, #0
 800b4fa:	d0fa      	beq.n	800b4f2 <platform_delay+0xa>
}
 800b4fc:	bd07      	pop	{r0, r1, r2, pc}

0800b4fe <sys_tick_handler>:

void sys_tick_handler(void)
{
 800b4fe:	b508      	push	{r3, lr}
	if(running_status)
 800b500:	4b07      	ldr	r3, [pc, #28]	; (800b520 <sys_tick_handler+0x22>)
 800b502:	781b      	ldrb	r3, [r3, #0]
 800b504:	2b00      	cmp	r3, #0
 800b506:	d005      	beq.n	800b514 <sys_tick_handler+0x16>
		gpio_toggle(LED_PORT, LED_IDLE_RUN);
 800b508:	2090      	movs	r0, #144	; 0x90
 800b50a:	4b06      	ldr	r3, [pc, #24]	; (800b524 <sys_tick_handler+0x26>)
 800b50c:	05c0      	lsls	r0, r0, #23
 800b50e:	8819      	ldrh	r1, [r3, #0]
 800b510:	f000 f8d8 	bl	800b6c4 <gpio_toggle>

	time_ms += 100;
 800b514:	4a04      	ldr	r2, [pc, #16]	; (800b528 <sys_tick_handler+0x2a>)
 800b516:	6813      	ldr	r3, [r2, #0]
 800b518:	3364      	adds	r3, #100	; 0x64
 800b51a:	6013      	str	r3, [r2, #0]

	SET_ERROR_STATE(morse_update());
}
 800b51c:	bd08      	pop	{r3, pc}
 800b51e:	46c0      	nop			; (mov r8, r8)
 800b520:	2000207c 	.word	0x2000207c
 800b524:	20002064 	.word	0x20002064
 800b528:	20001c80 	.word	0x20001c80

0800b52c <platform_time_ms>:

uint32_t platform_time_ms(void)
{
	return time_ms;
 800b52c:	4b01      	ldr	r3, [pc, #4]	; (800b534 <platform_time_ms+0x8>)
 800b52e:	6818      	ldr	r0, [r3, #0]
}
 800b530:	4770      	bx	lr
 800b532:	46c0      	nop			; (mov r8, r8)
 800b534:	20001c80 	.word	0x20001c80

0800b538 <rcc_is_osc_ready>:
{
	return ((RCC_CIR & RCC_CIR_CSSF) != 0);
}

bool rcc_is_osc_ready(enum rcc_osc osc)
{
 800b538:	b500      	push	{lr}
	case RCC_LSE:
		return (RCC_BDCR & RCC_BDCR_LSERDY);
	case RCC_LSI:
		return (RCC_CSR & RCC_CSR_LSIRDY);
	}
	return false;
 800b53a:	2300      	movs	r3, #0
	return ((RCC_CIR & RCC_CIR_CSSF) != 0);
}

bool rcc_is_osc_ready(enum rcc_osc osc)
{
	switch (osc) {
 800b53c:	2806      	cmp	r0, #6
 800b53e:	d81a      	bhi.n	800b576 <rcc_is_osc_ready+0x3e>
 800b540:	2201      	movs	r2, #1
 800b542:	f003 fa1b 	bl	800e97c <__gnu_thumb1_case_uqi>
 800b546:	0806      	.short	0x0806
 800b548:	12140e0a 	.word	0x12140e0a
 800b54c:	04          	.byte	0x04
 800b54d:	00          	.byte	0x00
	case RCC_HSI48:
		return (RCC_CR2 & RCC_CR2_HSI48RDY);
 800b54e:	4b0b      	ldr	r3, [pc, #44]	; (800b57c <rcc_is_osc_ready+0x44>)
 800b550:	e004      	b.n	800b55c <rcc_is_osc_ready+0x24>
	case RCC_HSI14:
		return (RCC_CR2 & RCC_CR2_HSI14RDY);
 800b552:	4b0a      	ldr	r3, [pc, #40]	; (800b57c <rcc_is_osc_ready+0x44>)
 800b554:	e00c      	b.n	800b570 <rcc_is_osc_ready+0x38>
	case RCC_HSI:
		return (RCC_CR & RCC_CR_HSIRDY);
 800b556:	4b0a      	ldr	r3, [pc, #40]	; (800b580 <rcc_is_osc_ready+0x48>)
 800b558:	e00a      	b.n	800b570 <rcc_is_osc_ready+0x38>
	case RCC_HSE:
		return (RCC_CR & RCC_CR_HSERDY);
 800b55a:	4b09      	ldr	r3, [pc, #36]	; (800b580 <rcc_is_osc_ready+0x48>)
 800b55c:	681b      	ldr	r3, [r3, #0]
 800b55e:	0c5b      	lsrs	r3, r3, #17
 800b560:	e008      	b.n	800b574 <rcc_is_osc_ready+0x3c>
	case RCC_PLL:
		return (RCC_CR & RCC_CR_PLLRDY);
 800b562:	4b07      	ldr	r3, [pc, #28]	; (800b580 <rcc_is_osc_ready+0x48>)
 800b564:	681b      	ldr	r3, [r3, #0]
 800b566:	0e5b      	lsrs	r3, r3, #25
 800b568:	e004      	b.n	800b574 <rcc_is_osc_ready+0x3c>
	case RCC_LSE:
		return (RCC_BDCR & RCC_BDCR_LSERDY);
 800b56a:	4b06      	ldr	r3, [pc, #24]	; (800b584 <rcc_is_osc_ready+0x4c>)
 800b56c:	e000      	b.n	800b570 <rcc_is_osc_ready+0x38>
	case RCC_LSI:
		return (RCC_CSR & RCC_CSR_LSIRDY);
 800b56e:	4b06      	ldr	r3, [pc, #24]	; (800b588 <rcc_is_osc_ready+0x50>)
 800b570:	681b      	ldr	r3, [r3, #0]
 800b572:	085b      	lsrs	r3, r3, #1
 800b574:	4013      	ands	r3, r2
	}
	return false;
}
 800b576:	1c18      	adds	r0, r3, #0
 800b578:	bd00      	pop	{pc}
 800b57a:	46c0      	nop			; (mov r8, r8)
 800b57c:	40021034 	.word	0x40021034
 800b580:	40021000 	.word	0x40021000
 800b584:	40021020 	.word	0x40021020
 800b588:	40021024 	.word	0x40021024

0800b58c <rcc_wait_for_osc_ready>:

void rcc_wait_for_osc_ready(enum rcc_osc osc)
{
 800b58c:	b510      	push	{r4, lr}
 800b58e:	1c04      	adds	r4, r0, #0
	while (!rcc_is_osc_ready(osc));
 800b590:	1c20      	adds	r0, r4, #0
 800b592:	f7ff ffd1 	bl	800b538 <rcc_is_osc_ready>
 800b596:	2800      	cmp	r0, #0
 800b598:	d0fa      	beq.n	800b590 <rcc_wait_for_osc_ready+0x4>
}
 800b59a:	bd10      	pop	{r4, pc}

0800b59c <rcc_osc_on>:
 *
 * @param[in] osc enum ::osc_t. Oscillator ID
 */

void rcc_osc_on(enum rcc_osc osc)
{
 800b59c:	b500      	push	{lr}
	switch (osc) {
 800b59e:	2806      	cmp	r0, #6
 800b5a0:	d81c      	bhi.n	800b5dc <rcc_osc_on+0x40>
 800b5a2:	f003 f9eb 	bl	800e97c <__gnu_thumb1_case_uqi>
 800b5a6:	0806      	.short	0x0806
 800b5a8:	0f11150a 	.word	0x0f11150a
 800b5ac:	04          	.byte	0x04
 800b5ad:	00          	.byte	0x00
	case RCC_HSI48:
		RCC_CR2 |= RCC_CR2_HSI48ON;
 800b5ae:	4a0c      	ldr	r2, [pc, #48]	; (800b5e0 <rcc_osc_on+0x44>)
 800b5b0:	e004      	b.n	800b5bc <rcc_osc_on+0x20>
		break;
	case RCC_HSI14:
		RCC_CR2 |= RCC_CR2_HSI14ON;
 800b5b2:	4a0b      	ldr	r2, [pc, #44]	; (800b5e0 <rcc_osc_on+0x44>)
 800b5b4:	e009      	b.n	800b5ca <rcc_osc_on+0x2e>
		break;
	case RCC_HSI:
		RCC_CR |= RCC_CR_HSION;
 800b5b6:	4a0b      	ldr	r2, [pc, #44]	; (800b5e4 <rcc_osc_on+0x48>)
 800b5b8:	e007      	b.n	800b5ca <rcc_osc_on+0x2e>
		break;
	case RCC_HSE:
		RCC_CR |= RCC_CR_HSEON;
 800b5ba:	4a0a      	ldr	r2, [pc, #40]	; (800b5e4 <rcc_osc_on+0x48>)
 800b5bc:	2180      	movs	r1, #128	; 0x80
 800b5be:	6813      	ldr	r3, [r2, #0]
 800b5c0:	0249      	lsls	r1, r1, #9
 800b5c2:	e009      	b.n	800b5d8 <rcc_osc_on+0x3c>
		break;
	case RCC_LSE:
		RCC_BDCR |= RCC_BDCR_LSEON;
 800b5c4:	4a08      	ldr	r2, [pc, #32]	; (800b5e8 <rcc_osc_on+0x4c>)
 800b5c6:	e000      	b.n	800b5ca <rcc_osc_on+0x2e>
		break;
	case RCC_LSI:
		RCC_CSR |= RCC_CSR_LSION;
 800b5c8:	4a08      	ldr	r2, [pc, #32]	; (800b5ec <rcc_osc_on+0x50>)
 800b5ca:	6813      	ldr	r3, [r2, #0]
 800b5cc:	2101      	movs	r1, #1
 800b5ce:	e003      	b.n	800b5d8 <rcc_osc_on+0x3c>
		break;
	case RCC_PLL:
		RCC_CR |= RCC_CR_PLLON;
 800b5d0:	2180      	movs	r1, #128	; 0x80
 800b5d2:	4a04      	ldr	r2, [pc, #16]	; (800b5e4 <rcc_osc_on+0x48>)
 800b5d4:	0449      	lsls	r1, r1, #17
 800b5d6:	6813      	ldr	r3, [r2, #0]
 800b5d8:	430b      	orrs	r3, r1
 800b5da:	6013      	str	r3, [r2, #0]
		break;
	}
}
 800b5dc:	bd00      	pop	{pc}
 800b5de:	46c0      	nop			; (mov r8, r8)
 800b5e0:	40021034 	.word	0x40021034
 800b5e4:	40021000 	.word	0x40021000
 800b5e8:	40021020 	.word	0x40021020
 800b5ec:	40021024 	.word	0x40021024

0800b5f0 <rcc_set_sysclk_source>:
 * effect.
 */

void rcc_set_sysclk_source(enum rcc_osc clk)
{
	switch (clk) {
 800b5f0:	3801      	subs	r0, #1
 * @param[in] osc enum ::osc_t. Oscillator ID. Only HSE, LSE and PLL have
 * effect.
 */

void rcc_set_sysclk_source(enum rcc_osc clk)
{
 800b5f2:	b500      	push	{lr}
	switch (clk) {
 800b5f4:	2805      	cmp	r0, #5
 800b5f6:	d81a      	bhi.n	800b62e <rcc_set_sysclk_source+0x3e>
 800b5f8:	f003 f9c0 	bl	800e97c <__gnu_thumb1_case_uqi>
 800b5fc:	190e0803 	.word	0x190e0803
 800b600:	1419      	.short	0x1419
	case RCC_HSI:
		RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI;
 800b602:	2103      	movs	r1, #3
 800b604:	4a0a      	ldr	r2, [pc, #40]	; (800b630 <rcc_set_sysclk_source+0x40>)
 800b606:	6813      	ldr	r3, [r2, #0]
 800b608:	438b      	bics	r3, r1
 800b60a:	e00f      	b.n	800b62c <rcc_set_sysclk_source+0x3c>
		break;
	case RCC_HSE:
		RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSE;
 800b60c:	2103      	movs	r1, #3
 800b60e:	4a08      	ldr	r2, [pc, #32]	; (800b630 <rcc_set_sysclk_source+0x40>)
 800b610:	6813      	ldr	r3, [r2, #0]
 800b612:	438b      	bics	r3, r1
 800b614:	3902      	subs	r1, #2
 800b616:	e008      	b.n	800b62a <rcc_set_sysclk_source+0x3a>
		break;
	case RCC_PLL:
		RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_PLL;
 800b618:	2103      	movs	r1, #3
 800b61a:	4a05      	ldr	r2, [pc, #20]	; (800b630 <rcc_set_sysclk_source+0x40>)
 800b61c:	6813      	ldr	r3, [r2, #0]
 800b61e:	438b      	bics	r3, r1
 800b620:	3901      	subs	r1, #1
 800b622:	e002      	b.n	800b62a <rcc_set_sysclk_source+0x3a>
		break;
	case RCC_HSI48:
		RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_HSI48;
 800b624:	2103      	movs	r1, #3
 800b626:	4a02      	ldr	r2, [pc, #8]	; (800b630 <rcc_set_sysclk_source+0x40>)
 800b628:	6813      	ldr	r3, [r2, #0]
 800b62a:	430b      	orrs	r3, r1
 800b62c:	6013      	str	r3, [r2, #0]
	case RCC_LSE:
	case RCC_HSI14:
		/* do nothing */
		break;
	}
}
 800b62e:	bd00      	pop	{pc}
 800b630:	40021004 	.word	0x40021004

0800b634 <rcc_set_usbclk_source>:
 * @param[in] osc enum ::osc_t. Oscillator ID. Only HSI48 or PLL have
 * effect.
 */
void rcc_set_usbclk_source(enum rcc_osc clk)
{
	switch (clk) {
 800b634:	2803      	cmp	r0, #3
 800b636:	d006      	beq.n	800b646 <rcc_set_usbclk_source+0x12>
 800b638:	2806      	cmp	r0, #6
 800b63a:	d109      	bne.n	800b650 <rcc_set_usbclk_source+0x1c>
	case RCC_PLL:
		RCC_CFGR3 |= RCC_CFGR3_USBSW;
		break;
	case RCC_HSI48:
		RCC_CFGR3 &= ~RCC_CFGR3_USBSW;
 800b63c:	2180      	movs	r1, #128	; 0x80
 800b63e:	4a05      	ldr	r2, [pc, #20]	; (800b654 <rcc_set_usbclk_source+0x20>)
 800b640:	6813      	ldr	r3, [r2, #0]
 800b642:	438b      	bics	r3, r1
 800b644:	e003      	b.n	800b64e <rcc_set_usbclk_source+0x1a>
 */
void rcc_set_usbclk_source(enum rcc_osc clk)
{
	switch (clk) {
	case RCC_PLL:
		RCC_CFGR3 |= RCC_CFGR3_USBSW;
 800b646:	2180      	movs	r1, #128	; 0x80
 800b648:	4a02      	ldr	r2, [pc, #8]	; (800b654 <rcc_set_usbclk_source+0x20>)
 800b64a:	6813      	ldr	r3, [r2, #0]
 800b64c:	430b      	orrs	r3, r1
		break;
	case RCC_HSI48:
		RCC_CFGR3 &= ~RCC_CFGR3_USBSW;
 800b64e:	6013      	str	r3, [r2, #0]
	case RCC_LSE:
	case RCC_HSI14:
		/* do nothing */
		break;
	}
}
 800b650:	4770      	bx	lr
 800b652:	46c0      	nop			; (mov r8, r8)
 800b654:	40021030 	.word	0x40021030

0800b658 <rcc_set_pll_multiplication_factor>:
 * @param[in] mul Unsigned int32. PLL multiplication factor @ref rcc_cfgr_pmf
 */

void rcc_set_pll_multiplication_factor(uint32_t mul)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PLLMUL) | mul;
 800b658:	4a03      	ldr	r2, [pc, #12]	; (800b668 <rcc_set_pll_multiplication_factor+0x10>)
 800b65a:	4b04      	ldr	r3, [pc, #16]	; (800b66c <rcc_set_pll_multiplication_factor+0x14>)
 800b65c:	6811      	ldr	r1, [r2, #0]
 800b65e:	400b      	ands	r3, r1
 800b660:	4318      	orrs	r0, r3
 800b662:	6010      	str	r0, [r2, #0]
}
 800b664:	4770      	bx	lr
 800b666:	46c0      	nop			; (mov r8, r8)
 800b668:	40021004 	.word	0x40021004
 800b66c:	ffc3ffff 	.word	0xffc3ffff

0800b670 <rcc_set_ppre>:
 * @param[in] ppre1 Unsigned int32. APB prescale factor @ref rcc_cfgr_apb1pre
 */

void rcc_set_ppre(uint32_t ppre)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PPRE) | ppre;
 800b670:	4a03      	ldr	r2, [pc, #12]	; (800b680 <rcc_set_ppre+0x10>)
 800b672:	4b04      	ldr	r3, [pc, #16]	; (800b684 <rcc_set_ppre+0x14>)
 800b674:	6811      	ldr	r1, [r2, #0]
 800b676:	400b      	ands	r3, r1
 800b678:	4318      	orrs	r0, r3
 800b67a:	6010      	str	r0, [r2, #0]
}
 800b67c:	4770      	bx	lr
 800b67e:	46c0      	nop			; (mov r8, r8)
 800b680:	40021004 	.word	0x40021004
 800b684:	fffff8ff 	.word	0xfffff8ff

0800b688 <rcc_set_hpre>:
 * @param[in] hpre Unsigned int32. AHB prescale factor @ref rcc_cfgr_ahbpre
 */

void rcc_set_hpre(uint32_t hpre)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_HPRE) | hpre;
 800b688:	21f0      	movs	r1, #240	; 0xf0
 800b68a:	4a03      	ldr	r2, [pc, #12]	; (800b698 <rcc_set_hpre+0x10>)
 800b68c:	6813      	ldr	r3, [r2, #0]
 800b68e:	438b      	bics	r3, r1
 800b690:	4318      	orrs	r0, r3
 800b692:	6010      	str	r0, [r2, #0]
}
 800b694:	4770      	bx	lr
 800b696:	46c0      	nop			; (mov r8, r8)
 800b698:	40021004 	.word	0x40021004

0800b69c <usart_wait_send_ready>:
 */

void usart_wait_send_ready(uint32_t usart)
{
	/* Wait until the data has been transferred into the shift register. */
	while ((USART_ISR(usart) & USART_ISR_TXE) == 0);
 800b69c:	69c3      	ldr	r3, [r0, #28]
 800b69e:	061b      	lsls	r3, r3, #24
 800b6a0:	d5fc      	bpl.n	800b69c <usart_wait_send_ready>
}
 800b6a2:	4770      	bx	lr

0800b6a4 <usart_send_blocking>:
 * usart_reg_base
 * @param[in] data unsigned 16 bit.
 */

void usart_send_blocking(uint32_t usart, uint8_t data)
{
 800b6a4:	b538      	push	{r3, r4, r5, lr}
 800b6a6:	1c04      	adds	r4, r0, #0
 800b6a8:	1c0d      	adds	r5, r1, #0
 * @param[in] data unsigned 16 bit.
 */

void usart_send(uint32_t usart, uint8_t data)
{
	USART_TDR(usart) = data;
 800b6aa:	3428      	adds	r4, #40	; 0x28
 * @param[in] data unsigned 16 bit.
 */

void usart_send_blocking(uint32_t usart, uint8_t data)
{
	usart_wait_send_ready(usart);
 800b6ac:	f7ff fff6 	bl	800b69c <usart_wait_send_ready>
 * @param[in] data unsigned 16 bit.
 */

void usart_send(uint32_t usart, uint8_t data)
{
	USART_TDR(usart) = data;
 800b6b0:	7025      	strb	r5, [r4, #0]

void usart_send_blocking(uint32_t usart, uint8_t data)
{
	usart_wait_send_ready(usart);
	usart_send(usart, data);
}
 800b6b2:	bd38      	pop	{r3, r4, r5, pc}

0800b6b4 <gpio_set>:
	     If multiple pins are to be changed, use bitwise OR '|' to separate
	     them.
*/
void gpio_set(uint32_t gpioport, uint16_t gpios)
{
	GPIO_BSRR(gpioport) = gpios;
 800b6b4:	6181      	str	r1, [r0, #24]
}
 800b6b6:	4770      	bx	lr

0800b6b8 <gpio_clear>:
	     If multiple pins are to be changed, use bitwise OR '|' to separate
	     them.
*/
void  gpio_clear(uint32_t gpioport, uint16_t gpios)
{
	GPIO_BSRR(gpioport) = (gpios << 16);
 800b6b8:	0409      	lsls	r1, r1, #16
 800b6ba:	6181      	str	r1, [r0, #24]
}
 800b6bc:	4770      	bx	lr

0800b6be <gpio_get>:
@param[in] gpioport Unsigned int32. Port identifier @ref gpio_port_id
@return Unsigned int16. The value held in the specified GPIO port.
*/
uint16_t gpio_port_read(uint32_t gpioport)
{
	return (uint16_t)GPIO_IDR(gpioport);
 800b6be:	6900      	ldr	r0, [r0, #16]
@return Unsigned int16 value of the pin values. The bit position of the pin
	value returned corresponds to the pin number.
*/
uint16_t gpio_get(uint32_t gpioport, uint16_t gpios)
{
	return gpio_port_read(gpioport) & gpios;
 800b6c0:	4008      	ands	r0, r1
}
 800b6c2:	4770      	bx	lr

0800b6c4 <gpio_toggle>:
	     them.
*/
void gpio_toggle(uint32_t gpioport, uint16_t gpios)
{
	uint32_t port = GPIO_ODR(gpioport);
	GPIO_BSRR(gpioport) = ((port & gpios) << 16) | (~port & gpios);
 800b6c4:	1c0a      	adds	r2, r1, #0
	     If multiple pins are to be changed, use bitwise OR '|' to separate
	     them.
*/
void gpio_toggle(uint32_t gpioport, uint16_t gpios)
{
	uint32_t port = GPIO_ODR(gpioport);
 800b6c6:	6943      	ldr	r3, [r0, #20]
	GPIO_BSRR(gpioport) = ((port & gpios) << 16) | (~port & gpios);
 800b6c8:	439a      	bics	r2, r3
 800b6ca:	400b      	ands	r3, r1
 800b6cc:	041b      	lsls	r3, r3, #16
 800b6ce:	4313      	orrs	r3, r2
 800b6d0:	6183      	str	r3, [r0, #24]
}
 800b6d2:	4770      	bx	lr

0800b6d4 <gpio_mode_setup>:
	     If multiple pins are to be set, use bitwise OR '|' to separate
	     them.
*/
void gpio_mode_setup(uint32_t gpioport, uint8_t mode, uint8_t pull_up_down,
		     uint16_t gpios)
{
 800b6d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	/*
	 * We want to set the config only for the pins mentioned in gpios,
	 * but keeping the others, so read out the actual config first.
	 */
	moder = GPIO_MODER(gpioport);
	pupd = GPIO_PUPDR(gpioport);
 800b6d6:	2500      	movs	r5, #0

	/*
	 * We want to set the config only for the pins mentioned in gpios,
	 * but keeping the others, so read out the actual config first.
	 */
	moder = GPIO_MODER(gpioport);
 800b6d8:	6804      	ldr	r4, [r0, #0]
	pupd = GPIO_PUPDR(gpioport);
 800b6da:	68c7      	ldr	r7, [r0, #12]
	     If multiple pins are to be set, use bitwise OR '|' to separate
	     them.
*/
void gpio_mode_setup(uint32_t gpioport, uint8_t mode, uint8_t pull_up_down,
		     uint16_t gpios)
{
 800b6dc:	9100      	str	r1, [sp, #0]
 800b6de:	9301      	str	r3, [sp, #4]
	 */
	moder = GPIO_MODER(gpioport);
	pupd = GPIO_PUPDR(gpioport);

	for (i = 0; i < 16; i++) {
		if (!((1 << i) & gpios)) {
 800b6e0:	9901      	ldr	r1, [sp, #4]
 800b6e2:	4129      	asrs	r1, r5
 800b6e4:	07cb      	lsls	r3, r1, #31
 800b6e6:	d50d      	bpl.n	800b704 <gpio_mode_setup+0x30>
			continue;
		}

		moder &= ~GPIO_MODE_MASK(i);
 800b6e8:	2103      	movs	r1, #3
 800b6ea:	006e      	lsls	r6, r5, #1
 800b6ec:	40b1      	lsls	r1, r6
 800b6ee:	43c9      	mvns	r1, r1
 800b6f0:	400c      	ands	r4, r1
 800b6f2:	46a4      	mov	ip, r4
		moder |= GPIO_MODE(i, mode);
		pupd &= ~GPIO_PUPD_MASK(i);
 800b6f4:	400f      	ands	r7, r1
		pupd |= GPIO_PUPD(i, pull_up_down);
 800b6f6:	1c11      	adds	r1, r2, #0
		if (!((1 << i) & gpios)) {
			continue;
		}

		moder &= ~GPIO_MODE_MASK(i);
		moder |= GPIO_MODE(i, mode);
 800b6f8:	9c00      	ldr	r4, [sp, #0]
 800b6fa:	4663      	mov	r3, ip
 800b6fc:	40b4      	lsls	r4, r6
		pupd &= ~GPIO_PUPD_MASK(i);
		pupd |= GPIO_PUPD(i, pull_up_down);
 800b6fe:	40b1      	lsls	r1, r6
		if (!((1 << i) & gpios)) {
			continue;
		}

		moder &= ~GPIO_MODE_MASK(i);
		moder |= GPIO_MODE(i, mode);
 800b700:	431c      	orrs	r4, r3
		pupd &= ~GPIO_PUPD_MASK(i);
		pupd |= GPIO_PUPD(i, pull_up_down);
 800b702:	430f      	orrs	r7, r1
 800b704:	3501      	adds	r5, #1
	 * but keeping the others, so read out the actual config first.
	 */
	moder = GPIO_MODER(gpioport);
	pupd = GPIO_PUPDR(gpioport);

	for (i = 0; i < 16; i++) {
 800b706:	2d10      	cmp	r5, #16
 800b708:	d1ea      	bne.n	800b6e0 <gpio_mode_setup+0xc>
		pupd &= ~GPIO_PUPD_MASK(i);
		pupd |= GPIO_PUPD(i, pull_up_down);
	}

	/* Set mode and pull up/down control registers. */
	GPIO_MODER(gpioport) = moder;
 800b70a:	6004      	str	r4, [r0, #0]
	GPIO_PUPDR(gpioport) = pupd;
 800b70c:	60c7      	str	r7, [r0, #12]
}
 800b70e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

0800b710 <gpio_set_output_options>:
	     If multiple pins are to be set, use bitwise OR '|' to separate
	     them.
*/
void gpio_set_output_options(uint32_t gpioport, uint8_t otype, uint8_t speed,
			     uint16_t gpios)
{
 800b710:	b570      	push	{r4, r5, r6, lr}
	uint16_t i;
	uint32_t ospeedr;

	if (otype == 0x1) {
 800b712:	2901      	cmp	r1, #1
 800b714:	d102      	bne.n	800b71c <gpio_set_output_options+0xc>
		GPIO_OTYPER(gpioport) |= gpios;
 800b716:	6841      	ldr	r1, [r0, #4]
 800b718:	4319      	orrs	r1, r3
 800b71a:	e001      	b.n	800b720 <gpio_set_output_options+0x10>
	} else {
		GPIO_OTYPER(gpioport) &= ~gpios;
 800b71c:	6841      	ldr	r1, [r0, #4]
 800b71e:	4399      	bics	r1, r3
	}

	ospeedr = GPIO_OSPEEDR(gpioport);
 800b720:	2400      	movs	r4, #0
	uint32_t ospeedr;

	if (otype == 0x1) {
		GPIO_OTYPER(gpioport) |= gpios;
	} else {
		GPIO_OTYPER(gpioport) &= ~gpios;
 800b722:	6041      	str	r1, [r0, #4]
	}

	ospeedr = GPIO_OSPEEDR(gpioport);
 800b724:	6881      	ldr	r1, [r0, #8]

	for (i = 0; i < 16; i++) {
		if (!((1 << i) & gpios)) {
 800b726:	1c1d      	adds	r5, r3, #0
 800b728:	4125      	asrs	r5, r4
 800b72a:	07ed      	lsls	r5, r5, #31
 800b72c:	d506      	bpl.n	800b73c <gpio_set_output_options+0x2c>
			continue;
		}
		ospeedr &= ~GPIO_OSPEED_MASK(i);
 800b72e:	2603      	movs	r6, #3
 800b730:	0065      	lsls	r5, r4, #1
 800b732:	40ae      	lsls	r6, r5
 800b734:	43b1      	bics	r1, r6
		ospeedr |= GPIO_OSPEED(i, speed);
 800b736:	1c16      	adds	r6, r2, #0
 800b738:	40ae      	lsls	r6, r5
 800b73a:	4331      	orrs	r1, r6
 800b73c:	3401      	adds	r4, #1
		GPIO_OTYPER(gpioport) &= ~gpios;
	}

	ospeedr = GPIO_OSPEEDR(gpioport);

	for (i = 0; i < 16; i++) {
 800b73e:	2c10      	cmp	r4, #16
 800b740:	d1f1      	bne.n	800b726 <gpio_set_output_options+0x16>
		}
		ospeedr &= ~GPIO_OSPEED_MASK(i);
		ospeedr |= GPIO_OSPEED(i, speed);
	}

	GPIO_OSPEEDR(gpioport) = ospeedr;
 800b742:	6081      	str	r1, [r0, #8]
}
 800b744:	bd70      	pop	{r4, r5, r6, pc}
	...

0800b748 <flash_set_ws>:
@param[in] ws values from @ref flash_latency.
*/

void flash_set_ws(uint32_t ws)
{
	FLASH_ACR = (FLASH_ACR & ~FLASH_ACR_LATENCY) | ws;
 800b748:	2107      	movs	r1, #7
 800b74a:	4a03      	ldr	r2, [pc, #12]	; (800b758 <flash_set_ws+0x10>)
 800b74c:	6813      	ldr	r3, [r2, #0]
 800b74e:	438b      	bics	r3, r1
 800b750:	4318      	orrs	r0, r3
 800b752:	6010      	str	r0, [r2, #0]
}
 800b754:	4770      	bx	lr
 800b756:	46c0      	nop			; (mov r8, r8)
 800b758:	40022000 	.word	0x40022000

0800b75c <timer_enable_irq>:
enable bits to be set
*/

void timer_enable_irq(uint32_t timer_peripheral, uint32_t irq)
{
	TIM_DIER(timer_peripheral) |= irq;
 800b75c:	68c3      	ldr	r3, [r0, #12]
 800b75e:	4319      	orrs	r1, r3
 800b760:	60c1      	str	r1, [r0, #12]
}
 800b762:	4770      	bx	lr

0800b764 <rcc_periph_clock_enable>:
 * For available constants, see #rcc_periph_clken (RCC_UART1 for example)
 */

void rcc_periph_clock_enable(enum rcc_periph_clken clken)
{
	_RCC_REG(clken) |= _RCC_BIT(clken);
 800b764:	4b06      	ldr	r3, [pc, #24]	; (800b780 <rcc_periph_clock_enable+0x1c>)
 800b766:	0942      	lsrs	r2, r0, #5
 800b768:	18d2      	adds	r2, r2, r3
 800b76a:	1c01      	adds	r1, r0, #0
 800b76c:	231f      	movs	r3, #31
 800b76e:	4019      	ands	r1, r3
 800b770:	3b1e      	subs	r3, #30
 800b772:	408b      	lsls	r3, r1
 800b774:	1c18      	adds	r0, r3, #0
 *
 * For available constants, see #rcc_periph_clken (RCC_UART1 for example)
 */

void rcc_periph_clock_enable(enum rcc_periph_clken clken)
{
 800b776:	b510      	push	{r4, lr}
	_RCC_REG(clken) |= _RCC_BIT(clken);
 800b778:	6814      	ldr	r4, [r2, #0]
 800b77a:	4320      	orrs	r0, r4
 800b77c:	6010      	str	r0, [r2, #0]
}
 800b77e:	bd10      	pop	{r4, pc}
 800b780:	40021000 	.word	0x40021000

0800b784 <usbd_init>:
usbd_device *usbd_init(const usbd_driver *driver,
		       const struct usb_device_descriptor *dev,
		       const struct usb_config_descriptor *conf,
		       const char **strings, int num_strings,
		       uint8_t *control_buffer, uint16_t control_buffer_size)
{
 800b784:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b786:	1c1d      	adds	r5, r3, #0
 800b788:	ab0a      	add	r3, sp, #40	; 0x28
 800b78a:	881b      	ldrh	r3, [r3, #0]
 800b78c:	1c16      	adds	r6, r2, #0
 800b78e:	9301      	str	r3, [sp, #4]
	usbd_device *usbd_dev;

	usbd_dev = driver->init();
 800b790:	6803      	ldr	r3, [r0, #0]
usbd_device *usbd_init(const usbd_driver *driver,
		       const struct usb_device_descriptor *dev,
		       const struct usb_config_descriptor *conf,
		       const char **strings, int num_strings,
		       uint8_t *control_buffer, uint16_t control_buffer_size)
{
 800b792:	1c0f      	adds	r7, r1, #0
 800b794:	1c04      	adds	r4, r0, #0
	usbd_device *usbd_dev;

	usbd_dev = driver->init();
 800b796:	4798      	blx	r3

	usbd_dev->driver = driver;
 800b798:	1c03      	adds	r3, r0, #0
 800b79a:	33dc      	adds	r3, #220	; 0xdc
 800b79c:	601c      	str	r4, [r3, #0]
	usbd_dev->desc = dev;
	usbd_dev->config = conf;
	usbd_dev->strings = strings;
	usbd_dev->num_strings = num_strings;
 800b79e:	9b08      	ldr	r3, [sp, #32]
	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_IN] =
	    _usbd_control_in;

	int i;
	for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
		usbd_dev->user_callback_set_config[i] = NULL;
 800b7a0:	1c02      	adds	r2, r0, #0

	usbd_dev->driver = driver;
	usbd_dev->desc = dev;
	usbd_dev->config = conf;
	usbd_dev->strings = strings;
	usbd_dev->num_strings = num_strings;
 800b7a2:	60c3      	str	r3, [r0, #12]
	usbd_dev->ctrl_buf = control_buffer;
 800b7a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_IN] =
	    _usbd_control_in;

	int i;
	for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
		usbd_dev->user_callback_set_config[i] = NULL;
 800b7a6:	32c8      	adds	r2, #200	; 0xc8
	usbd_dev->driver = driver;
	usbd_dev->desc = dev;
	usbd_dev->config = conf;
	usbd_dev->strings = strings;
	usbd_dev->num_strings = num_strings;
	usbd_dev->ctrl_buf = control_buffer;
 800b7a8:	6103      	str	r3, [r0, #16]
	usbd_dev->ctrl_buf_len = control_buffer_size;
 800b7aa:	466b      	mov	r3, sp
 800b7ac:	889b      	ldrh	r3, [r3, #4]
	usbd_device *usbd_dev;

	usbd_dev = driver->init();

	usbd_dev->driver = driver;
	usbd_dev->desc = dev;
 800b7ae:	6007      	str	r7, [r0, #0]
	usbd_dev->config = conf;
	usbd_dev->strings = strings;
	usbd_dev->num_strings = num_strings;
	usbd_dev->ctrl_buf = control_buffer;
	usbd_dev->ctrl_buf_len = control_buffer_size;
 800b7b0:	8283      	strh	r3, [r0, #20]

	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_SETUP] =
 800b7b2:	4b07      	ldr	r3, [pc, #28]	; (800b7d0 <usbd_init+0x4c>)

	usbd_dev = driver->init();

	usbd_dev->driver = driver;
	usbd_dev->desc = dev;
	usbd_dev->config = conf;
 800b7b4:	6046      	str	r6, [r0, #4]
	usbd_dev->strings = strings;
	usbd_dev->num_strings = num_strings;
	usbd_dev->ctrl_buf = control_buffer;
	usbd_dev->ctrl_buf_len = control_buffer_size;

	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_SETUP] =
 800b7b6:	6703      	str	r3, [r0, #112]	; 0x70
	    _usbd_control_setup;
	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_OUT] =
 800b7b8:	4b06      	ldr	r3, [pc, #24]	; (800b7d4 <usbd_init+0x50>)
	usbd_dev = driver->init();

	usbd_dev->driver = driver;
	usbd_dev->desc = dev;
	usbd_dev->config = conf;
	usbd_dev->strings = strings;
 800b7ba:	6085      	str	r5, [r0, #8]
	usbd_dev->ctrl_buf = control_buffer;
	usbd_dev->ctrl_buf_len = control_buffer_size;

	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_SETUP] =
	    _usbd_control_setup;
	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_OUT] =
 800b7bc:	66c3      	str	r3, [r0, #108]	; 0x6c
	    _usbd_control_out;
	usbd_dev->user_callback_ctr[0][USB_TRANSACTION_IN] =
 800b7be:	4b06      	ldr	r3, [pc, #24]	; (800b7d8 <usbd_init+0x54>)
 800b7c0:	6683      	str	r3, [r0, #104]	; 0x68
	    _usbd_control_in;

	int i;
	for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
		usbd_dev->user_callback_set_config[i] = NULL;
 800b7c2:	2300      	movs	r3, #0
 800b7c4:	6013      	str	r3, [r2, #0]
 800b7c6:	6053      	str	r3, [r2, #4]
 800b7c8:	6093      	str	r3, [r2, #8]
 800b7ca:	60d3      	str	r3, [r2, #12]
	}

	return usbd_dev;
}
 800b7cc:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800b7ce:	46c0      	nop			; (mov r8, r8)
 800b7d0:	0800b9f1 	.word	0x0800b9f1
 800b7d4:	0800ba53 	.word	0x0800ba53
 800b7d8:	0800bad7 	.word	0x0800bad7

0800b7dc <usbd_poll>:
	}
}

/* Functions to wrap the low-level driver */
void usbd_poll(usbd_device *usbd_dev)
{
 800b7dc:	b508      	push	{r3, lr}
	usbd_dev->driver->poll(usbd_dev);
 800b7de:	1c03      	adds	r3, r0, #0
 800b7e0:	33dc      	adds	r3, #220	; 0xdc
 800b7e2:	681b      	ldr	r3, [r3, #0]
 800b7e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b7e6:	4798      	blx	r3
}
 800b7e8:	bd08      	pop	{r3, pc}

0800b7ea <usbd_ep_setup>:
	}
}

void usbd_ep_setup(usbd_device *usbd_dev, uint8_t addr, uint8_t type,
		   uint16_t max_size, usbd_endpoint_callback callback)
{
 800b7ea:	b537      	push	{r0, r1, r2, r4, r5, lr}
	usbd_dev->driver->ep_setup(usbd_dev, addr, type, max_size, callback);
 800b7ec:	1c04      	adds	r4, r0, #0
 800b7ee:	9d06      	ldr	r5, [sp, #24]
 800b7f0:	34dc      	adds	r4, #220	; 0xdc
 800b7f2:	6824      	ldr	r4, [r4, #0]
 800b7f4:	9500      	str	r5, [sp, #0]
 800b7f6:	68a4      	ldr	r4, [r4, #8]
 800b7f8:	47a0      	blx	r4
}
 800b7fa:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0800b7fc <_usbd_reset>:
{
	usbd_dev->user_callback_sof = callback;
}

void _usbd_reset(usbd_device *usbd_dev)
{
 800b7fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	usbd_dev->current_address = 0;
 800b7fe:	2500      	movs	r5, #0
{
	usbd_dev->user_callback_sof = callback;
}

void _usbd_reset(usbd_device *usbd_dev)
{
 800b800:	1c04      	adds	r4, r0, #0
	usbd_dev->current_address = 0;
	usbd_dev->current_config = 0;
	usbd_ep_setup(usbd_dev, 0, USB_ENDPOINT_ATTR_CONTROL, usbd_dev->desc->bMaxPacketSize0, NULL);
 800b802:	6803      	ldr	r3, [r0, #0]
	usbd_dev->user_callback_sof = callback;
}

void _usbd_reset(usbd_device *usbd_dev)
{
	usbd_dev->current_address = 0;
 800b804:	7585      	strb	r5, [r0, #22]
	usbd_dev->current_config = 0;
 800b806:	75c5      	strb	r5, [r0, #23]
	usbd_ep_setup(usbd_dev, 0, USB_ENDPOINT_ATTR_CONTROL, usbd_dev->desc->bMaxPacketSize0, NULL);
 800b808:	79db      	ldrb	r3, [r3, #7]
 800b80a:	1c29      	adds	r1, r5, #0
 800b80c:	1c2a      	adds	r2, r5, #0
 800b80e:	9500      	str	r5, [sp, #0]
 800b810:	f7ff ffeb 	bl	800b7ea <usbd_ep_setup>
	usbd_dev->driver->set_address(usbd_dev, 0);
 800b814:	1c23      	adds	r3, r4, #0
 800b816:	33dc      	adds	r3, #220	; 0xdc
 800b818:	681b      	ldr	r3, [r3, #0]
 800b81a:	1c20      	adds	r0, r4, #0
 800b81c:	685b      	ldr	r3, [r3, #4]
 800b81e:	1c29      	adds	r1, r5, #0
 800b820:	4798      	blx	r3

	if (usbd_dev->user_callback_reset) {
 800b822:	69e3      	ldr	r3, [r4, #28]
 800b824:	42ab      	cmp	r3, r5
 800b826:	d000      	beq.n	800b82a <_usbd_reset+0x2e>
		usbd_dev->user_callback_reset();
 800b828:	4798      	blx	r3
	}
}
 800b82a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0800b82c <usbd_ep_write_packet>:
	usbd_dev->driver->ep_setup(usbd_dev, addr, type, max_size, callback);
}

uint16_t usbd_ep_write_packet(usbd_device *usbd_dev, uint8_t addr,
			 const void *buf, uint16_t len)
{
 800b82c:	b510      	push	{r4, lr}
	return usbd_dev->driver->ep_write_packet(usbd_dev, addr, buf, len);
 800b82e:	1c04      	adds	r4, r0, #0
 800b830:	34dc      	adds	r4, #220	; 0xdc
 800b832:	6824      	ldr	r4, [r4, #0]
 800b834:	69e4      	ldr	r4, [r4, #28]
 800b836:	47a0      	blx	r4
}
 800b838:	bd10      	pop	{r4, pc}

0800b83a <usbd_ep_read_packet>:

uint16_t usbd_ep_read_packet(usbd_device *usbd_dev, uint8_t addr, void *buf,
			     uint16_t len)
{
 800b83a:	b510      	push	{r4, lr}
	return usbd_dev->driver->ep_read_packet(usbd_dev, addr, buf, len);
 800b83c:	1c04      	adds	r4, r0, #0
 800b83e:	34dc      	adds	r4, #220	; 0xdc
 800b840:	6824      	ldr	r4, [r4, #0]
 800b842:	6a24      	ldr	r4, [r4, #32]
 800b844:	47a0      	blx	r4
}
 800b846:	bd10      	pop	{r4, pc}

0800b848 <usbd_ep_stall_set>:

void usbd_ep_stall_set(usbd_device *usbd_dev, uint8_t addr, uint8_t stall)
{
 800b848:	b508      	push	{r3, lr}
	usbd_dev->driver->ep_stall_set(usbd_dev, addr, stall);
 800b84a:	1c03      	adds	r3, r0, #0
 800b84c:	33dc      	adds	r3, #220	; 0xdc
 800b84e:	681b      	ldr	r3, [r3, #0]
 800b850:	691b      	ldr	r3, [r3, #16]
 800b852:	4798      	blx	r3
}
 800b854:	bd08      	pop	{r3, pc}

0800b856 <usbd_ep_stall_get>:

uint8_t usbd_ep_stall_get(usbd_device *usbd_dev, uint8_t addr)
{
 800b856:	b508      	push	{r3, lr}
	return usbd_dev->driver->ep_stall_get(usbd_dev, addr);
 800b858:	1c03      	adds	r3, r0, #0
 800b85a:	33dc      	adds	r3, #220	; 0xdc
 800b85c:	681b      	ldr	r3, [r3, #0]
 800b85e:	699b      	ldr	r3, [r3, #24]
 800b860:	4798      	blx	r3
}
 800b862:	bd08      	pop	{r3, pc}

0800b864 <stall_transaction>:
 * According to the USB 2.0 specification, section 8.5.3, when a control
 * transfer is stalled, the pipe becomes idle. We provide one utility to stall
 * a transaction to reduce boilerplate code.
 */
static void stall_transaction(usbd_device *usbd_dev)
{
 800b864:	b510      	push	{r4, lr}
	usbd_ep_stall_set(usbd_dev, 0, 1);
 800b866:	2100      	movs	r1, #0
 * According to the USB 2.0 specification, section 8.5.3, when a control
 * transfer is stalled, the pipe becomes idle. We provide one utility to stall
 * a transaction to reduce boilerplate code.
 */
static void stall_transaction(usbd_device *usbd_dev)
{
 800b868:	1c04      	adds	r4, r0, #0
	usbd_ep_stall_set(usbd_dev, 0, 1);
 800b86a:	2201      	movs	r2, #1
 800b86c:	f7ff ffec 	bl	800b848 <usbd_ep_stall_set>
	usbd_dev->control_state.state = IDLE;
 800b870:	2300      	movs	r3, #0
 800b872:	342c      	adds	r4, #44	; 0x2c
 800b874:	7023      	strb	r3, [r4, #0]
}
 800b876:	bd10      	pop	{r4, pc}

0800b878 <usb_control_recv_chunk>:
		usbd_dev->control_state.ctrl_buf = NULL;
	}
}

static int usb_control_recv_chunk(usbd_device *usbd_dev)
{
 800b878:	b570      	push	{r4, r5, r6, lr}
	uint16_t packetsize = MIN(usbd_dev->desc->bMaxPacketSize0,
 800b87a:	6803      	ldr	r3, [r0, #0]
 800b87c:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
 800b87e:	8ec4      	ldrh	r4, [r0, #54]	; 0x36
 800b880:	79db      	ldrb	r3, [r3, #7]
		usbd_dev->control_state.ctrl_buf = NULL;
	}
}

static int usb_control_recv_chunk(usbd_device *usbd_dev)
{
 800b882:	1c05      	adds	r5, r0, #0
	uint16_t packetsize = MIN(usbd_dev->desc->bMaxPacketSize0,
 800b884:	1aa4      	subs	r4, r4, r2
 800b886:	429c      	cmp	r4, r3
 800b888:	dd00      	ble.n	800b88c <usb_control_recv_chunk+0x14>
 800b88a:	1c1c      	adds	r4, r3, #0
			usbd_dev->control_state.req.wLength -
			usbd_dev->control_state.ctrl_len);
	uint16_t size = usbd_ep_read_packet(usbd_dev, 0,
 800b88c:	6bab      	ldr	r3, [r5, #56]	; 0x38
	}
}

static int usb_control_recv_chunk(usbd_device *usbd_dev)
{
	uint16_t packetsize = MIN(usbd_dev->desc->bMaxPacketSize0,
 800b88e:	b2a6      	uxth	r6, r4
			usbd_dev->control_state.req.wLength -
			usbd_dev->control_state.ctrl_len);
	uint16_t size = usbd_ep_read_packet(usbd_dev, 0,
 800b890:	189a      	adds	r2, r3, r2
 800b892:	1c28      	adds	r0, r5, #0
 800b894:	2100      	movs	r1, #0
 800b896:	1c33      	adds	r3, r6, #0
 800b898:	f7ff ffcf 	bl	800b83a <usbd_ep_read_packet>
				       usbd_dev->control_state.ctrl_buf +
				       usbd_dev->control_state.ctrl_len,
				       packetsize);

	if (size != packetsize) {
 800b89c:	42b0      	cmp	r0, r6
 800b89e:	d005      	beq.n	800b8ac <usb_control_recv_chunk+0x34>
		stall_transaction(usbd_dev);
 800b8a0:	1c28      	adds	r0, r5, #0
 800b8a2:	f7ff ffdf 	bl	800b864 <stall_transaction>
		return -1;
 800b8a6:	2001      	movs	r0, #1
 800b8a8:	4240      	negs	r0, r0
 800b8aa:	e003      	b.n	800b8b4 <usb_control_recv_chunk+0x3c>
	}

	usbd_dev->control_state.ctrl_len += size;
 800b8ac:	8fab      	ldrh	r3, [r5, #60]	; 0x3c
 800b8ae:	18c0      	adds	r0, r0, r3
 800b8b0:	87a8      	strh	r0, [r5, #60]	; 0x3c

	return packetsize;
 800b8b2:	b2a0      	uxth	r0, r4
}
 800b8b4:	bd70      	pop	{r4, r5, r6, pc}

0800b8b6 <usb_control_send_chunk>:

	return -1;
}

static void usb_control_send_chunk(usbd_device *usbd_dev)
{
 800b8b6:	b570      	push	{r4, r5, r6, lr}
 800b8b8:	1c04      	adds	r4, r0, #0
 800b8ba:	1c05      	adds	r5, r0, #0
	if (usbd_dev->desc->bMaxPacketSize0 <
 800b8bc:	6803      	ldr	r3, [r0, #0]
 800b8be:	352c      	adds	r5, #44	; 0x2c
 800b8c0:	79de      	ldrb	r6, [r3, #7]
			usbd_dev->control_state.ctrl_len) {
 800b8c2:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
		/* Data stage, normal transmission */
		usbd_ep_write_packet(usbd_dev, 0,
 800b8c4:	2100      	movs	r1, #0
 800b8c6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	return -1;
}

static void usb_control_send_chunk(usbd_device *usbd_dev)
{
	if (usbd_dev->desc->bMaxPacketSize0 <
 800b8c8:	429e      	cmp	r6, r3
 800b8ca:	d20e      	bcs.n	800b8ea <usb_control_send_chunk+0x34>
			usbd_dev->control_state.ctrl_len) {
		/* Data stage, normal transmission */
		usbd_ep_write_packet(usbd_dev, 0,
 800b8cc:	1c33      	adds	r3, r6, #0
 800b8ce:	f7ff ffad 	bl	800b82c <usbd_ep_write_packet>
				     usbd_dev->control_state.ctrl_buf,
				     usbd_dev->desc->bMaxPacketSize0);
		usbd_dev->control_state.state = DATA_IN;
 800b8d2:	2302      	movs	r3, #2
		usbd_dev->control_state.ctrl_buf +=
			usbd_dev->desc->bMaxPacketSize0;
 800b8d4:	6822      	ldr	r2, [r4, #0]
			usbd_dev->control_state.ctrl_len) {
		/* Data stage, normal transmission */
		usbd_ep_write_packet(usbd_dev, 0,
				     usbd_dev->control_state.ctrl_buf,
				     usbd_dev->desc->bMaxPacketSize0);
		usbd_dev->control_state.state = DATA_IN;
 800b8d6:	702b      	strb	r3, [r5, #0]
		usbd_dev->control_state.ctrl_buf +=
 800b8d8:	79d3      	ldrb	r3, [r2, #7]
 800b8da:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800b8dc:	18cb      	adds	r3, r1, r3
 800b8de:	63a3      	str	r3, [r4, #56]	; 0x38
			usbd_dev->desc->bMaxPacketSize0;
		usbd_dev->control_state.ctrl_len -=
 800b8e0:	79d2      	ldrb	r2, [r2, #7]
 800b8e2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 800b8e4:	1a9b      	subs	r3, r3, r2
 800b8e6:	87a3      	strh	r3, [r4, #60]	; 0x3c
 800b8e8:	e00d      	b.n	800b906 <usb_control_send_chunk+0x50>
			usbd_dev->desc->bMaxPacketSize0;
	} else {
		/* Data stage, end of transmission */
		usbd_ep_write_packet(usbd_dev, 0,
 800b8ea:	f7ff ff9f 	bl	800b82c <usbd_ep_write_packet>
				     usbd_dev->control_state.ctrl_buf,
				     usbd_dev->control_state.ctrl_len);

		usbd_dev->control_state.state =
			usbd_dev->control_state.needs_zlp ?
 800b8ee:	1c21      	adds	r1, r4, #0
 800b8f0:	3144      	adds	r1, #68	; 0x44
		/* Data stage, end of transmission */
		usbd_ep_write_packet(usbd_dev, 0,
				     usbd_dev->control_state.ctrl_buf,
				     usbd_dev->control_state.ctrl_len);

		usbd_dev->control_state.state =
 800b8f2:	780b      	ldrb	r3, [r1, #0]
 800b8f4:	1e5a      	subs	r2, r3, #1
 800b8f6:	4193      	sbcs	r3, r2
 800b8f8:	2203      	movs	r2, #3
 800b8fa:	1ad3      	subs	r3, r2, r3
 800b8fc:	702b      	strb	r3, [r5, #0]
			usbd_dev->control_state.needs_zlp ?
			DATA_IN : LAST_DATA_IN;
		usbd_dev->control_state.needs_zlp = false;
 800b8fe:	2300      	movs	r3, #0
 800b900:	700b      	strb	r3, [r1, #0]
		usbd_dev->control_state.ctrl_len = 0;
 800b902:	87a3      	strh	r3, [r4, #60]	; 0x3c
		usbd_dev->control_state.ctrl_buf = NULL;
 800b904:	63a3      	str	r3, [r4, #56]	; 0x38
	}
}
 800b906:	bd70      	pop	{r4, r5, r6, pc}

0800b908 <usb_control_request_dispatch>:
	return packetsize;
}

static int usb_control_request_dispatch(usbd_device *usbd_dev,
					struct usb_setup_data *req)
{
 800b908:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	int i, result = 0;
	struct user_control_callback *cb = usbd_dev->user_control_callback;
 800b90a:	1c05      	adds	r5, r0, #0
 800b90c:	1c07      	adds	r7, r0, #0
	return packetsize;
}

static int usb_control_request_dispatch(usbd_device *usbd_dev,
					struct usb_setup_data *req)
{
 800b90e:	1c04      	adds	r4, r0, #0
 800b910:	1c0e      	adds	r6, r1, #0
	int i, result = 0;
	struct user_control_callback *cb = usbd_dev->user_control_callback;
 800b912:	3548      	adds	r5, #72	; 0x48
 800b914:	3768      	adds	r7, #104	; 0x68

	/* Call user command hook function. */
	for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
		if (cb[i].cb == NULL) {
 800b916:	682b      	ldr	r3, [r5, #0]
 800b918:	469c      	mov	ip, r3
 800b91a:	2b00      	cmp	r3, #0
 800b91c:	d108      	bne.n	800b930 <usb_control_request_dispatch+0x28>
			}
		}
	}

	/* Try standard request if not already handled. */
	return _usbd_standard_request(usbd_dev, req,
 800b91e:	1c22      	adds	r2, r4, #0
 800b920:	1c23      	adds	r3, r4, #0
 800b922:	3238      	adds	r2, #56	; 0x38
 800b924:	333c      	adds	r3, #60	; 0x3c
 800b926:	1c20      	adds	r0, r4, #0
 800b928:	1c31      	adds	r1, r6, #0
 800b92a:	f000 fc21 	bl	800c170 <_usbd_standard_request>
 800b92e:	e014      	b.n	800b95a <usb_control_request_dispatch+0x52>
	for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
		if (cb[i].cb == NULL) {
			break;
		}

		if ((req->bmRequestType & cb[i].type_mask) == cb[i].type) {
 800b930:	796b      	ldrb	r3, [r5, #5]
 800b932:	7831      	ldrb	r1, [r6, #0]
 800b934:	792a      	ldrb	r2, [r5, #4]
 800b936:	400b      	ands	r3, r1
 800b938:	429a      	cmp	r2, r3
 800b93a:	d10a      	bne.n	800b952 <usb_control_request_dispatch+0x4a>
			result = cb[i].cb(usbd_dev, req,
 800b93c:	1c23      	adds	r3, r4, #0
 800b93e:	1c22      	adds	r2, r4, #0
 800b940:	3340      	adds	r3, #64	; 0x40
 800b942:	9300      	str	r3, [sp, #0]
 800b944:	1c20      	adds	r0, r4, #0
 800b946:	1c31      	adds	r1, r6, #0
 800b948:	3238      	adds	r2, #56	; 0x38
 800b94a:	3b04      	subs	r3, #4
 800b94c:	47e0      	blx	ip
					  &(usbd_dev->control_state.ctrl_buf),
					  &(usbd_dev->control_state.ctrl_len),
					  &(usbd_dev->control_state.complete));
			if (result == USBD_REQ_HANDLED ||
 800b94e:	2801      	cmp	r0, #1
 800b950:	d903      	bls.n	800b95a <usb_control_request_dispatch+0x52>
 800b952:	3508      	adds	r5, #8
{
	int i, result = 0;
	struct user_control_callback *cb = usbd_dev->user_control_callback;

	/* Call user command hook function. */
	for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
 800b954:	42bd      	cmp	r5, r7
 800b956:	d1de      	bne.n	800b916 <usb_control_request_dispatch+0xe>
 800b958:	e7e1      	b.n	800b91e <usb_control_request_dispatch+0x16>

	/* Try standard request if not already handled. */
	return _usbd_standard_request(usbd_dev, req,
				      &(usbd_dev->control_state.ctrl_buf),
				      &(usbd_dev->control_state.ctrl_len));
}
 800b95a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800b95c <usb_control_setup_read>:

/* Handle commands and read requests. */
static void usb_control_setup_read(usbd_device *usbd_dev,
		struct usb_setup_data *req)
{
 800b95c:	b538      	push	{r3, r4, r5, lr}
	usbd_dev->control_state.ctrl_buf = usbd_dev->ctrl_buf;
 800b95e:	6903      	ldr	r3, [r0, #16]
}

/* Handle commands and read requests. */
static void usb_control_setup_read(usbd_device *usbd_dev,
		struct usb_setup_data *req)
{
 800b960:	1c04      	adds	r4, r0, #0
	usbd_dev->control_state.ctrl_buf = usbd_dev->ctrl_buf;
 800b962:	6383      	str	r3, [r0, #56]	; 0x38
	usbd_dev->control_state.ctrl_len = req->wLength;
 800b964:	79cb      	ldrb	r3, [r1, #7]
 800b966:	798a      	ldrb	r2, [r1, #6]
 800b968:	021b      	lsls	r3, r3, #8
 800b96a:	4313      	orrs	r3, r2
 800b96c:	8783      	strh	r3, [r0, #60]	; 0x3c
}

/* Handle commands and read requests. */
static void usb_control_setup_read(usbd_device *usbd_dev,
		struct usb_setup_data *req)
{
 800b96e:	1c0d      	adds	r5, r1, #0
	usbd_dev->control_state.ctrl_buf = usbd_dev->ctrl_buf;
	usbd_dev->control_state.ctrl_len = req->wLength;

	if (usb_control_request_dispatch(usbd_dev, req)) {
 800b970:	f7ff ffca 	bl	800b908 <usb_control_request_dispatch>
 800b974:	2800      	cmp	r0, #0
 800b976:	d021      	beq.n	800b9bc <usb_control_setup_read+0x60>
		if (req->wLength) {
 800b978:	79eb      	ldrb	r3, [r5, #7]
 800b97a:	79aa      	ldrb	r2, [r5, #6]
 800b97c:	021b      	lsls	r3, r3, #8
 800b97e:	4313      	orrs	r3, r2
 800b980:	d013      	beq.n	800b9aa <usb_control_setup_read+0x4e>
			usbd_dev->control_state.needs_zlp =
				needs_zlp(usbd_dev->control_state.ctrl_len,
 800b982:	6822      	ldr	r2, [r4, #0]
 800b984:	8fa0      	ldrh	r0, [r4, #60]	; 0x3c
 800b986:	79d1      	ldrb	r1, [r2, #7]
	if (len < wLength) {
		if (len && (len % ep_size == 0)) {
			return true;
		}
	}
	return false;
 800b988:	2200      	movs	r2, #0
 * @param ep_size
 * @return
 */
static bool needs_zlp(uint16_t len, uint16_t wLength, uint8_t ep_size)
{
	if (len < wLength) {
 800b98a:	4298      	cmp	r0, r3
 800b98c:	d206      	bcs.n	800b99c <usb_control_setup_read+0x40>
		if (len && (len % ep_size == 0)) {
 800b98e:	4290      	cmp	r0, r2
 800b990:	d004      	beq.n	800b99c <usb_control_setup_read+0x40>
 800b992:	f003 f973 	bl	800ec7c <__aeabi_idivmod>
 800b996:	424a      	negs	r2, r1
 800b998:	414a      	adcs	r2, r1
 800b99a:	b2d2      	uxtb	r2, r2
	usbd_dev->control_state.ctrl_buf = usbd_dev->ctrl_buf;
	usbd_dev->control_state.ctrl_len = req->wLength;

	if (usb_control_request_dispatch(usbd_dev, req)) {
		if (req->wLength) {
			usbd_dev->control_state.needs_zlp =
 800b99c:	1c23      	adds	r3, r4, #0
 800b99e:	3344      	adds	r3, #68	; 0x44
 800b9a0:	701a      	strb	r2, [r3, #0]
				needs_zlp(usbd_dev->control_state.ctrl_len,
					req->wLength,
					usbd_dev->desc->bMaxPacketSize0);
			/* Go to data out stage if handled. */
			usb_control_send_chunk(usbd_dev);
 800b9a2:	1c20      	adds	r0, r4, #0
 800b9a4:	f7ff ff87 	bl	800b8b6 <usb_control_send_chunk>
 800b9a8:	e00b      	b.n	800b9c2 <usb_control_setup_read+0x66>
		} else {
			/* Go to status stage if handled. */
			usbd_ep_write_packet(usbd_dev, 0, NULL, 0);
 800b9aa:	1c20      	adds	r0, r4, #0
 800b9ac:	1c19      	adds	r1, r3, #0
 800b9ae:	1c1a      	adds	r2, r3, #0
 800b9b0:	f7ff ff3c 	bl	800b82c <usbd_ep_write_packet>
			usbd_dev->control_state.state = STATUS_IN;
 800b9b4:	2304      	movs	r3, #4
 800b9b6:	342c      	adds	r4, #44	; 0x2c
 800b9b8:	7023      	strb	r3, [r4, #0]
 800b9ba:	e002      	b.n	800b9c2 <usb_control_setup_read+0x66>
		}
	} else {
		/* Stall endpoint on failure. */
		stall_transaction(usbd_dev);
 800b9bc:	1c20      	adds	r0, r4, #0
 800b9be:	f7ff ff51 	bl	800b864 <stall_transaction>
	}
}
 800b9c2:	bd38      	pop	{r3, r4, r5, pc}

0800b9c4 <usbd_register_control_callback>:

/* Register application callback function for handling USB control requests. */
int usbd_register_control_callback(usbd_device *usbd_dev, uint8_t type,
				   uint8_t type_mask,
				   usbd_control_callback callback)
{
 800b9c4:	b570      	push	{r4, r5, r6, lr}
	int i;

	for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
 800b9c6:	2600      	movs	r6, #0
 800b9c8:	00f4      	lsls	r4, r6, #3
 800b9ca:	1904      	adds	r4, r0, r4
		if (usbd_dev->user_control_callback[i].cb) {
 800b9cc:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 800b9ce:	2d00      	cmp	r5, #0
 800b9d0:	d005      	beq.n	800b9de <usbd_register_control_callback+0x1a>
				   uint8_t type_mask,
				   usbd_control_callback callback)
{
	int i;

	for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
 800b9d2:	3601      	adds	r6, #1
 800b9d4:	2e04      	cmp	r6, #4
 800b9d6:	d1f7      	bne.n	800b9c8 <usbd_register_control_callback+0x4>
		usbd_dev->user_control_callback[i].type_mask = type_mask;
		usbd_dev->user_control_callback[i].cb = callback;
		return 0;
	}

	return -1;
 800b9d8:	2001      	movs	r0, #1
 800b9da:	4240      	negs	r0, r0
 800b9dc:	e007      	b.n	800b9ee <usbd_register_control_callback+0x2a>
	for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
		if (usbd_dev->user_control_callback[i].cb) {
			continue;
		}

		usbd_dev->user_control_callback[i].type = type;
 800b9de:	1c20      	adds	r0, r4, #0
 800b9e0:	304c      	adds	r0, #76	; 0x4c
 800b9e2:	7001      	strb	r1, [r0, #0]
		usbd_dev->user_control_callback[i].type_mask = type_mask;
 800b9e4:	1c21      	adds	r1, r4, #0
		usbd_dev->user_control_callback[i].cb = callback;
		return 0;
 800b9e6:	1c28      	adds	r0, r5, #0
		if (usbd_dev->user_control_callback[i].cb) {
			continue;
		}

		usbd_dev->user_control_callback[i].type = type;
		usbd_dev->user_control_callback[i].type_mask = type_mask;
 800b9e8:	314d      	adds	r1, #77	; 0x4d
 800b9ea:	700a      	strb	r2, [r1, #0]
		usbd_dev->user_control_callback[i].cb = callback;
 800b9ec:	64a3      	str	r3, [r4, #72]	; 0x48
		return 0;
	}

	return -1;
}
 800b9ee:	bd70      	pop	{r4, r5, r6, pc}

0800b9f0 <_usbd_control_setup>:

/* Do not appear to belong to the API, so are omitted from docs */
/**@}*/

void _usbd_control_setup(usbd_device *usbd_dev, uint8_t ea)
{
 800b9f0:	b570      	push	{r4, r5, r6, lr}
	struct usb_setup_data *req = &usbd_dev->control_state.req;
 800b9f2:	1c05      	adds	r5, r0, #0
	(void)ea;

	usbd_dev->control_state.complete = NULL;
 800b9f4:	2600      	movs	r6, #0
/* Do not appear to belong to the API, so are omitted from docs */
/**@}*/

void _usbd_control_setup(usbd_device *usbd_dev, uint8_t ea)
{
	struct usb_setup_data *req = &usbd_dev->control_state.req;
 800b9f6:	3530      	adds	r5, #48	; 0x30
	(void)ea;

	usbd_dev->control_state.complete = NULL;
 800b9f8:	6406      	str	r6, [r0, #64]	; 0x40

	if (usbd_ep_read_packet(usbd_dev, 0, req, 8) != 8) {
 800b9fa:	1c31      	adds	r1, r6, #0
 800b9fc:	1c2a      	adds	r2, r5, #0
 800b9fe:	2308      	movs	r3, #8

/* Do not appear to belong to the API, so are omitted from docs */
/**@}*/

void _usbd_control_setup(usbd_device *usbd_dev, uint8_t ea)
{
 800ba00:	1c04      	adds	r4, r0, #0
	struct usb_setup_data *req = &usbd_dev->control_state.req;
	(void)ea;

	usbd_dev->control_state.complete = NULL;

	if (usbd_ep_read_packet(usbd_dev, 0, req, 8) != 8) {
 800ba02:	f7ff ff1a 	bl	800b83a <usbd_ep_read_packet>
 800ba06:	2808      	cmp	r0, #8
 800ba08:	d003      	beq.n	800ba12 <_usbd_control_setup+0x22>
		stall_transaction(usbd_dev);
 800ba0a:	1c20      	adds	r0, r4, #0
 800ba0c:	f7ff ff2a 	bl	800b864 <stall_transaction>
		return;
 800ba10:	e01e      	b.n	800ba50 <_usbd_control_setup+0x60>
	}

	if (req->wLength == 0) {
 800ba12:	1c23      	adds	r3, r4, #0
 800ba14:	3336      	adds	r3, #54	; 0x36
 800ba16:	781a      	ldrb	r2, [r3, #0]
 800ba18:	3301      	adds	r3, #1
 800ba1a:	781b      	ldrb	r3, [r3, #0]
 800ba1c:	021b      	lsls	r3, r3, #8
 800ba1e:	4313      	orrs	r3, r2
 800ba20:	d002      	beq.n	800ba28 <_usbd_control_setup+0x38>
		usb_control_setup_read(usbd_dev, req);
	} else if (req->bmRequestType & 0x80) {
 800ba22:	782a      	ldrb	r2, [r5, #0]
 800ba24:	2a7f      	cmp	r2, #127	; 0x7f
 800ba26:	d904      	bls.n	800ba32 <_usbd_control_setup+0x42>
		usb_control_setup_read(usbd_dev, req);
 800ba28:	1c20      	adds	r0, r4, #0
 800ba2a:	1c29      	adds	r1, r5, #0
 800ba2c:	f7ff ff96 	bl	800b95c <usb_control_setup_read>
 800ba30:	e00e      	b.n	800ba50 <_usbd_control_setup+0x60>
}

static void usb_control_setup_write(usbd_device *usbd_dev,
				    struct usb_setup_data *req)
{
	if (req->wLength > usbd_dev->ctrl_buf_len) {
 800ba32:	8aa2      	ldrh	r2, [r4, #20]
 800ba34:	429a      	cmp	r2, r3
 800ba36:	d3e8      	bcc.n	800ba0a <_usbd_control_setup+0x1a>
		stall_transaction(usbd_dev);
		return;
	}

	/* Buffer into which to write received data. */
	usbd_dev->control_state.ctrl_buf = usbd_dev->ctrl_buf;
 800ba38:	6922      	ldr	r2, [r4, #16]
	usbd_dev->control_state.ctrl_len = 0;
 800ba3a:	87a6      	strh	r6, [r4, #60]	; 0x3c
		stall_transaction(usbd_dev);
		return;
	}

	/* Buffer into which to write received data. */
	usbd_dev->control_state.ctrl_buf = usbd_dev->ctrl_buf;
 800ba3c:	63a2      	str	r2, [r4, #56]	; 0x38
	usbd_dev->control_state.ctrl_len = 0;
	/* Wait for DATA OUT stage. */
	if (req->wLength > usbd_dev->desc->bMaxPacketSize0) {
 800ba3e:	6822      	ldr	r2, [r4, #0]
 800ba40:	342c      	adds	r4, #44	; 0x2c
 800ba42:	79d2      	ldrb	r2, [r2, #7]
 800ba44:	429a      	cmp	r2, r3
 800ba46:	d201      	bcs.n	800ba4c <_usbd_control_setup+0x5c>
		usbd_dev->control_state.state = DATA_OUT;
 800ba48:	2305      	movs	r3, #5
 800ba4a:	e000      	b.n	800ba4e <_usbd_control_setup+0x5e>
	} else {
		usbd_dev->control_state.state = LAST_DATA_OUT;
 800ba4c:	2306      	movs	r3, #6
 800ba4e:	7023      	strb	r3, [r4, #0]
	} else if (req->bmRequestType & 0x80) {
		usb_control_setup_read(usbd_dev, req);
	} else {
		usb_control_setup_write(usbd_dev, req);
	}
}
 800ba50:	bd70      	pop	{r4, r5, r6, pc}

0800ba52 <_usbd_control_out>:

void _usbd_control_out(usbd_device *usbd_dev, uint8_t ea)
{
 800ba52:	b538      	push	{r3, r4, r5, lr}
	(void)ea;

	switch (usbd_dev->control_state.state) {
 800ba54:	1c05      	adds	r5, r0, #0
 800ba56:	352c      	adds	r5, #44	; 0x2c
 800ba58:	782b      	ldrb	r3, [r5, #0]
		usb_control_setup_write(usbd_dev, req);
	}
}

void _usbd_control_out(usbd_device *usbd_dev, uint8_t ea)
{
 800ba5a:	1c04      	adds	r4, r0, #0
	(void)ea;

	switch (usbd_dev->control_state.state) {
 800ba5c:	2b06      	cmp	r3, #6
 800ba5e:	d010      	beq.n	800ba82 <_usbd_control_out+0x30>
 800ba60:	2b07      	cmp	r3, #7
 800ba62:	d024      	beq.n	800baae <_usbd_control_out+0x5c>
 800ba64:	2b05      	cmp	r3, #5
 800ba66:	d133      	bne.n	800bad0 <_usbd_control_out+0x7e>
	case DATA_OUT:
		if (usb_control_recv_chunk(usbd_dev) < 0) {
 800ba68:	f7ff ff06 	bl	800b878 <usb_control_recv_chunk>
 800ba6c:	2800      	cmp	r0, #0
 800ba6e:	db31      	blt.n	800bad4 <_usbd_control_out+0x82>
			break;
		}
		if ((usbd_dev->control_state.req.wLength -
 800ba70:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 800ba72:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800ba74:	1a9b      	subs	r3, r3, r2
					usbd_dev->control_state.ctrl_len) <=
					usbd_dev->desc->bMaxPacketSize0) {
 800ba76:	6822      	ldr	r2, [r4, #0]
	case DATA_OUT:
		if (usb_control_recv_chunk(usbd_dev) < 0) {
			break;
		}
		if ((usbd_dev->control_state.req.wLength -
					usbd_dev->control_state.ctrl_len) <=
 800ba78:	79d2      	ldrb	r2, [r2, #7]
	switch (usbd_dev->control_state.state) {
	case DATA_OUT:
		if (usb_control_recv_chunk(usbd_dev) < 0) {
			break;
		}
		if ((usbd_dev->control_state.req.wLength -
 800ba7a:	4293      	cmp	r3, r2
 800ba7c:	dc2a      	bgt.n	800bad4 <_usbd_control_out+0x82>
					usbd_dev->control_state.ctrl_len) <=
					usbd_dev->desc->bMaxPacketSize0) {
			usbd_dev->control_state.state = LAST_DATA_OUT;
 800ba7e:	2306      	movs	r3, #6
 800ba80:	e011      	b.n	800baa6 <_usbd_control_out+0x54>
		}
		break;
	case LAST_DATA_OUT:
		if (usb_control_recv_chunk(usbd_dev) < 0) {
 800ba82:	f7ff fef9 	bl	800b878 <usb_control_recv_chunk>
 800ba86:	2800      	cmp	r0, #0
 800ba88:	db24      	blt.n	800bad4 <_usbd_control_out+0x82>
		}
		/*
		 * We have now received the full data payload.
		 * Invoke callback to process.
		 */
		if (usb_control_request_dispatch(usbd_dev,
 800ba8a:	1c21      	adds	r1, r4, #0
 800ba8c:	1c20      	adds	r0, r4, #0
 800ba8e:	3130      	adds	r1, #48	; 0x30
 800ba90:	f7ff ff3a 	bl	800b908 <usb_control_request_dispatch>
 800ba94:	2800      	cmp	r0, #0
 800ba96:	d008      	beq.n	800baaa <_usbd_control_out+0x58>
					&(usbd_dev->control_state.req))) {
			/* Got to status stage on success. */
			usbd_ep_write_packet(usbd_dev, 0, NULL, 0);
 800ba98:	2100      	movs	r1, #0
 800ba9a:	1c20      	adds	r0, r4, #0
 800ba9c:	1c0b      	adds	r3, r1, #0
 800ba9e:	1c0a      	adds	r2, r1, #0
 800baa0:	f7ff fec4 	bl	800b82c <usbd_ep_write_packet>
			usbd_dev->control_state.state = STATUS_IN;
 800baa4:	2304      	movs	r3, #4
 800baa6:	702b      	strb	r3, [r5, #0]
 800baa8:	e014      	b.n	800bad4 <_usbd_control_out+0x82>
		} else {
			stall_transaction(usbd_dev);
 800baaa:	1c20      	adds	r0, r4, #0
 800baac:	e010      	b.n	800bad0 <_usbd_control_out+0x7e>
		}
		break;
	case STATUS_OUT:
		usbd_ep_read_packet(usbd_dev, 0, NULL, 0);
 800baae:	2100      	movs	r1, #0
 800bab0:	1c0b      	adds	r3, r1, #0
 800bab2:	1c0a      	adds	r2, r1, #0
 800bab4:	f7ff fec1 	bl	800b83a <usbd_ep_read_packet>
		usbd_dev->control_state.state = IDLE;
 800bab8:	2300      	movs	r3, #0
 800baba:	702b      	strb	r3, [r5, #0]
		if (usbd_dev->control_state.complete) {
 800babc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800babe:	2b00      	cmp	r3, #0
 800bac0:	d003      	beq.n	800baca <_usbd_control_out+0x78>
			usbd_dev->control_state.complete(usbd_dev,
 800bac2:	1c21      	adds	r1, r4, #0
 800bac4:	1c20      	adds	r0, r4, #0
 800bac6:	3130      	adds	r1, #48	; 0x30
 800bac8:	4798      	blx	r3
					&(usbd_dev->control_state.req));
		}
		usbd_dev->control_state.complete = NULL;
 800baca:	2300      	movs	r3, #0
 800bacc:	6423      	str	r3, [r4, #64]	; 0x40
		break;
 800bace:	e001      	b.n	800bad4 <_usbd_control_out+0x82>
	default:
		stall_transaction(usbd_dev);
 800bad0:	f7ff fec8 	bl	800b864 <stall_transaction>
	}
}
 800bad4:	bd38      	pop	{r3, r4, r5, pc}

0800bad6 <_usbd_control_in>:

void _usbd_control_in(usbd_device *usbd_dev, uint8_t ea)
{
 800bad6:	b570      	push	{r4, r5, r6, lr}
	(void)ea;
	struct usb_setup_data *req = &(usbd_dev->control_state.req);

	switch (usbd_dev->control_state.state) {
 800bad8:	1c05      	adds	r5, r0, #0
 800bada:	352c      	adds	r5, #44	; 0x2c
 800badc:	782b      	ldrb	r3, [r5, #0]
 800bade:	2b03      	cmp	r3, #3
 800bae0:	d007      	beq.n	800baf2 <_usbd_control_in+0x1c>
 800bae2:	1c04      	adds	r4, r0, #0
 800bae4:	2b04      	cmp	r3, #4
 800bae6:	d006      	beq.n	800baf6 <_usbd_control_in+0x20>
 800bae8:	2b02      	cmp	r3, #2
 800baea:	d11d      	bne.n	800bb28 <_usbd_control_in+0x52>
	case DATA_IN:
		usb_control_send_chunk(usbd_dev);
 800baec:	f7ff fee3 	bl	800b8b6 <usb_control_send_chunk>
		break;
 800baf0:	e01c      	b.n	800bb2c <_usbd_control_in+0x56>
	case LAST_DATA_IN:
		usbd_dev->control_state.state = STATUS_OUT;
 800baf2:	2307      	movs	r3, #7
 800baf4:	e016      	b.n	800bb24 <_usbd_control_in+0x4e>
 800baf6:	1c06      	adds	r6, r0, #0
		break;
	case STATUS_IN:
		if (usbd_dev->control_state.complete) {
 800baf8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bafa:	3630      	adds	r6, #48	; 0x30
 800bafc:	2b00      	cmp	r3, #0
 800bafe:	d001      	beq.n	800bb04 <_usbd_control_in+0x2e>
			usbd_dev->control_state.complete(usbd_dev,
 800bb00:	1c31      	adds	r1, r6, #0
 800bb02:	4798      	blx	r3
					&(usbd_dev->control_state.req));
		}

		/* Exception: Handle SET ADDRESS function here... */
		if ((req->bmRequestType == 0) &&
 800bb04:	7833      	ldrb	r3, [r6, #0]
 800bb06:	2b00      	cmp	r3, #0
 800bb08:	d10b      	bne.n	800bb22 <_usbd_control_in+0x4c>
 800bb0a:	7873      	ldrb	r3, [r6, #1]
 800bb0c:	2b05      	cmp	r3, #5
 800bb0e:	d108      	bne.n	800bb22 <_usbd_control_in+0x4c>
		    (req->bRequest == USB_REQ_SET_ADDRESS)) {
			usbd_dev->driver->set_address(usbd_dev, req->wValue);
 800bb10:	1c23      	adds	r3, r4, #0
 800bb12:	1c22      	adds	r2, r4, #0
 800bb14:	33dc      	adds	r3, #220	; 0xdc
 800bb16:	681b      	ldr	r3, [r3, #0]
 800bb18:	3232      	adds	r2, #50	; 0x32
 800bb1a:	7811      	ldrb	r1, [r2, #0]
 800bb1c:	685b      	ldr	r3, [r3, #4]
 800bb1e:	1c20      	adds	r0, r4, #0
 800bb20:	4798      	blx	r3
		}
		usbd_dev->control_state.state = IDLE;
 800bb22:	2300      	movs	r3, #0
 800bb24:	702b      	strb	r3, [r5, #0]
		break;
 800bb26:	e001      	b.n	800bb2c <_usbd_control_in+0x56>
	default:
		stall_transaction(usbd_dev);
 800bb28:	f7ff fe9c 	bl	800b864 <stall_transaction>
	}
}
 800bb2c:	bd70      	pop	{r4, r5, r6, pc}

0800bb2e <usb_standard_set_configuration>:
}

static int usb_standard_set_configuration(usbd_device *usbd_dev,
					  struct usb_setup_data *req,
					  uint8_t **buf, uint16_t *len)
{
 800bb2e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	(void)req;
	(void)buf;
	(void)len;

	if (req->wValue > 0) {
 800bb30:	78cc      	ldrb	r4, [r1, #3]
 800bb32:	788b      	ldrb	r3, [r1, #2]
 800bb34:	0224      	lsls	r4, r4, #8
 800bb36:	431c      	orrs	r4, r3
 800bb38:	d00f      	beq.n	800bb5a <usb_standard_set_configuration+0x2c>
		for (i = 0; i < usbd_dev->desc->bNumConfigurations; i++) {
 800bb3a:	6803      	ldr	r3, [r0, #0]
 800bb3c:	7c5d      	ldrb	r5, [r3, #17]
 800bb3e:	2300      	movs	r3, #0
 800bb40:	42ab      	cmp	r3, r5
 800bb42:	d208      	bcs.n	800bb56 <usb_standard_set_configuration+0x28>
			if (req->wValue
			    == usbd_dev->config[i].bConfigurationValue) {
 800bb44:	220d      	movs	r2, #13
 800bb46:	435a      	muls	r2, r3
 800bb48:	6846      	ldr	r6, [r0, #4]
 800bb4a:	18b2      	adds	r2, r6, r2
	(void)buf;
	(void)len;

	if (req->wValue > 0) {
		for (i = 0; i < usbd_dev->desc->bNumConfigurations; i++) {
			if (req->wValue
 800bb4c:	7952      	ldrb	r2, [r2, #5]
 800bb4e:	42a2      	cmp	r2, r4
 800bb50:	d005      	beq.n	800bb5e <usb_standard_set_configuration+0x30>
	(void)req;
	(void)buf;
	(void)len;

	if (req->wValue > 0) {
		for (i = 0; i < usbd_dev->desc->bNumConfigurations; i++) {
 800bb52:	3301      	adds	r3, #1
 800bb54:	e7f4      	b.n	800bb40 <usb_standard_set_configuration+0x12>
				found_index = i;
				break;
			}
		}
		if (found_index < 0) {
			return USBD_REQ_NOTSUPP;
 800bb56:	2000      	movs	r0, #0
 800bb58:	e043      	b.n	800bbe2 <usb_standard_set_configuration+0xb4>
static int usb_standard_set_configuration(usbd_device *usbd_dev,
					  struct usb_setup_data *req,
					  uint8_t **buf, uint16_t *len)
{
	unsigned i;
	int found_index = -1;
 800bb5a:	2301      	movs	r3, #1
 800bb5c:	425b      	negs	r3, r3
		if (found_index < 0) {
			return USBD_REQ_NOTSUPP;
		}
	}

	usbd_dev->current_config = found_index + 1;
 800bb5e:	3301      	adds	r3, #1
 800bb60:	b2db      	uxtb	r3, r3
 800bb62:	75c3      	strb	r3, [r0, #23]

	if (usbd_dev->current_config > 0) {
 800bb64:	2b00      	cmp	r3, #0
 800bb66:	d10c      	bne.n	800bb82 <usb_standard_set_configuration+0x54>
 800bb68:	1c04      	adds	r4, r0, #0
			}
		}
	}

	/* Reset all endpoints. */
	usbd_dev->driver->ep_reset(usbd_dev);
 800bb6a:	1c03      	adds	r3, r0, #0

	if (usbd_dev->user_callback_set_config[0]) {
 800bb6c:	1c25      	adds	r5, r4, #0
			}
		}
	}

	/* Reset all endpoints. */
	usbd_dev->driver->ep_reset(usbd_dev);
 800bb6e:	33dc      	adds	r3, #220	; 0xdc
 800bb70:	681b      	ldr	r3, [r3, #0]

	if (usbd_dev->user_callback_set_config[0]) {
 800bb72:	35c8      	adds	r5, #200	; 0xc8
			}
		}
	}

	/* Reset all endpoints. */
	usbd_dev->driver->ep_reset(usbd_dev);
 800bb74:	68db      	ldr	r3, [r3, #12]
 800bb76:	1c0e      	adds	r6, r1, #0
 800bb78:	4798      	blx	r3

	if (usbd_dev->user_callback_set_config[0]) {
 800bb7a:	682b      	ldr	r3, [r5, #0]
 800bb7c:	2b00      	cmp	r3, #0
 800bb7e:	d11c      	bne.n	800bbba <usb_standard_set_configuration+0x8c>
 800bb80:	e02e      	b.n	800bbe0 <usb_standard_set_configuration+0xb2>
	}

	usbd_dev->current_config = found_index + 1;

	if (usbd_dev->current_config > 0) {
		cfg = &usbd_dev->config[usbd_dev->current_config - 1];
 800bb82:	220d      	movs	r2, #13

		/* reset all alternate settings configuration */
		for (i = 0; i < cfg->bNumInterfaces; i++) {
 800bb84:	2700      	movs	r7, #0
	}

	usbd_dev->current_config = found_index + 1;

	if (usbd_dev->current_config > 0) {
		cfg = &usbd_dev->config[usbd_dev->current_config - 1];
 800bb86:	4353      	muls	r3, r2
 800bb88:	6842      	ldr	r2, [r0, #4]
 800bb8a:	3b0d      	subs	r3, #13
 800bb8c:	18d3      	adds	r3, r2, r3

		/* reset all alternate settings configuration */
		for (i = 0; i < cfg->bNumInterfaces; i++) {
 800bb8e:	791a      	ldrb	r2, [r3, #4]
 800bb90:	4297      	cmp	r7, r2
 800bb92:	d2e9      	bcs.n	800bb68 <usb_standard_set_configuration+0x3a>
			if (cfg->interface[i].cur_altsetting) {
 800bb94:	7a9c      	ldrb	r4, [r3, #10]
 800bb96:	7a5e      	ldrb	r6, [r3, #9]
 800bb98:	7ada      	ldrb	r2, [r3, #11]
 800bb9a:	0224      	lsls	r4, r4, #8
 800bb9c:	4334      	orrs	r4, r6
 800bb9e:	0412      	lsls	r2, r2, #16
 800bba0:	4322      	orrs	r2, r4
 800bba2:	1c14      	adds	r4, r2, #0
 800bba4:	7b1a      	ldrb	r2, [r3, #12]
 800bba6:	0612      	lsls	r2, r2, #24
 800bba8:	4322      	orrs	r2, r4
 800bbaa:	013c      	lsls	r4, r7, #4
 800bbac:	58a2      	ldr	r2, [r4, r2]
 800bbae:	2a00      	cmp	r2, #0
 800bbb0:	d001      	beq.n	800bbb6 <usb_standard_set_configuration+0x88>
				*cfg->interface[i].cur_altsetting = 0;
 800bbb2:	2400      	movs	r4, #0
 800bbb4:	7014      	strb	r4, [r2, #0]

	if (usbd_dev->current_config > 0) {
		cfg = &usbd_dev->config[usbd_dev->current_config - 1];

		/* reset all alternate settings configuration */
		for (i = 0; i < cfg->bNumInterfaces; i++) {
 800bbb6:	3701      	adds	r7, #1
 800bbb8:	e7e9      	b.n	800bb8e <usb_standard_set_configuration+0x60>
		/*
		 * Flush control callbacks. These will be reregistered
		 * by the user handler.
		 */
		for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
			usbd_dev->user_control_callback[i].cb = NULL;
 800bbba:	2300      	movs	r3, #0
 800bbbc:	1c27      	adds	r7, r4, #0
 800bbbe:	64a3      	str	r3, [r4, #72]	; 0x48
 800bbc0:	6523      	str	r3, [r4, #80]	; 0x50
 800bbc2:	65a3      	str	r3, [r4, #88]	; 0x58
 800bbc4:	6623      	str	r3, [r4, #96]	; 0x60
 800bbc6:	37d8      	adds	r7, #216	; 0xd8
		}

		for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
			if (usbd_dev->user_callback_set_config[i]) {
 800bbc8:	682a      	ldr	r2, [r5, #0]
 800bbca:	2a00      	cmp	r2, #0
 800bbcc:	d005      	beq.n	800bbda <usb_standard_set_configuration+0xac>
				usbd_dev->user_callback_set_config[i](usbd_dev,
 800bbce:	78f1      	ldrb	r1, [r6, #3]
 800bbd0:	78b3      	ldrb	r3, [r6, #2]
 800bbd2:	0209      	lsls	r1, r1, #8
 800bbd4:	4319      	orrs	r1, r3
 800bbd6:	1c20      	adds	r0, r4, #0
 800bbd8:	4790      	blx	r2
 800bbda:	3504      	adds	r5, #4
		 */
		for (i = 0; i < MAX_USER_CONTROL_CALLBACK; i++) {
			usbd_dev->user_control_callback[i].cb = NULL;
		}

		for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
 800bbdc:	42bd      	cmp	r5, r7
 800bbde:	d1f3      	bne.n	800bbc8 <usb_standard_set_configuration+0x9a>
								req->wValue);
			}
		}
	}

	return 1;
 800bbe0:	2001      	movs	r0, #1
}
 800bbe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800bbe4 <usb_standard_get_configuration>:
					  struct usb_setup_data *req,
					  uint8_t **buf, uint16_t *len)
{
	(void)req;

	if (*len > 1) {
 800bbe4:	8819      	ldrh	r1, [r3, #0]
 800bbe6:	2901      	cmp	r1, #1
 800bbe8:	d901      	bls.n	800bbee <usb_standard_get_configuration+0xa>
		*len = 1;
 800bbea:	2101      	movs	r1, #1
 800bbec:	8019      	strh	r1, [r3, #0]
	}
	if (usbd_dev->current_config > 0) {
 800bbee:	7dc3      	ldrb	r3, [r0, #23]
 800bbf0:	6811      	ldr	r1, [r2, #0]
 800bbf2:	2b00      	cmp	r3, #0
 800bbf4:	d005      	beq.n	800bc02 <usb_standard_get_configuration+0x1e>
		const struct usb_config_descriptor *cfg =
			&usbd_dev->config[usbd_dev->current_config - 1];
		(*buf)[0] = cfg->bConfigurationValue;
 800bbf6:	220d      	movs	r2, #13
 800bbf8:	4353      	muls	r3, r2
 800bbfa:	6840      	ldr	r0, [r0, #4]
 800bbfc:	18c3      	adds	r3, r0, r3
 800bbfe:	3b0d      	subs	r3, #13
 800bc00:	795b      	ldrb	r3, [r3, #5]
	} else {
		(*buf)[0] = 0;
	}

	return 1;
}
 800bc02:	2001      	movs	r0, #1
	if (usbd_dev->current_config > 0) {
		const struct usb_config_descriptor *cfg =
			&usbd_dev->config[usbd_dev->current_config - 1];
		(*buf)[0] = cfg->bConfigurationValue;
	} else {
		(*buf)[0] = 0;
 800bc04:	700b      	strb	r3, [r1, #0]
	}

	return 1;
}
 800bc06:	4770      	bx	lr

0800bc08 <usb_standard_get_interface>:
}

static int usb_standard_get_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
 800bc08:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bc0a:	1c0f      	adds	r7, r1, #0
	uint8_t *cur_altsetting;
	const struct usb_config_descriptor *cfx =
		&usbd_dev->config[usbd_dev->current_config - 1];
 800bc0c:	210d      	movs	r1, #13
 800bc0e:	7dc4      	ldrb	r4, [r0, #23]
 800bc10:	434c      	muls	r4, r1
static int usb_standard_get_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
	uint8_t *cur_altsetting;
	const struct usb_config_descriptor *cfx =
 800bc12:	6841      	ldr	r1, [r0, #4]
		&usbd_dev->config[usbd_dev->current_config - 1];
 800bc14:	3c0d      	subs	r4, #13
static int usb_standard_get_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
	uint8_t *cur_altsetting;
	const struct usb_config_descriptor *cfx =
 800bc16:	190c      	adds	r4, r1, r4
		&usbd_dev->config[usbd_dev->current_config - 1];

	if (req->wIndex >= cfx->bNumInterfaces) {
 800bc18:	7979      	ldrb	r1, [r7, #5]
 800bc1a:	7938      	ldrb	r0, [r7, #4]
 800bc1c:	7925      	ldrb	r5, [r4, #4]
 800bc1e:	0209      	lsls	r1, r1, #8
 800bc20:	4301      	orrs	r1, r0
		return USBD_REQ_NOTSUPP;
 800bc22:	2000      	movs	r0, #0
{
	uint8_t *cur_altsetting;
	const struct usb_config_descriptor *cfx =
		&usbd_dev->config[usbd_dev->current_config - 1];

	if (req->wIndex >= cfx->bNumInterfaces) {
 800bc24:	428d      	cmp	r5, r1
 800bc26:	d918      	bls.n	800bc5a <usb_standard_get_interface+0x52>
		return USBD_REQ_NOTSUPP;
	}

	*len = 1;
 800bc28:	2101      	movs	r1, #1
 800bc2a:	8019      	strh	r1, [r3, #0]
	cur_altsetting = cfx->interface[req->wIndex].cur_altsetting;
 800bc2c:	7aa0      	ldrb	r0, [r4, #10]
 800bc2e:	7a66      	ldrb	r6, [r4, #9]
 800bc30:	7ae3      	ldrb	r3, [r4, #11]
 800bc32:	0200      	lsls	r0, r0, #8
 800bc34:	4330      	orrs	r0, r6
 800bc36:	041b      	lsls	r3, r3, #16
 800bc38:	4303      	orrs	r3, r0
 800bc3a:	1c18      	adds	r0, r3, #0
 800bc3c:	7b23      	ldrb	r3, [r4, #12]
 800bc3e:	7979      	ldrb	r1, [r7, #5]
 800bc40:	061b      	lsls	r3, r3, #24
 800bc42:	4303      	orrs	r3, r0
 800bc44:	7938      	ldrb	r0, [r7, #4]
 800bc46:	0209      	lsls	r1, r1, #8
 800bc48:	4301      	orrs	r1, r0
 800bc4a:	0109      	lsls	r1, r1, #4
 800bc4c:	58cb      	ldr	r3, [r1, r3]
	(*buf)[0] = (cur_altsetting) ? *cur_altsetting : 0;
 800bc4e:	6811      	ldr	r1, [r2, #0]
 800bc50:	1e1a      	subs	r2, r3, #0
 800bc52:	d000      	beq.n	800bc56 <usb_standard_get_interface+0x4e>
 800bc54:	781a      	ldrb	r2, [r3, #0]

	return USBD_REQ_HANDLED;
 800bc56:	2001      	movs	r0, #1
		return USBD_REQ_NOTSUPP;
	}

	*len = 1;
	cur_altsetting = cfx->interface[req->wIndex].cur_altsetting;
	(*buf)[0] = (cur_altsetting) ? *cur_altsetting : 0;
 800bc58:	700a      	strb	r2, [r1, #0]

	return USBD_REQ_HANDLED;
}
 800bc5a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800bc5c <usb_standard_device_get_status>:
	(void)usbd_dev;
	(void)req;

	/* bit 0: self powered */
	/* bit 1: remote wakeup */
	if (*len > 2) {
 800bc5c:	8819      	ldrh	r1, [r3, #0]
 800bc5e:	2902      	cmp	r1, #2
 800bc60:	d901      	bls.n	800bc66 <usb_standard_device_get_status+0xa>
		*len = 2;
 800bc62:	2102      	movs	r1, #2
 800bc64:	8019      	strh	r1, [r3, #0]
	}
	(*buf)[0] = 0;
 800bc66:	2300      	movs	r3, #0
 800bc68:	6811      	ldr	r1, [r2, #0]
	(*buf)[1] = 0;

	return 1;
}
 800bc6a:	2001      	movs	r0, #1
	/* bit 0: self powered */
	/* bit 1: remote wakeup */
	if (*len > 2) {
		*len = 2;
	}
	(*buf)[0] = 0;
 800bc6c:	700b      	strb	r3, [r1, #0]
	(*buf)[1] = 0;
 800bc6e:	6812      	ldr	r2, [r2, #0]
 800bc70:	7053      	strb	r3, [r2, #1]

	return 1;
}
 800bc72:	4770      	bx	lr

0800bc74 <usb_standard_interface_get_status>:
{
	(void)usbd_dev;
	(void)req;
	/* not defined */

	if (*len > 2) {
 800bc74:	8819      	ldrh	r1, [r3, #0]
 800bc76:	2902      	cmp	r1, #2
 800bc78:	d901      	bls.n	800bc7e <usb_standard_interface_get_status+0xa>
		*len = 2;
 800bc7a:	2102      	movs	r1, #2
 800bc7c:	8019      	strh	r1, [r3, #0]
	}
	(*buf)[0] = 0;
 800bc7e:	2300      	movs	r3, #0
 800bc80:	6811      	ldr	r1, [r2, #0]
	(*buf)[1] = 0;

	return 1;
}
 800bc82:	2001      	movs	r0, #1
	/* not defined */

	if (*len > 2) {
		*len = 2;
	}
	(*buf)[0] = 0;
 800bc84:	700b      	strb	r3, [r1, #0]
	(*buf)[1] = 0;
 800bc86:	6812      	ldr	r2, [r2, #0]
 800bc88:	7053      	strb	r3, [r2, #1]

	return 1;
}
 800bc8a:	4770      	bx	lr

0800bc8c <usb_standard_endpoint_get_status>:

static int usb_standard_endpoint_get_status(usbd_device *usbd_dev,
					    struct usb_setup_data *req,
					    uint8_t **buf, uint16_t *len)
{
 800bc8c:	b538      	push	{r3, r4, r5, lr}
 800bc8e:	1c14      	adds	r4, r2, #0
	(void)req;

	if (*len > 2) {
 800bc90:	881a      	ldrh	r2, [r3, #0]
 800bc92:	2a02      	cmp	r2, #2
 800bc94:	d901      	bls.n	800bc9a <usb_standard_endpoint_get_status+0xe>
		*len = 2;
 800bc96:	2202      	movs	r2, #2
 800bc98:	801a      	strh	r2, [r3, #0]
	}
	(*buf)[0] = usbd_ep_stall_get(usbd_dev, req->wIndex) ? 1 : 0;
 800bc9a:	7909      	ldrb	r1, [r1, #4]
 800bc9c:	6825      	ldr	r5, [r4, #0]
 800bc9e:	f7ff fdda 	bl	800b856 <usbd_ep_stall_get>
 800bca2:	1e43      	subs	r3, r0, #1
 800bca4:	4198      	sbcs	r0, r3
	(*buf)[1] = 0;
 800bca6:	2200      	movs	r2, #0
	(void)req;

	if (*len > 2) {
		*len = 2;
	}
	(*buf)[0] = usbd_ep_stall_get(usbd_dev, req->wIndex) ? 1 : 0;
 800bca8:	7028      	strb	r0, [r5, #0]
	(*buf)[1] = 0;
 800bcaa:	6823      	ldr	r3, [r4, #0]

	return 1;
}
 800bcac:	2001      	movs	r0, #1

	if (*len > 2) {
		*len = 2;
	}
	(*buf)[0] = usbd_ep_stall_get(usbd_dev, req->wIndex) ? 1 : 0;
	(*buf)[1] = 0;
 800bcae:	705a      	strb	r2, [r3, #1]

	return 1;
}
 800bcb0:	bd38      	pop	{r3, r4, r5, pc}

0800bcb2 <usb_standard_endpoint_stall>:

static int usb_standard_endpoint_stall(usbd_device *usbd_dev,
				       struct usb_setup_data *req,
				       uint8_t **buf, uint16_t *len)
{
 800bcb2:	b508      	push	{r3, lr}
	(void)buf;
	(void)len;

	usbd_ep_stall_set(usbd_dev, req->wIndex, 1);
 800bcb4:	2201      	movs	r2, #1
 800bcb6:	7909      	ldrb	r1, [r1, #4]
 800bcb8:	f7ff fdc6 	bl	800b848 <usbd_ep_stall_set>

	return 1;
}
 800bcbc:	2001      	movs	r0, #1
 800bcbe:	bd08      	pop	{r3, pc}

0800bcc0 <usb_standard_endpoint_unstall>:

static int usb_standard_endpoint_unstall(usbd_device *usbd_dev,
					 struct usb_setup_data *req,
					 uint8_t **buf, uint16_t *len)
{
 800bcc0:	b508      	push	{r3, lr}
	(void)buf;
	(void)len;

	usbd_ep_stall_set(usbd_dev, req->wIndex, 0);
 800bcc2:	2200      	movs	r2, #0
 800bcc4:	7909      	ldrb	r1, [r1, #4]
 800bcc6:	f7ff fdbf 	bl	800b848 <usbd_ep_stall_set>

	return 1;
}
 800bcca:	2001      	movs	r0, #1
 800bccc:	bd08      	pop	{r3, pc}

0800bcce <usb_standard_set_address>:
}

static int usb_standard_set_address(usbd_device *usbd_dev,
				    struct usb_setup_data *req, uint8_t **buf,
				    uint16_t *len)
{
 800bcce:	b510      	push	{r4, lr}
	(void)buf;
	(void)len;

	/* The actual address is only latched at the STATUS IN stage. */
	if ((req->bmRequestType != 0) || (req->wValue >= 128)) {
		return 0;
 800bcd0:	2400      	movs	r4, #0
	(void)req;
	(void)buf;
	(void)len;

	/* The actual address is only latched at the STATUS IN stage. */
	if ((req->bmRequestType != 0) || (req->wValue >= 128)) {
 800bcd2:	780b      	ldrb	r3, [r1, #0]
 800bcd4:	42a3      	cmp	r3, r4
 800bcd6:	d112      	bne.n	800bcfe <usb_standard_set_address+0x30>
 800bcd8:	78cb      	ldrb	r3, [r1, #3]
 800bcda:	788a      	ldrb	r2, [r1, #2]
 800bcdc:	021b      	lsls	r3, r3, #8
 800bcde:	4313      	orrs	r3, r2
 800bce0:	2b7f      	cmp	r3, #127	; 0x7f
 800bce2:	d80c      	bhi.n	800bcfe <usb_standard_set_address+0x30>
		return 0;
	}

	usbd_dev->current_address = req->wValue;
 800bce4:	7583      	strb	r3, [r0, #22]

	/*
	 * Special workaround for STM32F10[57] that require the address
	 * to be set here. This is undocumented!
	 */
	if (usbd_dev->driver->set_address_before_status) {
 800bce6:	1c03      	adds	r3, r0, #0
 800bce8:	33dc      	adds	r3, #220	; 0xdc
 800bcea:	681b      	ldr	r3, [r3, #0]
		usbd_dev->driver->set_address(usbd_dev, req->wValue);
	}

	return 1;
 800bcec:	3401      	adds	r4, #1

	/*
	 * Special workaround for STM32F10[57] that require the address
	 * to be set here. This is undocumented!
	 */
	if (usbd_dev->driver->set_address_before_status) {
 800bcee:	1c1a      	adds	r2, r3, #0
 800bcf0:	3230      	adds	r2, #48	; 0x30
 800bcf2:	7812      	ldrb	r2, [r2, #0]
 800bcf4:	2a00      	cmp	r2, #0
 800bcf6:	d002      	beq.n	800bcfe <usb_standard_set_address+0x30>
		usbd_dev->driver->set_address(usbd_dev, req->wValue);
 800bcf8:	7889      	ldrb	r1, [r1, #2]
 800bcfa:	685b      	ldr	r3, [r3, #4]
 800bcfc:	4798      	blx	r3
	}

	return 1;
}
 800bcfe:	1c20      	adds	r0, r4, #0
 800bd00:	bd10      	pop	{r4, pc}

0800bd02 <usb_standard_set_interface>:
static int usb_standard_set_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
	const struct usb_config_descriptor *cfx =
		&usbd_dev->config[usbd_dev->current_config - 1];
 800bd02:	220d      	movs	r2, #13
}

static int usb_standard_set_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
 800bd04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct usb_config_descriptor *cfx =
		&usbd_dev->config[usbd_dev->current_config - 1];
 800bd06:	7dc4      	ldrb	r4, [r0, #23]
	const struct usb_interface *iface;

	(void)buf;

	if (req->wIndex >= cfx->bNumInterfaces) {
 800bd08:	790d      	ldrb	r5, [r1, #4]
static int usb_standard_set_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
	const struct usb_config_descriptor *cfx =
		&usbd_dev->config[usbd_dev->current_config - 1];
 800bd0a:	4362      	muls	r2, r4

static int usb_standard_set_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
	const struct usb_config_descriptor *cfx =
 800bd0c:	6844      	ldr	r4, [r0, #4]
		&usbd_dev->config[usbd_dev->current_config - 1];
 800bd0e:	3a0d      	subs	r2, #13

static int usb_standard_set_interface(usbd_device *usbd_dev,
				      struct usb_setup_data *req,
				      uint8_t **buf, uint16_t *len)
{
	const struct usb_config_descriptor *cfx =
 800bd10:	18a2      	adds	r2, r4, r2
		&usbd_dev->config[usbd_dev->current_config - 1];
	const struct usb_interface *iface;

	(void)buf;

	if (req->wIndex >= cfx->bNumInterfaces) {
 800bd12:	794c      	ldrb	r4, [r1, #5]
		return USBD_REQ_NOTSUPP;
 800bd14:	2700      	movs	r7, #0
		&usbd_dev->config[usbd_dev->current_config - 1];
	const struct usb_interface *iface;

	(void)buf;

	if (req->wIndex >= cfx->bNumInterfaces) {
 800bd16:	0224      	lsls	r4, r4, #8
 800bd18:	432c      	orrs	r4, r5
 800bd1a:	7915      	ldrb	r5, [r2, #4]
 800bd1c:	42a5      	cmp	r5, r4
 800bd1e:	d92c      	bls.n	800bd7a <usb_standard_set_interface+0x78>
		return USBD_REQ_NOTSUPP;
	}

	iface = &cfx->interface[req->wIndex];
 800bd20:	7a96      	ldrb	r6, [r2, #10]
 800bd22:	7a55      	ldrb	r5, [r2, #9]
 800bd24:	0236      	lsls	r6, r6, #8
 800bd26:	432e      	orrs	r6, r5
 800bd28:	7ad5      	ldrb	r5, [r2, #11]
 800bd2a:	7b12      	ldrb	r2, [r2, #12]
 800bd2c:	042d      	lsls	r5, r5, #16
 800bd2e:	432e      	orrs	r6, r5
 800bd30:	0612      	lsls	r2, r2, #24
 800bd32:	0124      	lsls	r4, r4, #4
 800bd34:	4332      	orrs	r2, r6
 800bd36:	1912      	adds	r2, r2, r4

	if (req->wValue >= iface->num_altsetting) {
 800bd38:	78cc      	ldrb	r4, [r1, #3]
 800bd3a:	788d      	ldrb	r5, [r1, #2]
 800bd3c:	0224      	lsls	r4, r4, #8
 800bd3e:	432c      	orrs	r4, r5
 800bd40:	7915      	ldrb	r5, [r2, #4]
 800bd42:	42a5      	cmp	r5, r4
 800bd44:	d919      	bls.n	800bd7a <usb_standard_set_interface+0x78>
		return USBD_REQ_NOTSUPP;
	}

	if (iface->cur_altsetting) {
 800bd46:	6812      	ldr	r2, [r2, #0]
 800bd48:	42ba      	cmp	r2, r7
 800bd4a:	d001      	beq.n	800bd50 <usb_standard_set_interface+0x4e>
		*iface->cur_altsetting = req->wValue;
 800bd4c:	7014      	strb	r4, [r2, #0]
 800bd4e:	e001      	b.n	800bd54 <usb_standard_set_interface+0x52>
	} else if (req->wValue > 0) {
 800bd50:	2c00      	cmp	r4, #0
 800bd52:	d112      	bne.n	800bd7a <usb_standard_set_interface+0x78>
		return USBD_REQ_NOTSUPP;
	}

	if (usbd_dev->user_callback_set_altsetting) {
 800bd54:	1c02      	adds	r2, r0, #0
 800bd56:	32d8      	adds	r2, #216	; 0xd8
 800bd58:	6816      	ldr	r6, [r2, #0]
 800bd5a:	1c1c      	adds	r4, r3, #0
 800bd5c:	1c0b      	adds	r3, r1, #0
 800bd5e:	2e00      	cmp	r6, #0
 800bd60:	d008      	beq.n	800bd74 <usb_standard_set_interface+0x72>
			usbd_dev->user_callback_set_altsetting(usbd_dev,
 800bd62:	790a      	ldrb	r2, [r1, #4]
 800bd64:	7949      	ldrb	r1, [r1, #5]
 800bd66:	789d      	ldrb	r5, [r3, #2]
 800bd68:	0209      	lsls	r1, r1, #8
 800bd6a:	4311      	orrs	r1, r2
 800bd6c:	78da      	ldrb	r2, [r3, #3]
 800bd6e:	0212      	lsls	r2, r2, #8
 800bd70:	432a      	orrs	r2, r5
 800bd72:	47b0      	blx	r6
							       req->wIndex,
							       req->wValue);
	}

	*len = 0;
 800bd74:	2300      	movs	r3, #0
 800bd76:	2701      	movs	r7, #1
 800bd78:	8023      	strh	r3, [r4, #0]

	return USBD_REQ_HANDLED;
}
 800bd7a:	1c38      	adds	r0, r7, #0
 800bd7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800bd80 <usb_standard_get_descriptor>:
}

static int usb_standard_get_descriptor(usbd_device *usbd_dev,
				       struct usb_setup_data *req,
				       uint8_t **buf, uint16_t *len)
{
 800bd80:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bd82:	b08d      	sub	sp, #52	; 0x34
 800bd84:	9305      	str	r3, [sp, #20]
	int i, array_idx, descr_idx;
	struct usb_string_descriptor *sd;

	descr_idx = usb_descriptor_index(req->wValue);
 800bd86:	78cb      	ldrb	r3, [r1, #3]
}

static int usb_standard_get_descriptor(usbd_device *usbd_dev,
				       struct usb_setup_data *req,
				       uint8_t **buf, uint16_t *len)
{
 800bd88:	1c17      	adds	r7, r2, #0
	int i, array_idx, descr_idx;
	struct usb_string_descriptor *sd;

	descr_idx = usb_descriptor_index(req->wValue);
 800bd8a:	788a      	ldrb	r2, [r1, #2]
 800bd8c:	021b      	lsls	r3, r3, #8
 800bd8e:	4313      	orrs	r3, r2
	return wValue >> 8;
}

static int usb_descriptor_index(uint16_t wValue)
{
	return wValue & 0xFF;
 800bd90:	b2dc      	uxtb	r4, r3
}

static int usb_standard_get_descriptor(usbd_device *usbd_dev,
				       struct usb_setup_data *req,
				       uint8_t **buf, uint16_t *len)
{
 800bd92:	1c06      	adds	r6, r0, #0
	int i, array_idx, descr_idx;
	struct usb_string_descriptor *sd;

	descr_idx = usb_descriptor_index(req->wValue);

	switch (usb_descriptor_type(req->wValue)) {
 800bd94:	0a1b      	lsrs	r3, r3, #8
 800bd96:	2b02      	cmp	r3, #2
 800bd98:	d013      	beq.n	800bdc2 <usb_standard_get_descriptor+0x42>
 800bd9a:	2b03      	cmp	r3, #3
 800bd9c:	d100      	bne.n	800bda0 <usb_standard_get_descriptor+0x20>
 800bd9e:	e146      	b.n	800c02e <usb_standard_get_descriptor+0x2ae>
		sd->bDescriptorType = USB_DT_STRING;
		*buf = (uint8_t *)sd;

		return USBD_REQ_HANDLED;
	}
	return USBD_REQ_NOTSUPP;
 800bda0:	2000      	movs	r0, #0
	int i, array_idx, descr_idx;
	struct usb_string_descriptor *sd;

	descr_idx = usb_descriptor_index(req->wValue);

	switch (usb_descriptor_type(req->wValue)) {
 800bda2:	2b01      	cmp	r3, #1
 800bda4:	d000      	beq.n	800bda8 <usb_standard_get_descriptor+0x28>
 800bda6:	e187      	b.n	800c0b8 <usb_standard_get_descriptor+0x338>
	case USB_DT_DEVICE:
		*buf = (uint8_t *) usbd_dev->desc;
 800bda8:	6833      	ldr	r3, [r6, #0]
 800bdaa:	603b      	str	r3, [r7, #0]
		*len = MIN(*len, usbd_dev->desc->bLength);
 800bdac:	6833      	ldr	r3, [r6, #0]
 800bdae:	781a      	ldrb	r2, [r3, #0]
 800bdb0:	9b05      	ldr	r3, [sp, #20]
 800bdb2:	8819      	ldrh	r1, [r3, #0]
 800bdb4:	1c0b      	adds	r3, r1, #0
 800bdb6:	4291      	cmp	r1, r2
 800bdb8:	d900      	bls.n	800bdbc <usb_standard_get_descriptor+0x3c>
 800bdba:	1c13      	adds	r3, r2, #0
 800bdbc:	9a05      	ldr	r2, [sp, #20]
 800bdbe:	8013      	strh	r3, [r2, #0]
 800bdc0:	e133      	b.n	800c02a <usb_standard_get_descriptor+0x2aa>
		return USBD_REQ_HANDLED;
	case USB_DT_CONFIGURATION:
		*buf = usbd_dev->ctrl_buf;
 800bdc2:	6903      	ldr	r3, [r0, #16]
 800bdc4:	603b      	str	r3, [r7, #0]
 800bdc6:	9306      	str	r3, [sp, #24]
		*len = build_config_descriptor(usbd_dev, descr_idx, *buf, *len);
 800bdc8:	9b05      	ldr	r3, [sp, #20]
 800bdca:	881d      	ldrh	r5, [r3, #0]

static uint16_t build_config_descriptor(usbd_device *usbd_dev,
				   uint8_t index, uint8_t *buf, uint16_t len)
{
	uint8_t *tmpbuf = buf;
	const struct usb_config_descriptor *cfg = &usbd_dev->config[index];
 800bdcc:	230d      	movs	r3, #13
 800bdce:	435c      	muls	r4, r3
 800bdd0:	6843      	ldr	r3, [r0, #4]
	uint16_t count, total = 0, totallen = 0;
	uint16_t i, j, k;

	memcpy(buf, cfg, count = MIN(len, cfg->bLength));
 800bdd2:	1c2f      	adds	r7, r5, #0

static uint16_t build_config_descriptor(usbd_device *usbd_dev,
				   uint8_t index, uint8_t *buf, uint16_t len)
{
	uint8_t *tmpbuf = buf;
	const struct usb_config_descriptor *cfg = &usbd_dev->config[index];
 800bdd4:	191b      	adds	r3, r3, r4
 800bdd6:	9303      	str	r3, [sp, #12]
	uint16_t count, total = 0, totallen = 0;
	uint16_t i, j, k;

	memcpy(buf, cfg, count = MIN(len, cfg->bLength));
 800bdd8:	781b      	ldrb	r3, [r3, #0]
 800bdda:	429d      	cmp	r5, r3
 800bddc:	d900      	bls.n	800bde0 <usb_standard_get_descriptor+0x60>
 800bdde:	1c1f      	adds	r7, r3, #0
 800bde0:	b2bb      	uxth	r3, r7
 800bde2:	1c1a      	adds	r2, r3, #0
 800bde4:	9806      	ldr	r0, [sp, #24]
 800bde6:	9903      	ldr	r1, [sp, #12]
 800bde8:	9302      	str	r3, [sp, #8]
 800bdea:	f000 fd65 	bl	800c8b8 <memcpy>
	buf += count;
 800bdee:	9a02      	ldr	r2, [sp, #8]
 800bdf0:	9b06      	ldr	r3, [sp, #24]
 800bdf2:	4694      	mov	ip, r2
 800bdf4:	4463      	add	r3, ip
 800bdf6:	9301      	str	r3, [sp, #4]
	len -= count;
	total += count;
	totallen += cfg->bLength;
 800bdf8:	9b03      	ldr	r3, [sp, #12]
	uint16_t count, total = 0, totallen = 0;
	uint16_t i, j, k;

	memcpy(buf, cfg, count = MIN(len, cfg->bLength));
	buf += count;
	len -= count;
 800bdfa:	1aad      	subs	r5, r5, r2
	total += count;
	totallen += cfg->bLength;
 800bdfc:	781b      	ldrb	r3, [r3, #0]
	uint16_t count, total = 0, totallen = 0;
	uint16_t i, j, k;

	memcpy(buf, cfg, count = MIN(len, cfg->bLength));
	buf += count;
	len -= count;
 800bdfe:	b2ae      	uxth	r6, r5
	total += count;
	totallen += cfg->bLength;
 800be00:	9304      	str	r3, [sp, #16]

	/* For each interface... */
	for (i = 0; i < cfg->bNumInterfaces; i++) {
 800be02:	2300      	movs	r3, #0
 800be04:	9307      	str	r3, [sp, #28]
 800be06:	9b03      	ldr	r3, [sp, #12]
 800be08:	9a07      	ldr	r2, [sp, #28]
 800be0a:	791b      	ldrb	r3, [r3, #4]
 800be0c:	4293      	cmp	r3, r2
 800be0e:	d800      	bhi.n	800be12 <usb_standard_get_descriptor+0x92>
 800be10:	e103      	b.n	800c01a <usb_standard_get_descriptor+0x29a>
		/* Interface Association Descriptor, if any */
		if (cfg->interface[i].iface_assoc) {
 800be12:	9b07      	ldr	r3, [sp, #28]
 800be14:	011b      	lsls	r3, r3, #4
 800be16:	930a      	str	r3, [sp, #40]	; 0x28
 800be18:	9b03      	ldr	r3, [sp, #12]
 800be1a:	7a9a      	ldrb	r2, [r3, #10]
 800be1c:	7a58      	ldrb	r0, [r3, #9]
 800be1e:	7adb      	ldrb	r3, [r3, #11]
 800be20:	0212      	lsls	r2, r2, #8
 800be22:	4302      	orrs	r2, r0
 800be24:	041b      	lsls	r3, r3, #16
 800be26:	4313      	orrs	r3, r2
 800be28:	1c1a      	adds	r2, r3, #0
 800be2a:	9b03      	ldr	r3, [sp, #12]
 800be2c:	7b1b      	ldrb	r3, [r3, #12]
 800be2e:	061b      	lsls	r3, r3, #24
 800be30:	4313      	orrs	r3, r2
 800be32:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800be34:	189b      	adds	r3, r3, r2
 800be36:	689c      	ldr	r4, [r3, #8]
 800be38:	2c00      	cmp	r4, #0
 800be3a:	d018      	beq.n	800be6e <usb_standard_get_descriptor+0xee>
			const struct usb_iface_assoc_descriptor *assoc =
					cfg->interface[i].iface_assoc;
			memcpy(buf, assoc, count = MIN(len, assoc->bLength));
 800be3c:	7823      	ldrb	r3, [r4, #0]
 800be3e:	1c37      	adds	r7, r6, #0
 800be40:	429e      	cmp	r6, r3
 800be42:	d900      	bls.n	800be46 <usb_standard_get_descriptor+0xc6>
 800be44:	1c1f      	adds	r7, r3, #0
 800be46:	b2bf      	uxth	r7, r7
 800be48:	1c3a      	adds	r2, r7, #0
 800be4a:	9801      	ldr	r0, [sp, #4]
 800be4c:	1c21      	adds	r1, r4, #0
 800be4e:	f000 fd33 	bl	800c8b8 <memcpy>
			buf += count;
 800be52:	9b01      	ldr	r3, [sp, #4]
			len -= count;
			total += count;
			totallen += assoc->bLength;
 800be54:	9a04      	ldr	r2, [sp, #16]
		/* Interface Association Descriptor, if any */
		if (cfg->interface[i].iface_assoc) {
			const struct usb_iface_assoc_descriptor *assoc =
					cfg->interface[i].iface_assoc;
			memcpy(buf, assoc, count = MIN(len, assoc->bLength));
			buf += count;
 800be56:	19db      	adds	r3, r3, r7
 800be58:	9301      	str	r3, [sp, #4]
			len -= count;
 800be5a:	1bf3      	subs	r3, r6, r7
 800be5c:	b29e      	uxth	r6, r3
			total += count;
 800be5e:	9b02      	ldr	r3, [sp, #8]
 800be60:	18ff      	adds	r7, r7, r3
 800be62:	b2bb      	uxth	r3, r7
 800be64:	9302      	str	r3, [sp, #8]
			totallen += assoc->bLength;
 800be66:	7823      	ldrb	r3, [r4, #0]
 800be68:	18d3      	adds	r3, r2, r3
 800be6a:	b29b      	uxth	r3, r3
 800be6c:	9304      	str	r3, [sp, #16]
}

static int usb_standard_get_descriptor(usbd_device *usbd_dev,
				       struct usb_setup_data *req,
				       uint8_t **buf, uint16_t *len)
{
 800be6e:	2300      	movs	r3, #0
			len -= count;
			total += count;
			totallen += assoc->bLength;
		}
		/* For each alternate setting... */
		for (j = 0; j < cfg->interface[i].num_altsetting; j++) {
 800be70:	9308      	str	r3, [sp, #32]
 800be72:	9b03      	ldr	r3, [sp, #12]
 800be74:	9908      	ldr	r1, [sp, #32]
 800be76:	7a9a      	ldrb	r2, [r3, #10]
 800be78:	7a58      	ldrb	r0, [r3, #9]
 800be7a:	7adb      	ldrb	r3, [r3, #11]
 800be7c:	0212      	lsls	r2, r2, #8
 800be7e:	4302      	orrs	r2, r0
 800be80:	041b      	lsls	r3, r3, #16
 800be82:	4313      	orrs	r3, r2
 800be84:	1c1a      	adds	r2, r3, #0
 800be86:	9b03      	ldr	r3, [sp, #12]
 800be88:	7b1b      	ldrb	r3, [r3, #12]
 800be8a:	061b      	lsls	r3, r3, #24
 800be8c:	4313      	orrs	r3, r2
 800be8e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800be90:	189b      	adds	r3, r3, r2
 800be92:	791a      	ldrb	r2, [r3, #4]
 800be94:	428a      	cmp	r2, r1
 800be96:	d800      	bhi.n	800be9a <usb_standard_get_descriptor+0x11a>
 800be98:	e0bb      	b.n	800c012 <usb_standard_get_descriptor+0x292>
			const struct usb_interface_descriptor *iface =
					&cfg->interface[i].altsetting[j];
 800be9a:	2415      	movs	r4, #21
 800be9c:	9a08      	ldr	r2, [sp, #32]
			total += count;
			totallen += assoc->bLength;
		}
		/* For each alternate setting... */
		for (j = 0; j < cfg->interface[i].num_altsetting; j++) {
			const struct usb_interface_descriptor *iface =
 800be9e:	68db      	ldr	r3, [r3, #12]
					&cfg->interface[i].altsetting[j];
 800bea0:	4354      	muls	r4, r2
			total += count;
			totallen += assoc->bLength;
		}
		/* For each alternate setting... */
		for (j = 0; j < cfg->interface[i].num_altsetting; j++) {
			const struct usb_interface_descriptor *iface =
 800bea2:	191c      	adds	r4, r3, r4
					&cfg->interface[i].altsetting[j];
			/* Copy interface descriptor. */
			memcpy(buf, iface, count = MIN(len, iface->bLength));
 800bea4:	7823      	ldrb	r3, [r4, #0]
 800bea6:	1c37      	adds	r7, r6, #0
 800bea8:	429e      	cmp	r6, r3
 800beaa:	d900      	bls.n	800beae <usb_standard_get_descriptor+0x12e>
 800beac:	1c1f      	adds	r7, r3, #0
 800beae:	b2bf      	uxth	r7, r7
 800beb0:	1c3a      	adds	r2, r7, #0
 800beb2:	1c21      	adds	r1, r4, #0
 800beb4:	9801      	ldr	r0, [sp, #4]
 800beb6:	f000 fcff 	bl	800c8b8 <memcpy>
			buf += count;
 800beba:	9b01      	ldr	r3, [sp, #4]
			len -= count;
			total += count;
			totallen += iface->bLength;
 800bebc:	9a04      	ldr	r2, [sp, #16]
		for (j = 0; j < cfg->interface[i].num_altsetting; j++) {
			const struct usb_interface_descriptor *iface =
					&cfg->interface[i].altsetting[j];
			/* Copy interface descriptor. */
			memcpy(buf, iface, count = MIN(len, iface->bLength));
			buf += count;
 800bebe:	19db      	adds	r3, r3, r7
 800bec0:	9301      	str	r3, [sp, #4]
			len -= count;
 800bec2:	1bf3      	subs	r3, r6, r7
 800bec4:	b29e      	uxth	r6, r3
			total += count;
 800bec6:	9b02      	ldr	r3, [sp, #8]
 800bec8:	18ff      	adds	r7, r7, r3
 800beca:	b2bb      	uxth	r3, r7
 800becc:	9302      	str	r3, [sp, #8]
			totallen += iface->bLength;
 800bece:	7823      	ldrb	r3, [r4, #0]
 800bed0:	18d3      	adds	r3, r2, r3
 800bed2:	b29b      	uxth	r3, r3
 800bed4:	9304      	str	r3, [sp, #16]
			/* Copy extra bytes (function descriptors). */
			if (iface->extra) {
 800bed6:	7ba3      	ldrb	r3, [r4, #14]
 800bed8:	7b60      	ldrb	r0, [r4, #13]
 800beda:	7be1      	ldrb	r1, [r4, #15]
 800bedc:	021b      	lsls	r3, r3, #8
 800bede:	4303      	orrs	r3, r0
 800bee0:	0409      	lsls	r1, r1, #16
 800bee2:	1c1a      	adds	r2, r3, #0
 800bee4:	1c0b      	adds	r3, r1, #0
 800bee6:	7c21      	ldrb	r1, [r4, #16]
 800bee8:	4313      	orrs	r3, r2
 800beea:	0609      	lsls	r1, r1, #24
 800beec:	4319      	orrs	r1, r3
 800beee:	d024      	beq.n	800bf3a <usb_standard_get_descriptor+0x1ba>
				memcpy(buf, iface->extra,
				       count = MIN(len, iface->extralen));
 800bef0:	7ca2      	ldrb	r2, [r4, #18]
 800bef2:	7c65      	ldrb	r5, [r4, #17]
 800bef4:	7ce3      	ldrb	r3, [r4, #19]
 800bef6:	0212      	lsls	r2, r2, #8
 800bef8:	432a      	orrs	r2, r5
 800befa:	041b      	lsls	r3, r3, #16
 800befc:	4313      	orrs	r3, r2
 800befe:	1c1a      	adds	r2, r3, #0
 800bf00:	7d23      	ldrb	r3, [r4, #20]
 800bf02:	1c35      	adds	r5, r6, #0
 800bf04:	061b      	lsls	r3, r3, #24
 800bf06:	4313      	orrs	r3, r2
 800bf08:	429e      	cmp	r6, r3
 800bf0a:	dd00      	ble.n	800bf0e <usb_standard_get_descriptor+0x18e>
 800bf0c:	1c1d      	adds	r5, r3, #0
 800bf0e:	b2af      	uxth	r7, r5
			len -= count;
			total += count;
			totallen += iface->bLength;
			/* Copy extra bytes (function descriptors). */
			if (iface->extra) {
				memcpy(buf, iface->extra,
 800bf10:	1c3a      	adds	r2, r7, #0
 800bf12:	9801      	ldr	r0, [sp, #4]
 800bf14:	f000 fcd0 	bl	800c8b8 <memcpy>
				       count = MIN(len, iface->extralen));
				buf += count;
 800bf18:	9b01      	ldr	r3, [sp, #4]
 800bf1a:	19db      	adds	r3, r3, r7
 800bf1c:	9301      	str	r3, [sp, #4]
				len -= count;
 800bf1e:	1bf3      	subs	r3, r6, r7
 800bf20:	b29e      	uxth	r6, r3
				total += count;
 800bf22:	9b02      	ldr	r3, [sp, #8]
 800bf24:	18ff      	adds	r7, r7, r3
 800bf26:	b2bb      	uxth	r3, r7
 800bf28:	9302      	str	r3, [sp, #8]
				totallen += iface->extralen;
 800bf2a:	7ca3      	ldrb	r3, [r4, #18]
 800bf2c:	7c62      	ldrb	r2, [r4, #17]
 800bf2e:	021b      	lsls	r3, r3, #8
 800bf30:	4313      	orrs	r3, r2
 800bf32:	9a04      	ldr	r2, [sp, #16]
 800bf34:	189b      	adds	r3, r3, r2
 800bf36:	b29b      	uxth	r3, r3
 800bf38:	9304      	str	r3, [sp, #16]
}

static int usb_standard_get_descriptor(usbd_device *usbd_dev,
				       struct usb_setup_data *req,
				       uint8_t **buf, uint16_t *len)
{
 800bf3a:	2300      	movs	r3, #0
				len -= count;
				total += count;
				totallen += iface->extralen;
			}
			/* For each endpoint... */
			for (k = 0; k < iface->bNumEndpoints; k++) {
 800bf3c:	9309      	str	r3, [sp, #36]	; 0x24
 800bf3e:	7923      	ldrb	r3, [r4, #4]
 800bf40:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800bf42:	4293      	cmp	r3, r2
 800bf44:	d961      	bls.n	800c00a <usb_standard_get_descriptor+0x28a>
				const struct usb_endpoint_descriptor *ep =
				    &iface->endpoint[k];
 800bf46:	7aa2      	ldrb	r2, [r4, #10]
 800bf48:	7a60      	ldrb	r0, [r4, #9]
 800bf4a:	7ae3      	ldrb	r3, [r4, #11]
 800bf4c:	0212      	lsls	r2, r2, #8
 800bf4e:	7b25      	ldrb	r5, [r4, #12]
 800bf50:	4302      	orrs	r2, r0
 800bf52:	041b      	lsls	r3, r3, #16
 800bf54:	4313      	orrs	r3, r2
 800bf56:	062d      	lsls	r5, r5, #24
 800bf58:	1c1a      	adds	r2, r3, #0
 800bf5a:	1c2b      	adds	r3, r5, #0
 800bf5c:	250f      	movs	r5, #15
 800bf5e:	4313      	orrs	r3, r2
 800bf60:	9a09      	ldr	r2, [sp, #36]	; 0x24
				memcpy(buf, ep, count = MIN(len, ep->bLength));
 800bf62:	1c37      	adds	r7, r6, #0
				totallen += iface->extralen;
			}
			/* For each endpoint... */
			for (k = 0; k < iface->bNumEndpoints; k++) {
				const struct usb_endpoint_descriptor *ep =
				    &iface->endpoint[k];
 800bf64:	4355      	muls	r5, r2
				total += count;
				totallen += iface->extralen;
			}
			/* For each endpoint... */
			for (k = 0; k < iface->bNumEndpoints; k++) {
				const struct usb_endpoint_descriptor *ep =
 800bf66:	195d      	adds	r5, r3, r5
				    &iface->endpoint[k];
				memcpy(buf, ep, count = MIN(len, ep->bLength));
 800bf68:	782b      	ldrb	r3, [r5, #0]
 800bf6a:	429e      	cmp	r6, r3
 800bf6c:	d900      	bls.n	800bf70 <usb_standard_get_descriptor+0x1f0>
 800bf6e:	1c1f      	adds	r7, r3, #0
 800bf70:	b2bf      	uxth	r7, r7
 800bf72:	1c3a      	adds	r2, r7, #0
 800bf74:	1c29      	adds	r1, r5, #0
 800bf76:	9801      	ldr	r0, [sp, #4]
 800bf78:	f000 fc9e 	bl	800c8b8 <memcpy>
				buf += count;
 800bf7c:	9b01      	ldr	r3, [sp, #4]
				len -= count;
				total += count;
				totallen += ep->bLength;
 800bf7e:	9a04      	ldr	r2, [sp, #16]
			/* For each endpoint... */
			for (k = 0; k < iface->bNumEndpoints; k++) {
				const struct usb_endpoint_descriptor *ep =
				    &iface->endpoint[k];
				memcpy(buf, ep, count = MIN(len, ep->bLength));
				buf += count;
 800bf80:	19db      	adds	r3, r3, r7
 800bf82:	9301      	str	r3, [sp, #4]
				len -= count;
 800bf84:	1bf3      	subs	r3, r6, r7
 800bf86:	b29e      	uxth	r6, r3
				total += count;
 800bf88:	9b02      	ldr	r3, [sp, #8]
 800bf8a:	18ff      	adds	r7, r7, r3
 800bf8c:	b2bb      	uxth	r3, r7
 800bf8e:	9302      	str	r3, [sp, #8]
				totallen += ep->bLength;
 800bf90:	782b      	ldrb	r3, [r5, #0]
 800bf92:	18d3      	adds	r3, r2, r3
 800bf94:	b29b      	uxth	r3, r3
 800bf96:	9304      	str	r3, [sp, #16]
				/* Copy extra bytes (class specific). */
				if (ep->extra) {
 800bf98:	7a2b      	ldrb	r3, [r5, #8]
 800bf9a:	79e8      	ldrb	r0, [r5, #7]
 800bf9c:	7a69      	ldrb	r1, [r5, #9]
 800bf9e:	021b      	lsls	r3, r3, #8
 800bfa0:	4303      	orrs	r3, r0
 800bfa2:	0409      	lsls	r1, r1, #16
 800bfa4:	1c1a      	adds	r2, r3, #0
 800bfa6:	1c0b      	adds	r3, r1, #0
 800bfa8:	7aa9      	ldrb	r1, [r5, #10]
 800bfaa:	4313      	orrs	r3, r2
 800bfac:	0609      	lsls	r1, r1, #24
 800bfae:	4319      	orrs	r1, r3
 800bfb0:	d027      	beq.n	800c002 <usb_standard_get_descriptor+0x282>
					memcpy(buf, ep->extra,
					       count = MIN(len, ep->extralen));
 800bfb2:	7b2a      	ldrb	r2, [r5, #12]
 800bfb4:	7aeb      	ldrb	r3, [r5, #11]
 800bfb6:	0212      	lsls	r2, r2, #8
 800bfb8:	431a      	orrs	r2, r3
 800bfba:	7b6b      	ldrb	r3, [r5, #13]
 800bfbc:	041b      	lsls	r3, r3, #16
 800bfbe:	4313      	orrs	r3, r2
 800bfc0:	1c1a      	adds	r2, r3, #0
 800bfc2:	7bab      	ldrb	r3, [r5, #14]
 800bfc4:	061b      	lsls	r3, r3, #24
 800bfc6:	4313      	orrs	r3, r2
 800bfc8:	1e32      	subs	r2, r6, #0
 800bfca:	429a      	cmp	r2, r3
 800bfcc:	dd00      	ble.n	800bfd0 <usb_standard_get_descriptor+0x250>
 800bfce:	1c1a      	adds	r2, r3, #0
 800bfd0:	b297      	uxth	r7, r2
				len -= count;
				total += count;
				totallen += ep->bLength;
				/* Copy extra bytes (class specific). */
				if (ep->extra) {
					memcpy(buf, ep->extra,
 800bfd2:	1c3a      	adds	r2, r7, #0
 800bfd4:	9801      	ldr	r0, [sp, #4]
 800bfd6:	970b      	str	r7, [sp, #44]	; 0x2c
 800bfd8:	f000 fc6e 	bl	800c8b8 <memcpy>
					       count = MIN(len, ep->extralen));
					buf += count;
 800bfdc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800bfde:	9b01      	ldr	r3, [sp, #4]
 800bfe0:	4694      	mov	ip, r2
 800bfe2:	4463      	add	r3, ip
 800bfe4:	9301      	str	r3, [sp, #4]
					len -= count;
 800bfe6:	1bf3      	subs	r3, r6, r7
 800bfe8:	b29e      	uxth	r6, r3
					total += count;
 800bfea:	9b02      	ldr	r3, [sp, #8]
 800bfec:	18ff      	adds	r7, r7, r3
 800bfee:	b2bb      	uxth	r3, r7
 800bff0:	9302      	str	r3, [sp, #8]
					totallen += ep->extralen;
 800bff2:	7b2b      	ldrb	r3, [r5, #12]
 800bff4:	7aea      	ldrb	r2, [r5, #11]
 800bff6:	021b      	lsls	r3, r3, #8
 800bff8:	4313      	orrs	r3, r2
 800bffa:	9a04      	ldr	r2, [sp, #16]
 800bffc:	189b      	adds	r3, r3, r2
 800bffe:	b29b      	uxth	r3, r3
 800c000:	9304      	str	r3, [sp, #16]
				len -= count;
				total += count;
				totallen += iface->extralen;
			}
			/* For each endpoint... */
			for (k = 0; k < iface->bNumEndpoints; k++) {
 800c002:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c004:	3301      	adds	r3, #1
 800c006:	b29b      	uxth	r3, r3
 800c008:	e798      	b.n	800bf3c <usb_standard_get_descriptor+0x1bc>
			len -= count;
			total += count;
			totallen += assoc->bLength;
		}
		/* For each alternate setting... */
		for (j = 0; j < cfg->interface[i].num_altsetting; j++) {
 800c00a:	9b08      	ldr	r3, [sp, #32]
 800c00c:	3301      	adds	r3, #1
 800c00e:	b29b      	uxth	r3, r3
 800c010:	e72e      	b.n	800be70 <usb_standard_get_descriptor+0xf0>
	len -= count;
	total += count;
	totallen += cfg->bLength;

	/* For each interface... */
	for (i = 0; i < cfg->bNumInterfaces; i++) {
 800c012:	9b07      	ldr	r3, [sp, #28]
 800c014:	3301      	adds	r3, #1
 800c016:	b29b      	uxth	r3, r3
 800c018:	e6f4      	b.n	800be04 <usb_standard_get_descriptor+0x84>
			}
		}
	}

	/* Fill in wTotalLength. */
	*(uint16_t *)(tmpbuf + 2) = totallen;
 800c01a:	466a      	mov	r2, sp
 800c01c:	9b06      	ldr	r3, [sp, #24]
 800c01e:	8a12      	ldrh	r2, [r2, #16]
 800c020:	805a      	strh	r2, [r3, #2]
		*buf = (uint8_t *) usbd_dev->desc;
		*len = MIN(*len, usbd_dev->desc->bLength);
		return USBD_REQ_HANDLED;
	case USB_DT_CONFIGURATION:
		*buf = usbd_dev->ctrl_buf;
		*len = build_config_descriptor(usbd_dev, descr_idx, *buf, *len);
 800c022:	466a      	mov	r2, sp
 800c024:	9b05      	ldr	r3, [sp, #20]
 800c026:	8912      	ldrh	r2, [r2, #8]
 800c028:	801a      	strh	r2, [r3, #0]
		return USBD_REQ_HANDLED;
 800c02a:	2001      	movs	r0, #1
 800c02c:	e044      	b.n	800c0b8 <usb_standard_get_descriptor+0x338>
	case USB_DT_STRING:
		sd = (struct usb_string_descriptor *)usbd_dev->ctrl_buf;
 800c02e:	6905      	ldr	r5, [r0, #16]

		if (descr_idx == 0) {
 800c030:	2c00      	cmp	r4, #0
 800c032:	d10d      	bne.n	800c050 <usb_standard_get_descriptor+0x2d0>
			/* Send sane Language ID descriptor... */
			sd->wData[0] = USB_LANGID_ENGLISH_US;
 800c034:	2309      	movs	r3, #9
			sd->bLength = sizeof(sd->bLength) +
				      sizeof(sd->bDescriptorType) +
				      sizeof(sd->wData[0]);

			*len = MIN(*len, sd->bLength);
 800c036:	9a05      	ldr	r2, [sp, #20]
	case USB_DT_STRING:
		sd = (struct usb_string_descriptor *)usbd_dev->ctrl_buf;

		if (descr_idx == 0) {
			/* Send sane Language ID descriptor... */
			sd->wData[0] = USB_LANGID_ENGLISH_US;
 800c038:	70ab      	strb	r3, [r5, #2]
 800c03a:	3b05      	subs	r3, #5
 800c03c:	70eb      	strb	r3, [r5, #3]
			sd->bLength = sizeof(sd->bLength) +
 800c03e:	702b      	strb	r3, [r5, #0]
				      sizeof(sd->bDescriptorType) +
				      sizeof(sd->wData[0]);

			*len = MIN(*len, sd->bLength);
 800c040:	8811      	ldrh	r1, [r2, #0]
 800c042:	1c0a      	adds	r2, r1, #0
 800c044:	4299      	cmp	r1, r3
 800c046:	d900      	bls.n	800c04a <usb_standard_get_descriptor+0x2ca>
 800c048:	1c1a      	adds	r2, r3, #0
 800c04a:	9b05      	ldr	r3, [sp, #20]
 800c04c:	801a      	strh	r2, [r3, #0]
 800c04e:	e02f      	b.n	800c0b0 <usb_standard_get_descriptor+0x330>
		} else {
			array_idx = descr_idx - 1;

			if (!usbd_dev->strings) {
 800c050:	6883      	ldr	r3, [r0, #8]
				      sizeof(sd->bDescriptorType) +
				      sizeof(sd->wData[0]);

			*len = MIN(*len, sd->bLength);
		} else {
			array_idx = descr_idx - 1;
 800c052:	3c01      	subs	r4, #1

			if (!usbd_dev->strings) {
				/* Device doesn't support strings. */
				return USBD_REQ_NOTSUPP;
 800c054:	1e18      	subs	r0, r3, #0

			*len = MIN(*len, sd->bLength);
		} else {
			array_idx = descr_idx - 1;

			if (!usbd_dev->strings) {
 800c056:	d02f      	beq.n	800c0b8 <usb_standard_get_descriptor+0x338>
				/* Device doesn't support strings. */
				return USBD_REQ_NOTSUPP;
			}

			/* Check that string index is in range. */
			if (array_idx >= usbd_dev->num_strings) {
 800c058:	68f2      	ldr	r2, [r6, #12]
		} else {
			array_idx = descr_idx - 1;

			if (!usbd_dev->strings) {
				/* Device doesn't support strings. */
				return USBD_REQ_NOTSUPP;
 800c05a:	2000      	movs	r0, #0
			}

			/* Check that string index is in range. */
			if (array_idx >= usbd_dev->num_strings) {
 800c05c:	4294      	cmp	r4, r2
 800c05e:	da2b      	bge.n	800c0b8 <usb_standard_get_descriptor+0x338>
				return USBD_REQ_NOTSUPP;
			}

			/* Strings with Language ID differnet from
			 * USB_LANGID_ENGLISH_US are not supported */
			if (req->wIndex != USB_LANGID_ENGLISH_US) {
 800c060:	790a      	ldrb	r2, [r1, #4]
 800c062:	7949      	ldrb	r1, [r1, #5]
 800c064:	0209      	lsls	r1, r1, #8
 800c066:	430a      	orrs	r2, r1
 800c068:	4914      	ldr	r1, [pc, #80]	; (800c0bc <usb_standard_get_descriptor+0x33c>)
 800c06a:	428a      	cmp	r2, r1
 800c06c:	d124      	bne.n	800c0b8 <usb_standard_get_descriptor+0x338>
			}

			/* This string is returned as UTF16, hence the
			 * multiplication
			 */
			sd->bLength = strlen(usbd_dev->strings[array_idx]) * 2 +
 800c06e:	00a4      	lsls	r4, r4, #2
 800c070:	5918      	ldr	r0, [r3, r4]
 800c072:	f000 fed9 	bl	800ce28 <strlen>
 800c076:	3001      	adds	r0, #1
 800c078:	0040      	lsls	r0, r0, #1
 800c07a:	b2c0      	uxtb	r0, r0
				      sizeof(sd->bLength) +
				      sizeof(sd->bDescriptorType);

			*len = MIN(*len, sd->bLength);
 800c07c:	9b05      	ldr	r3, [sp, #20]
			}

			/* This string is returned as UTF16, hence the
			 * multiplication
			 */
			sd->bLength = strlen(usbd_dev->strings[array_idx]) * 2 +
 800c07e:	7028      	strb	r0, [r5, #0]
				      sizeof(sd->bLength) +
				      sizeof(sd->bDescriptorType);

			*len = MIN(*len, sd->bLength);
 800c080:	881a      	ldrh	r2, [r3, #0]
 800c082:	1c03      	adds	r3, r0, #0
 800c084:	4290      	cmp	r0, r2
 800c086:	d900      	bls.n	800c08a <usb_standard_get_descriptor+0x30a>
 800c088:	1c13      	adds	r3, r2, #0
 800c08a:	9a05      	ldr	r2, [sp, #20]
 800c08c:	8013      	strh	r3, [r2, #0]

			for (i = 0; i < (*len / 2) - 1; i++) {
 800c08e:	2200      	movs	r2, #0
 800c090:	9b05      	ldr	r3, [sp, #20]
 800c092:	881b      	ldrh	r3, [r3, #0]
 800c094:	085b      	lsrs	r3, r3, #1
 800c096:	3b01      	subs	r3, #1
 800c098:	429a      	cmp	r2, r3
 800c09a:	da09      	bge.n	800c0b0 <usb_standard_get_descriptor+0x330>
				sd->wData[i] =
					usbd_dev->strings[array_idx][i];
 800c09c:	68b1      	ldr	r1, [r6, #8]
				      sizeof(sd->bDescriptorType);

			*len = MIN(*len, sd->bLength);

			for (i = 0; i < (*len / 2) - 1; i++) {
				sd->wData[i] =
 800c09e:	0053      	lsls	r3, r2, #1
					usbd_dev->strings[array_idx][i];
 800c0a0:	5909      	ldr	r1, [r1, r4]
				      sizeof(sd->bDescriptorType);

			*len = MIN(*len, sd->bLength);

			for (i = 0; i < (*len / 2) - 1; i++) {
				sd->wData[i] =
 800c0a2:	18eb      	adds	r3, r5, r3
 800c0a4:	5c89      	ldrb	r1, [r1, r2]
				      sizeof(sd->bLength) +
				      sizeof(sd->bDescriptorType);

			*len = MIN(*len, sd->bLength);

			for (i = 0; i < (*len / 2) - 1; i++) {
 800c0a6:	3201      	adds	r2, #1
				sd->wData[i] =
 800c0a8:	7099      	strb	r1, [r3, #2]
 800c0aa:	2100      	movs	r1, #0
 800c0ac:	70d9      	strb	r1, [r3, #3]
 800c0ae:	e7ef      	b.n	800c090 <usb_standard_get_descriptor+0x310>
					usbd_dev->strings[array_idx][i];
			}
		}

		sd->bDescriptorType = USB_DT_STRING;
 800c0b0:	2303      	movs	r3, #3
 800c0b2:	706b      	strb	r3, [r5, #1]
		*buf = (uint8_t *)sd;
 800c0b4:	603d      	str	r5, [r7, #0]
 800c0b6:	e7b8      	b.n	800c02a <usb_standard_get_descriptor+0x2aa>

		return USBD_REQ_HANDLED;
	}
	return USBD_REQ_NOTSUPP;
}
 800c0b8:	b00d      	add	sp, #52	; 0x34
 800c0ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c0bc:	00000409 	.word	0x00000409

0800c0c0 <usbd_register_set_config_callback>:
#include <libopencm3/usb/usbd.h>
#include "usb_private.h"

int usbd_register_set_config_callback(usbd_device *usbd_dev,
				       usbd_set_config_callback callback)
{
 800c0c0:	b510      	push	{r4, lr}
 800c0c2:	1c04      	adds	r4, r0, #0
	int i;

	for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
 800c0c4:	2300      	movs	r3, #0
 800c0c6:	34c8      	adds	r4, #200	; 0xc8
		if (usbd_dev->user_callback_set_config[i]) {
 800c0c8:	6822      	ldr	r2, [r4, #0]
 800c0ca:	2a00      	cmp	r2, #0
 800c0cc:	d006      	beq.n	800c0dc <usbd_register_set_config_callback+0x1c>
int usbd_register_set_config_callback(usbd_device *usbd_dev,
				       usbd_set_config_callback callback)
{
	int i;

	for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
 800c0ce:	3301      	adds	r3, #1
 800c0d0:	3404      	adds	r4, #4
 800c0d2:	2b04      	cmp	r3, #4
 800c0d4:	d1f8      	bne.n	800c0c8 <usbd_register_set_config_callback+0x8>

		usbd_dev->user_callback_set_config[i] = callback;
		return 0;
	}

	return -1;
 800c0d6:	2001      	movs	r0, #1
 800c0d8:	4240      	negs	r0, r0
 800c0da:	e003      	b.n	800c0e4 <usbd_register_set_config_callback+0x24>
	for (i = 0; i < MAX_USER_SET_CONFIG_CALLBACK; i++) {
		if (usbd_dev->user_callback_set_config[i]) {
			continue;
		}

		usbd_dev->user_callback_set_config[i] = callback;
 800c0dc:	3332      	adds	r3, #50	; 0x32
 800c0de:	009b      	lsls	r3, r3, #2
 800c0e0:	5019      	str	r1, [r3, r0]
		return 0;
 800c0e2:	1c10      	adds	r0, r2, #0
	}

	return -1;
}
 800c0e4:	bd10      	pop	{r4, pc}
	...

0800c0e8 <_usbd_standard_request_device>:
/**@}*/

int _usbd_standard_request_device(usbd_device *usbd_dev,
				  struct usb_setup_data *req, uint8_t **buf,
				  uint16_t *len)
{
 800c0e8:	b570      	push	{r4, r5, r6, lr}
	int (*command)(usbd_device *usbd_dev, struct usb_setup_data *req,
		       uint8_t **buf, uint16_t *len) = NULL;

	switch (req->bRequest) {
 800c0ea:	784c      	ldrb	r4, [r1, #1]
/**@}*/

int _usbd_standard_request_device(usbd_device *usbd_dev,
				  struct usb_setup_data *req, uint8_t **buf,
				  uint16_t *len)
{
 800c0ec:	1c05      	adds	r5, r0, #0
		/* SET_DESCRIPTOR is optional and not implemented. */
		break;
	}

	if (!command) {
		return 0;
 800c0ee:	2000      	movs	r0, #0
 800c0f0:	2c09      	cmp	r4, #9
 800c0f2:	d806      	bhi.n	800c102 <_usbd_standard_request_device+0x1a>
 800c0f4:	4e03      	ldr	r6, [pc, #12]	; (800c104 <_usbd_standard_request_device+0x1c>)
 800c0f6:	00a4      	lsls	r4, r4, #2
 800c0f8:	59a4      	ldr	r4, [r4, r6]
	case USB_REQ_SET_DESCRIPTOR:
		/* SET_DESCRIPTOR is optional and not implemented. */
		break;
	}

	if (!command) {
 800c0fa:	4284      	cmp	r4, r0
 800c0fc:	d001      	beq.n	800c102 <_usbd_standard_request_device+0x1a>
 800c0fe:	1c28      	adds	r0, r5, #0
		return 0;
	}

	return command(usbd_dev, req, buf, len);
 800c100:	47a0      	blx	r4
}
 800c102:	bd70      	pop	{r4, r5, r6, pc}
 800c104:	0801515c 	.word	0x0801515c

0800c108 <_usbd_standard_request_interface>:

int _usbd_standard_request_interface(usbd_device *usbd_dev,
				     struct usb_setup_data *req, uint8_t **buf,
				     uint16_t *len)
{
 800c108:	b570      	push	{r4, r5, r6, lr}
	int (*command)(usbd_device *usbd_dev, struct usb_setup_data *req,
		       uint8_t **buf, uint16_t *len) = NULL;

	switch (req->bRequest) {
 800c10a:	784c      	ldrb	r4, [r1, #1]
}

int _usbd_standard_request_interface(usbd_device *usbd_dev,
				     struct usb_setup_data *req, uint8_t **buf,
				     uint16_t *len)
{
 800c10c:	1c05      	adds	r5, r0, #0
		command = usb_standard_interface_get_status;
		break;
	}

	if (!command) {
		return 0;
 800c10e:	2000      	movs	r0, #0
 800c110:	2c0b      	cmp	r4, #11
 800c112:	d806      	bhi.n	800c122 <_usbd_standard_request_interface+0x1a>
 800c114:	4e03      	ldr	r6, [pc, #12]	; (800c124 <_usbd_standard_request_interface+0x1c>)
 800c116:	00a4      	lsls	r4, r4, #2
 800c118:	59a4      	ldr	r4, [r4, r6]
	case USB_REQ_GET_STATUS:
		command = usb_standard_interface_get_status;
		break;
	}

	if (!command) {
 800c11a:	4284      	cmp	r4, r0
 800c11c:	d001      	beq.n	800c122 <_usbd_standard_request_interface+0x1a>
 800c11e:	1c28      	adds	r0, r5, #0
		return 0;
	}

	return command(usbd_dev, req, buf, len);
 800c120:	47a0      	blx	r4
}
 800c122:	bd70      	pop	{r4, r5, r6, pc}
 800c124:	08015184 	.word	0x08015184

0800c128 <_usbd_standard_request_endpoint>:

int _usbd_standard_request_endpoint(usbd_device *usbd_dev,
				    struct usb_setup_data *req, uint8_t **buf,
				    uint16_t *len)
{
 800c128:	b538      	push	{r3, r4, r5, lr}
	int (*command) (usbd_device *usbd_dev, struct usb_setup_data *req,
			uint8_t **buf, uint16_t *len) = NULL;

	switch (req->bRequest) {
 800c12a:	784c      	ldrb	r4, [r1, #1]
 800c12c:	2c01      	cmp	r4, #1
 800c12e:	d004      	beq.n	800c13a <_usbd_standard_request_endpoint+0x12>
 800c130:	2c00      	cmp	r4, #0
 800c132:	d00f      	beq.n	800c154 <_usbd_standard_request_endpoint+0x2c>
 800c134:	2c03      	cmp	r4, #3
 800c136:	d006      	beq.n	800c146 <_usbd_standard_request_endpoint+0x1e>
 800c138:	e00a      	b.n	800c150 <_usbd_standard_request_endpoint+0x28>
	case USB_REQ_CLEAR_FEATURE:
		if (req->wValue == USB_FEAT_ENDPOINT_HALT) {
 800c13a:	78cc      	ldrb	r4, [r1, #3]
 800c13c:	788d      	ldrb	r5, [r1, #2]
 800c13e:	0224      	lsls	r4, r4, #8
 800c140:	432c      	orrs	r4, r5
 800c142:	d009      	beq.n	800c158 <_usbd_standard_request_endpoint+0x30>
 800c144:	e004      	b.n	800c150 <_usbd_standard_request_endpoint+0x28>
			command = usb_standard_endpoint_unstall;
		}
		break;
	case USB_REQ_SET_FEATURE:
		if (req->wValue == USB_FEAT_ENDPOINT_HALT) {
 800c146:	78cc      	ldrb	r4, [r1, #3]
 800c148:	788d      	ldrb	r5, [r1, #2]
 800c14a:	0224      	lsls	r4, r4, #8
 800c14c:	432c      	orrs	r4, r5
 800c14e:	d005      	beq.n	800c15c <_usbd_standard_request_endpoint+0x34>
		 */
		break;
	}

	if (!command) {
		return 0;
 800c150:	2000      	movs	r0, #0
 800c152:	e005      	b.n	800c160 <_usbd_standard_request_endpoint+0x38>
		if (req->wValue == USB_FEAT_ENDPOINT_HALT) {
			command = usb_standard_endpoint_stall;
		}
		break;
	case USB_REQ_GET_STATUS:
		command = usb_standard_endpoint_get_status;
 800c154:	4c03      	ldr	r4, [pc, #12]	; (800c164 <_usbd_standard_request_endpoint+0x3c>)
 800c156:	e002      	b.n	800c15e <_usbd_standard_request_endpoint+0x36>
			uint8_t **buf, uint16_t *len) = NULL;

	switch (req->bRequest) {
	case USB_REQ_CLEAR_FEATURE:
		if (req->wValue == USB_FEAT_ENDPOINT_HALT) {
			command = usb_standard_endpoint_unstall;
 800c158:	4c03      	ldr	r4, [pc, #12]	; (800c168 <_usbd_standard_request_endpoint+0x40>)
 800c15a:	e000      	b.n	800c15e <_usbd_standard_request_endpoint+0x36>
		}
		break;
	case USB_REQ_SET_FEATURE:
		if (req->wValue == USB_FEAT_ENDPOINT_HALT) {
			command = usb_standard_endpoint_stall;
 800c15c:	4c03      	ldr	r4, [pc, #12]	; (800c16c <_usbd_standard_request_endpoint+0x44>)

	if (!command) {
		return 0;
	}

	return command(usbd_dev, req, buf, len);
 800c15e:	47a0      	blx	r4
}
 800c160:	bd38      	pop	{r3, r4, r5, pc}
 800c162:	46c0      	nop			; (mov r8, r8)
 800c164:	0800bc8d 	.word	0x0800bc8d
 800c168:	0800bcc1 	.word	0x0800bcc1
 800c16c:	0800bcb3 	.word	0x0800bcb3

0800c170 <_usbd_standard_request>:

int _usbd_standard_request(usbd_device *usbd_dev, struct usb_setup_data *req,
			   uint8_t **buf, uint16_t *len)
{
 800c170:	b570      	push	{r4, r5, r6, lr}
	/* FIXME: Have class/vendor requests as well. */
	if ((req->bmRequestType & USB_REQ_TYPE_TYPE) != USB_REQ_TYPE_STANDARD) {
 800c172:	2560      	movs	r5, #96	; 0x60
 800c174:	780e      	ldrb	r6, [r1, #0]
	return command(usbd_dev, req, buf, len);
}

int _usbd_standard_request(usbd_device *usbd_dev, struct usb_setup_data *req,
			   uint8_t **buf, uint16_t *len)
{
 800c176:	1c04      	adds	r4, r0, #0
	/* FIXME: Have class/vendor requests as well. */
	if ((req->bmRequestType & USB_REQ_TYPE_TYPE) != USB_REQ_TYPE_STANDARD) {
		return 0;
 800c178:	2000      	movs	r0, #0

int _usbd_standard_request(usbd_device *usbd_dev, struct usb_setup_data *req,
			   uint8_t **buf, uint16_t *len)
{
	/* FIXME: Have class/vendor requests as well. */
	if ((req->bmRequestType & USB_REQ_TYPE_TYPE) != USB_REQ_TYPE_STANDARD) {
 800c17a:	422e      	tst	r6, r5
 800c17c:	d112      	bne.n	800c1a4 <_usbd_standard_request+0x34>
		return 0;
	}

	switch (req->bmRequestType & USB_REQ_TYPE_RECIPIENT) {
 800c17e:	3d41      	subs	r5, #65	; 0x41
 800c180:	4035      	ands	r5, r6
 800c182:	2d01      	cmp	r5, #1
 800c184:	d00b      	beq.n	800c19e <_usbd_standard_request+0x2e>
 800c186:	4285      	cmp	r5, r0
 800c188:	d005      	beq.n	800c196 <_usbd_standard_request+0x26>
 800c18a:	2d02      	cmp	r5, #2
 800c18c:	d10a      	bne.n	800c1a4 <_usbd_standard_request+0x34>
		return _usbd_standard_request_device(usbd_dev, req, buf, len);
	case USB_REQ_TYPE_INTERFACE:
		return _usbd_standard_request_interface(usbd_dev, req,
							buf, len);
	case USB_REQ_TYPE_ENDPOINT:
		return _usbd_standard_request_endpoint(usbd_dev, req, buf, len);
 800c18e:	1c20      	adds	r0, r4, #0
 800c190:	f7ff ffca 	bl	800c128 <_usbd_standard_request_endpoint>
 800c194:	e006      	b.n	800c1a4 <_usbd_standard_request+0x34>
		return 0;
	}

	switch (req->bmRequestType & USB_REQ_TYPE_RECIPIENT) {
	case USB_REQ_TYPE_DEVICE:
		return _usbd_standard_request_device(usbd_dev, req, buf, len);
 800c196:	1c20      	adds	r0, r4, #0
 800c198:	f7ff ffa6 	bl	800c0e8 <_usbd_standard_request_device>
 800c19c:	e002      	b.n	800c1a4 <_usbd_standard_request+0x34>
	case USB_REQ_TYPE_INTERFACE:
		return _usbd_standard_request_interface(usbd_dev, req,
 800c19e:	1c20      	adds	r0, r4, #0
 800c1a0:	f7ff ffb2 	bl	800c108 <_usbd_standard_request_interface>
	case USB_REQ_TYPE_ENDPOINT:
		return _usbd_standard_request_endpoint(usbd_dev, req, buf, len);
	default:
		return 0;
	}
}
 800c1a4:	bd70      	pop	{r4, r5, r6, pc}
	...

0800c1a8 <st_usbfs_v2_usbd_init>:
	.poll = st_usbfs_poll,
};

/** Initialize the USB device controller hardware of the STM32. */
static usbd_device *st_usbfs_v2_usbd_init(void)
{
 800c1a8:	b508      	push	{r3, lr}
	rcc_periph_clock_enable(RCC_USB);
 800c1aa:	4809      	ldr	r0, [pc, #36]	; (800c1d0 <st_usbfs_v2_usbd_init+0x28>)
 800c1ac:	f7ff fada 	bl	800b764 <rcc_periph_clock_enable>
	SET_REG(USB_CNTR_REG, 0);
 800c1b0:	2300      	movs	r3, #0
 800c1b2:	4a08      	ldr	r2, [pc, #32]	; (800c1d4 <st_usbfs_v2_usbd_init+0x2c>)
	SET_REG(USB_BTABLE_REG, 0);
 800c1b4:	4908      	ldr	r1, [pc, #32]	; (800c1d8 <st_usbfs_v2_usbd_init+0x30>)

/** Initialize the USB device controller hardware of the STM32. */
static usbd_device *st_usbfs_v2_usbd_init(void)
{
	rcc_periph_clock_enable(RCC_USB);
	SET_REG(USB_CNTR_REG, 0);
 800c1b6:	6013      	str	r3, [r2, #0]
	SET_REG(USB_BTABLE_REG, 0);
 800c1b8:	600b      	str	r3, [r1, #0]
	SET_REG(USB_ISTR_REG, 0);
 800c1ba:	4908      	ldr	r1, [pc, #32]	; (800c1dc <st_usbfs_v2_usbd_init+0x34>)
	/* Enable RESET, SUSPEND, RESUME and CTR interrupts. */
	SET_REG(USB_CNTR_REG, USB_CNTR_RESETM | USB_CNTR_CTRM |
		USB_CNTR_SUSPM | USB_CNTR_WKUPM);
	SET_REG(USB_BCDR_REG, USB_BCDR_DPPU);
	return &st_usbfs_dev;
}
 800c1bc:	4808      	ldr	r0, [pc, #32]	; (800c1e0 <st_usbfs_v2_usbd_init+0x38>)
static usbd_device *st_usbfs_v2_usbd_init(void)
{
	rcc_periph_clock_enable(RCC_USB);
	SET_REG(USB_CNTR_REG, 0);
	SET_REG(USB_BTABLE_REG, 0);
	SET_REG(USB_ISTR_REG, 0);
 800c1be:	600b      	str	r3, [r1, #0]

	/* Enable RESET, SUSPEND, RESUME and CTR interrupts. */
	SET_REG(USB_CNTR_REG, USB_CNTR_RESETM | USB_CNTR_CTRM |
 800c1c0:	239c      	movs	r3, #156	; 0x9c
 800c1c2:	021b      	lsls	r3, r3, #8
 800c1c4:	6013      	str	r3, [r2, #0]
		USB_CNTR_SUSPM | USB_CNTR_WKUPM);
	SET_REG(USB_BCDR_REG, USB_BCDR_DPPU);
 800c1c6:	2280      	movs	r2, #128	; 0x80
 800c1c8:	4b06      	ldr	r3, [pc, #24]	; (800c1e4 <st_usbfs_v2_usbd_init+0x3c>)
 800c1ca:	0212      	lsls	r2, r2, #8
 800c1cc:	601a      	str	r2, [r3, #0]
	return &st_usbfs_dev;
}
 800c1ce:	bd08      	pop	{r3, pc}
 800c1d0:	00000397 	.word	0x00000397
 800c1d4:	40005c40 	.word	0x40005c40
 800c1d8:	40005c50 	.word	0x40005c50
 800c1dc:	40005c44 	.word	0x40005c44
 800c1e0:	20001c8c 	.word	0x20001c8c
 800c1e4:	40005c58 	.word	0x40005c58

0800c1e8 <st_usbfs_copy_to_pm>:
	 * that don't support unaligned accesses.
	 */
	const uint8_t *lbuf = buf;
	volatile uint16_t *PM = vPM;
	uint32_t i;
	for (i = 0; i < len; i += 2) {
 800c1e8:	2300      	movs	r3, #0
	SET_REG(USB_BCDR_REG, USB_BCDR_DPPU);
	return &st_usbfs_dev;
}

void st_usbfs_copy_to_pm(volatile void *vPM, const void *buf, uint16_t len)
{
 800c1ea:	b570      	push	{r4, r5, r6, lr}
 800c1ec:	18c5      	adds	r5, r0, r3
	 * that don't support unaligned accesses.
	 */
	const uint8_t *lbuf = buf;
	volatile uint16_t *PM = vPM;
	uint32_t i;
	for (i = 0; i < len; i += 2) {
 800c1ee:	4293      	cmp	r3, r2
 800c1f0:	d207      	bcs.n	800c202 <st_usbfs_copy_to_pm+0x1a>
 800c1f2:	18cc      	adds	r4, r1, r3
		*PM++ = (uint16_t)lbuf[i+1] << 8 | lbuf[i];
 800c1f4:	7864      	ldrb	r4, [r4, #1]
 800c1f6:	5cce      	ldrb	r6, [r1, r3]
 800c1f8:	0224      	lsls	r4, r4, #8
 800c1fa:	4334      	orrs	r4, r6
 800c1fc:	802c      	strh	r4, [r5, #0]
	 * that don't support unaligned accesses.
	 */
	const uint8_t *lbuf = buf;
	volatile uint16_t *PM = vPM;
	uint32_t i;
	for (i = 0; i < len; i += 2) {
 800c1fe:	3302      	adds	r3, #2
 800c200:	e7f4      	b.n	800c1ec <st_usbfs_copy_to_pm+0x4>
		*PM++ = (uint16_t)lbuf[i+1] << 8 | lbuf[i];
	}
}
 800c202:	bd70      	pop	{r4, r5, r6, pc}

0800c204 <st_usbfs_copy_from_pm>:
 * @param len Number of bytes to copy.
 */
void st_usbfs_copy_from_pm(void *buf, const volatile void *vPM, uint16_t len)
{
	const volatile uint16_t *PM = vPM;
	uint8_t odd = len & 1;
 800c204:	2301      	movs	r3, #1
 * @param buf Destination pointer for data buffer.
 * @param vPM Source pointer into packet memory.
 * @param len Number of bytes to copy.
 */
void st_usbfs_copy_from_pm(void *buf, const volatile void *vPM, uint16_t len)
{
 800c206:	b5f0      	push	{r4, r5, r6, r7, lr}
	const volatile uint16_t *PM = vPM;
	uint8_t odd = len & 1;
 800c208:	1c14      	adds	r4, r2, #0
	len >>= 1;
 800c20a:	40da      	lsrs	r2, r3
 * @param len Number of bytes to copy.
 */
void st_usbfs_copy_from_pm(void *buf, const volatile void *vPM, uint16_t len)
{
	const volatile uint16_t *PM = vPM;
	uint8_t odd = len & 1;
 800c20c:	401c      	ands	r4, r3
	len >>= 1;

	if (((uintptr_t) buf) & 0x01) {
 800c20e:	4218      	tst	r0, r3
 800c210:	d103      	bne.n	800c21a <st_usbfs_copy_from_pm+0x16>
 800c212:	1c0e      	adds	r6, r1, #0
 800c214:	1c13      	adds	r3, r2, #0
 800c216:	1c05      	adds	r5, r0, #0
 800c218:	e00e      	b.n	800c238 <st_usbfs_copy_from_pm+0x34>
 800c21a:	1c06      	adds	r6, r0, #0
 800c21c:	1c0f      	adds	r7, r1, #0
 800c21e:	1c15      	adds	r5, r2, #0
		for (; len; PM++, len--) {
 800c220:	2d00      	cmp	r5, #0
 800c222:	d012      	beq.n	800c24a <st_usbfs_copy_from_pm+0x46>
			uint16_t value = *PM;
 800c224:	883b      	ldrh	r3, [r7, #0]
	const volatile uint16_t *PM = vPM;
	uint8_t odd = len & 1;
	len >>= 1;

	if (((uintptr_t) buf) & 0x01) {
		for (; len; PM++, len--) {
 800c226:	3d01      	subs	r5, #1
			uint16_t value = *PM;
 800c228:	b29b      	uxth	r3, r3
			*(uint8_t *) buf++ = value;
 800c22a:	7033      	strb	r3, [r6, #0]
			*(uint8_t *) buf++ = value >> 8;
 800c22c:	0a1b      	lsrs	r3, r3, #8
 800c22e:	7073      	strb	r3, [r6, #1]
	const volatile uint16_t *PM = vPM;
	uint8_t odd = len & 1;
	len >>= 1;

	if (((uintptr_t) buf) & 0x01) {
		for (; len; PM++, len--) {
 800c230:	3702      	adds	r7, #2
 800c232:	b2ad      	uxth	r5, r5
 800c234:	3602      	adds	r6, #2
 800c236:	e7f3      	b.n	800c220 <st_usbfs_copy_from_pm+0x1c>
			uint16_t value = *PM;
			*(uint8_t *) buf++ = value;
			*(uint8_t *) buf++ = value >> 8;
		}
	} else {
		for (; len; PM++, buf += 2, len--) {
 800c238:	2b00      	cmp	r3, #0
 800c23a:	d006      	beq.n	800c24a <st_usbfs_copy_from_pm+0x46>
			*(uint16_t *) buf = *PM;
 800c23c:	8837      	ldrh	r7, [r6, #0]
			uint16_t value = *PM;
			*(uint8_t *) buf++ = value;
			*(uint8_t *) buf++ = value >> 8;
		}
	} else {
		for (; len; PM++, buf += 2, len--) {
 800c23e:	3b01      	subs	r3, #1
			*(uint16_t *) buf = *PM;
 800c240:	802f      	strh	r7, [r5, #0]
			uint16_t value = *PM;
			*(uint8_t *) buf++ = value;
			*(uint8_t *) buf++ = value >> 8;
		}
	} else {
		for (; len; PM++, buf += 2, len--) {
 800c242:	3602      	adds	r6, #2
 800c244:	3502      	adds	r5, #2
 800c246:	b29b      	uxth	r3, r3
 800c248:	e7f6      	b.n	800c238 <st_usbfs_copy_from_pm+0x34>
 800c24a:	0052      	lsls	r2, r2, #1
 800c24c:	1880      	adds	r0, r0, r2
 800c24e:	188a      	adds	r2, r1, r2
			*(uint16_t *) buf = *PM;
		}
	}

	if (odd) {
 800c250:	2c00      	cmp	r4, #0
 800c252:	d001      	beq.n	800c258 <st_usbfs_copy_from_pm+0x54>
		*(uint8_t *) buf = *(uint8_t *) PM;
 800c254:	7813      	ldrb	r3, [r2, #0]
 800c256:	7003      	strb	r3, [r0, #0]
	}
}
 800c258:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800c25a <blocking_handler>:

}

void blocking_handler(void)
{
	while (1);
 800c25a:	e7fe      	b.n	800c25a <blocking_handler>

0800c25c <null_handler>:
}

void null_handler(void)
{
	/* Do nothing. */
}
 800c25c:	4770      	bx	lr
	...

0800c260 <reset_handler>:
void __attribute__ ((weak, naked)) reset_handler(void)
{
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
 800c260:	2200      	movs	r2, #0
 800c262:	4b17      	ldr	r3, [pc, #92]	; (800c2c0 <reset_handler+0x60>)
 800c264:	4917      	ldr	r1, [pc, #92]	; (800c2c4 <reset_handler+0x64>)
 800c266:	4818      	ldr	r0, [pc, #96]	; (800c2c8 <reset_handler+0x68>)
 800c268:	18d3      	adds	r3, r2, r3
 800c26a:	1851      	adds	r1, r2, r1
 800c26c:	4283      	cmp	r3, r0
 800c26e:	d203      	bcs.n	800c278 <reset_handler+0x18>
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
 800c270:	6809      	ldr	r1, [r1, #0]
 800c272:	3204      	adds	r2, #4
 800c274:	6019      	str	r1, [r3, #0]
 800c276:	e7f4      	b.n	800c262 <reset_handler+0x2>
	}

	while (dest < &_ebss) {
 800c278:	4a14      	ldr	r2, [pc, #80]	; (800c2cc <reset_handler+0x6c>)
 800c27a:	4293      	cmp	r3, r2
 800c27c:	d203      	bcs.n	800c286 <reset_handler+0x26>
		*dest++ = 0;
 800c27e:	2200      	movs	r2, #0
 800c280:	601a      	str	r2, [r3, #0]
 800c282:	3304      	adds	r3, #4
 800c284:	e7f8      	b.n	800c278 <reset_handler+0x18>
	}

	/* Ensure 8-byte alignment of stack pointer on interrupts */
	/* Enabled by default on most Cortex-M parts, but not M3 r1 */
	SCB_CCR |= SCB_CCR_STKALIGN;
 800c286:	2180      	movs	r1, #128	; 0x80
 800c288:	4a11      	ldr	r2, [pc, #68]	; (800c2d0 <reset_handler+0x70>)
 800c28a:	0089      	lsls	r1, r1, #2
 800c28c:	6813      	ldr	r3, [r2, #0]

	/* might be provided by platform specific vector.c */
	pre_main();

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
 800c28e:	4c11      	ldr	r4, [pc, #68]	; (800c2d4 <reset_handler+0x74>)
		*dest++ = 0;
	}

	/* Ensure 8-byte alignment of stack pointer on interrupts */
	/* Enabled by default on most Cortex-M parts, but not M3 r1 */
	SCB_CCR |= SCB_CCR_STKALIGN;
 800c290:	430b      	orrs	r3, r1
 800c292:	6013      	str	r3, [r2, #0]

	/* might be provided by platform specific vector.c */
	pre_main();

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
 800c294:	4b10      	ldr	r3, [pc, #64]	; (800c2d8 <reset_handler+0x78>)
 800c296:	429c      	cmp	r4, r3
 800c298:	d202      	bcs.n	800c2a0 <reset_handler+0x40>
		(*fp)();
 800c29a:	cc08      	ldmia	r4!, {r3}
 800c29c:	4798      	blx	r3
 800c29e:	e7f9      	b.n	800c294 <reset_handler+0x34>
 800c2a0:	4c0e      	ldr	r4, [pc, #56]	; (800c2dc <reset_handler+0x7c>)
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
 800c2a2:	4b0f      	ldr	r3, [pc, #60]	; (800c2e0 <reset_handler+0x80>)
 800c2a4:	429c      	cmp	r4, r3
 800c2a6:	d202      	bcs.n	800c2ae <reset_handler+0x4e>
		(*fp)();
 800c2a8:	cc08      	ldmia	r4!, {r3}
 800c2aa:	4798      	blx	r3
 800c2ac:	e7f9      	b.n	800c2a2 <reset_handler+0x42>
	}

	/* Call the application's entry point. */
	main();
 800c2ae:	f7f8 fc6f 	bl	8004b90 <main>

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
 800c2b2:	4c0c      	ldr	r4, [pc, #48]	; (800c2e4 <reset_handler+0x84>)
 800c2b4:	4b0c      	ldr	r3, [pc, #48]	; (800c2e8 <reset_handler+0x88>)
 800c2b6:	429c      	cmp	r4, r3
 800c2b8:	d202      	bcs.n	800c2c0 <reset_handler+0x60>
		(*fp)();
 800c2ba:	cc08      	ldmia	r4!, {r3}
 800c2bc:	4798      	blx	r3
 800c2be:	e7f9      	b.n	800c2b4 <reset_handler+0x54>
 800c2c0:	20000000 	.word	0x20000000
 800c2c4:	080153cc 	.word	0x080153cc
 800c2c8:	20000138 	.word	0x20000138
 800c2cc:	20002194 	.word	0x20002194
 800c2d0:	e000ed14 	.word	0xe000ed14
 800c2d4:	080153b0 	.word	0x080153b0
 800c2d8:	080153b0 	.word	0x080153b0
 800c2dc:	080153b0 	.word	0x080153b0
 800c2e0:	080153c4 	.word	0x080153c4
 800c2e4:	080153c4 	.word	0x080153c4
 800c2e8:	080153c4 	.word	0x080153c4

0800c2ec <systick_set_reload>:
 * @param[in] value uint32_t. 24 bit reload value.
 */

void systick_set_reload(uint32_t value)
{
	STK_RVR = (value & STK_RVR_RELOAD);
 800c2ec:	4b02      	ldr	r3, [pc, #8]	; (800c2f8 <systick_set_reload+0xc>)
 800c2ee:	0200      	lsls	r0, r0, #8
 800c2f0:	0a00      	lsrs	r0, r0, #8
 800c2f2:	6018      	str	r0, [r3, #0]
}
 800c2f4:	4770      	bx	lr
 800c2f6:	46c0      	nop			; (mov r8, r8)
 800c2f8:	e000e014 	.word	0xe000e014

0800c2fc <systick_set_clocksource>:
 * @param[in] clocksource uint8_t. Clock source from @ref systick_clksource.
 */

void systick_set_clocksource(uint8_t clocksource)
{
	STK_CSR = (STK_CSR & ~STK_CSR_CLKSOURCE) |
 800c2fc:	2104      	movs	r1, #4
 800c2fe:	4a03      	ldr	r2, [pc, #12]	; (800c30c <systick_set_clocksource+0x10>)
 800c300:	4008      	ands	r0, r1
 800c302:	6813      	ldr	r3, [r2, #0]
 800c304:	438b      	bics	r3, r1
 800c306:	4318      	orrs	r0, r3
 800c308:	6010      	str	r0, [r2, #0]
		  (clocksource & STK_CSR_CLKSOURCE);
}
 800c30a:	4770      	bx	lr
 800c30c:	e000e010 	.word	0xe000e010

0800c310 <systick_interrupt_enable>:
 *
 */

void systick_interrupt_enable(void)
{
	STK_CSR |= STK_CSR_TICKINT;
 800c310:	2102      	movs	r1, #2
 800c312:	4a02      	ldr	r2, [pc, #8]	; (800c31c <systick_interrupt_enable+0xc>)
 800c314:	6813      	ldr	r3, [r2, #0]
 800c316:	430b      	orrs	r3, r1
 800c318:	6013      	str	r3, [r2, #0]
}
 800c31a:	4770      	bx	lr
 800c31c:	e000e010 	.word	0xe000e010

0800c320 <systick_counter_enable>:
 *
 */

void systick_counter_enable(void)
{
	STK_CSR |= STK_CSR_ENABLE;
 800c320:	2101      	movs	r1, #1
 800c322:	4a02      	ldr	r2, [pc, #8]	; (800c32c <systick_counter_enable+0xc>)
 800c324:	6813      	ldr	r3, [r2, #0]
 800c326:	430b      	orrs	r3, r1
 800c328:	6013      	str	r3, [r2, #0]
}
 800c32a:	4770      	bx	lr
 800c32c:	e000e010 	.word	0xe000e010

0800c330 <nvic_enable_irq>:
 * @param[in] irqn Unsigned int8. Interrupt number @ref nvic_stm32f1_userint
 */

void nvic_enable_irq(uint8_t irqn)
{
	NVIC_ISER(irqn / 32) = (1 << (irqn % 32));
 800c330:	0943      	lsrs	r3, r0, #5
 800c332:	4a04      	ldr	r2, [pc, #16]	; (800c344 <nvic_enable_irq+0x14>)
 800c334:	009b      	lsls	r3, r3, #2
 800c336:	189b      	adds	r3, r3, r2
 800c338:	221f      	movs	r2, #31
 800c33a:	4010      	ands	r0, r2
 800c33c:	3a1e      	subs	r2, #30
 800c33e:	4082      	lsls	r2, r0
 800c340:	601a      	str	r2, [r3, #0]
}
 800c342:	4770      	bx	lr
 800c344:	e000e100 	.word	0xe000e100

0800c348 <nvic_set_priority>:
void nvic_set_priority(uint8_t irqn, uint8_t priority)
{
	/* code from lpc43xx/nvic.c -- this is quite a hack and alludes to the
	 * negative interrupt numbers assigned to the system interrupts. better
	 * handling would mean signed integers. */
	if (irqn >= NVIC_IRQ_COUNT) {
 800c348:	281f      	cmp	r0, #31
 800c34a:	d903      	bls.n	800c354 <nvic_set_priority+0xc>
		/* Cortex-M  system interrupts */
		SCS_SHPR((irqn & 0xF) - 4) = priority;
 800c34c:	230f      	movs	r3, #15
 800c34e:	4018      	ands	r0, r3
 800c350:	4b02      	ldr	r3, [pc, #8]	; (800c35c <nvic_set_priority+0x14>)
 800c352:	e000      	b.n	800c356 <nvic_set_priority+0xe>
	} else {
		/* Device specific interrupts */
		NVIC_IPR(irqn) = priority;
 800c354:	4b02      	ldr	r3, [pc, #8]	; (800c360 <nvic_set_priority+0x18>)
 800c356:	18c0      	adds	r0, r0, r3
 800c358:	7001      	strb	r1, [r0, #0]
	}
}
 800c35a:	4770      	bx	lr
 800c35c:	e000ed14 	.word	0xe000ed14
 800c360:	e000e400 	.word	0xe000e400

0800c364 <st_usbfs_set_address>:

void st_usbfs_set_address(usbd_device *dev, uint8_t addr)
{
	(void)dev;
	/* Set device address and enable. */
	SET_REG(USB_DADDR_REG, (addr & USB_DADDR_ADDR) | USB_DADDR_EF);
 800c364:	2380      	movs	r3, #128	; 0x80
 800c366:	4319      	orrs	r1, r3
 800c368:	4b01      	ldr	r3, [pc, #4]	; (800c370 <st_usbfs_set_address+0xc>)
 800c36a:	6019      	str	r1, [r3, #0]
}
 800c36c:	4770      	bx	lr
 800c36e:	46c0      	nop			; (mov r8, r8)
 800c370:	40005c4c 	.word	0x40005c4c

0800c374 <st_usbfs_set_ep_rx_bufsize>:
 *
 * @param ep Index of endpoint to configure.
 * @param size Size in bytes of the RX buffer.
 */
void st_usbfs_set_ep_rx_bufsize(usbd_device *dev, uint8_t ep, uint32_t size)
{
 800c374:	480d      	ldr	r0, [pc, #52]	; (800c3ac <st_usbfs_set_ep_rx_bufsize+0x38>)
 800c376:	00c9      	lsls	r1, r1, #3
	(void)dev;
	if (size > 62) {
 800c378:	2a3e      	cmp	r2, #62	; 0x3e
 800c37a:	d90b      	bls.n	800c394 <st_usbfs_set_ep_rx_bufsize+0x20>
		if (size & 0x1f) {
 800c37c:	06d3      	lsls	r3, r2, #27
 800c37e:	d000      	beq.n	800c382 <st_usbfs_set_ep_rx_bufsize+0xe>
			size -= 32;
 800c380:	3a20      	subs	r2, #32
		}
		USB_SET_EP_RX_COUNT(ep, (size << 5) | 0x8000);
 800c382:	6803      	ldr	r3, [r0, #0]
 800c384:	0152      	lsls	r2, r2, #5
 800c386:	b29b      	uxth	r3, r3
 800c388:	18c9      	adds	r1, r1, r3
 800c38a:	4b09      	ldr	r3, [pc, #36]	; (800c3b0 <st_usbfs_set_ep_rx_bufsize+0x3c>)
 800c38c:	18c9      	adds	r1, r1, r3
 800c38e:	4b09      	ldr	r3, [pc, #36]	; (800c3b4 <st_usbfs_set_ep_rx_bufsize+0x40>)
 800c390:	431a      	orrs	r2, r3
 800c392:	e008      	b.n	800c3a6 <st_usbfs_set_ep_rx_bufsize+0x32>
	} else {
		if (size & 1) {
			size++;
 800c394:	2301      	movs	r3, #1
 800c396:	4013      	ands	r3, r2
 800c398:	18d2      	adds	r2, r2, r3
		}
		USB_SET_EP_RX_COUNT(ep, size << 10);
 800c39a:	6803      	ldr	r3, [r0, #0]
 800c39c:	0292      	lsls	r2, r2, #10
 800c39e:	b29b      	uxth	r3, r3
 800c3a0:	18c9      	adds	r1, r1, r3
 800c3a2:	4b03      	ldr	r3, [pc, #12]	; (800c3b0 <st_usbfs_set_ep_rx_bufsize+0x3c>)
 800c3a4:	18c9      	adds	r1, r1, r3
 800c3a6:	800a      	strh	r2, [r1, #0]
	}
}
 800c3a8:	4770      	bx	lr
 800c3aa:	46c0      	nop			; (mov r8, r8)
 800c3ac:	40005c50 	.word	0x40005c50
 800c3b0:	40006006 	.word	0x40006006
 800c3b4:	ffff8000 	.word	0xffff8000

0800c3b8 <st_usbfs_ep_setup>:

void st_usbfs_ep_setup(usbd_device *dev, uint8_t addr, uint8_t type,
		uint16_t max_size,
		void (*callback) (usbd_device *usbd_dev,
		uint8_t ep))
{
 800c3b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c3ba:	1c0c      	adds	r4, r1, #0
 800c3bc:	b085      	sub	sp, #20
 800c3be:	1c17      	adds	r7, r2, #0
	/* Translate USB standard type codes to STM32. */
	const uint16_t typelookup[] = {
 800c3c0:	4938      	ldr	r1, [pc, #224]	; (800c4a4 <st_usbfs_ep_setup+0xec>)
 800c3c2:	2208      	movs	r2, #8

void st_usbfs_ep_setup(usbd_device *dev, uint8_t addr, uint8_t type,
		uint16_t max_size,
		void (*callback) (usbd_device *usbd_dev,
		uint8_t ep))
{
 800c3c4:	1c05      	adds	r5, r0, #0
	/* Translate USB standard type codes to STM32. */
	const uint16_t typelookup[] = {
 800c3c6:	a802      	add	r0, sp, #8

void st_usbfs_ep_setup(usbd_device *dev, uint8_t addr, uint8_t type,
		uint16_t max_size,
		void (*callback) (usbd_device *usbd_dev,
		uint8_t ep))
{
 800c3c8:	9301      	str	r3, [sp, #4]
	/* Translate USB standard type codes to STM32. */
	const uint16_t typelookup[] = {
 800c3ca:	f000 fa75 	bl	800c8b8 <memcpy>
		[USB_ENDPOINT_ATTR_CONTROL] = USB_EP_TYPE_CONTROL,
		[USB_ENDPOINT_ATTR_ISOCHRONOUS] = USB_EP_TYPE_ISO,
		[USB_ENDPOINT_ATTR_BULK] = USB_EP_TYPE_BULK,
		[USB_ENDPOINT_ATTR_INTERRUPT] = USB_EP_TYPE_INTERRUPT,
	};
	uint8_t dir = addr & 0x80;
 800c3ce:	237f      	movs	r3, #127	; 0x7f
 800c3d0:	1c21      	adds	r1, r4, #0
	addr &= 0x7f;
 800c3d2:	401c      	ands	r4, r3
 800c3d4:	1c26      	adds	r6, r4, #0
		[USB_ENDPOINT_ATTR_CONTROL] = USB_EP_TYPE_CONTROL,
		[USB_ENDPOINT_ATTR_ISOCHRONOUS] = USB_EP_TYPE_ISO,
		[USB_ENDPOINT_ATTR_BULK] = USB_EP_TYPE_BULK,
		[USB_ENDPOINT_ATTR_INTERRUPT] = USB_EP_TYPE_INTERRUPT,
	};
	uint8_t dir = addr & 0x80;
 800c3d6:	4399      	bics	r1, r3
	addr &= 0x7f;

	/* Assign address. */
	USB_SET_EP_ADDR(addr, addr);
 800c3d8:	4b33      	ldr	r3, [pc, #204]	; (800c4a8 <st_usbfs_ep_setup+0xf0>)
 800c3da:	00a4      	lsls	r4, r4, #2
 800c3dc:	18e4      	adds	r4, r4, r3
 800c3de:	6822      	ldr	r2, [r4, #0]
 800c3e0:	4b32      	ldr	r3, [pc, #200]	; (800c4ac <st_usbfs_ep_setup+0xf4>)
	USB_SET_EP_TYPE(addr, typelookup[type]);
 800c3e2:	007f      	lsls	r7, r7, #1
	};
	uint8_t dir = addr & 0x80;
	addr &= 0x7f;

	/* Assign address. */
	USB_SET_EP_ADDR(addr, addr);
 800c3e4:	4013      	ands	r3, r2
 800c3e6:	4333      	orrs	r3, r6
 800c3e8:	b29b      	uxth	r3, r3
 800c3ea:	6023      	str	r3, [r4, #0]
	USB_SET_EP_TYPE(addr, typelookup[type]);
 800c3ec:	6822      	ldr	r2, [r4, #0]
 800c3ee:	4b30      	ldr	r3, [pc, #192]	; (800c4b0 <st_usbfs_ep_setup+0xf8>)
 800c3f0:	4013      	ands	r3, r2
 800c3f2:	aa02      	add	r2, sp, #8
 800c3f4:	5aba      	ldrh	r2, [r7, r2]
 800c3f6:	4f2f      	ldr	r7, [pc, #188]	; (800c4b4 <st_usbfs_ep_setup+0xfc>)
 800c3f8:	4313      	orrs	r3, r2
 800c3fa:	b29b      	uxth	r3, r3
 800c3fc:	6023      	str	r3, [r4, #0]

	if (dir || (addr == 0)) {
 800c3fe:	2900      	cmp	r1, #0
 800c400:	d118      	bne.n	800c434 <st_usbfs_ep_setup+0x7c>
 800c402:	2e00      	cmp	r6, #0
 800c404:	d016      	beq.n	800c434 <st_usbfs_ep_setup+0x7c>
		USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_NAK);
		dev->pm_top += max_size;
	}

	if (!dir) {
		USB_SET_EP_RX_ADDR(addr, dev->pm_top);
 800c406:	4b2c      	ldr	r3, [pc, #176]	; (800c4b8 <st_usbfs_ep_setup+0x100>)
 800c408:	00f1      	lsls	r1, r6, #3
 800c40a:	681b      	ldr	r3, [r3, #0]
 800c40c:	8b2a      	ldrh	r2, [r5, #24]
 800c40e:	b29b      	uxth	r3, r3
 800c410:	18cb      	adds	r3, r1, r3
 800c412:	492a      	ldr	r1, [pc, #168]	; (800c4bc <st_usbfs_ep_setup+0x104>)
		st_usbfs_set_ep_rx_bufsize(dev, addr, max_size);
 800c414:	1c28      	adds	r0, r5, #0
		USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_NAK);
		dev->pm_top += max_size;
	}

	if (!dir) {
		USB_SET_EP_RX_ADDR(addr, dev->pm_top);
 800c416:	185b      	adds	r3, r3, r1
 800c418:	801a      	strh	r2, [r3, #0]
		st_usbfs_set_ep_rx_bufsize(dev, addr, max_size);
 800c41a:	1c31      	adds	r1, r6, #0
 800c41c:	9a01      	ldr	r2, [sp, #4]
 800c41e:	f7ff ffa9 	bl	800c374 <st_usbfs_set_ep_rx_bufsize>
		if (callback) {
 800c422:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c424:	2b00      	cmp	r3, #0
 800c426:	d02a      	beq.n	800c47e <st_usbfs_ep_setup+0xc6>
			dev->user_callback_ctr[addr][USB_TRANSACTION_OUT] =
 800c428:	230c      	movs	r3, #12
 800c42a:	4373      	muls	r3, r6
 800c42c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800c42e:	18eb      	adds	r3, r5, r3
 800c430:	66da      	str	r2, [r3, #108]	; 0x6c
 800c432:	e024      	b.n	800c47e <st_usbfs_ep_setup+0xc6>
	/* Assign address. */
	USB_SET_EP_ADDR(addr, addr);
	USB_SET_EP_TYPE(addr, typelookup[type]);

	if (dir || (addr == 0)) {
		USB_SET_EP_TX_ADDR(addr, dev->pm_top);
 800c434:	00f2      	lsls	r2, r6, #3
 800c436:	4694      	mov	ip, r2
 800c438:	4b1f      	ldr	r3, [pc, #124]	; (800c4b8 <st_usbfs_ep_setup+0x100>)
 800c43a:	4a21      	ldr	r2, [pc, #132]	; (800c4c0 <st_usbfs_ep_setup+0x108>)
 800c43c:	681b      	ldr	r3, [r3, #0]
 800c43e:	8b28      	ldrh	r0, [r5, #24]
 800c440:	b29b      	uxth	r3, r3
 800c442:	4463      	add	r3, ip
 800c444:	189b      	adds	r3, r3, r2
 800c446:	8018      	strh	r0, [r3, #0]
		if (callback) {
 800c448:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c44a:	2b00      	cmp	r3, #0
 800c44c:	d004      	beq.n	800c458 <st_usbfs_ep_setup+0xa0>
			dev->user_callback_ctr[addr][USB_TRANSACTION_IN] =
 800c44e:	230c      	movs	r3, #12
 800c450:	4373      	muls	r3, r6
 800c452:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800c454:	18eb      	adds	r3, r5, r3
 800c456:	669a      	str	r2, [r3, #104]	; 0x68
			    (void *)callback;
		}
		USB_CLR_EP_TX_DTOG(addr);
 800c458:	6820      	ldr	r0, [r4, #0]
 800c45a:	4b1a      	ldr	r3, [pc, #104]	; (800c4c4 <st_usbfs_ep_setup+0x10c>)
		USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_NAK);
		dev->pm_top += max_size;
 800c45c:	9a01      	ldr	r2, [sp, #4]
		USB_SET_EP_TX_ADDR(addr, dev->pm_top);
		if (callback) {
			dev->user_callback_ctr[addr][USB_TRANSACTION_IN] =
			    (void *)callback;
		}
		USB_CLR_EP_TX_DTOG(addr);
 800c45e:	4003      	ands	r3, r0
 800c460:	6023      	str	r3, [r4, #0]
		USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_NAK);
 800c462:	6820      	ldr	r0, [r4, #0]
 800c464:	4b18      	ldr	r3, [pc, #96]	; (800c4c8 <st_usbfs_ep_setup+0x110>)
 800c466:	4003      	ands	r3, r0
 800c468:	2020      	movs	r0, #32
 800c46a:	4043      	eors	r3, r0
 800c46c:	433b      	orrs	r3, r7
 800c46e:	b29b      	uxth	r3, r3
 800c470:	6023      	str	r3, [r4, #0]
		dev->pm_top += max_size;
 800c472:	8b2b      	ldrh	r3, [r5, #24]
 800c474:	18d3      	adds	r3, r2, r3
 800c476:	832b      	strh	r3, [r5, #24]
	}

	if (!dir) {
 800c478:	2900      	cmp	r1, #0
 800c47a:	d111      	bne.n	800c4a0 <st_usbfs_ep_setup+0xe8>
 800c47c:	e7c3      	b.n	800c406 <st_usbfs_ep_setup+0x4e>
		st_usbfs_set_ep_rx_bufsize(dev, addr, max_size);
		if (callback) {
			dev->user_callback_ctr[addr][USB_TRANSACTION_OUT] =
			    (void *)callback;
		}
		USB_CLR_EP_RX_DTOG(addr);
 800c47e:	6822      	ldr	r2, [r4, #0]
 800c480:	4b12      	ldr	r3, [pc, #72]	; (800c4cc <st_usbfs_ep_setup+0x114>)
 800c482:	4013      	ands	r3, r2
 800c484:	6023      	str	r3, [r4, #0]
		USB_SET_EP_RX_STAT(addr, USB_EP_RX_STAT_VALID);
 800c486:	6822      	ldr	r2, [r4, #0]
 800c488:	4b11      	ldr	r3, [pc, #68]	; (800c4d0 <st_usbfs_ep_setup+0x118>)
 800c48a:	4013      	ands	r3, r2
 800c48c:	22c0      	movs	r2, #192	; 0xc0
 800c48e:	0192      	lsls	r2, r2, #6
 800c490:	4053      	eors	r3, r2
 800c492:	431f      	orrs	r7, r3
 800c494:	b2bf      	uxth	r7, r7
 800c496:	6027      	str	r7, [r4, #0]
		dev->pm_top += max_size;
 800c498:	8b2b      	ldrh	r3, [r5, #24]
 800c49a:	9a01      	ldr	r2, [sp, #4]
 800c49c:	18d3      	adds	r3, r2, r3
 800c49e:	832b      	strh	r3, [r5, #24]
	}
}
 800c4a0:	b005      	add	sp, #20
 800c4a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c4a4:	080151e8 	.word	0x080151e8
 800c4a8:	40005c00 	.word	0x40005c00
 800c4ac:	ffff8f80 	.word	0xffff8f80
 800c4b0:	ffff898f 	.word	0xffff898f
 800c4b4:	ffff8080 	.word	0xffff8080
 800c4b8:	40005c50 	.word	0x40005c50
 800c4bc:	40006004 	.word	0x40006004
 800c4c0:	40006000 	.word	0x40006000
 800c4c4:	00008fcf 	.word	0x00008fcf
 800c4c8:	00008fbf 	.word	0x00008fbf
 800c4cc:	0000cf8f 	.word	0x0000cf8f
 800c4d0:	0000bf8f 	.word	0x0000bf8f

0800c4d4 <st_usbfs_endpoints_reset>:

void st_usbfs_endpoints_reset(usbd_device *dev)
{
 800c4d4:	b510      	push	{r4, lr}
 800c4d6:	490b      	ldr	r1, [pc, #44]	; (800c504 <st_usbfs_endpoints_reset+0x30>)
	int i;

	/* Reset all endpoints. */
	for (i = 1; i < 8; i++) {
		USB_SET_EP_TX_STAT(i, USB_EP_TX_STAT_DISABLED);
 800c4d8:	680a      	ldr	r2, [r1, #0]
 800c4da:	4b0b      	ldr	r3, [pc, #44]	; (800c508 <st_usbfs_endpoints_reset+0x34>)
 800c4dc:	4c0b      	ldr	r4, [pc, #44]	; (800c50c <st_usbfs_endpoints_reset+0x38>)
 800c4de:	401a      	ands	r2, r3
 800c4e0:	4322      	orrs	r2, r4
 800c4e2:	b292      	uxth	r2, r2
 800c4e4:	600a      	str	r2, [r1, #0]
		USB_SET_EP_RX_STAT(i, USB_EP_RX_STAT_DISABLED);
 800c4e6:	680b      	ldr	r3, [r1, #0]
 800c4e8:	4a09      	ldr	r2, [pc, #36]	; (800c510 <st_usbfs_endpoints_reset+0x3c>)
 800c4ea:	4013      	ands	r3, r2
 800c4ec:	4323      	orrs	r3, r4
 800c4ee:	b29b      	uxth	r3, r3
 800c4f0:	c108      	stmia	r1!, {r3}
void st_usbfs_endpoints_reset(usbd_device *dev)
{
	int i;

	/* Reset all endpoints. */
	for (i = 1; i < 8; i++) {
 800c4f2:	4b08      	ldr	r3, [pc, #32]	; (800c514 <st_usbfs_endpoints_reset+0x40>)
 800c4f4:	4299      	cmp	r1, r3
 800c4f6:	d1ef      	bne.n	800c4d8 <st_usbfs_endpoints_reset+0x4>
		USB_SET_EP_TX_STAT(i, USB_EP_TX_STAT_DISABLED);
		USB_SET_EP_RX_STAT(i, USB_EP_RX_STAT_DISABLED);
	}
	dev->pm_top = USBD_PM_TOP + (2 * dev->desc->bMaxPacketSize0);
 800c4f8:	6803      	ldr	r3, [r0, #0]
 800c4fa:	79db      	ldrb	r3, [r3, #7]
 800c4fc:	3320      	adds	r3, #32
 800c4fe:	005b      	lsls	r3, r3, #1
 800c500:	8303      	strh	r3, [r0, #24]
}
 800c502:	bd10      	pop	{r4, pc}
 800c504:	40005c04 	.word	0x40005c04
 800c508:	ffff8fbf 	.word	0xffff8fbf
 800c50c:	ffff8080 	.word	0xffff8080
 800c510:	ffffbf8f 	.word	0xffffbf8f
 800c514:	40005c20 	.word	0x40005c20

0800c518 <st_usbfs_ep_stall_set>:

void st_usbfs_ep_stall_set(usbd_device *dev, uint8_t addr,
				   uint8_t stall)
{
 800c518:	b530      	push	{r4, r5, lr}
 800c51a:	b24b      	sxtb	r3, r1
 800c51c:	4c21      	ldr	r4, [pc, #132]	; (800c5a4 <st_usbfs_ep_stall_set+0x8c>)
	(void)dev;
	if (addr == 0) {
 800c51e:	2900      	cmp	r1, #0
 800c520:	d10c      	bne.n	800c53c <st_usbfs_ep_stall_set+0x24>
		USB_SET_EP_TX_STAT(addr, stall ? USB_EP_TX_STAT_STALL :
 800c522:	4821      	ldr	r0, [pc, #132]	; (800c5a8 <st_usbfs_ep_stall_set+0x90>)
 800c524:	4b21      	ldr	r3, [pc, #132]	; (800c5ac <st_usbfs_ep_stall_set+0x94>)
 800c526:	6805      	ldr	r5, [r0, #0]
 800c528:	402b      	ands	r3, r5
 800c52a:	2510      	movs	r5, #16
 800c52c:	2a00      	cmp	r2, #0
 800c52e:	d100      	bne.n	800c532 <st_usbfs_ep_stall_set+0x1a>
 800c530:	196d      	adds	r5, r5, r5
 800c532:	406b      	eors	r3, r5
 800c534:	4323      	orrs	r3, r4
 800c536:	b29b      	uxth	r3, r3
 800c538:	6003      	str	r3, [r0, #0]
 800c53a:	e018      	b.n	800c56e <st_usbfs_ep_stall_set+0x56>
				   USB_EP_TX_STAT_NAK);
	}

	if (addr & 0x80) {
 800c53c:	2b00      	cmp	r3, #0
 800c53e:	da16      	bge.n	800c56e <st_usbfs_ep_stall_set+0x56>
		addr &= 0x7F;

		USB_SET_EP_TX_STAT(addr, stall ? USB_EP_TX_STAT_STALL :
 800c540:	237f      	movs	r3, #127	; 0x7f
 800c542:	4019      	ands	r1, r3
 800c544:	4b18      	ldr	r3, [pc, #96]	; (800c5a8 <st_usbfs_ep_stall_set+0x90>)
 800c546:	0089      	lsls	r1, r1, #2
 800c548:	18c9      	adds	r1, r1, r3
 800c54a:	6808      	ldr	r0, [r1, #0]
 800c54c:	4b17      	ldr	r3, [pc, #92]	; (800c5ac <st_usbfs_ep_stall_set+0x94>)
 800c54e:	4018      	ands	r0, r3
 800c550:	2310      	movs	r3, #16
 800c552:	2a00      	cmp	r2, #0
 800c554:	d100      	bne.n	800c558 <st_usbfs_ep_stall_set+0x40>
 800c556:	18db      	adds	r3, r3, r3
 800c558:	4058      	eors	r0, r3
 800c55a:	1c23      	adds	r3, r4, #0
 800c55c:	4303      	orrs	r3, r0
 800c55e:	b29b      	uxth	r3, r3
 800c560:	600b      	str	r3, [r1, #0]
				   USB_EP_TX_STAT_NAK);

		/* Reset to DATA0 if clearing stall condition. */
		if (!stall) {
 800c562:	2a00      	cmp	r2, #0
 800c564:	d11c      	bne.n	800c5a0 <st_usbfs_ep_stall_set+0x88>
			USB_CLR_EP_TX_DTOG(addr);
 800c566:	680a      	ldr	r2, [r1, #0]
 800c568:	4b11      	ldr	r3, [pc, #68]	; (800c5b0 <st_usbfs_ep_stall_set+0x98>)
 800c56a:	4013      	ands	r3, r2
 800c56c:	e017      	b.n	800c59e <st_usbfs_ep_stall_set+0x86>
 800c56e:	0089      	lsls	r1, r1, #2
		}
	} else {
		/* Reset to DATA0 if clearing stall condition. */
		if (!stall) {
 800c570:	2a00      	cmp	r2, #0
 800c572:	d105      	bne.n	800c580 <st_usbfs_ep_stall_set+0x68>
			USB_CLR_EP_RX_DTOG(addr);
 800c574:	4b0c      	ldr	r3, [pc, #48]	; (800c5a8 <st_usbfs_ep_stall_set+0x90>)
 800c576:	18c8      	adds	r0, r1, r3
 800c578:	6805      	ldr	r5, [r0, #0]
 800c57a:	4b0e      	ldr	r3, [pc, #56]	; (800c5b4 <st_usbfs_ep_stall_set+0x9c>)
 800c57c:	402b      	ands	r3, r5
 800c57e:	6003      	str	r3, [r0, #0]
		}

		USB_SET_EP_RX_STAT(addr, stall ? USB_EP_RX_STAT_STALL :
 800c580:	4b09      	ldr	r3, [pc, #36]	; (800c5a8 <st_usbfs_ep_stall_set+0x90>)
 800c582:	480d      	ldr	r0, [pc, #52]	; (800c5b8 <st_usbfs_ep_stall_set+0xa0>)
 800c584:	18c9      	adds	r1, r1, r3
 800c586:	680b      	ldr	r3, [r1, #0]
 800c588:	4018      	ands	r0, r3
 800c58a:	2a00      	cmp	r2, #0
 800c58c:	d102      	bne.n	800c594 <st_usbfs_ep_stall_set+0x7c>
 800c58e:	23c0      	movs	r3, #192	; 0xc0
 800c590:	019b      	lsls	r3, r3, #6
 800c592:	e001      	b.n	800c598 <st_usbfs_ep_stall_set+0x80>
 800c594:	2380      	movs	r3, #128	; 0x80
 800c596:	015b      	lsls	r3, r3, #5
 800c598:	4043      	eors	r3, r0
 800c59a:	4323      	orrs	r3, r4
 800c59c:	b29b      	uxth	r3, r3
 800c59e:	600b      	str	r3, [r1, #0]
				   USB_EP_RX_STAT_VALID);
	}
}
 800c5a0:	bd30      	pop	{r4, r5, pc}
 800c5a2:	46c0      	nop			; (mov r8, r8)
 800c5a4:	ffff8080 	.word	0xffff8080
 800c5a8:	40005c00 	.word	0x40005c00
 800c5ac:	00008fbf 	.word	0x00008fbf
 800c5b0:	00008fcf 	.word	0x00008fcf
 800c5b4:	0000cf8f 	.word	0x0000cf8f
 800c5b8:	0000bf8f 	.word	0x0000bf8f

0800c5bc <st_usbfs_ep_stall_get>:

uint8_t st_usbfs_ep_stall_get(usbd_device *dev, uint8_t addr)
{
	(void)dev;
	if (addr & 0x80) {
 800c5bc:	b24b      	sxtb	r3, r1
 800c5be:	2b00      	cmp	r3, #0
 800c5c0:	da09      	bge.n	800c5d6 <st_usbfs_ep_stall_get+0x1a>
		if ((*USB_EP_REG(addr & 0x7F) & USB_EP_TX_STAT) ==
 800c5c2:	237f      	movs	r3, #127	; 0x7f
 800c5c4:	4019      	ands	r1, r3
 800c5c6:	4b0a      	ldr	r3, [pc, #40]	; (800c5f0 <st_usbfs_ep_stall_get+0x34>)
 800c5c8:	0089      	lsls	r1, r1, #2
 800c5ca:	18c9      	adds	r1, r1, r3
 800c5cc:	2330      	movs	r3, #48	; 0x30
 800c5ce:	6808      	ldr	r0, [r1, #0]
 800c5d0:	4018      	ands	r0, r3
 800c5d2:	3810      	subs	r0, #16
 800c5d4:	e008      	b.n	800c5e8 <st_usbfs_ep_stall_get+0x2c>
		    USB_EP_TX_STAT_STALL) {
			return 1;
		}
	} else {
		if ((*USB_EP_REG(addr) & USB_EP_RX_STAT) ==
 800c5d6:	4b06      	ldr	r3, [pc, #24]	; (800c5f0 <st_usbfs_ep_stall_get+0x34>)
 800c5d8:	0089      	lsls	r1, r1, #2
 800c5da:	18c9      	adds	r1, r1, r3
 800c5dc:	23c0      	movs	r3, #192	; 0xc0
 800c5de:	6808      	ldr	r0, [r1, #0]
 800c5e0:	019b      	lsls	r3, r3, #6
 800c5e2:	4018      	ands	r0, r3
 800c5e4:	4b03      	ldr	r3, [pc, #12]	; (800c5f4 <st_usbfs_ep_stall_get+0x38>)
 800c5e6:	18c0      	adds	r0, r0, r3
 800c5e8:	4243      	negs	r3, r0
 800c5ea:	4158      	adcs	r0, r3
{
	(void)dev;
	if (addr & 0x80) {
		if ((*USB_EP_REG(addr & 0x7F) & USB_EP_TX_STAT) ==
		    USB_EP_TX_STAT_STALL) {
			return 1;
 800c5ec:	b2c0      	uxtb	r0, r0
		    USB_EP_RX_STAT_STALL) {
			return 1;
		}
	}
	return 0;
}
 800c5ee:	4770      	bx	lr
 800c5f0:	40005c00 	.word	0x40005c00
 800c5f4:	fffff000 	.word	0xfffff000

0800c5f8 <st_usbfs_ep_nak_set>:

void st_usbfs_ep_nak_set(usbd_device *dev, uint8_t addr, uint8_t nak)
{
	(void)dev;
	/* It does not make sense to force NAK on IN endpoints. */
	if (addr & 0x80) {
 800c5f8:	b24b      	sxtb	r3, r1
 800c5fa:	2b00      	cmp	r3, #0
 800c5fc:	db1c      	blt.n	800c638 <st_usbfs_ep_nak_set+0x40>
		return;
	}

	st_usbfs_force_nak[addr] = nak;
 800c5fe:	4b0f      	ldr	r3, [pc, #60]	; (800c63c <st_usbfs_ep_nak_set+0x44>)
 800c600:	480f      	ldr	r0, [pc, #60]	; (800c640 <st_usbfs_ep_nak_set+0x48>)
 800c602:	545a      	strb	r2, [r3, r1]
 800c604:	0089      	lsls	r1, r1, #2
 800c606:	4b0f      	ldr	r3, [pc, #60]	; (800c644 <st_usbfs_ep_nak_set+0x4c>)

	if (nak) {
 800c608:	2a00      	cmp	r2, #0
 800c60a:	d00a      	beq.n	800c622 <st_usbfs_ep_nak_set+0x2a>
		USB_SET_EP_RX_STAT(addr, USB_EP_RX_STAT_NAK);
 800c60c:	4a0e      	ldr	r2, [pc, #56]	; (800c648 <st_usbfs_ep_nak_set+0x50>)
 800c60e:	1889      	adds	r1, r1, r2
 800c610:	680a      	ldr	r2, [r1, #0]
 800c612:	401a      	ands	r2, r3
 800c614:	2380      	movs	r3, #128	; 0x80
 800c616:	b292      	uxth	r2, r2
 800c618:	019b      	lsls	r3, r3, #6
 800c61a:	405a      	eors	r2, r3
 800c61c:	1c03      	adds	r3, r0, #0
 800c61e:	4313      	orrs	r3, r2
 800c620:	e008      	b.n	800c634 <st_usbfs_ep_nak_set+0x3c>
	} else {
		USB_SET_EP_RX_STAT(addr, USB_EP_RX_STAT_VALID);
 800c622:	4a09      	ldr	r2, [pc, #36]	; (800c648 <st_usbfs_ep_nak_set+0x50>)
 800c624:	1889      	adds	r1, r1, r2
 800c626:	680a      	ldr	r2, [r1, #0]
 800c628:	401a      	ands	r2, r3
 800c62a:	23c0      	movs	r3, #192	; 0xc0
 800c62c:	b292      	uxth	r2, r2
 800c62e:	019b      	lsls	r3, r3, #6
 800c630:	4053      	eors	r3, r2
 800c632:	4303      	orrs	r3, r0
 800c634:	b29b      	uxth	r3, r3
 800c636:	600b      	str	r3, [r1, #0]
	}
}
 800c638:	4770      	bx	lr
 800c63a:	46c0      	nop			; (mov r8, r8)
 800c63c:	20001c84 	.word	0x20001c84
 800c640:	ffff8080 	.word	0xffff8080
 800c644:	ffffbf8f 	.word	0xffffbf8f
 800c648:	40005c00 	.word	0x40005c00

0800c64c <st_usbfs_ep_write_packet>:

uint16_t st_usbfs_ep_write_packet(usbd_device *dev, uint8_t addr,
				     const void *buf, uint16_t len)
{
 800c64c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c64e:	1c1e      	adds	r6, r3, #0
	(void)dev;
	addr &= 0x7F;
 800c650:	237f      	movs	r3, #127	; 0x7f
 800c652:	4019      	ands	r1, r3

	if ((*USB_EP_REG(addr) & USB_EP_TX_STAT) == USB_EP_TX_STAT_VALID) {
 800c654:	008d      	lsls	r5, r1, #2

uint16_t st_usbfs_ep_write_packet(usbd_device *dev, uint8_t addr,
				     const void *buf, uint16_t len)
{
	(void)dev;
	addr &= 0x7F;
 800c656:	1c0c      	adds	r4, r1, #0

	if ((*USB_EP_REG(addr) & USB_EP_TX_STAT) == USB_EP_TX_STAT_VALID) {
 800c658:	2130      	movs	r1, #48	; 0x30
 800c65a:	4b12      	ldr	r3, [pc, #72]	; (800c6a4 <st_usbfs_ep_write_packet+0x58>)
		return 0;
 800c65c:	2000      	movs	r0, #0
				     const void *buf, uint16_t len)
{
	(void)dev;
	addr &= 0x7F;

	if ((*USB_EP_REG(addr) & USB_EP_TX_STAT) == USB_EP_TX_STAT_VALID) {
 800c65e:	18ed      	adds	r5, r5, r3
 800c660:	682b      	ldr	r3, [r5, #0]
 800c662:	400b      	ands	r3, r1
 800c664:	428b      	cmp	r3, r1
 800c666:	d01b      	beq.n	800c6a0 <st_usbfs_ep_write_packet+0x54>
		return 0;
	}

	st_usbfs_copy_to_pm(USB_GET_EP_TX_BUFF(addr), buf, len);
 800c668:	4f0f      	ldr	r7, [pc, #60]	; (800c6a8 <st_usbfs_ep_write_packet+0x5c>)
 800c66a:	4910      	ldr	r1, [pc, #64]	; (800c6ac <st_usbfs_ep_write_packet+0x60>)
 800c66c:	683b      	ldr	r3, [r7, #0]
 800c66e:	00e4      	lsls	r4, r4, #3
 800c670:	b29b      	uxth	r3, r3
 800c672:	18e3      	adds	r3, r4, r3
 800c674:	185b      	adds	r3, r3, r1
 800c676:	8818      	ldrh	r0, [r3, #0]
 800c678:	1840      	adds	r0, r0, r1
 800c67a:	1c11      	adds	r1, r2, #0
 800c67c:	1c32      	adds	r2, r6, #0
 800c67e:	f7ff fdb3 	bl	800c1e8 <st_usbfs_copy_to_pm>
	USB_SET_EP_TX_COUNT(addr, len);
 800c682:	6839      	ldr	r1, [r7, #0]
 800c684:	4b0a      	ldr	r3, [pc, #40]	; (800c6b0 <st_usbfs_ep_write_packet+0x64>)
 800c686:	b289      	uxth	r1, r1
 800c688:	1864      	adds	r4, r4, r1
	USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_VALID);
 800c68a:	682a      	ldr	r2, [r5, #0]
	if ((*USB_EP_REG(addr) & USB_EP_TX_STAT) == USB_EP_TX_STAT_VALID) {
		return 0;
	}

	st_usbfs_copy_to_pm(USB_GET_EP_TX_BUFF(addr), buf, len);
	USB_SET_EP_TX_COUNT(addr, len);
 800c68c:	18e4      	adds	r4, r4, r3
	USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_VALID);
 800c68e:	4b09      	ldr	r3, [pc, #36]	; (800c6b4 <st_usbfs_ep_write_packet+0x68>)

	return len;
 800c690:	1c30      	adds	r0, r6, #0
		return 0;
	}

	st_usbfs_copy_to_pm(USB_GET_EP_TX_BUFF(addr), buf, len);
	USB_SET_EP_TX_COUNT(addr, len);
	USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_VALID);
 800c692:	4013      	ands	r3, r2
 800c694:	2230      	movs	r2, #48	; 0x30
 800c696:	4053      	eors	r3, r2
 800c698:	4a07      	ldr	r2, [pc, #28]	; (800c6b8 <st_usbfs_ep_write_packet+0x6c>)
	if ((*USB_EP_REG(addr) & USB_EP_TX_STAT) == USB_EP_TX_STAT_VALID) {
		return 0;
	}

	st_usbfs_copy_to_pm(USB_GET_EP_TX_BUFF(addr), buf, len);
	USB_SET_EP_TX_COUNT(addr, len);
 800c69a:	8026      	strh	r6, [r4, #0]
	USB_SET_EP_TX_STAT(addr, USB_EP_TX_STAT_VALID);
 800c69c:	4313      	orrs	r3, r2
 800c69e:	602b      	str	r3, [r5, #0]

	return len;
}
 800c6a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c6a2:	46c0      	nop			; (mov r8, r8)
 800c6a4:	40005c00 	.word	0x40005c00
 800c6a8:	40005c50 	.word	0x40005c50
 800c6ac:	40006000 	.word	0x40006000
 800c6b0:	40006002 	.word	0x40006002
 800c6b4:	00008fbf 	.word	0x00008fbf
 800c6b8:	00008080 	.word	0x00008080

0800c6bc <st_usbfs_ep_read_packet>:

uint16_t st_usbfs_ep_read_packet(usbd_device *dev, uint8_t addr,
					 void *buf, uint16_t len)
{
 800c6bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)dev;
	if ((*USB_EP_REG(addr) & USB_EP_RX_STAT) == USB_EP_RX_STAT_VALID) {
 800c6be:	008d      	lsls	r5, r1, #2
	return len;
}

uint16_t st_usbfs_ep_read_packet(usbd_device *dev, uint8_t addr,
					 void *buf, uint16_t len)
{
 800c6c0:	1c0e      	adds	r6, r1, #0
	(void)dev;
	if ((*USB_EP_REG(addr) & USB_EP_RX_STAT) == USB_EP_RX_STAT_VALID) {
 800c6c2:	21c0      	movs	r1, #192	; 0xc0
	return len;
}

uint16_t st_usbfs_ep_read_packet(usbd_device *dev, uint8_t addr,
					 void *buf, uint16_t len)
{
 800c6c4:	1c1c      	adds	r4, r3, #0
	(void)dev;
	if ((*USB_EP_REG(addr) & USB_EP_RX_STAT) == USB_EP_RX_STAT_VALID) {
 800c6c6:	4b1e      	ldr	r3, [pc, #120]	; (800c740 <st_usbfs_ep_read_packet+0x84>)
 800c6c8:	0189      	lsls	r1, r1, #6
 800c6ca:	18ed      	adds	r5, r5, r3
 800c6cc:	682b      	ldr	r3, [r5, #0]
		return 0;
 800c6ce:	2000      	movs	r0, #0

uint16_t st_usbfs_ep_read_packet(usbd_device *dev, uint8_t addr,
					 void *buf, uint16_t len)
{
	(void)dev;
	if ((*USB_EP_REG(addr) & USB_EP_RX_STAT) == USB_EP_RX_STAT_VALID) {
 800c6d0:	400b      	ands	r3, r1
 800c6d2:	428b      	cmp	r3, r1
 800c6d4:	d032      	beq.n	800c73c <st_usbfs_ep_read_packet+0x80>
		return 0;
	}

	len = MIN(USB_GET_EP_RX_COUNT(addr) & 0x3ff, len);
 800c6d6:	4b1b      	ldr	r3, [pc, #108]	; (800c744 <st_usbfs_ep_read_packet+0x88>)
 800c6d8:	00f0      	lsls	r0, r6, #3
 800c6da:	6819      	ldr	r1, [r3, #0]
 800c6dc:	4f1a      	ldr	r7, [pc, #104]	; (800c748 <st_usbfs_ep_read_packet+0x8c>)
 800c6de:	b289      	uxth	r1, r1
 800c6e0:	1841      	adds	r1, r0, r1
 800c6e2:	19c9      	adds	r1, r1, r7
 800c6e4:	8809      	ldrh	r1, [r1, #0]
 800c6e6:	0589      	lsls	r1, r1, #22
 800c6e8:	0d89      	lsrs	r1, r1, #22
 800c6ea:	42a1      	cmp	r1, r4
 800c6ec:	da06      	bge.n	800c6fc <st_usbfs_ep_read_packet+0x40>
 800c6ee:	6819      	ldr	r1, [r3, #0]
 800c6f0:	b289      	uxth	r1, r1
 800c6f2:	1841      	adds	r1, r0, r1
 800c6f4:	19c9      	adds	r1, r1, r7
 800c6f6:	880c      	ldrh	r4, [r1, #0]
 800c6f8:	05a4      	lsls	r4, r4, #22
 800c6fa:	0da4      	lsrs	r4, r4, #22
	st_usbfs_copy_from_pm(buf, USB_GET_EP_RX_BUFF(addr), len);
 800c6fc:	681b      	ldr	r3, [r3, #0]
 800c6fe:	4913      	ldr	r1, [pc, #76]	; (800c74c <st_usbfs_ep_read_packet+0x90>)
 800c700:	b29b      	uxth	r3, r3
 800c702:	18c3      	adds	r3, r0, r3
 800c704:	185b      	adds	r3, r3, r1
 800c706:	8819      	ldrh	r1, [r3, #0]
 800c708:	4b11      	ldr	r3, [pc, #68]	; (800c750 <st_usbfs_ep_read_packet+0x94>)
 800c70a:	1c10      	adds	r0, r2, #0
 800c70c:	18c9      	adds	r1, r1, r3
 800c70e:	1c22      	adds	r2, r4, #0
 800c710:	f7ff fd78 	bl	800c204 <st_usbfs_copy_from_pm>
	USB_CLR_EP_RX_CTR(addr);
 800c714:	682a      	ldr	r2, [r5, #0]
 800c716:	4b0f      	ldr	r3, [pc, #60]	; (800c754 <st_usbfs_ep_read_packet+0x98>)

	if (!st_usbfs_force_nak[addr]) {
		USB_SET_EP_RX_STAT(addr, USB_EP_RX_STAT_VALID);
	}

	return len;
 800c718:	1c20      	adds	r0, r4, #0
		return 0;
	}

	len = MIN(USB_GET_EP_RX_COUNT(addr) & 0x3ff, len);
	st_usbfs_copy_from_pm(buf, USB_GET_EP_RX_BUFF(addr), len);
	USB_CLR_EP_RX_CTR(addr);
 800c71a:	4013      	ands	r3, r2
 800c71c:	2280      	movs	r2, #128	; 0x80
 800c71e:	4313      	orrs	r3, r2
 800c720:	602b      	str	r3, [r5, #0]

	if (!st_usbfs_force_nak[addr]) {
 800c722:	4b0d      	ldr	r3, [pc, #52]	; (800c758 <st_usbfs_ep_read_packet+0x9c>)
 800c724:	5d9b      	ldrb	r3, [r3, r6]
 800c726:	2b00      	cmp	r3, #0
 800c728:	d108      	bne.n	800c73c <st_usbfs_ep_read_packet+0x80>
		USB_SET_EP_RX_STAT(addr, USB_EP_RX_STAT_VALID);
 800c72a:	682a      	ldr	r2, [r5, #0]
 800c72c:	4b0b      	ldr	r3, [pc, #44]	; (800c75c <st_usbfs_ep_read_packet+0xa0>)
 800c72e:	4013      	ands	r3, r2
 800c730:	22c0      	movs	r2, #192	; 0xc0
 800c732:	0192      	lsls	r2, r2, #6
 800c734:	4053      	eors	r3, r2
 800c736:	4a0a      	ldr	r2, [pc, #40]	; (800c760 <st_usbfs_ep_read_packet+0xa4>)
 800c738:	4313      	orrs	r3, r2
 800c73a:	602b      	str	r3, [r5, #0]
	}

	return len;
}
 800c73c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c73e:	46c0      	nop			; (mov r8, r8)
 800c740:	40005c00 	.word	0x40005c00
 800c744:	40005c50 	.word	0x40005c50
 800c748:	40006006 	.word	0x40006006
 800c74c:	40006004 	.word	0x40006004
 800c750:	40006000 	.word	0x40006000
 800c754:	00000f0f 	.word	0x00000f0f
 800c758:	20001c84 	.word	0x20001c84
 800c75c:	0000bf8f 	.word	0x0000bf8f
 800c760:	00008080 	.word	0x00008080

0800c764 <st_usbfs_poll>:

void st_usbfs_poll(usbd_device *dev)
{
	uint16_t istr = *USB_ISTR_REG;
 800c764:	4a31      	ldr	r2, [pc, #196]	; (800c82c <st_usbfs_poll+0xc8>)

	return len;
}

void st_usbfs_poll(usbd_device *dev)
{
 800c766:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t istr = *USB_ISTR_REG;
 800c768:	6813      	ldr	r3, [r2, #0]

	return len;
}

void st_usbfs_poll(usbd_device *dev)
{
 800c76a:	1c04      	adds	r4, r0, #0
 800c76c:	b29d      	uxth	r5, r3
 800c76e:	1c16      	adds	r6, r2, #0
	uint16_t istr = *USB_ISTR_REG;

	if (istr & USB_ISTR_RESET) {
 800c770:	0569      	lsls	r1, r5, #21
 800c772:	d506      	bpl.n	800c782 <st_usbfs_poll+0x1e>
		USB_CLR_ISTR_RESET();
 800c774:	4b2e      	ldr	r3, [pc, #184]	; (800c830 <st_usbfs_poll+0xcc>)
 800c776:	6013      	str	r3, [r2, #0]
		dev->pm_top = USBD_PM_TOP;
 800c778:	2340      	movs	r3, #64	; 0x40
 800c77a:	8303      	strh	r3, [r0, #24]
		_usbd_reset(dev);
 800c77c:	f7ff f83e 	bl	800b7fc <_usbd_reset>
		return;
 800c780:	e052      	b.n	800c828 <st_usbfs_poll+0xc4>
	}

	if (istr & USB_ISTR_CTR) {
 800c782:	041a      	lsls	r2, r3, #16
 800c784:	d52b      	bpl.n	800c7de <st_usbfs_poll+0x7a>
		uint8_t ep = istr & USB_ISTR_EP_ID;
 800c786:	210f      	movs	r1, #15
 800c788:	4019      	ands	r1, r3
		uint8_t type;

		if (istr & USB_ISTR_DIR) {
 800c78a:	2310      	movs	r3, #16
 800c78c:	008a      	lsls	r2, r1, #2
 800c78e:	402b      	ands	r3, r5
 800c790:	d006      	beq.n	800c7a0 <st_usbfs_poll+0x3c>
			/* OUT or SETUP? */
			if (*USB_EP_REG(ep) & USB_EP_SETUP) {
 800c792:	4b28      	ldr	r3, [pc, #160]	; (800c834 <st_usbfs_poll+0xd0>)
 800c794:	18d3      	adds	r3, r2, r3
 800c796:	681b      	ldr	r3, [r3, #0]
 800c798:	051b      	lsls	r3, r3, #20
				type = USB_TRANSACTION_SETUP;
			} else {
				type = USB_TRANSACTION_OUT;
 800c79a:	0fdb      	lsrs	r3, r3, #31
 800c79c:	3301      	adds	r3, #1
 800c79e:	e00b      	b.n	800c7b8 <st_usbfs_poll+0x54>
			}
		} else {
			type = USB_TRANSACTION_IN;
			USB_CLR_EP_TX_CTR(ep);
 800c7a0:	4824      	ldr	r0, [pc, #144]	; (800c834 <st_usbfs_poll+0xd0>)
 800c7a2:	4684      	mov	ip, r0
 800c7a4:	4494      	add	ip, r2
 800c7a6:	4660      	mov	r0, ip
 800c7a8:	6807      	ldr	r7, [r0, #0]
 800c7aa:	4823      	ldr	r0, [pc, #140]	; (800c838 <st_usbfs_poll+0xd4>)
 800c7ac:	4038      	ands	r0, r7
 800c7ae:	2780      	movs	r7, #128	; 0x80
 800c7b0:	023f      	lsls	r7, r7, #8
 800c7b2:	4338      	orrs	r0, r7
 800c7b4:	4667      	mov	r7, ip
 800c7b6:	6038      	str	r0, [r7, #0]
		}

		if (dev->user_callback_ctr[ep][type]) {
 800c7b8:	2003      	movs	r0, #3
 800c7ba:	4348      	muls	r0, r1
 800c7bc:	18c3      	adds	r3, r0, r3
 800c7be:	331a      	adds	r3, #26
 800c7c0:	009b      	lsls	r3, r3, #2
 800c7c2:	591b      	ldr	r3, [r3, r4]
 800c7c4:	2b00      	cmp	r3, #0
 800c7c6:	d002      	beq.n	800c7ce <st_usbfs_poll+0x6a>
			dev->user_callback_ctr[ep][type] (dev, ep);
 800c7c8:	1c20      	adds	r0, r4, #0
 800c7ca:	4798      	blx	r3
 800c7cc:	e007      	b.n	800c7de <st_usbfs_poll+0x7a>
		} else {
			USB_CLR_EP_RX_CTR(ep);
 800c7ce:	4b19      	ldr	r3, [pc, #100]	; (800c834 <st_usbfs_poll+0xd0>)
 800c7d0:	18d2      	adds	r2, r2, r3
 800c7d2:	6811      	ldr	r1, [r2, #0]
 800c7d4:	4b18      	ldr	r3, [pc, #96]	; (800c838 <st_usbfs_poll+0xd4>)
 800c7d6:	400b      	ands	r3, r1
 800c7d8:	2180      	movs	r1, #128	; 0x80
 800c7da:	430b      	orrs	r3, r1
 800c7dc:	6013      	str	r3, [r2, #0]
		}
	}

	if (istr & USB_ISTR_SUSP) {
 800c7de:	052b      	lsls	r3, r5, #20
 800c7e0:	d505      	bpl.n	800c7ee <st_usbfs_poll+0x8a>
		USB_CLR_ISTR_SUSP();
 800c7e2:	4b16      	ldr	r3, [pc, #88]	; (800c83c <st_usbfs_poll+0xd8>)
 800c7e4:	6033      	str	r3, [r6, #0]
		if (dev->user_callback_suspend) {
 800c7e6:	6a23      	ldr	r3, [r4, #32]
 800c7e8:	2b00      	cmp	r3, #0
 800c7ea:	d000      	beq.n	800c7ee <st_usbfs_poll+0x8a>
			dev->user_callback_suspend();
 800c7ec:	4798      	blx	r3
		}
	}

	if (istr & USB_ISTR_WKUP) {
 800c7ee:	04eb      	lsls	r3, r5, #19
 800c7f0:	d505      	bpl.n	800c7fe <st_usbfs_poll+0x9a>
		USB_CLR_ISTR_WKUP();
 800c7f2:	4b13      	ldr	r3, [pc, #76]	; (800c840 <st_usbfs_poll+0xdc>)
 800c7f4:	6033      	str	r3, [r6, #0]
		if (dev->user_callback_resume) {
 800c7f6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800c7f8:	2b00      	cmp	r3, #0
 800c7fa:	d000      	beq.n	800c7fe <st_usbfs_poll+0x9a>
			dev->user_callback_resume();
 800c7fc:	4798      	blx	r3
		}
	}

	if (istr & USB_ISTR_SOF) {
 800c7fe:	05ab      	lsls	r3, r5, #22
 800c800:	d505      	bpl.n	800c80e <st_usbfs_poll+0xaa>
		USB_CLR_ISTR_SOF();
 800c802:	4b10      	ldr	r3, [pc, #64]	; (800c844 <st_usbfs_poll+0xe0>)
 800c804:	6033      	str	r3, [r6, #0]
		if (dev->user_callback_sof) {
 800c806:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800c808:	2b00      	cmp	r3, #0
 800c80a:	d000      	beq.n	800c80e <st_usbfs_poll+0xaa>
			dev->user_callback_sof();
 800c80c:	4798      	blx	r3
		}
	}

	if (dev->user_callback_sof) {
 800c80e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800c810:	4b0d      	ldr	r3, [pc, #52]	; (800c848 <st_usbfs_poll+0xe4>)
 800c812:	2a00      	cmp	r2, #0
 800c814:	d004      	beq.n	800c820 <st_usbfs_poll+0xbc>
		*USB_CNTR_REG |= USB_CNTR_SOFM;
 800c816:	2180      	movs	r1, #128	; 0x80
 800c818:	681a      	ldr	r2, [r3, #0]
 800c81a:	0089      	lsls	r1, r1, #2
 800c81c:	430a      	orrs	r2, r1
 800c81e:	e002      	b.n	800c826 <st_usbfs_poll+0xc2>
	} else {
		*USB_CNTR_REG &= ~USB_CNTR_SOFM;
 800c820:	6819      	ldr	r1, [r3, #0]
 800c822:	4a0a      	ldr	r2, [pc, #40]	; (800c84c <st_usbfs_poll+0xe8>)
 800c824:	400a      	ands	r2, r1
 800c826:	601a      	str	r2, [r3, #0]
	}
}
 800c828:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c82a:	46c0      	nop			; (mov r8, r8)
 800c82c:	40005c44 	.word	0x40005c44
 800c830:	0000fbff 	.word	0x0000fbff
 800c834:	40005c00 	.word	0x40005c00
 800c838:	00000f0f 	.word	0x00000f0f
 800c83c:	0000f7ff 	.word	0x0000f7ff
 800c840:	0000efff 	.word	0x0000efff
 800c844:	0000fdff 	.word	0x0000fdff
 800c848:	40005c40 	.word	0x40005c40
 800c84c:	fffffdff 	.word	0xfffffdff

0800c850 <abort>:
 800c850:	b508      	push	{r3, lr}
 800c852:	2006      	movs	r0, #6
 800c854:	f000 f9f2 	bl	800cc3c <raise>
 800c858:	2001      	movs	r0, #1
 800c85a:	f002 f88d 	bl	800e978 <_exit>

0800c85e <atoi>:
 800c85e:	b508      	push	{r3, lr}
 800c860:	2100      	movs	r1, #0
 800c862:	220a      	movs	r2, #10
 800c864:	f000 fc28 	bl	800d0b8 <strtol>
 800c868:	bd08      	pop	{r3, pc}

0800c86a <atol>:
 800c86a:	b508      	push	{r3, lr}
 800c86c:	2100      	movs	r1, #0
 800c86e:	220a      	movs	r2, #10
 800c870:	f000 fc22 	bl	800d0b8 <strtol>
 800c874:	bd08      	pop	{r3, pc}
	...

0800c878 <calloc>:
 800c878:	b508      	push	{r3, lr}
 800c87a:	1c03      	adds	r3, r0, #0
 800c87c:	1c0a      	adds	r2, r1, #0
 800c87e:	4903      	ldr	r1, [pc, #12]	; (800c88c <calloc+0x14>)
 800c880:	6808      	ldr	r0, [r1, #0]
 800c882:	1c19      	adds	r1, r3, #0
 800c884:	f000 f83d 	bl	800c902 <_calloc_r>
 800c888:	bd08      	pop	{r3, pc}
 800c88a:	46c0      	nop			; (mov r8, r8)
 800c88c:	20000130 	.word	0x20000130

0800c890 <malloc>:
 800c890:	b508      	push	{r3, lr}
 800c892:	4b03      	ldr	r3, [pc, #12]	; (800c8a0 <malloc+0x10>)
 800c894:	1c01      	adds	r1, r0, #0
 800c896:	6818      	ldr	r0, [r3, #0]
 800c898:	f000 f888 	bl	800c9ac <_malloc_r>
 800c89c:	bd08      	pop	{r3, pc}
 800c89e:	46c0      	nop			; (mov r8, r8)
 800c8a0:	20000130 	.word	0x20000130

0800c8a4 <free>:
 800c8a4:	b508      	push	{r3, lr}
 800c8a6:	4b03      	ldr	r3, [pc, #12]	; (800c8b4 <free+0x10>)
 800c8a8:	1c01      	adds	r1, r0, #0
 800c8aa:	6818      	ldr	r0, [r3, #0]
 800c8ac:	f000 f838 	bl	800c920 <_free_r>
 800c8b0:	bd08      	pop	{r3, pc}
 800c8b2:	46c0      	nop			; (mov r8, r8)
 800c8b4:	20000130 	.word	0x20000130

0800c8b8 <memcpy>:
 800c8b8:	2300      	movs	r3, #0
 800c8ba:	b510      	push	{r4, lr}
 800c8bc:	4293      	cmp	r3, r2
 800c8be:	d003      	beq.n	800c8c8 <memcpy+0x10>
 800c8c0:	5ccc      	ldrb	r4, [r1, r3]
 800c8c2:	54c4      	strb	r4, [r0, r3]
 800c8c4:	3301      	adds	r3, #1
 800c8c6:	e7f9      	b.n	800c8bc <memcpy+0x4>
 800c8c8:	bd10      	pop	{r4, pc}

0800c8ca <memmove>:
 800c8ca:	b510      	push	{r4, lr}
 800c8cc:	4281      	cmp	r1, r0
 800c8ce:	d208      	bcs.n	800c8e2 <memmove+0x18>
 800c8d0:	188b      	adds	r3, r1, r2
 800c8d2:	4298      	cmp	r0, r3
 800c8d4:	d205      	bcs.n	800c8e2 <memmove+0x18>
 800c8d6:	1a9b      	subs	r3, r3, r2
 800c8d8:	3a01      	subs	r2, #1
 800c8da:	d309      	bcc.n	800c8f0 <memmove+0x26>
 800c8dc:	5c99      	ldrb	r1, [r3, r2]
 800c8de:	5481      	strb	r1, [r0, r2]
 800c8e0:	e7fa      	b.n	800c8d8 <memmove+0xe>
 800c8e2:	2300      	movs	r3, #0
 800c8e4:	4293      	cmp	r3, r2
 800c8e6:	d003      	beq.n	800c8f0 <memmove+0x26>
 800c8e8:	5ccc      	ldrb	r4, [r1, r3]
 800c8ea:	54c4      	strb	r4, [r0, r3]
 800c8ec:	3301      	adds	r3, #1
 800c8ee:	e7f9      	b.n	800c8e4 <memmove+0x1a>
 800c8f0:	bd10      	pop	{r4, pc}

0800c8f2 <memset>:
 800c8f2:	1c03      	adds	r3, r0, #0
 800c8f4:	1882      	adds	r2, r0, r2
 800c8f6:	4293      	cmp	r3, r2
 800c8f8:	d002      	beq.n	800c900 <memset+0xe>
 800c8fa:	7019      	strb	r1, [r3, #0]
 800c8fc:	3301      	adds	r3, #1
 800c8fe:	e7fa      	b.n	800c8f6 <memset+0x4>
 800c900:	4770      	bx	lr

0800c902 <_calloc_r>:
 800c902:	434a      	muls	r2, r1
 800c904:	b538      	push	{r3, r4, r5, lr}
 800c906:	1c11      	adds	r1, r2, #0
 800c908:	1c14      	adds	r4, r2, #0
 800c90a:	f000 f84f 	bl	800c9ac <_malloc_r>
 800c90e:	1e05      	subs	r5, r0, #0
 800c910:	d003      	beq.n	800c91a <_calloc_r+0x18>
 800c912:	2100      	movs	r1, #0
 800c914:	1c22      	adds	r2, r4, #0
 800c916:	f7ff ffec 	bl	800c8f2 <memset>
 800c91a:	1c28      	adds	r0, r5, #0
 800c91c:	bd38      	pop	{r3, r4, r5, pc}
	...

0800c920 <_free_r>:
 800c920:	b530      	push	{r4, r5, lr}
 800c922:	2900      	cmp	r1, #0
 800c924:	d03e      	beq.n	800c9a4 <_free_r+0x84>
 800c926:	3904      	subs	r1, #4
 800c928:	680b      	ldr	r3, [r1, #0]
 800c92a:	2b00      	cmp	r3, #0
 800c92c:	da00      	bge.n	800c930 <_free_r+0x10>
 800c92e:	18c9      	adds	r1, r1, r3
 800c930:	4a1d      	ldr	r2, [pc, #116]	; (800c9a8 <_free_r+0x88>)
 800c932:	6813      	ldr	r3, [r2, #0]
 800c934:	1c14      	adds	r4, r2, #0
 800c936:	2b00      	cmp	r3, #0
 800c938:	d102      	bne.n	800c940 <_free_r+0x20>
 800c93a:	604b      	str	r3, [r1, #4]
 800c93c:	6011      	str	r1, [r2, #0]
 800c93e:	e031      	b.n	800c9a4 <_free_r+0x84>
 800c940:	4299      	cmp	r1, r3
 800c942:	d20d      	bcs.n	800c960 <_free_r+0x40>
 800c944:	6808      	ldr	r0, [r1, #0]
 800c946:	180a      	adds	r2, r1, r0
 800c948:	429a      	cmp	r2, r3
 800c94a:	d103      	bne.n	800c954 <_free_r+0x34>
 800c94c:	6813      	ldr	r3, [r2, #0]
 800c94e:	18c3      	adds	r3, r0, r3
 800c950:	600b      	str	r3, [r1, #0]
 800c952:	6853      	ldr	r3, [r2, #4]
 800c954:	604b      	str	r3, [r1, #4]
 800c956:	6021      	str	r1, [r4, #0]
 800c958:	e024      	b.n	800c9a4 <_free_r+0x84>
 800c95a:	428a      	cmp	r2, r1
 800c95c:	d803      	bhi.n	800c966 <_free_r+0x46>
 800c95e:	1c13      	adds	r3, r2, #0
 800c960:	685a      	ldr	r2, [r3, #4]
 800c962:	2a00      	cmp	r2, #0
 800c964:	d1f9      	bne.n	800c95a <_free_r+0x3a>
 800c966:	681d      	ldr	r5, [r3, #0]
 800c968:	195c      	adds	r4, r3, r5
 800c96a:	428c      	cmp	r4, r1
 800c96c:	d10b      	bne.n	800c986 <_free_r+0x66>
 800c96e:	6809      	ldr	r1, [r1, #0]
 800c970:	1869      	adds	r1, r5, r1
 800c972:	1858      	adds	r0, r3, r1
 800c974:	6019      	str	r1, [r3, #0]
 800c976:	4290      	cmp	r0, r2
 800c978:	d114      	bne.n	800c9a4 <_free_r+0x84>
 800c97a:	6810      	ldr	r0, [r2, #0]
 800c97c:	6852      	ldr	r2, [r2, #4]
 800c97e:	1809      	adds	r1, r1, r0
 800c980:	6019      	str	r1, [r3, #0]
 800c982:	605a      	str	r2, [r3, #4]
 800c984:	e00e      	b.n	800c9a4 <_free_r+0x84>
 800c986:	428c      	cmp	r4, r1
 800c988:	d902      	bls.n	800c990 <_free_r+0x70>
 800c98a:	230c      	movs	r3, #12
 800c98c:	6003      	str	r3, [r0, #0]
 800c98e:	e009      	b.n	800c9a4 <_free_r+0x84>
 800c990:	6808      	ldr	r0, [r1, #0]
 800c992:	180c      	adds	r4, r1, r0
 800c994:	4294      	cmp	r4, r2
 800c996:	d103      	bne.n	800c9a0 <_free_r+0x80>
 800c998:	6814      	ldr	r4, [r2, #0]
 800c99a:	6852      	ldr	r2, [r2, #4]
 800c99c:	1900      	adds	r0, r0, r4
 800c99e:	6008      	str	r0, [r1, #0]
 800c9a0:	604a      	str	r2, [r1, #4]
 800c9a2:	6059      	str	r1, [r3, #4]
 800c9a4:	bd30      	pop	{r4, r5, pc}
 800c9a6:	46c0      	nop			; (mov r8, r8)
 800c9a8:	20001d8c 	.word	0x20001d8c

0800c9ac <_malloc_r>:
 800c9ac:	2303      	movs	r3, #3
 800c9ae:	b570      	push	{r4, r5, r6, lr}
 800c9b0:	1ccc      	adds	r4, r1, #3
 800c9b2:	439c      	bics	r4, r3
 800c9b4:	3408      	adds	r4, #8
 800c9b6:	1c05      	adds	r5, r0, #0
 800c9b8:	2c0c      	cmp	r4, #12
 800c9ba:	d201      	bcs.n	800c9c0 <_malloc_r+0x14>
 800c9bc:	240c      	movs	r4, #12
 800c9be:	e005      	b.n	800c9cc <_malloc_r+0x20>
 800c9c0:	2c00      	cmp	r4, #0
 800c9c2:	da03      	bge.n	800c9cc <_malloc_r+0x20>
 800c9c4:	230c      	movs	r3, #12
 800c9c6:	2000      	movs	r0, #0
 800c9c8:	602b      	str	r3, [r5, #0]
 800c9ca:	e042      	b.n	800ca52 <_malloc_r+0xa6>
 800c9cc:	428c      	cmp	r4, r1
 800c9ce:	d3f9      	bcc.n	800c9c4 <_malloc_r+0x18>
 800c9d0:	4a20      	ldr	r2, [pc, #128]	; (800ca54 <_malloc_r+0xa8>)
 800c9d2:	6813      	ldr	r3, [r2, #0]
 800c9d4:	1c10      	adds	r0, r2, #0
 800c9d6:	1c19      	adds	r1, r3, #0
 800c9d8:	2900      	cmp	r1, #0
 800c9da:	d013      	beq.n	800ca04 <_malloc_r+0x58>
 800c9dc:	680a      	ldr	r2, [r1, #0]
 800c9de:	1b12      	subs	r2, r2, r4
 800c9e0:	d40d      	bmi.n	800c9fe <_malloc_r+0x52>
 800c9e2:	2a0b      	cmp	r2, #11
 800c9e4:	d902      	bls.n	800c9ec <_malloc_r+0x40>
 800c9e6:	600a      	str	r2, [r1, #0]
 800c9e8:	188b      	adds	r3, r1, r2
 800c9ea:	e01f      	b.n	800ca2c <_malloc_r+0x80>
 800c9ec:	428b      	cmp	r3, r1
 800c9ee:	d102      	bne.n	800c9f6 <_malloc_r+0x4a>
 800c9f0:	685a      	ldr	r2, [r3, #4]
 800c9f2:	6002      	str	r2, [r0, #0]
 800c9f4:	e01b      	b.n	800ca2e <_malloc_r+0x82>
 800c9f6:	684a      	ldr	r2, [r1, #4]
 800c9f8:	605a      	str	r2, [r3, #4]
 800c9fa:	1c0b      	adds	r3, r1, #0
 800c9fc:	e017      	b.n	800ca2e <_malloc_r+0x82>
 800c9fe:	1c0b      	adds	r3, r1, #0
 800ca00:	6849      	ldr	r1, [r1, #4]
 800ca02:	e7e9      	b.n	800c9d8 <_malloc_r+0x2c>
 800ca04:	4e14      	ldr	r6, [pc, #80]	; (800ca58 <_malloc_r+0xac>)
 800ca06:	6833      	ldr	r3, [r6, #0]
 800ca08:	2b00      	cmp	r3, #0
 800ca0a:	d103      	bne.n	800ca14 <_malloc_r+0x68>
 800ca0c:	1c28      	adds	r0, r5, #0
 800ca0e:	f000 f8bf 	bl	800cb90 <_sbrk_r>
 800ca12:	6030      	str	r0, [r6, #0]
 800ca14:	1c28      	adds	r0, r5, #0
 800ca16:	1c21      	adds	r1, r4, #0
 800ca18:	f000 f8ba 	bl	800cb90 <_sbrk_r>
 800ca1c:	1c03      	adds	r3, r0, #0
 800ca1e:	1c42      	adds	r2, r0, #1
 800ca20:	d0d0      	beq.n	800c9c4 <_malloc_r+0x18>
 800ca22:	2203      	movs	r2, #3
 800ca24:	1cc6      	adds	r6, r0, #3
 800ca26:	4396      	bics	r6, r2
 800ca28:	4286      	cmp	r6, r0
 800ca2a:	d10a      	bne.n	800ca42 <_malloc_r+0x96>
 800ca2c:	601c      	str	r4, [r3, #0]
 800ca2e:	1c18      	adds	r0, r3, #0
 800ca30:	2107      	movs	r1, #7
 800ca32:	300b      	adds	r0, #11
 800ca34:	1d1a      	adds	r2, r3, #4
 800ca36:	4388      	bics	r0, r1
 800ca38:	1a82      	subs	r2, r0, r2
 800ca3a:	d00a      	beq.n	800ca52 <_malloc_r+0xa6>
 800ca3c:	4251      	negs	r1, r2
 800ca3e:	5099      	str	r1, [r3, r2]
 800ca40:	e007      	b.n	800ca52 <_malloc_r+0xa6>
 800ca42:	1a31      	subs	r1, r6, r0
 800ca44:	1c28      	adds	r0, r5, #0
 800ca46:	f000 f8a3 	bl	800cb90 <_sbrk_r>
 800ca4a:	1c43      	adds	r3, r0, #1
 800ca4c:	d0ba      	beq.n	800c9c4 <_malloc_r+0x18>
 800ca4e:	1c33      	adds	r3, r6, #0
 800ca50:	e7ec      	b.n	800ca2c <_malloc_r+0x80>
 800ca52:	bd70      	pop	{r4, r5, r6, pc}
 800ca54:	20001d8c 	.word	0x20001d8c
 800ca58:	20001d88 	.word	0x20001d88

0800ca5c <iprintf>:
 800ca5c:	b40f      	push	{r0, r1, r2, r3}
 800ca5e:	4b0b      	ldr	r3, [pc, #44]	; (800ca8c <iprintf+0x30>)
 800ca60:	b513      	push	{r0, r1, r4, lr}
 800ca62:	681c      	ldr	r4, [r3, #0]
 800ca64:	2c00      	cmp	r4, #0
 800ca66:	d005      	beq.n	800ca74 <iprintf+0x18>
 800ca68:	69a3      	ldr	r3, [r4, #24]
 800ca6a:	2b00      	cmp	r3, #0
 800ca6c:	d102      	bne.n	800ca74 <iprintf+0x18>
 800ca6e:	1c20      	adds	r0, r4, #0
 800ca70:	f000 fdd4 	bl	800d61c <__sinit>
 800ca74:	ab05      	add	r3, sp, #20
 800ca76:	1c20      	adds	r0, r4, #0
 800ca78:	68a1      	ldr	r1, [r4, #8]
 800ca7a:	9a04      	ldr	r2, [sp, #16]
 800ca7c:	9301      	str	r3, [sp, #4]
 800ca7e:	f001 fa1d 	bl	800debc <_vfiprintf_r>
 800ca82:	bc16      	pop	{r1, r2, r4}
 800ca84:	bc08      	pop	{r3}
 800ca86:	b004      	add	sp, #16
 800ca88:	4718      	bx	r3
 800ca8a:	46c0      	nop			; (mov r8, r8)
 800ca8c:	20000130 	.word	0x20000130

0800ca90 <putchar>:
 800ca90:	b538      	push	{r3, r4, r5, lr}
 800ca92:	4b08      	ldr	r3, [pc, #32]	; (800cab4 <putchar+0x24>)
 800ca94:	1c05      	adds	r5, r0, #0
 800ca96:	681c      	ldr	r4, [r3, #0]
 800ca98:	2c00      	cmp	r4, #0
 800ca9a:	d005      	beq.n	800caa8 <putchar+0x18>
 800ca9c:	69a3      	ldr	r3, [r4, #24]
 800ca9e:	2b00      	cmp	r3, #0
 800caa0:	d102      	bne.n	800caa8 <putchar+0x18>
 800caa2:	1c20      	adds	r0, r4, #0
 800caa4:	f000 fdba 	bl	800d61c <__sinit>
 800caa8:	1c29      	adds	r1, r5, #0
 800caaa:	1c20      	adds	r0, r4, #0
 800caac:	68a2      	ldr	r2, [r4, #8]
 800caae:	f001 fdf3 	bl	800e698 <_putc_r>
 800cab2:	bd38      	pop	{r3, r4, r5, pc}
 800cab4:	20000130 	.word	0x20000130

0800cab8 <_puts_r>:
 800cab8:	b570      	push	{r4, r5, r6, lr}
 800caba:	1c05      	adds	r5, r0, #0
 800cabc:	1c0e      	adds	r6, r1, #0
 800cabe:	2800      	cmp	r0, #0
 800cac0:	d004      	beq.n	800cacc <_puts_r+0x14>
 800cac2:	6983      	ldr	r3, [r0, #24]
 800cac4:	2b00      	cmp	r3, #0
 800cac6:	d101      	bne.n	800cacc <_puts_r+0x14>
 800cac8:	f000 fda8 	bl	800d61c <__sinit>
 800cacc:	68ac      	ldr	r4, [r5, #8]
 800cace:	89a3      	ldrh	r3, [r4, #12]
 800cad0:	071b      	lsls	r3, r3, #28
 800cad2:	d502      	bpl.n	800cada <_puts_r+0x22>
 800cad4:	6923      	ldr	r3, [r4, #16]
 800cad6:	2b00      	cmp	r3, #0
 800cad8:	d119      	bne.n	800cb0e <_puts_r+0x56>
 800cada:	1c28      	adds	r0, r5, #0
 800cadc:	1c21      	adds	r1, r4, #0
 800cade:	f000 fc1f 	bl	800d320 <__swsetup_r>
 800cae2:	2800      	cmp	r0, #0
 800cae4:	d013      	beq.n	800cb0e <_puts_r+0x56>
 800cae6:	2001      	movs	r0, #1
 800cae8:	4240      	negs	r0, r0
 800caea:	e045      	b.n	800cb78 <_puts_r+0xc0>
 800caec:	7831      	ldrb	r1, [r6, #0]
 800caee:	2b00      	cmp	r3, #0
 800caf0:	da1b      	bge.n	800cb2a <_puts_r+0x72>
 800caf2:	69a2      	ldr	r2, [r4, #24]
 800caf4:	4293      	cmp	r3, r2
 800caf6:	da11      	bge.n	800cb1c <_puts_r+0x64>
 800caf8:	1c22      	adds	r2, r4, #0
 800cafa:	1c28      	adds	r0, r5, #0
 800cafc:	f000 fba4 	bl	800d248 <__swbuf_r>
 800cb00:	3001      	adds	r0, #1
 800cb02:	4242      	negs	r2, r0
 800cb04:	4142      	adcs	r2, r0
 800cb06:	b2d0      	uxtb	r0, r2
 800cb08:	2800      	cmp	r0, #0
 800cb0a:	d1ec      	bne.n	800cae6 <_puts_r+0x2e>
 800cb0c:	3601      	adds	r6, #1
 800cb0e:	68a3      	ldr	r3, [r4, #8]
 800cb10:	7832      	ldrb	r2, [r6, #0]
 800cb12:	3b01      	subs	r3, #1
 800cb14:	60a3      	str	r3, [r4, #8]
 800cb16:	2a00      	cmp	r2, #0
 800cb18:	d1e8      	bne.n	800caec <_puts_r+0x34>
 800cb1a:	e00c      	b.n	800cb36 <_puts_r+0x7e>
 800cb1c:	6823      	ldr	r3, [r4, #0]
 800cb1e:	7019      	strb	r1, [r3, #0]
 800cb20:	6823      	ldr	r3, [r4, #0]
 800cb22:	7819      	ldrb	r1, [r3, #0]
 800cb24:	290a      	cmp	r1, #10
 800cb26:	d103      	bne.n	800cb30 <_puts_r+0x78>
 800cb28:	e7e6      	b.n	800caf8 <_puts_r+0x40>
 800cb2a:	6823      	ldr	r3, [r4, #0]
 800cb2c:	7019      	strb	r1, [r3, #0]
 800cb2e:	6823      	ldr	r3, [r4, #0]
 800cb30:	3301      	adds	r3, #1
 800cb32:	6023      	str	r3, [r4, #0]
 800cb34:	e7ea      	b.n	800cb0c <_puts_r+0x54>
 800cb36:	2b00      	cmp	r3, #0
 800cb38:	da17      	bge.n	800cb6a <_puts_r+0xb2>
 800cb3a:	69a2      	ldr	r2, [r4, #24]
 800cb3c:	4293      	cmp	r3, r2
 800cb3e:	db08      	blt.n	800cb52 <_puts_r+0x9a>
 800cb40:	230a      	movs	r3, #10
 800cb42:	6822      	ldr	r2, [r4, #0]
 800cb44:	7013      	strb	r3, [r2, #0]
 800cb46:	6823      	ldr	r3, [r4, #0]
 800cb48:	7819      	ldrb	r1, [r3, #0]
 800cb4a:	290a      	cmp	r1, #10
 800cb4c:	d111      	bne.n	800cb72 <_puts_r+0xba>
 800cb4e:	1c28      	adds	r0, r5, #0
 800cb50:	e001      	b.n	800cb56 <_puts_r+0x9e>
 800cb52:	1c28      	adds	r0, r5, #0
 800cb54:	210a      	movs	r1, #10
 800cb56:	1c22      	adds	r2, r4, #0
 800cb58:	f000 fb76 	bl	800d248 <__swbuf_r>
 800cb5c:	3001      	adds	r0, #1
 800cb5e:	4242      	negs	r2, r0
 800cb60:	4142      	adcs	r2, r0
 800cb62:	b2d0      	uxtb	r0, r2
 800cb64:	2800      	cmp	r0, #0
 800cb66:	d006      	beq.n	800cb76 <_puts_r+0xbe>
 800cb68:	e7bd      	b.n	800cae6 <_puts_r+0x2e>
 800cb6a:	230a      	movs	r3, #10
 800cb6c:	6822      	ldr	r2, [r4, #0]
 800cb6e:	7013      	strb	r3, [r2, #0]
 800cb70:	6823      	ldr	r3, [r4, #0]
 800cb72:	3301      	adds	r3, #1
 800cb74:	6023      	str	r3, [r4, #0]
 800cb76:	200a      	movs	r0, #10
 800cb78:	bd70      	pop	{r4, r5, r6, pc}
	...

0800cb7c <puts>:
 800cb7c:	b508      	push	{r3, lr}
 800cb7e:	4b03      	ldr	r3, [pc, #12]	; (800cb8c <puts+0x10>)
 800cb80:	1c01      	adds	r1, r0, #0
 800cb82:	6818      	ldr	r0, [r3, #0]
 800cb84:	f7ff ff98 	bl	800cab8 <_puts_r>
 800cb88:	bd08      	pop	{r3, pc}
 800cb8a:	46c0      	nop			; (mov r8, r8)
 800cb8c:	20000130 	.word	0x20000130

0800cb90 <_sbrk_r>:
 800cb90:	b538      	push	{r3, r4, r5, lr}
 800cb92:	2300      	movs	r3, #0
 800cb94:	4c06      	ldr	r4, [pc, #24]	; (800cbb0 <_sbrk_r+0x20>)
 800cb96:	1c05      	adds	r5, r0, #0
 800cb98:	1c08      	adds	r0, r1, #0
 800cb9a:	6023      	str	r3, [r4, #0]
 800cb9c:	f001 fed6 	bl	800e94c <_sbrk>
 800cba0:	1c43      	adds	r3, r0, #1
 800cba2:	d103      	bne.n	800cbac <_sbrk_r+0x1c>
 800cba4:	6823      	ldr	r3, [r4, #0]
 800cba6:	2b00      	cmp	r3, #0
 800cba8:	d000      	beq.n	800cbac <_sbrk_r+0x1c>
 800cbaa:	602b      	str	r3, [r5, #0]
 800cbac:	bd38      	pop	{r3, r4, r5, pc}
 800cbae:	46c0      	nop			; (mov r8, r8)
 800cbb0:	20002190 	.word	0x20002190

0800cbb4 <setjmp>:
 800cbb4:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800cbb6:	4641      	mov	r1, r8
 800cbb8:	464a      	mov	r2, r9
 800cbba:	4653      	mov	r3, sl
 800cbbc:	465c      	mov	r4, fp
 800cbbe:	466d      	mov	r5, sp
 800cbc0:	4676      	mov	r6, lr
 800cbc2:	c07e      	stmia	r0!, {r1, r2, r3, r4, r5, r6}
 800cbc4:	3828      	subs	r0, #40	; 0x28
 800cbc6:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800cbc8:	2000      	movs	r0, #0
 800cbca:	4770      	bx	lr

0800cbcc <longjmp>:
 800cbcc:	3010      	adds	r0, #16
 800cbce:	c87c      	ldmia	r0!, {r2, r3, r4, r5, r6}
 800cbd0:	4690      	mov	r8, r2
 800cbd2:	4699      	mov	r9, r3
 800cbd4:	46a2      	mov	sl, r4
 800cbd6:	46ab      	mov	fp, r5
 800cbd8:	46b5      	mov	sp, r6
 800cbda:	c808      	ldmia	r0!, {r3}
 800cbdc:	3828      	subs	r0, #40	; 0x28
 800cbde:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800cbe0:	1c08      	adds	r0, r1, #0
 800cbe2:	d100      	bne.n	800cbe6 <longjmp+0x1a>
 800cbe4:	2001      	movs	r0, #1
 800cbe6:	4718      	bx	r3

0800cbe8 <_raise_r>:
 800cbe8:	b538      	push	{r3, r4, r5, lr}
 800cbea:	291f      	cmp	r1, #31
 800cbec:	d904      	bls.n	800cbf8 <_raise_r+0x10>
 800cbee:	2316      	movs	r3, #22
 800cbf0:	6003      	str	r3, [r0, #0]
 800cbf2:	2001      	movs	r0, #1
 800cbf4:	4240      	negs	r0, r0
 800cbf6:	e020      	b.n	800cc3a <_raise_r+0x52>
 800cbf8:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800cbfa:	1c0d      	adds	r5, r1, #0
 800cbfc:	1c04      	adds	r4, r0, #0
 800cbfe:	2a00      	cmp	r2, #0
 800cc00:	d004      	beq.n	800cc0c <_raise_r+0x24>
 800cc02:	008b      	lsls	r3, r1, #2
 800cc04:	18d2      	adds	r2, r2, r3
 800cc06:	6813      	ldr	r3, [r2, #0]
 800cc08:	2b00      	cmp	r3, #0
 800cc0a:	d108      	bne.n	800cc1e <_raise_r+0x36>
 800cc0c:	1c20      	adds	r0, r4, #0
 800cc0e:	f000 f831 	bl	800cc74 <_getpid_r>
 800cc12:	1c2a      	adds	r2, r5, #0
 800cc14:	1c01      	adds	r1, r0, #0
 800cc16:	1c20      	adds	r0, r4, #0
 800cc18:	f000 f81a 	bl	800cc50 <_kill_r>
 800cc1c:	e00d      	b.n	800cc3a <_raise_r+0x52>
 800cc1e:	2000      	movs	r0, #0
 800cc20:	2b01      	cmp	r3, #1
 800cc22:	d00a      	beq.n	800cc3a <_raise_r+0x52>
 800cc24:	1c59      	adds	r1, r3, #1
 800cc26:	d103      	bne.n	800cc30 <_raise_r+0x48>
 800cc28:	3317      	adds	r3, #23
 800cc2a:	6023      	str	r3, [r4, #0]
 800cc2c:	3001      	adds	r0, #1
 800cc2e:	e004      	b.n	800cc3a <_raise_r+0x52>
 800cc30:	2400      	movs	r4, #0
 800cc32:	1c28      	adds	r0, r5, #0
 800cc34:	6014      	str	r4, [r2, #0]
 800cc36:	4798      	blx	r3
 800cc38:	1c20      	adds	r0, r4, #0
 800cc3a:	bd38      	pop	{r3, r4, r5, pc}

0800cc3c <raise>:
 800cc3c:	b508      	push	{r3, lr}
 800cc3e:	4b03      	ldr	r3, [pc, #12]	; (800cc4c <raise+0x10>)
 800cc40:	1c01      	adds	r1, r0, #0
 800cc42:	6818      	ldr	r0, [r3, #0]
 800cc44:	f7ff ffd0 	bl	800cbe8 <_raise_r>
 800cc48:	bd08      	pop	{r3, pc}
 800cc4a:	46c0      	nop			; (mov r8, r8)
 800cc4c:	20000130 	.word	0x20000130

0800cc50 <_kill_r>:
 800cc50:	b538      	push	{r3, r4, r5, lr}
 800cc52:	2300      	movs	r3, #0
 800cc54:	4c06      	ldr	r4, [pc, #24]	; (800cc70 <_kill_r+0x20>)
 800cc56:	1c05      	adds	r5, r0, #0
 800cc58:	1c08      	adds	r0, r1, #0
 800cc5a:	1c11      	adds	r1, r2, #0
 800cc5c:	6023      	str	r3, [r4, #0]
 800cc5e:	f001 fe5d 	bl	800e91c <_kill>
 800cc62:	1c43      	adds	r3, r0, #1
 800cc64:	d103      	bne.n	800cc6e <_kill_r+0x1e>
 800cc66:	6823      	ldr	r3, [r4, #0]
 800cc68:	2b00      	cmp	r3, #0
 800cc6a:	d000      	beq.n	800cc6e <_kill_r+0x1e>
 800cc6c:	602b      	str	r3, [r5, #0]
 800cc6e:	bd38      	pop	{r3, r4, r5, pc}
 800cc70:	20002190 	.word	0x20002190

0800cc74 <_getpid_r>:
 800cc74:	b508      	push	{r3, lr}
 800cc76:	f001 fe41 	bl	800e8fc <_getpid>
 800cc7a:	bd08      	pop	{r3, pc}

0800cc7c <sniprintf>:
 800cc7c:	b40c      	push	{r2, r3}
 800cc7e:	b530      	push	{r4, r5, lr}
 800cc80:	4b17      	ldr	r3, [pc, #92]	; (800cce0 <sniprintf+0x64>)
 800cc82:	b09d      	sub	sp, #116	; 0x74
 800cc84:	681d      	ldr	r5, [r3, #0]
 800cc86:	2900      	cmp	r1, #0
 800cc88:	da04      	bge.n	800cc94 <sniprintf+0x18>
 800cc8a:	238b      	movs	r3, #139	; 0x8b
 800cc8c:	2001      	movs	r0, #1
 800cc8e:	602b      	str	r3, [r5, #0]
 800cc90:	4240      	negs	r0, r0
 800cc92:	e01f      	b.n	800ccd4 <sniprintf+0x58>
 800cc94:	2382      	movs	r3, #130	; 0x82
 800cc96:	aa02      	add	r2, sp, #8
 800cc98:	009b      	lsls	r3, r3, #2
 800cc9a:	8193      	strh	r3, [r2, #12]
 800cc9c:	2300      	movs	r3, #0
 800cc9e:	9002      	str	r0, [sp, #8]
 800cca0:	6110      	str	r0, [r2, #16]
 800cca2:	4299      	cmp	r1, r3
 800cca4:	d000      	beq.n	800cca8 <sniprintf+0x2c>
 800cca6:	1e4b      	subs	r3, r1, #1
 800cca8:	6093      	str	r3, [r2, #8]
 800ccaa:	6153      	str	r3, [r2, #20]
 800ccac:	2301      	movs	r3, #1
 800ccae:	425b      	negs	r3, r3
 800ccb0:	81d3      	strh	r3, [r2, #14]
 800ccb2:	1c0c      	adds	r4, r1, #0
 800ccb4:	ab21      	add	r3, sp, #132	; 0x84
 800ccb6:	1c11      	adds	r1, r2, #0
 800ccb8:	1c28      	adds	r0, r5, #0
 800ccba:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800ccbc:	9301      	str	r3, [sp, #4]
 800ccbe:	f000 fe0b 	bl	800d8d8 <_svfiprintf_r>
 800ccc2:	1c43      	adds	r3, r0, #1
 800ccc4:	da01      	bge.n	800ccca <sniprintf+0x4e>
 800ccc6:	238b      	movs	r3, #139	; 0x8b
 800ccc8:	602b      	str	r3, [r5, #0]
 800ccca:	2c00      	cmp	r4, #0
 800cccc:	d002      	beq.n	800ccd4 <sniprintf+0x58>
 800ccce:	2300      	movs	r3, #0
 800ccd0:	9a02      	ldr	r2, [sp, #8]
 800ccd2:	7013      	strb	r3, [r2, #0]
 800ccd4:	b01d      	add	sp, #116	; 0x74
 800ccd6:	bc30      	pop	{r4, r5}
 800ccd8:	bc08      	pop	{r3}
 800ccda:	b002      	add	sp, #8
 800ccdc:	4718      	bx	r3
 800ccde:	46c0      	nop			; (mov r8, r8)
 800cce0:	20000130 	.word	0x20000130

0800cce4 <siprintf>:
 800cce4:	b40e      	push	{r1, r2, r3}
 800cce6:	b510      	push	{r4, lr}
 800cce8:	b09d      	sub	sp, #116	; 0x74
 800ccea:	a902      	add	r1, sp, #8
 800ccec:	9002      	str	r0, [sp, #8]
 800ccee:	6108      	str	r0, [r1, #16]
 800ccf0:	480b      	ldr	r0, [pc, #44]	; (800cd20 <siprintf+0x3c>)
 800ccf2:	2482      	movs	r4, #130	; 0x82
 800ccf4:	6088      	str	r0, [r1, #8]
 800ccf6:	6148      	str	r0, [r1, #20]
 800ccf8:	2001      	movs	r0, #1
 800ccfa:	4240      	negs	r0, r0
 800ccfc:	ab1f      	add	r3, sp, #124	; 0x7c
 800ccfe:	81c8      	strh	r0, [r1, #14]
 800cd00:	4808      	ldr	r0, [pc, #32]	; (800cd24 <siprintf+0x40>)
 800cd02:	cb04      	ldmia	r3!, {r2}
 800cd04:	00a4      	lsls	r4, r4, #2
 800cd06:	6800      	ldr	r0, [r0, #0]
 800cd08:	9301      	str	r3, [sp, #4]
 800cd0a:	818c      	strh	r4, [r1, #12]
 800cd0c:	f000 fde4 	bl	800d8d8 <_svfiprintf_r>
 800cd10:	2300      	movs	r3, #0
 800cd12:	9a02      	ldr	r2, [sp, #8]
 800cd14:	7013      	strb	r3, [r2, #0]
 800cd16:	b01d      	add	sp, #116	; 0x74
 800cd18:	bc10      	pop	{r4}
 800cd1a:	bc08      	pop	{r3}
 800cd1c:	b003      	add	sp, #12
 800cd1e:	4718      	bx	r3
 800cd20:	7fffffff 	.word	0x7fffffff
 800cd24:	20000130 	.word	0x20000130

0800cd28 <siscanf>:
 800cd28:	b40e      	push	{r1, r2, r3}
 800cd2a:	2381      	movs	r3, #129	; 0x81
 800cd2c:	b570      	push	{r4, r5, r6, lr}
 800cd2e:	b09d      	sub	sp, #116	; 0x74
 800cd30:	ac02      	add	r4, sp, #8
 800cd32:	ad21      	add	r5, sp, #132	; 0x84
 800cd34:	009b      	lsls	r3, r3, #2
 800cd36:	cd40      	ldmia	r5!, {r6}
 800cd38:	81a3      	strh	r3, [r4, #12]
 800cd3a:	9002      	str	r0, [sp, #8]
 800cd3c:	9006      	str	r0, [sp, #24]
 800cd3e:	f000 f873 	bl	800ce28 <strlen>
 800cd42:	4b0b      	ldr	r3, [pc, #44]	; (800cd70 <siscanf+0x48>)
 800cd44:	6060      	str	r0, [r4, #4]
 800cd46:	6263      	str	r3, [r4, #36]	; 0x24
 800cd48:	2300      	movs	r3, #0
 800cd4a:	6363      	str	r3, [r4, #52]	; 0x34
 800cd4c:	64a3      	str	r3, [r4, #72]	; 0x48
 800cd4e:	3b01      	subs	r3, #1
 800cd50:	81e3      	strh	r3, [r4, #14]
 800cd52:	4b08      	ldr	r3, [pc, #32]	; (800cd74 <siscanf+0x4c>)
 800cd54:	6160      	str	r0, [r4, #20]
 800cd56:	1c21      	adds	r1, r4, #0
 800cd58:	6818      	ldr	r0, [r3, #0]
 800cd5a:	1c32      	adds	r2, r6, #0
 800cd5c:	1c2b      	adds	r3, r5, #0
 800cd5e:	9501      	str	r5, [sp, #4]
 800cd60:	f000 ff0c 	bl	800db7c <__ssvfiscanf_r>
 800cd64:	b01d      	add	sp, #116	; 0x74
 800cd66:	bc70      	pop	{r4, r5, r6}
 800cd68:	bc08      	pop	{r3}
 800cd6a:	b003      	add	sp, #12
 800cd6c:	4718      	bx	r3
 800cd6e:	46c0      	nop			; (mov r8, r8)
 800cd70:	0800cda1 	.word	0x0800cda1
 800cd74:	20000130 	.word	0x20000130

0800cd78 <__sread>:
 800cd78:	b538      	push	{r3, r4, r5, lr}
 800cd7a:	1c0c      	adds	r4, r1, #0
 800cd7c:	250e      	movs	r5, #14
 800cd7e:	5f49      	ldrsh	r1, [r1, r5]
 800cd80:	f001 fcc6 	bl	800e710 <_read_r>
 800cd84:	2800      	cmp	r0, #0
 800cd86:	db03      	blt.n	800cd90 <__sread+0x18>
 800cd88:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800cd8a:	181b      	adds	r3, r3, r0
 800cd8c:	6563      	str	r3, [r4, #84]	; 0x54
 800cd8e:	e003      	b.n	800cd98 <__sread+0x20>
 800cd90:	89a2      	ldrh	r2, [r4, #12]
 800cd92:	4b02      	ldr	r3, [pc, #8]	; (800cd9c <__sread+0x24>)
 800cd94:	4013      	ands	r3, r2
 800cd96:	81a3      	strh	r3, [r4, #12]
 800cd98:	bd38      	pop	{r3, r4, r5, pc}
 800cd9a:	46c0      	nop			; (mov r8, r8)
 800cd9c:	ffffefff 	.word	0xffffefff

0800cda0 <__seofread>:
 800cda0:	2000      	movs	r0, #0
 800cda2:	4770      	bx	lr

0800cda4 <__swrite>:
 800cda4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cda6:	1c1e      	adds	r6, r3, #0
 800cda8:	898b      	ldrh	r3, [r1, #12]
 800cdaa:	1c05      	adds	r5, r0, #0
 800cdac:	1c0c      	adds	r4, r1, #0
 800cdae:	1c17      	adds	r7, r2, #0
 800cdb0:	05db      	lsls	r3, r3, #23
 800cdb2:	d505      	bpl.n	800cdc0 <__swrite+0x1c>
 800cdb4:	230e      	movs	r3, #14
 800cdb6:	5ec9      	ldrsh	r1, [r1, r3]
 800cdb8:	2200      	movs	r2, #0
 800cdba:	2302      	movs	r3, #2
 800cdbc:	f000 fcc0 	bl	800d740 <_lseek_r>
 800cdc0:	89a2      	ldrh	r2, [r4, #12]
 800cdc2:	4b05      	ldr	r3, [pc, #20]	; (800cdd8 <__swrite+0x34>)
 800cdc4:	1c28      	adds	r0, r5, #0
 800cdc6:	4013      	ands	r3, r2
 800cdc8:	81a3      	strh	r3, [r4, #12]
 800cdca:	1c3a      	adds	r2, r7, #0
 800cdcc:	230e      	movs	r3, #14
 800cdce:	5ee1      	ldrsh	r1, [r4, r3]
 800cdd0:	1c33      	adds	r3, r6, #0
 800cdd2:	f000 fa91 	bl	800d2f8 <_write_r>
 800cdd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cdd8:	ffffefff 	.word	0xffffefff

0800cddc <__sseek>:
 800cddc:	b538      	push	{r3, r4, r5, lr}
 800cdde:	1c0c      	adds	r4, r1, #0
 800cde0:	250e      	movs	r5, #14
 800cde2:	5f49      	ldrsh	r1, [r1, r5]
 800cde4:	f000 fcac 	bl	800d740 <_lseek_r>
 800cde8:	89a3      	ldrh	r3, [r4, #12]
 800cdea:	1c42      	adds	r2, r0, #1
 800cdec:	d103      	bne.n	800cdf6 <__sseek+0x1a>
 800cdee:	4a05      	ldr	r2, [pc, #20]	; (800ce04 <__sseek+0x28>)
 800cdf0:	4013      	ands	r3, r2
 800cdf2:	81a3      	strh	r3, [r4, #12]
 800cdf4:	e004      	b.n	800ce00 <__sseek+0x24>
 800cdf6:	2280      	movs	r2, #128	; 0x80
 800cdf8:	0152      	lsls	r2, r2, #5
 800cdfa:	4313      	orrs	r3, r2
 800cdfc:	81a3      	strh	r3, [r4, #12]
 800cdfe:	6560      	str	r0, [r4, #84]	; 0x54
 800ce00:	bd38      	pop	{r3, r4, r5, pc}
 800ce02:	46c0      	nop			; (mov r8, r8)
 800ce04:	ffffefff 	.word	0xffffefff

0800ce08 <__sclose>:
 800ce08:	b508      	push	{r3, lr}
 800ce0a:	230e      	movs	r3, #14
 800ce0c:	5ec9      	ldrsh	r1, [r1, r3]
 800ce0e:	f000 fafb 	bl	800d408 <_close_r>
 800ce12:	bd08      	pop	{r3, pc}

0800ce14 <strcmp>:
 800ce14:	7802      	ldrb	r2, [r0, #0]
 800ce16:	780b      	ldrb	r3, [r1, #0]
 800ce18:	2a00      	cmp	r2, #0
 800ce1a:	d003      	beq.n	800ce24 <strcmp+0x10>
 800ce1c:	3001      	adds	r0, #1
 800ce1e:	3101      	adds	r1, #1
 800ce20:	429a      	cmp	r2, r3
 800ce22:	d0f7      	beq.n	800ce14 <strcmp>
 800ce24:	1ad0      	subs	r0, r2, r3
 800ce26:	4770      	bx	lr

0800ce28 <strlen>:
 800ce28:	2300      	movs	r3, #0
 800ce2a:	5cc2      	ldrb	r2, [r0, r3]
 800ce2c:	3301      	adds	r3, #1
 800ce2e:	2a00      	cmp	r2, #0
 800ce30:	d1fb      	bne.n	800ce2a <strlen+0x2>
 800ce32:	1e58      	subs	r0, r3, #1
 800ce34:	4770      	bx	lr
	...

0800ce38 <strncasecmp>:
 800ce38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ce3a:	2500      	movs	r5, #0
 800ce3c:	4b10      	ldr	r3, [pc, #64]	; (800ce80 <strncasecmp+0x48>)
 800ce3e:	9201      	str	r2, [sp, #4]
 800ce40:	681e      	ldr	r6, [r3, #0]
 800ce42:	9b01      	ldr	r3, [sp, #4]
 800ce44:	429d      	cmp	r5, r3
 800ce46:	d017      	beq.n	800ce78 <strncasecmp+0x40>
 800ce48:	5d43      	ldrb	r3, [r0, r5]
 800ce4a:	18f4      	adds	r4, r6, r3
 800ce4c:	7867      	ldrb	r7, [r4, #1]
 800ce4e:	2403      	movs	r4, #3
 800ce50:	403c      	ands	r4, r7
 800ce52:	2c01      	cmp	r4, #1
 800ce54:	d100      	bne.n	800ce58 <strncasecmp+0x20>
 800ce56:	3320      	adds	r3, #32
 800ce58:	5d4c      	ldrb	r4, [r1, r5]
 800ce5a:	1937      	adds	r7, r6, r4
 800ce5c:	787f      	ldrb	r7, [r7, #1]
 800ce5e:	46bc      	mov	ip, r7
 800ce60:	2703      	movs	r7, #3
 800ce62:	4662      	mov	r2, ip
 800ce64:	4017      	ands	r7, r2
 800ce66:	2f01      	cmp	r7, #1
 800ce68:	d100      	bne.n	800ce6c <strncasecmp+0x34>
 800ce6a:	3420      	adds	r4, #32
 800ce6c:	1b1b      	subs	r3, r3, r4
 800ce6e:	d104      	bne.n	800ce7a <strncasecmp+0x42>
 800ce70:	3501      	adds	r5, #1
 800ce72:	2c00      	cmp	r4, #0
 800ce74:	d1e5      	bne.n	800ce42 <strncasecmp+0xa>
 800ce76:	e000      	b.n	800ce7a <strncasecmp+0x42>
 800ce78:	2300      	movs	r3, #0
 800ce7a:	1c18      	adds	r0, r3, #0
 800ce7c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800ce7e:	46c0      	nop			; (mov r8, r8)
 800ce80:	20000134 	.word	0x20000134

0800ce84 <strncmp>:
 800ce84:	2300      	movs	r3, #0
 800ce86:	b530      	push	{r4, r5, lr}
 800ce88:	429a      	cmp	r2, r3
 800ce8a:	d00d      	beq.n	800cea8 <strncmp+0x24>
 800ce8c:	3a01      	subs	r2, #1
 800ce8e:	5cc4      	ldrb	r4, [r0, r3]
 800ce90:	5ccd      	ldrb	r5, [r1, r3]
 800ce92:	42ac      	cmp	r4, r5
 800ce94:	d102      	bne.n	800ce9c <strncmp+0x18>
 800ce96:	4293      	cmp	r3, r2
 800ce98:	d102      	bne.n	800cea0 <strncmp+0x1c>
 800ce9a:	1c25      	adds	r5, r4, #0
 800ce9c:	1b63      	subs	r3, r4, r5
 800ce9e:	e003      	b.n	800cea8 <strncmp+0x24>
 800cea0:	3301      	adds	r3, #1
 800cea2:	2c00      	cmp	r4, #0
 800cea4:	d1f3      	bne.n	800ce8e <strncmp+0xa>
 800cea6:	e7f8      	b.n	800ce9a <strncmp+0x16>
 800cea8:	1c18      	adds	r0, r3, #0
 800ceaa:	bd30      	pop	{r4, r5, pc}

0800ceac <strncpy>:
 800ceac:	1c03      	adds	r3, r0, #0
 800ceae:	b530      	push	{r4, r5, lr}
 800ceb0:	2a00      	cmp	r2, #0
 800ceb2:	d007      	beq.n	800cec4 <strncpy+0x18>
 800ceb4:	780c      	ldrb	r4, [r1, #0]
 800ceb6:	3301      	adds	r3, #1
 800ceb8:	1e5d      	subs	r5, r3, #1
 800ceba:	3a01      	subs	r2, #1
 800cebc:	702c      	strb	r4, [r5, #0]
 800cebe:	3101      	adds	r1, #1
 800cec0:	2c00      	cmp	r4, #0
 800cec2:	d1f5      	bne.n	800ceb0 <strncpy+0x4>
 800cec4:	189a      	adds	r2, r3, r2
 800cec6:	4293      	cmp	r3, r2
 800cec8:	d003      	beq.n	800ced2 <strncpy+0x26>
 800ceca:	2100      	movs	r1, #0
 800cecc:	7019      	strb	r1, [r3, #0]
 800cece:	3301      	adds	r3, #1
 800ced0:	e7f9      	b.n	800cec6 <strncpy+0x1a>
 800ced2:	bd30      	pop	{r4, r5, pc}

0800ced4 <strtok>:
 800ced4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ced6:	4b17      	ldr	r3, [pc, #92]	; (800cf34 <strtok+0x60>)
 800ced8:	1c07      	adds	r7, r0, #0
 800ceda:	681d      	ldr	r5, [r3, #0]
 800cedc:	1c0e      	adds	r6, r1, #0
 800cede:	6dac      	ldr	r4, [r5, #88]	; 0x58
 800cee0:	2c00      	cmp	r4, #0
 800cee2:	d11f      	bne.n	800cf24 <strtok+0x50>
 800cee4:	2050      	movs	r0, #80	; 0x50
 800cee6:	f7ff fcd3 	bl	800c890 <malloc>
 800ceea:	65a8      	str	r0, [r5, #88]	; 0x58
 800ceec:	6084      	str	r4, [r0, #8]
 800ceee:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cef0:	6004      	str	r4, [r0, #0]
 800cef2:	6044      	str	r4, [r0, #4]
 800cef4:	611c      	str	r4, [r3, #16]
 800cef6:	60dc      	str	r4, [r3, #12]
 800cef8:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cefa:	619c      	str	r4, [r3, #24]
 800cefc:	615c      	str	r4, [r3, #20]
 800cefe:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf00:	62dc      	str	r4, [r3, #44]	; 0x2c
 800cf02:	629c      	str	r4, [r3, #40]	; 0x28
 800cf04:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf06:	635c      	str	r4, [r3, #52]	; 0x34
 800cf08:	631c      	str	r4, [r3, #48]	; 0x30
 800cf0a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf0c:	63dc      	str	r4, [r3, #60]	; 0x3c
 800cf0e:	639c      	str	r4, [r3, #56]	; 0x38
 800cf10:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf12:	645c      	str	r4, [r3, #68]	; 0x44
 800cf14:	641c      	str	r4, [r3, #64]	; 0x40
 800cf16:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf18:	64dc      	str	r4, [r3, #76]	; 0x4c
 800cf1a:	649c      	str	r4, [r3, #72]	; 0x48
 800cf1c:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf1e:	771c      	strb	r4, [r3, #28]
 800cf20:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800cf22:	625c      	str	r4, [r3, #36]	; 0x24
 800cf24:	1c38      	adds	r0, r7, #0
 800cf26:	1c31      	adds	r1, r6, #0
 800cf28:	6daa      	ldr	r2, [r5, #88]	; 0x58
 800cf2a:	2301      	movs	r3, #1
 800cf2c:	f000 f804 	bl	800cf38 <__strtok_r>
 800cf30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cf32:	46c0      	nop			; (mov r8, r8)
 800cf34:	20000130 	.word	0x20000130

0800cf38 <__strtok_r>:
 800cf38:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cf3a:	1e04      	subs	r4, r0, #0
 800cf3c:	d10c      	bne.n	800cf58 <__strtok_r+0x20>
 800cf3e:	6814      	ldr	r4, [r2, #0]
 800cf40:	1e20      	subs	r0, r4, #0
 800cf42:	d109      	bne.n	800cf58 <__strtok_r+0x20>
 800cf44:	e026      	b.n	800cf94 <__strtok_r+0x5c>
 800cf46:	7837      	ldrb	r7, [r6, #0]
 800cf48:	2f00      	cmp	r7, #0
 800cf4a:	d00c      	beq.n	800cf66 <__strtok_r+0x2e>
 800cf4c:	3601      	adds	r6, #1
 800cf4e:	42b8      	cmp	r0, r7
 800cf50:	d1f9      	bne.n	800cf46 <__strtok_r+0xe>
 800cf52:	2b00      	cmp	r3, #0
 800cf54:	d004      	beq.n	800cf60 <__strtok_r+0x28>
 800cf56:	1c2c      	adds	r4, r5, #0
 800cf58:	1c65      	adds	r5, r4, #1
 800cf5a:	7820      	ldrb	r0, [r4, #0]
 800cf5c:	1c0e      	adds	r6, r1, #0
 800cf5e:	e7f2      	b.n	800cf46 <__strtok_r+0xe>
 800cf60:	6015      	str	r5, [r2, #0]
 800cf62:	7023      	strb	r3, [r4, #0]
 800cf64:	e015      	b.n	800cf92 <__strtok_r+0x5a>
 800cf66:	2800      	cmp	r0, #0
 800cf68:	d108      	bne.n	800cf7c <__strtok_r+0x44>
 800cf6a:	6010      	str	r0, [r2, #0]
 800cf6c:	e012      	b.n	800cf94 <__strtok_r+0x5c>
 800cf6e:	7807      	ldrb	r7, [r0, #0]
 800cf70:	42b7      	cmp	r7, r6
 800cf72:	d007      	beq.n	800cf84 <__strtok_r+0x4c>
 800cf74:	3001      	adds	r0, #1
 800cf76:	2f00      	cmp	r7, #0
 800cf78:	d1f9      	bne.n	800cf6e <__strtok_r+0x36>
 800cf7a:	1c1d      	adds	r5, r3, #0
 800cf7c:	1c6b      	adds	r3, r5, #1
 800cf7e:	782e      	ldrb	r6, [r5, #0]
 800cf80:	1c08      	adds	r0, r1, #0
 800cf82:	e7f4      	b.n	800cf6e <__strtok_r+0x36>
 800cf84:	2e00      	cmp	r6, #0
 800cf86:	d002      	beq.n	800cf8e <__strtok_r+0x56>
 800cf88:	2100      	movs	r1, #0
 800cf8a:	7029      	strb	r1, [r5, #0]
 800cf8c:	e000      	b.n	800cf90 <__strtok_r+0x58>
 800cf8e:	1c33      	adds	r3, r6, #0
 800cf90:	6013      	str	r3, [r2, #0]
 800cf92:	1c20      	adds	r0, r4, #0
 800cf94:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800cf98 <_strtol_r>:
 800cf98:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cf9a:	1c1e      	adds	r6, r3, #0
 800cf9c:	4b44      	ldr	r3, [pc, #272]	; (800d0b0 <_strtol_r+0x118>)
 800cf9e:	b087      	sub	sp, #28
 800cfa0:	681b      	ldr	r3, [r3, #0]
 800cfa2:	9005      	str	r0, [sp, #20]
 800cfa4:	9302      	str	r3, [sp, #8]
 800cfa6:	1c0b      	adds	r3, r1, #0
 800cfa8:	9103      	str	r1, [sp, #12]
 800cfaa:	9201      	str	r2, [sp, #4]
 800cfac:	781c      	ldrb	r4, [r3, #0]
 800cfae:	9a02      	ldr	r2, [sp, #8]
 800cfb0:	1c5d      	adds	r5, r3, #1
 800cfb2:	1912      	adds	r2, r2, r4
 800cfb4:	7850      	ldrb	r0, [r2, #1]
 800cfb6:	2208      	movs	r2, #8
 800cfb8:	4010      	ands	r0, r2
 800cfba:	d001      	beq.n	800cfc0 <_strtol_r+0x28>
 800cfbc:	1c2b      	adds	r3, r5, #0
 800cfbe:	e7f5      	b.n	800cfac <_strtol_r+0x14>
 800cfc0:	2c2d      	cmp	r4, #45	; 0x2d
 800cfc2:	d104      	bne.n	800cfce <_strtol_r+0x36>
 800cfc4:	1c9d      	adds	r5, r3, #2
 800cfc6:	785c      	ldrb	r4, [r3, #1]
 800cfc8:	2301      	movs	r3, #1
 800cfca:	9300      	str	r3, [sp, #0]
 800cfcc:	e004      	b.n	800cfd8 <_strtol_r+0x40>
 800cfce:	9000      	str	r0, [sp, #0]
 800cfd0:	2c2b      	cmp	r4, #43	; 0x2b
 800cfd2:	d101      	bne.n	800cfd8 <_strtol_r+0x40>
 800cfd4:	785c      	ldrb	r4, [r3, #1]
 800cfd6:	1c9d      	adds	r5, r3, #2
 800cfd8:	2e00      	cmp	r6, #0
 800cfda:	d002      	beq.n	800cfe2 <_strtol_r+0x4a>
 800cfdc:	2e10      	cmp	r6, #16
 800cfde:	d10a      	bne.n	800cff6 <_strtol_r+0x5e>
 800cfe0:	e060      	b.n	800d0a4 <_strtol_r+0x10c>
 800cfe2:	2c30      	cmp	r4, #48	; 0x30
 800cfe4:	d15c      	bne.n	800d0a0 <_strtol_r+0x108>
 800cfe6:	2220      	movs	r2, #32
 800cfe8:	782b      	ldrb	r3, [r5, #0]
 800cfea:	4393      	bics	r3, r2
 800cfec:	2b58      	cmp	r3, #88	; 0x58
 800cfee:	d152      	bne.n	800d096 <_strtol_r+0xfe>
 800cff0:	2610      	movs	r6, #16
 800cff2:	786c      	ldrb	r4, [r5, #1]
 800cff4:	3502      	adds	r5, #2
 800cff6:	9f00      	ldr	r7, [sp, #0]
 800cff8:	1c31      	adds	r1, r6, #0
 800cffa:	1e7b      	subs	r3, r7, #1
 800cffc:	419f      	sbcs	r7, r3
 800cffe:	4b2d      	ldr	r3, [pc, #180]	; (800d0b4 <_strtol_r+0x11c>)
 800d000:	18ff      	adds	r7, r7, r3
 800d002:	1c38      	adds	r0, r7, #0
 800d004:	f001 fd4a 	bl	800ea9c <__aeabi_uidivmod>
 800d008:	1c38      	adds	r0, r7, #0
 800d00a:	9104      	str	r1, [sp, #16]
 800d00c:	1c31      	adds	r1, r6, #0
 800d00e:	f001 fcbf 	bl	800e990 <__aeabi_uidiv>
 800d012:	2200      	movs	r2, #0
 800d014:	1c07      	adds	r7, r0, #0
 800d016:	1c13      	adds	r3, r2, #0
 800d018:	9902      	ldr	r1, [sp, #8]
 800d01a:	1909      	adds	r1, r1, r4
 800d01c:	7849      	ldrb	r1, [r1, #1]
 800d01e:	0748      	lsls	r0, r1, #29
 800d020:	d501      	bpl.n	800d026 <_strtol_r+0x8e>
 800d022:	3c30      	subs	r4, #48	; 0x30
 800d024:	e007      	b.n	800d036 <_strtol_r+0x9e>
 800d026:	2003      	movs	r0, #3
 800d028:	4008      	ands	r0, r1
 800d02a:	d017      	beq.n	800d05c <_strtol_r+0xc4>
 800d02c:	2137      	movs	r1, #55	; 0x37
 800d02e:	2801      	cmp	r0, #1
 800d030:	d000      	beq.n	800d034 <_strtol_r+0x9c>
 800d032:	3120      	adds	r1, #32
 800d034:	1a64      	subs	r4, r4, r1
 800d036:	42b4      	cmp	r4, r6
 800d038:	da10      	bge.n	800d05c <_strtol_r+0xc4>
 800d03a:	1c51      	adds	r1, r2, #1
 800d03c:	d00b      	beq.n	800d056 <_strtol_r+0xbe>
 800d03e:	42bb      	cmp	r3, r7
 800d040:	d807      	bhi.n	800d052 <_strtol_r+0xba>
 800d042:	d102      	bne.n	800d04a <_strtol_r+0xb2>
 800d044:	9a04      	ldr	r2, [sp, #16]
 800d046:	4294      	cmp	r4, r2
 800d048:	dc03      	bgt.n	800d052 <_strtol_r+0xba>
 800d04a:	4373      	muls	r3, r6
 800d04c:	2201      	movs	r2, #1
 800d04e:	18e3      	adds	r3, r4, r3
 800d050:	e001      	b.n	800d056 <_strtol_r+0xbe>
 800d052:	2201      	movs	r2, #1
 800d054:	4252      	negs	r2, r2
 800d056:	782c      	ldrb	r4, [r5, #0]
 800d058:	3501      	adds	r5, #1
 800d05a:	e7dd      	b.n	800d018 <_strtol_r+0x80>
 800d05c:	1c18      	adds	r0, r3, #0
 800d05e:	1c51      	adds	r1, r2, #1
 800d060:	d10b      	bne.n	800d07a <_strtol_r+0xe2>
 800d062:	9800      	ldr	r0, [sp, #0]
 800d064:	9a05      	ldr	r2, [sp, #20]
 800d066:	1e43      	subs	r3, r0, #1
 800d068:	4198      	sbcs	r0, r3
 800d06a:	4b12      	ldr	r3, [pc, #72]	; (800d0b4 <_strtol_r+0x11c>)
 800d06c:	18c0      	adds	r0, r0, r3
 800d06e:	2322      	movs	r3, #34	; 0x22
 800d070:	6013      	str	r3, [r2, #0]
 800d072:	9b01      	ldr	r3, [sp, #4]
 800d074:	2b00      	cmp	r3, #0
 800d076:	d10a      	bne.n	800d08e <_strtol_r+0xf6>
 800d078:	e017      	b.n	800d0aa <_strtol_r+0x112>
 800d07a:	9900      	ldr	r1, [sp, #0]
 800d07c:	2900      	cmp	r1, #0
 800d07e:	d000      	beq.n	800d082 <_strtol_r+0xea>
 800d080:	4258      	negs	r0, r3
 800d082:	9b01      	ldr	r3, [sp, #4]
 800d084:	2b00      	cmp	r3, #0
 800d086:	d010      	beq.n	800d0aa <_strtol_r+0x112>
 800d088:	9b03      	ldr	r3, [sp, #12]
 800d08a:	2a00      	cmp	r2, #0
 800d08c:	d000      	beq.n	800d090 <_strtol_r+0xf8>
 800d08e:	1e6b      	subs	r3, r5, #1
 800d090:	9a01      	ldr	r2, [sp, #4]
 800d092:	6013      	str	r3, [r2, #0]
 800d094:	e009      	b.n	800d0aa <_strtol_r+0x112>
 800d096:	2430      	movs	r4, #48	; 0x30
 800d098:	2e00      	cmp	r6, #0
 800d09a:	d1ac      	bne.n	800cff6 <_strtol_r+0x5e>
 800d09c:	2608      	movs	r6, #8
 800d09e:	e7aa      	b.n	800cff6 <_strtol_r+0x5e>
 800d0a0:	260a      	movs	r6, #10
 800d0a2:	e7a8      	b.n	800cff6 <_strtol_r+0x5e>
 800d0a4:	2c30      	cmp	r4, #48	; 0x30
 800d0a6:	d1a6      	bne.n	800cff6 <_strtol_r+0x5e>
 800d0a8:	e79d      	b.n	800cfe6 <_strtol_r+0x4e>
 800d0aa:	b007      	add	sp, #28
 800d0ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d0ae:	46c0      	nop			; (mov r8, r8)
 800d0b0:	20000134 	.word	0x20000134
 800d0b4:	7fffffff 	.word	0x7fffffff

0800d0b8 <strtol>:
 800d0b8:	b538      	push	{r3, r4, r5, lr}
 800d0ba:	1c05      	adds	r5, r0, #0
 800d0bc:	1c0c      	adds	r4, r1, #0
 800d0be:	1c13      	adds	r3, r2, #0
 800d0c0:	4a03      	ldr	r2, [pc, #12]	; (800d0d0 <strtol+0x18>)
 800d0c2:	1c29      	adds	r1, r5, #0
 800d0c4:	6810      	ldr	r0, [r2, #0]
 800d0c6:	1c22      	adds	r2, r4, #0
 800d0c8:	f7ff ff66 	bl	800cf98 <_strtol_r>
 800d0cc:	bd38      	pop	{r3, r4, r5, pc}
 800d0ce:	46c0      	nop			; (mov r8, r8)
 800d0d0:	20000130 	.word	0x20000130

0800d0d4 <_strtoul_r>:
 800d0d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d0d6:	1c1e      	adds	r6, r3, #0
 800d0d8:	4b3e      	ldr	r3, [pc, #248]	; (800d1d4 <_strtoul_r+0x100>)
 800d0da:	b087      	sub	sp, #28
 800d0dc:	681b      	ldr	r3, [r3, #0]
 800d0de:	1c17      	adds	r7, r2, #0
 800d0e0:	9302      	str	r3, [sp, #8]
 800d0e2:	1c0b      	adds	r3, r1, #0
 800d0e4:	9005      	str	r0, [sp, #20]
 800d0e6:	9104      	str	r1, [sp, #16]
 800d0e8:	781c      	ldrb	r4, [r3, #0]
 800d0ea:	9a02      	ldr	r2, [sp, #8]
 800d0ec:	1c5d      	adds	r5, r3, #1
 800d0ee:	1912      	adds	r2, r2, r4
 800d0f0:	7851      	ldrb	r1, [r2, #1]
 800d0f2:	2208      	movs	r2, #8
 800d0f4:	400a      	ands	r2, r1
 800d0f6:	d001      	beq.n	800d0fc <_strtoul_r+0x28>
 800d0f8:	1c2b      	adds	r3, r5, #0
 800d0fa:	e7f5      	b.n	800d0e8 <_strtoul_r+0x14>
 800d0fc:	2c2d      	cmp	r4, #45	; 0x2d
 800d0fe:	d104      	bne.n	800d10a <_strtoul_r+0x36>
 800d100:	1c9d      	adds	r5, r3, #2
 800d102:	785c      	ldrb	r4, [r3, #1]
 800d104:	2301      	movs	r3, #1
 800d106:	9301      	str	r3, [sp, #4]
 800d108:	e004      	b.n	800d114 <_strtoul_r+0x40>
 800d10a:	9201      	str	r2, [sp, #4]
 800d10c:	2c2b      	cmp	r4, #43	; 0x2b
 800d10e:	d101      	bne.n	800d114 <_strtoul_r+0x40>
 800d110:	785c      	ldrb	r4, [r3, #1]
 800d112:	1c9d      	adds	r5, r3, #2
 800d114:	2e00      	cmp	r6, #0
 800d116:	d002      	beq.n	800d11e <_strtoul_r+0x4a>
 800d118:	2e10      	cmp	r6, #16
 800d11a:	d10a      	bne.n	800d132 <_strtoul_r+0x5e>
 800d11c:	e054      	b.n	800d1c8 <_strtoul_r+0xf4>
 800d11e:	2c30      	cmp	r4, #48	; 0x30
 800d120:	d150      	bne.n	800d1c4 <_strtoul_r+0xf0>
 800d122:	2220      	movs	r2, #32
 800d124:	782b      	ldrb	r3, [r5, #0]
 800d126:	4393      	bics	r3, r2
 800d128:	2b58      	cmp	r3, #88	; 0x58
 800d12a:	d146      	bne.n	800d1ba <_strtoul_r+0xe6>
 800d12c:	2610      	movs	r6, #16
 800d12e:	786c      	ldrb	r4, [r5, #1]
 800d130:	3502      	adds	r5, #2
 800d132:	2001      	movs	r0, #1
 800d134:	1c31      	adds	r1, r6, #0
 800d136:	4240      	negs	r0, r0
 800d138:	f001 fc2a 	bl	800e990 <__aeabi_uidiv>
 800d13c:	9003      	str	r0, [sp, #12]
 800d13e:	2001      	movs	r0, #1
 800d140:	1c31      	adds	r1, r6, #0
 800d142:	4240      	negs	r0, r0
 800d144:	f001 fcaa 	bl	800ea9c <__aeabi_uidivmod>
 800d148:	2200      	movs	r2, #0
 800d14a:	468c      	mov	ip, r1
 800d14c:	1c13      	adds	r3, r2, #0
 800d14e:	9902      	ldr	r1, [sp, #8]
 800d150:	1909      	adds	r1, r1, r4
 800d152:	7849      	ldrb	r1, [r1, #1]
 800d154:	0748      	lsls	r0, r1, #29
 800d156:	d501      	bpl.n	800d15c <_strtoul_r+0x88>
 800d158:	3c30      	subs	r4, #48	; 0x30
 800d15a:	e007      	b.n	800d16c <_strtoul_r+0x98>
 800d15c:	2003      	movs	r0, #3
 800d15e:	4008      	ands	r0, r1
 800d160:	d017      	beq.n	800d192 <_strtoul_r+0xbe>
 800d162:	2137      	movs	r1, #55	; 0x37
 800d164:	2801      	cmp	r0, #1
 800d166:	d000      	beq.n	800d16a <_strtoul_r+0x96>
 800d168:	3120      	adds	r1, #32
 800d16a:	1a64      	subs	r4, r4, r1
 800d16c:	42b4      	cmp	r4, r6
 800d16e:	da10      	bge.n	800d192 <_strtoul_r+0xbe>
 800d170:	1c51      	adds	r1, r2, #1
 800d172:	d00b      	beq.n	800d18c <_strtoul_r+0xb8>
 800d174:	9a03      	ldr	r2, [sp, #12]
 800d176:	4293      	cmp	r3, r2
 800d178:	d806      	bhi.n	800d188 <_strtoul_r+0xb4>
 800d17a:	d101      	bne.n	800d180 <_strtoul_r+0xac>
 800d17c:	4564      	cmp	r4, ip
 800d17e:	dc03      	bgt.n	800d188 <_strtoul_r+0xb4>
 800d180:	4373      	muls	r3, r6
 800d182:	2201      	movs	r2, #1
 800d184:	18e3      	adds	r3, r4, r3
 800d186:	e001      	b.n	800d18c <_strtoul_r+0xb8>
 800d188:	2201      	movs	r2, #1
 800d18a:	4252      	negs	r2, r2
 800d18c:	782c      	ldrb	r4, [r5, #0]
 800d18e:	3501      	adds	r5, #1
 800d190:	e7dd      	b.n	800d14e <_strtoul_r+0x7a>
 800d192:	1c18      	adds	r0, r3, #0
 800d194:	1c51      	adds	r1, r2, #1
 800d196:	d104      	bne.n	800d1a2 <_strtoul_r+0xce>
 800d198:	2322      	movs	r3, #34	; 0x22
 800d19a:	9905      	ldr	r1, [sp, #20]
 800d19c:	1c10      	adds	r0, r2, #0
 800d19e:	600b      	str	r3, [r1, #0]
 800d1a0:	e003      	b.n	800d1aa <_strtoul_r+0xd6>
 800d1a2:	9901      	ldr	r1, [sp, #4]
 800d1a4:	2900      	cmp	r1, #0
 800d1a6:	d000      	beq.n	800d1aa <_strtoul_r+0xd6>
 800d1a8:	4258      	negs	r0, r3
 800d1aa:	2f00      	cmp	r7, #0
 800d1ac:	d00f      	beq.n	800d1ce <_strtoul_r+0xfa>
 800d1ae:	9b04      	ldr	r3, [sp, #16]
 800d1b0:	2a00      	cmp	r2, #0
 800d1b2:	d000      	beq.n	800d1b6 <_strtoul_r+0xe2>
 800d1b4:	1e6b      	subs	r3, r5, #1
 800d1b6:	603b      	str	r3, [r7, #0]
 800d1b8:	e009      	b.n	800d1ce <_strtoul_r+0xfa>
 800d1ba:	2430      	movs	r4, #48	; 0x30
 800d1bc:	2e00      	cmp	r6, #0
 800d1be:	d1b8      	bne.n	800d132 <_strtoul_r+0x5e>
 800d1c0:	2608      	movs	r6, #8
 800d1c2:	e7b6      	b.n	800d132 <_strtoul_r+0x5e>
 800d1c4:	260a      	movs	r6, #10
 800d1c6:	e7b4      	b.n	800d132 <_strtoul_r+0x5e>
 800d1c8:	2c30      	cmp	r4, #48	; 0x30
 800d1ca:	d1b2      	bne.n	800d132 <_strtoul_r+0x5e>
 800d1cc:	e7a9      	b.n	800d122 <_strtoul_r+0x4e>
 800d1ce:	b007      	add	sp, #28
 800d1d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d1d2:	46c0      	nop			; (mov r8, r8)
 800d1d4:	20000134 	.word	0x20000134

0800d1d8 <strtoul>:
 800d1d8:	b538      	push	{r3, r4, r5, lr}
 800d1da:	1c05      	adds	r5, r0, #0
 800d1dc:	1c0c      	adds	r4, r1, #0
 800d1de:	1c13      	adds	r3, r2, #0
 800d1e0:	4a03      	ldr	r2, [pc, #12]	; (800d1f0 <strtoul+0x18>)
 800d1e2:	1c29      	adds	r1, r5, #0
 800d1e4:	6810      	ldr	r0, [r2, #0]
 800d1e6:	1c22      	adds	r2, r4, #0
 800d1e8:	f7ff ff74 	bl	800d0d4 <_strtoul_r>
 800d1ec:	bd38      	pop	{r3, r4, r5, pc}
 800d1ee:	46c0      	nop			; (mov r8, r8)
 800d1f0:	20000130 	.word	0x20000130

0800d1f4 <_vasiprintf_r>:
 800d1f4:	b570      	push	{r4, r5, r6, lr}
 800d1f6:	1c0d      	adds	r5, r1, #0
 800d1f8:	b09a      	sub	sp, #104	; 0x68
 800d1fa:	21a2      	movs	r1, #162	; 0xa2
 800d1fc:	466c      	mov	r4, sp
 800d1fe:	0089      	lsls	r1, r1, #2
 800d200:	81a1      	strh	r1, [r4, #12]
 800d202:	2101      	movs	r1, #1
 800d204:	466e      	mov	r6, sp
 800d206:	2400      	movs	r4, #0
 800d208:	4249      	negs	r1, r1
 800d20a:	81f1      	strh	r1, [r6, #14]
 800d20c:	4669      	mov	r1, sp
 800d20e:	9400      	str	r4, [sp, #0]
 800d210:	9404      	str	r4, [sp, #16]
 800d212:	9402      	str	r4, [sp, #8]
 800d214:	9405      	str	r4, [sp, #20]
 800d216:	f000 fb5f 	bl	800d8d8 <_svfiprintf_r>
 800d21a:	42a0      	cmp	r0, r4
 800d21c:	db03      	blt.n	800d226 <_vasiprintf_r+0x32>
 800d21e:	9b00      	ldr	r3, [sp, #0]
 800d220:	701c      	strb	r4, [r3, #0]
 800d222:	9b04      	ldr	r3, [sp, #16]
 800d224:	602b      	str	r3, [r5, #0]
 800d226:	b01a      	add	sp, #104	; 0x68
 800d228:	bd70      	pop	{r4, r5, r6, pc}
	...

0800d22c <vasiprintf>:
 800d22c:	b538      	push	{r3, r4, r5, lr}
 800d22e:	1c05      	adds	r5, r0, #0
 800d230:	1c0c      	adds	r4, r1, #0
 800d232:	1c13      	adds	r3, r2, #0
 800d234:	4a03      	ldr	r2, [pc, #12]	; (800d244 <vasiprintf+0x18>)
 800d236:	1c29      	adds	r1, r5, #0
 800d238:	6810      	ldr	r0, [r2, #0]
 800d23a:	1c22      	adds	r2, r4, #0
 800d23c:	f7ff ffda 	bl	800d1f4 <_vasiprintf_r>
 800d240:	bd38      	pop	{r3, r4, r5, pc}
 800d242:	46c0      	nop			; (mov r8, r8)
 800d244:	20000130 	.word	0x20000130

0800d248 <__swbuf_r>:
 800d248:	b570      	push	{r4, r5, r6, lr}
 800d24a:	1c05      	adds	r5, r0, #0
 800d24c:	1c0e      	adds	r6, r1, #0
 800d24e:	1c14      	adds	r4, r2, #0
 800d250:	2800      	cmp	r0, #0
 800d252:	d004      	beq.n	800d25e <__swbuf_r+0x16>
 800d254:	6983      	ldr	r3, [r0, #24]
 800d256:	2b00      	cmp	r3, #0
 800d258:	d101      	bne.n	800d25e <__swbuf_r+0x16>
 800d25a:	f000 f9df 	bl	800d61c <__sinit>
 800d25e:	4b23      	ldr	r3, [pc, #140]	; (800d2ec <__swbuf_r+0xa4>)
 800d260:	429c      	cmp	r4, r3
 800d262:	d101      	bne.n	800d268 <__swbuf_r+0x20>
 800d264:	686c      	ldr	r4, [r5, #4]
 800d266:	e008      	b.n	800d27a <__swbuf_r+0x32>
 800d268:	4b21      	ldr	r3, [pc, #132]	; (800d2f0 <__swbuf_r+0xa8>)
 800d26a:	429c      	cmp	r4, r3
 800d26c:	d101      	bne.n	800d272 <__swbuf_r+0x2a>
 800d26e:	68ac      	ldr	r4, [r5, #8]
 800d270:	e003      	b.n	800d27a <__swbuf_r+0x32>
 800d272:	4b20      	ldr	r3, [pc, #128]	; (800d2f4 <__swbuf_r+0xac>)
 800d274:	429c      	cmp	r4, r3
 800d276:	d100      	bne.n	800d27a <__swbuf_r+0x32>
 800d278:	68ec      	ldr	r4, [r5, #12]
 800d27a:	69a3      	ldr	r3, [r4, #24]
 800d27c:	60a3      	str	r3, [r4, #8]
 800d27e:	89a3      	ldrh	r3, [r4, #12]
 800d280:	071b      	lsls	r3, r3, #28
 800d282:	d50a      	bpl.n	800d29a <__swbuf_r+0x52>
 800d284:	6923      	ldr	r3, [r4, #16]
 800d286:	2b00      	cmp	r3, #0
 800d288:	d007      	beq.n	800d29a <__swbuf_r+0x52>
 800d28a:	6823      	ldr	r3, [r4, #0]
 800d28c:	6922      	ldr	r2, [r4, #16]
 800d28e:	b2f6      	uxtb	r6, r6
 800d290:	1a98      	subs	r0, r3, r2
 800d292:	6963      	ldr	r3, [r4, #20]
 800d294:	4298      	cmp	r0, r3
 800d296:	db0f      	blt.n	800d2b8 <__swbuf_r+0x70>
 800d298:	e008      	b.n	800d2ac <__swbuf_r+0x64>
 800d29a:	1c28      	adds	r0, r5, #0
 800d29c:	1c21      	adds	r1, r4, #0
 800d29e:	f000 f83f 	bl	800d320 <__swsetup_r>
 800d2a2:	2800      	cmp	r0, #0
 800d2a4:	d0f1      	beq.n	800d28a <__swbuf_r+0x42>
 800d2a6:	2001      	movs	r0, #1
 800d2a8:	4240      	negs	r0, r0
 800d2aa:	e01d      	b.n	800d2e8 <__swbuf_r+0xa0>
 800d2ac:	1c28      	adds	r0, r5, #0
 800d2ae:	1c21      	adds	r1, r4, #0
 800d2b0:	f000 f946 	bl	800d540 <_fflush_r>
 800d2b4:	2800      	cmp	r0, #0
 800d2b6:	d1f6      	bne.n	800d2a6 <__swbuf_r+0x5e>
 800d2b8:	68a3      	ldr	r3, [r4, #8]
 800d2ba:	3001      	adds	r0, #1
 800d2bc:	3b01      	subs	r3, #1
 800d2be:	60a3      	str	r3, [r4, #8]
 800d2c0:	6823      	ldr	r3, [r4, #0]
 800d2c2:	1c5a      	adds	r2, r3, #1
 800d2c4:	6022      	str	r2, [r4, #0]
 800d2c6:	701e      	strb	r6, [r3, #0]
 800d2c8:	6963      	ldr	r3, [r4, #20]
 800d2ca:	4298      	cmp	r0, r3
 800d2cc:	d005      	beq.n	800d2da <__swbuf_r+0x92>
 800d2ce:	89a3      	ldrh	r3, [r4, #12]
 800d2d0:	1c30      	adds	r0, r6, #0
 800d2d2:	07db      	lsls	r3, r3, #31
 800d2d4:	d508      	bpl.n	800d2e8 <__swbuf_r+0xa0>
 800d2d6:	2e0a      	cmp	r6, #10
 800d2d8:	d106      	bne.n	800d2e8 <__swbuf_r+0xa0>
 800d2da:	1c28      	adds	r0, r5, #0
 800d2dc:	1c21      	adds	r1, r4, #0
 800d2de:	f000 f92f 	bl	800d540 <_fflush_r>
 800d2e2:	2800      	cmp	r0, #0
 800d2e4:	d1df      	bne.n	800d2a6 <__swbuf_r+0x5e>
 800d2e6:	1c30      	adds	r0, r6, #0
 800d2e8:	bd70      	pop	{r4, r5, r6, pc}
 800d2ea:	46c0      	nop			; (mov r8, r8)
 800d2ec:	080152f8 	.word	0x080152f8
 800d2f0:	08015318 	.word	0x08015318
 800d2f4:	08015338 	.word	0x08015338

0800d2f8 <_write_r>:
 800d2f8:	b538      	push	{r3, r4, r5, lr}
 800d2fa:	1c05      	adds	r5, r0, #0
 800d2fc:	2000      	movs	r0, #0
 800d2fe:	4c07      	ldr	r4, [pc, #28]	; (800d31c <_write_r+0x24>)
 800d300:	6020      	str	r0, [r4, #0]
 800d302:	1c08      	adds	r0, r1, #0
 800d304:	1c11      	adds	r1, r2, #0
 800d306:	1c1a      	adds	r2, r3, #0
 800d308:	f001 fb2e 	bl	800e968 <_write>
 800d30c:	1c43      	adds	r3, r0, #1
 800d30e:	d103      	bne.n	800d318 <_write_r+0x20>
 800d310:	6823      	ldr	r3, [r4, #0]
 800d312:	2b00      	cmp	r3, #0
 800d314:	d000      	beq.n	800d318 <_write_r+0x20>
 800d316:	602b      	str	r3, [r5, #0]
 800d318:	bd38      	pop	{r3, r4, r5, pc}
 800d31a:	46c0      	nop			; (mov r8, r8)
 800d31c:	20002190 	.word	0x20002190

0800d320 <__swsetup_r>:
 800d320:	4b35      	ldr	r3, [pc, #212]	; (800d3f8 <__swsetup_r+0xd8>)
 800d322:	b570      	push	{r4, r5, r6, lr}
 800d324:	681d      	ldr	r5, [r3, #0]
 800d326:	1c06      	adds	r6, r0, #0
 800d328:	1c0c      	adds	r4, r1, #0
 800d32a:	2d00      	cmp	r5, #0
 800d32c:	d005      	beq.n	800d33a <__swsetup_r+0x1a>
 800d32e:	69ab      	ldr	r3, [r5, #24]
 800d330:	2b00      	cmp	r3, #0
 800d332:	d102      	bne.n	800d33a <__swsetup_r+0x1a>
 800d334:	1c28      	adds	r0, r5, #0
 800d336:	f000 f971 	bl	800d61c <__sinit>
 800d33a:	4b30      	ldr	r3, [pc, #192]	; (800d3fc <__swsetup_r+0xdc>)
 800d33c:	429c      	cmp	r4, r3
 800d33e:	d101      	bne.n	800d344 <__swsetup_r+0x24>
 800d340:	686c      	ldr	r4, [r5, #4]
 800d342:	e008      	b.n	800d356 <__swsetup_r+0x36>
 800d344:	4b2e      	ldr	r3, [pc, #184]	; (800d400 <__swsetup_r+0xe0>)
 800d346:	429c      	cmp	r4, r3
 800d348:	d101      	bne.n	800d34e <__swsetup_r+0x2e>
 800d34a:	68ac      	ldr	r4, [r5, #8]
 800d34c:	e003      	b.n	800d356 <__swsetup_r+0x36>
 800d34e:	4b2d      	ldr	r3, [pc, #180]	; (800d404 <__swsetup_r+0xe4>)
 800d350:	429c      	cmp	r4, r3
 800d352:	d100      	bne.n	800d356 <__swsetup_r+0x36>
 800d354:	68ec      	ldr	r4, [r5, #12]
 800d356:	89a3      	ldrh	r3, [r4, #12]
 800d358:	b29a      	uxth	r2, r3
 800d35a:	0711      	lsls	r1, r2, #28
 800d35c:	d423      	bmi.n	800d3a6 <__swsetup_r+0x86>
 800d35e:	06d1      	lsls	r1, r2, #27
 800d360:	d407      	bmi.n	800d372 <__swsetup_r+0x52>
 800d362:	2209      	movs	r2, #9
 800d364:	2001      	movs	r0, #1
 800d366:	6032      	str	r2, [r6, #0]
 800d368:	3237      	adds	r2, #55	; 0x37
 800d36a:	4313      	orrs	r3, r2
 800d36c:	81a3      	strh	r3, [r4, #12]
 800d36e:	4240      	negs	r0, r0
 800d370:	e040      	b.n	800d3f4 <__swsetup_r+0xd4>
 800d372:	0753      	lsls	r3, r2, #29
 800d374:	d513      	bpl.n	800d39e <__swsetup_r+0x7e>
 800d376:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d378:	2900      	cmp	r1, #0
 800d37a:	d008      	beq.n	800d38e <__swsetup_r+0x6e>
 800d37c:	1c23      	adds	r3, r4, #0
 800d37e:	3344      	adds	r3, #68	; 0x44
 800d380:	4299      	cmp	r1, r3
 800d382:	d002      	beq.n	800d38a <__swsetup_r+0x6a>
 800d384:	1c30      	adds	r0, r6, #0
 800d386:	f7ff facb 	bl	800c920 <_free_r>
 800d38a:	2300      	movs	r3, #0
 800d38c:	6363      	str	r3, [r4, #52]	; 0x34
 800d38e:	2224      	movs	r2, #36	; 0x24
 800d390:	89a3      	ldrh	r3, [r4, #12]
 800d392:	4393      	bics	r3, r2
 800d394:	81a3      	strh	r3, [r4, #12]
 800d396:	2300      	movs	r3, #0
 800d398:	6063      	str	r3, [r4, #4]
 800d39a:	6923      	ldr	r3, [r4, #16]
 800d39c:	6023      	str	r3, [r4, #0]
 800d39e:	2208      	movs	r2, #8
 800d3a0:	89a3      	ldrh	r3, [r4, #12]
 800d3a2:	4313      	orrs	r3, r2
 800d3a4:	81a3      	strh	r3, [r4, #12]
 800d3a6:	6923      	ldr	r3, [r4, #16]
 800d3a8:	2b00      	cmp	r3, #0
 800d3aa:	d10b      	bne.n	800d3c4 <__swsetup_r+0xa4>
 800d3ac:	23a0      	movs	r3, #160	; 0xa0
 800d3ae:	89a2      	ldrh	r2, [r4, #12]
 800d3b0:	009b      	lsls	r3, r3, #2
 800d3b2:	4013      	ands	r3, r2
 800d3b4:	2280      	movs	r2, #128	; 0x80
 800d3b6:	0092      	lsls	r2, r2, #2
 800d3b8:	4293      	cmp	r3, r2
 800d3ba:	d003      	beq.n	800d3c4 <__swsetup_r+0xa4>
 800d3bc:	1c30      	adds	r0, r6, #0
 800d3be:	1c21      	adds	r1, r4, #0
 800d3c0:	f000 f9d2 	bl	800d768 <__smakebuf_r>
 800d3c4:	2301      	movs	r3, #1
 800d3c6:	89a2      	ldrh	r2, [r4, #12]
 800d3c8:	4013      	ands	r3, r2
 800d3ca:	d005      	beq.n	800d3d8 <__swsetup_r+0xb8>
 800d3cc:	2300      	movs	r3, #0
 800d3ce:	60a3      	str	r3, [r4, #8]
 800d3d0:	6963      	ldr	r3, [r4, #20]
 800d3d2:	425b      	negs	r3, r3
 800d3d4:	61a3      	str	r3, [r4, #24]
 800d3d6:	e003      	b.n	800d3e0 <__swsetup_r+0xc0>
 800d3d8:	0791      	lsls	r1, r2, #30
 800d3da:	d400      	bmi.n	800d3de <__swsetup_r+0xbe>
 800d3dc:	6963      	ldr	r3, [r4, #20]
 800d3de:	60a3      	str	r3, [r4, #8]
 800d3e0:	2000      	movs	r0, #0
 800d3e2:	6923      	ldr	r3, [r4, #16]
 800d3e4:	4283      	cmp	r3, r0
 800d3e6:	d105      	bne.n	800d3f4 <__swsetup_r+0xd4>
 800d3e8:	0613      	lsls	r3, r2, #24
 800d3ea:	d503      	bpl.n	800d3f4 <__swsetup_r+0xd4>
 800d3ec:	2340      	movs	r3, #64	; 0x40
 800d3ee:	431a      	orrs	r2, r3
 800d3f0:	81a2      	strh	r2, [r4, #12]
 800d3f2:	3801      	subs	r0, #1
 800d3f4:	bd70      	pop	{r4, r5, r6, pc}
 800d3f6:	46c0      	nop			; (mov r8, r8)
 800d3f8:	20000130 	.word	0x20000130
 800d3fc:	080152f8 	.word	0x080152f8
 800d400:	08015318 	.word	0x08015318
 800d404:	08015338 	.word	0x08015338

0800d408 <_close_r>:
 800d408:	b538      	push	{r3, r4, r5, lr}
 800d40a:	2300      	movs	r3, #0
 800d40c:	4c06      	ldr	r4, [pc, #24]	; (800d428 <_close_r+0x20>)
 800d40e:	1c05      	adds	r5, r0, #0
 800d410:	1c08      	adds	r0, r1, #0
 800d412:	6023      	str	r3, [r4, #0]
 800d414:	f001 fa62 	bl	800e8dc <_close>
 800d418:	1c43      	adds	r3, r0, #1
 800d41a:	d103      	bne.n	800d424 <_close_r+0x1c>
 800d41c:	6823      	ldr	r3, [r4, #0]
 800d41e:	2b00      	cmp	r3, #0
 800d420:	d000      	beq.n	800d424 <_close_r+0x1c>
 800d422:	602b      	str	r3, [r5, #0]
 800d424:	bd38      	pop	{r3, r4, r5, pc}
 800d426:	46c0      	nop			; (mov r8, r8)
 800d428:	20002190 	.word	0x20002190

0800d42c <__sflush_r>:
 800d42c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d42e:	898a      	ldrh	r2, [r1, #12]
 800d430:	1c05      	adds	r5, r0, #0
 800d432:	1c0c      	adds	r4, r1, #0
 800d434:	0713      	lsls	r3, r2, #28
 800d436:	d45e      	bmi.n	800d4f6 <__sflush_r+0xca>
 800d438:	684b      	ldr	r3, [r1, #4]
 800d43a:	2b00      	cmp	r3, #0
 800d43c:	dc02      	bgt.n	800d444 <__sflush_r+0x18>
 800d43e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800d440:	2b00      	cmp	r3, #0
 800d442:	dd1a      	ble.n	800d47a <__sflush_r+0x4e>
 800d444:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800d446:	2f00      	cmp	r7, #0
 800d448:	d017      	beq.n	800d47a <__sflush_r+0x4e>
 800d44a:	2300      	movs	r3, #0
 800d44c:	682e      	ldr	r6, [r5, #0]
 800d44e:	602b      	str	r3, [r5, #0]
 800d450:	2380      	movs	r3, #128	; 0x80
 800d452:	015b      	lsls	r3, r3, #5
 800d454:	401a      	ands	r2, r3
 800d456:	d001      	beq.n	800d45c <__sflush_r+0x30>
 800d458:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800d45a:	e015      	b.n	800d488 <__sflush_r+0x5c>
 800d45c:	1c28      	adds	r0, r5, #0
 800d45e:	6a21      	ldr	r1, [r4, #32]
 800d460:	2301      	movs	r3, #1
 800d462:	47b8      	blx	r7
 800d464:	1c02      	adds	r2, r0, #0
 800d466:	1c43      	adds	r3, r0, #1
 800d468:	d10e      	bne.n	800d488 <__sflush_r+0x5c>
 800d46a:	682b      	ldr	r3, [r5, #0]
 800d46c:	2b00      	cmp	r3, #0
 800d46e:	d00b      	beq.n	800d488 <__sflush_r+0x5c>
 800d470:	2b1d      	cmp	r3, #29
 800d472:	d001      	beq.n	800d478 <__sflush_r+0x4c>
 800d474:	2b16      	cmp	r3, #22
 800d476:	d102      	bne.n	800d47e <__sflush_r+0x52>
 800d478:	602e      	str	r6, [r5, #0]
 800d47a:	2000      	movs	r0, #0
 800d47c:	e05e      	b.n	800d53c <__sflush_r+0x110>
 800d47e:	2140      	movs	r1, #64	; 0x40
 800d480:	89a3      	ldrh	r3, [r4, #12]
 800d482:	430b      	orrs	r3, r1
 800d484:	81a3      	strh	r3, [r4, #12]
 800d486:	e059      	b.n	800d53c <__sflush_r+0x110>
 800d488:	89a3      	ldrh	r3, [r4, #12]
 800d48a:	075b      	lsls	r3, r3, #29
 800d48c:	d506      	bpl.n	800d49c <__sflush_r+0x70>
 800d48e:	6863      	ldr	r3, [r4, #4]
 800d490:	1ad2      	subs	r2, r2, r3
 800d492:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800d494:	2b00      	cmp	r3, #0
 800d496:	d001      	beq.n	800d49c <__sflush_r+0x70>
 800d498:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d49a:	1ad2      	subs	r2, r2, r3
 800d49c:	2300      	movs	r3, #0
 800d49e:	1c28      	adds	r0, r5, #0
 800d4a0:	6a21      	ldr	r1, [r4, #32]
 800d4a2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800d4a4:	47b8      	blx	r7
 800d4a6:	89a3      	ldrh	r3, [r4, #12]
 800d4a8:	1c42      	adds	r2, r0, #1
 800d4aa:	d106      	bne.n	800d4ba <__sflush_r+0x8e>
 800d4ac:	682a      	ldr	r2, [r5, #0]
 800d4ae:	2a00      	cmp	r2, #0
 800d4b0:	d003      	beq.n	800d4ba <__sflush_r+0x8e>
 800d4b2:	2a1d      	cmp	r2, #29
 800d4b4:	d001      	beq.n	800d4ba <__sflush_r+0x8e>
 800d4b6:	2a16      	cmp	r2, #22
 800d4b8:	d119      	bne.n	800d4ee <__sflush_r+0xc2>
 800d4ba:	2200      	movs	r2, #0
 800d4bc:	6062      	str	r2, [r4, #4]
 800d4be:	6922      	ldr	r2, [r4, #16]
 800d4c0:	6022      	str	r2, [r4, #0]
 800d4c2:	04db      	lsls	r3, r3, #19
 800d4c4:	d505      	bpl.n	800d4d2 <__sflush_r+0xa6>
 800d4c6:	1c43      	adds	r3, r0, #1
 800d4c8:	d102      	bne.n	800d4d0 <__sflush_r+0xa4>
 800d4ca:	682b      	ldr	r3, [r5, #0]
 800d4cc:	2b00      	cmp	r3, #0
 800d4ce:	d100      	bne.n	800d4d2 <__sflush_r+0xa6>
 800d4d0:	6560      	str	r0, [r4, #84]	; 0x54
 800d4d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800d4d4:	602e      	str	r6, [r5, #0]
 800d4d6:	2900      	cmp	r1, #0
 800d4d8:	d0cf      	beq.n	800d47a <__sflush_r+0x4e>
 800d4da:	1c23      	adds	r3, r4, #0
 800d4dc:	3344      	adds	r3, #68	; 0x44
 800d4de:	4299      	cmp	r1, r3
 800d4e0:	d002      	beq.n	800d4e8 <__sflush_r+0xbc>
 800d4e2:	1c28      	adds	r0, r5, #0
 800d4e4:	f7ff fa1c 	bl	800c920 <_free_r>
 800d4e8:	2000      	movs	r0, #0
 800d4ea:	6360      	str	r0, [r4, #52]	; 0x34
 800d4ec:	e026      	b.n	800d53c <__sflush_r+0x110>
 800d4ee:	2240      	movs	r2, #64	; 0x40
 800d4f0:	4313      	orrs	r3, r2
 800d4f2:	81a3      	strh	r3, [r4, #12]
 800d4f4:	e022      	b.n	800d53c <__sflush_r+0x110>
 800d4f6:	690f      	ldr	r7, [r1, #16]
 800d4f8:	2f00      	cmp	r7, #0
 800d4fa:	d0be      	beq.n	800d47a <__sflush_r+0x4e>
 800d4fc:	680b      	ldr	r3, [r1, #0]
 800d4fe:	600f      	str	r7, [r1, #0]
 800d500:	1bdb      	subs	r3, r3, r7
 800d502:	9301      	str	r3, [sp, #4]
 800d504:	2300      	movs	r3, #0
 800d506:	0792      	lsls	r2, r2, #30
 800d508:	d100      	bne.n	800d50c <__sflush_r+0xe0>
 800d50a:	694b      	ldr	r3, [r1, #20]
 800d50c:	60a3      	str	r3, [r4, #8]
 800d50e:	9b01      	ldr	r3, [sp, #4]
 800d510:	2b00      	cmp	r3, #0
 800d512:	ddb2      	ble.n	800d47a <__sflush_r+0x4e>
 800d514:	1c28      	adds	r0, r5, #0
 800d516:	6a21      	ldr	r1, [r4, #32]
 800d518:	1c3a      	adds	r2, r7, #0
 800d51a:	9b01      	ldr	r3, [sp, #4]
 800d51c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800d51e:	47b0      	blx	r6
 800d520:	2800      	cmp	r0, #0
 800d522:	dc06      	bgt.n	800d532 <__sflush_r+0x106>
 800d524:	2240      	movs	r2, #64	; 0x40
 800d526:	2001      	movs	r0, #1
 800d528:	89a3      	ldrh	r3, [r4, #12]
 800d52a:	4240      	negs	r0, r0
 800d52c:	4313      	orrs	r3, r2
 800d52e:	81a3      	strh	r3, [r4, #12]
 800d530:	e004      	b.n	800d53c <__sflush_r+0x110>
 800d532:	9b01      	ldr	r3, [sp, #4]
 800d534:	183f      	adds	r7, r7, r0
 800d536:	1a1b      	subs	r3, r3, r0
 800d538:	9301      	str	r3, [sp, #4]
 800d53a:	e7e8      	b.n	800d50e <__sflush_r+0xe2>
 800d53c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0800d540 <_fflush_r>:
 800d540:	b538      	push	{r3, r4, r5, lr}
 800d542:	690b      	ldr	r3, [r1, #16]
 800d544:	1c05      	adds	r5, r0, #0
 800d546:	1c0c      	adds	r4, r1, #0
 800d548:	2b00      	cmp	r3, #0
 800d54a:	d101      	bne.n	800d550 <_fflush_r+0x10>
 800d54c:	2000      	movs	r0, #0
 800d54e:	e01c      	b.n	800d58a <_fflush_r+0x4a>
 800d550:	2800      	cmp	r0, #0
 800d552:	d004      	beq.n	800d55e <_fflush_r+0x1e>
 800d554:	6983      	ldr	r3, [r0, #24]
 800d556:	2b00      	cmp	r3, #0
 800d558:	d101      	bne.n	800d55e <_fflush_r+0x1e>
 800d55a:	f000 f85f 	bl	800d61c <__sinit>
 800d55e:	4b0b      	ldr	r3, [pc, #44]	; (800d58c <_fflush_r+0x4c>)
 800d560:	429c      	cmp	r4, r3
 800d562:	d101      	bne.n	800d568 <_fflush_r+0x28>
 800d564:	686c      	ldr	r4, [r5, #4]
 800d566:	e008      	b.n	800d57a <_fflush_r+0x3a>
 800d568:	4b09      	ldr	r3, [pc, #36]	; (800d590 <_fflush_r+0x50>)
 800d56a:	429c      	cmp	r4, r3
 800d56c:	d101      	bne.n	800d572 <_fflush_r+0x32>
 800d56e:	68ac      	ldr	r4, [r5, #8]
 800d570:	e003      	b.n	800d57a <_fflush_r+0x3a>
 800d572:	4b08      	ldr	r3, [pc, #32]	; (800d594 <_fflush_r+0x54>)
 800d574:	429c      	cmp	r4, r3
 800d576:	d100      	bne.n	800d57a <_fflush_r+0x3a>
 800d578:	68ec      	ldr	r4, [r5, #12]
 800d57a:	220c      	movs	r2, #12
 800d57c:	5ea3      	ldrsh	r3, [r4, r2]
 800d57e:	2b00      	cmp	r3, #0
 800d580:	d0e4      	beq.n	800d54c <_fflush_r+0xc>
 800d582:	1c28      	adds	r0, r5, #0
 800d584:	1c21      	adds	r1, r4, #0
 800d586:	f7ff ff51 	bl	800d42c <__sflush_r>
 800d58a:	bd38      	pop	{r3, r4, r5, pc}
 800d58c:	080152f8 	.word	0x080152f8
 800d590:	08015318 	.word	0x08015318
 800d594:	08015338 	.word	0x08015338

0800d598 <_cleanup_r>:
 800d598:	b508      	push	{r3, lr}
 800d59a:	4902      	ldr	r1, [pc, #8]	; (800d5a4 <_cleanup_r+0xc>)
 800d59c:	f000 f8ae 	bl	800d6fc <_fwalk_reent>
 800d5a0:	bd08      	pop	{r3, pc}
 800d5a2:	46c0      	nop			; (mov r8, r8)
 800d5a4:	0800d541 	.word	0x0800d541

0800d5a8 <std.isra.0>:
 800d5a8:	2300      	movs	r3, #0
 800d5aa:	b510      	push	{r4, lr}
 800d5ac:	1c04      	adds	r4, r0, #0
 800d5ae:	6003      	str	r3, [r0, #0]
 800d5b0:	6043      	str	r3, [r0, #4]
 800d5b2:	6083      	str	r3, [r0, #8]
 800d5b4:	8181      	strh	r1, [r0, #12]
 800d5b6:	6643      	str	r3, [r0, #100]	; 0x64
 800d5b8:	81c2      	strh	r2, [r0, #14]
 800d5ba:	6103      	str	r3, [r0, #16]
 800d5bc:	6143      	str	r3, [r0, #20]
 800d5be:	6183      	str	r3, [r0, #24]
 800d5c0:	1c19      	adds	r1, r3, #0
 800d5c2:	2208      	movs	r2, #8
 800d5c4:	305c      	adds	r0, #92	; 0x5c
 800d5c6:	f7ff f994 	bl	800c8f2 <memset>
 800d5ca:	4b05      	ldr	r3, [pc, #20]	; (800d5e0 <std.isra.0+0x38>)
 800d5cc:	6224      	str	r4, [r4, #32]
 800d5ce:	6263      	str	r3, [r4, #36]	; 0x24
 800d5d0:	4b04      	ldr	r3, [pc, #16]	; (800d5e4 <std.isra.0+0x3c>)
 800d5d2:	62a3      	str	r3, [r4, #40]	; 0x28
 800d5d4:	4b04      	ldr	r3, [pc, #16]	; (800d5e8 <std.isra.0+0x40>)
 800d5d6:	62e3      	str	r3, [r4, #44]	; 0x2c
 800d5d8:	4b04      	ldr	r3, [pc, #16]	; (800d5ec <std.isra.0+0x44>)
 800d5da:	6323      	str	r3, [r4, #48]	; 0x30
 800d5dc:	bd10      	pop	{r4, pc}
 800d5de:	46c0      	nop			; (mov r8, r8)
 800d5e0:	0800cd79 	.word	0x0800cd79
 800d5e4:	0800cda5 	.word	0x0800cda5
 800d5e8:	0800cddd 	.word	0x0800cddd
 800d5ec:	0800ce09 	.word	0x0800ce09

0800d5f0 <__sfmoreglue>:
 800d5f0:	b570      	push	{r4, r5, r6, lr}
 800d5f2:	2568      	movs	r5, #104	; 0x68
 800d5f4:	1e4b      	subs	r3, r1, #1
 800d5f6:	435d      	muls	r5, r3
 800d5f8:	1c0e      	adds	r6, r1, #0
 800d5fa:	1c29      	adds	r1, r5, #0
 800d5fc:	3174      	adds	r1, #116	; 0x74
 800d5fe:	f7ff f9d5 	bl	800c9ac <_malloc_r>
 800d602:	1e04      	subs	r4, r0, #0
 800d604:	d008      	beq.n	800d618 <__sfmoreglue+0x28>
 800d606:	2100      	movs	r1, #0
 800d608:	1c2a      	adds	r2, r5, #0
 800d60a:	6001      	str	r1, [r0, #0]
 800d60c:	6046      	str	r6, [r0, #4]
 800d60e:	300c      	adds	r0, #12
 800d610:	60a0      	str	r0, [r4, #8]
 800d612:	3268      	adds	r2, #104	; 0x68
 800d614:	f7ff f96d 	bl	800c8f2 <memset>
 800d618:	1c20      	adds	r0, r4, #0
 800d61a:	bd70      	pop	{r4, r5, r6, pc}

0800d61c <__sinit>:
 800d61c:	6983      	ldr	r3, [r0, #24]
 800d61e:	b513      	push	{r0, r1, r4, lr}
 800d620:	2b00      	cmp	r3, #0
 800d622:	d128      	bne.n	800d676 <__sinit+0x5a>
 800d624:	6483      	str	r3, [r0, #72]	; 0x48
 800d626:	64c3      	str	r3, [r0, #76]	; 0x4c
 800d628:	6503      	str	r3, [r0, #80]	; 0x50
 800d62a:	4b13      	ldr	r3, [pc, #76]	; (800d678 <__sinit+0x5c>)
 800d62c:	4a13      	ldr	r2, [pc, #76]	; (800d67c <__sinit+0x60>)
 800d62e:	681b      	ldr	r3, [r3, #0]
 800d630:	6282      	str	r2, [r0, #40]	; 0x28
 800d632:	9301      	str	r3, [sp, #4]
 800d634:	4298      	cmp	r0, r3
 800d636:	d101      	bne.n	800d63c <__sinit+0x20>
 800d638:	2301      	movs	r3, #1
 800d63a:	6183      	str	r3, [r0, #24]
 800d63c:	1c04      	adds	r4, r0, #0
 800d63e:	f000 f81f 	bl	800d680 <__sfp>
 800d642:	6060      	str	r0, [r4, #4]
 800d644:	1c20      	adds	r0, r4, #0
 800d646:	f000 f81b 	bl	800d680 <__sfp>
 800d64a:	60a0      	str	r0, [r4, #8]
 800d64c:	1c20      	adds	r0, r4, #0
 800d64e:	f000 f817 	bl	800d680 <__sfp>
 800d652:	2104      	movs	r1, #4
 800d654:	60e0      	str	r0, [r4, #12]
 800d656:	2200      	movs	r2, #0
 800d658:	6860      	ldr	r0, [r4, #4]
 800d65a:	f7ff ffa5 	bl	800d5a8 <std.isra.0>
 800d65e:	68a0      	ldr	r0, [r4, #8]
 800d660:	2109      	movs	r1, #9
 800d662:	2201      	movs	r2, #1
 800d664:	f7ff ffa0 	bl	800d5a8 <std.isra.0>
 800d668:	68e0      	ldr	r0, [r4, #12]
 800d66a:	2112      	movs	r1, #18
 800d66c:	2202      	movs	r2, #2
 800d66e:	f7ff ff9b 	bl	800d5a8 <std.isra.0>
 800d672:	2301      	movs	r3, #1
 800d674:	61a3      	str	r3, [r4, #24]
 800d676:	bd13      	pop	{r0, r1, r4, pc}
 800d678:	080151f0 	.word	0x080151f0
 800d67c:	0800d599 	.word	0x0800d599

0800d680 <__sfp>:
 800d680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800d682:	4b1d      	ldr	r3, [pc, #116]	; (800d6f8 <__sfp+0x78>)
 800d684:	1c06      	adds	r6, r0, #0
 800d686:	681d      	ldr	r5, [r3, #0]
 800d688:	69ab      	ldr	r3, [r5, #24]
 800d68a:	2b00      	cmp	r3, #0
 800d68c:	d102      	bne.n	800d694 <__sfp+0x14>
 800d68e:	1c28      	adds	r0, r5, #0
 800d690:	f7ff ffc4 	bl	800d61c <__sinit>
 800d694:	3548      	adds	r5, #72	; 0x48
 800d696:	68ac      	ldr	r4, [r5, #8]
 800d698:	686b      	ldr	r3, [r5, #4]
 800d69a:	3b01      	subs	r3, #1
 800d69c:	d405      	bmi.n	800d6aa <__sfp+0x2a>
 800d69e:	220c      	movs	r2, #12
 800d6a0:	5ea7      	ldrsh	r7, [r4, r2]
 800d6a2:	2f00      	cmp	r7, #0
 800d6a4:	d010      	beq.n	800d6c8 <__sfp+0x48>
 800d6a6:	3468      	adds	r4, #104	; 0x68
 800d6a8:	e7f7      	b.n	800d69a <__sfp+0x1a>
 800d6aa:	682b      	ldr	r3, [r5, #0]
 800d6ac:	2b00      	cmp	r3, #0
 800d6ae:	d106      	bne.n	800d6be <__sfp+0x3e>
 800d6b0:	1c30      	adds	r0, r6, #0
 800d6b2:	2104      	movs	r1, #4
 800d6b4:	f7ff ff9c 	bl	800d5f0 <__sfmoreglue>
 800d6b8:	6028      	str	r0, [r5, #0]
 800d6ba:	2800      	cmp	r0, #0
 800d6bc:	d001      	beq.n	800d6c2 <__sfp+0x42>
 800d6be:	682d      	ldr	r5, [r5, #0]
 800d6c0:	e7e9      	b.n	800d696 <__sfp+0x16>
 800d6c2:	230c      	movs	r3, #12
 800d6c4:	6033      	str	r3, [r6, #0]
 800d6c6:	e016      	b.n	800d6f6 <__sfp+0x76>
 800d6c8:	2301      	movs	r3, #1
 800d6ca:	1c20      	adds	r0, r4, #0
 800d6cc:	425b      	negs	r3, r3
 800d6ce:	81e3      	strh	r3, [r4, #14]
 800d6d0:	3302      	adds	r3, #2
 800d6d2:	81a3      	strh	r3, [r4, #12]
 800d6d4:	6667      	str	r7, [r4, #100]	; 0x64
 800d6d6:	6027      	str	r7, [r4, #0]
 800d6d8:	60a7      	str	r7, [r4, #8]
 800d6da:	6067      	str	r7, [r4, #4]
 800d6dc:	6127      	str	r7, [r4, #16]
 800d6de:	6167      	str	r7, [r4, #20]
 800d6e0:	61a7      	str	r7, [r4, #24]
 800d6e2:	305c      	adds	r0, #92	; 0x5c
 800d6e4:	1c39      	adds	r1, r7, #0
 800d6e6:	2208      	movs	r2, #8
 800d6e8:	f7ff f903 	bl	800c8f2 <memset>
 800d6ec:	1c20      	adds	r0, r4, #0
 800d6ee:	6367      	str	r7, [r4, #52]	; 0x34
 800d6f0:	63a7      	str	r7, [r4, #56]	; 0x38
 800d6f2:	64a7      	str	r7, [r4, #72]	; 0x48
 800d6f4:	64e7      	str	r7, [r4, #76]	; 0x4c
 800d6f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d6f8:	080151f0 	.word	0x080151f0

0800d6fc <_fwalk_reent>:
 800d6fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800d6fe:	1c04      	adds	r4, r0, #0
 800d700:	1c07      	adds	r7, r0, #0
 800d702:	2600      	movs	r6, #0
 800d704:	9101      	str	r1, [sp, #4]
 800d706:	3448      	adds	r4, #72	; 0x48
 800d708:	2c00      	cmp	r4, #0
 800d70a:	d016      	beq.n	800d73a <_fwalk_reent+0x3e>
 800d70c:	6863      	ldr	r3, [r4, #4]
 800d70e:	68a5      	ldr	r5, [r4, #8]
 800d710:	9300      	str	r3, [sp, #0]
 800d712:	9b00      	ldr	r3, [sp, #0]
 800d714:	3b01      	subs	r3, #1
 800d716:	9300      	str	r3, [sp, #0]
 800d718:	d40d      	bmi.n	800d736 <_fwalk_reent+0x3a>
 800d71a:	89ab      	ldrh	r3, [r5, #12]
 800d71c:	2b01      	cmp	r3, #1
 800d71e:	d908      	bls.n	800d732 <_fwalk_reent+0x36>
 800d720:	220e      	movs	r2, #14
 800d722:	5eab      	ldrsh	r3, [r5, r2]
 800d724:	3301      	adds	r3, #1
 800d726:	d004      	beq.n	800d732 <_fwalk_reent+0x36>
 800d728:	1c38      	adds	r0, r7, #0
 800d72a:	1c29      	adds	r1, r5, #0
 800d72c:	9b01      	ldr	r3, [sp, #4]
 800d72e:	4798      	blx	r3
 800d730:	4306      	orrs	r6, r0
 800d732:	3568      	adds	r5, #104	; 0x68
 800d734:	e7ed      	b.n	800d712 <_fwalk_reent+0x16>
 800d736:	6824      	ldr	r4, [r4, #0]
 800d738:	e7e6      	b.n	800d708 <_fwalk_reent+0xc>
 800d73a:	1c30      	adds	r0, r6, #0
 800d73c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0800d740 <_lseek_r>:
 800d740:	b538      	push	{r3, r4, r5, lr}
 800d742:	1c05      	adds	r5, r0, #0
 800d744:	2000      	movs	r0, #0
 800d746:	4c07      	ldr	r4, [pc, #28]	; (800d764 <_lseek_r+0x24>)
 800d748:	6020      	str	r0, [r4, #0]
 800d74a:	1c08      	adds	r0, r1, #0
 800d74c:	1c11      	adds	r1, r2, #0
 800d74e:	1c1a      	adds	r2, r3, #0
 800d750:	f001 f8ec 	bl	800e92c <_lseek>
 800d754:	1c43      	adds	r3, r0, #1
 800d756:	d103      	bne.n	800d760 <_lseek_r+0x20>
 800d758:	6823      	ldr	r3, [r4, #0]
 800d75a:	2b00      	cmp	r3, #0
 800d75c:	d000      	beq.n	800d760 <_lseek_r+0x20>
 800d75e:	602b      	str	r3, [r5, #0]
 800d760:	bd38      	pop	{r3, r4, r5, pc}
 800d762:	46c0      	nop			; (mov r8, r8)
 800d764:	20002190 	.word	0x20002190

0800d768 <__smakebuf_r>:
 800d768:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d76a:	898b      	ldrh	r3, [r1, #12]
 800d76c:	b091      	sub	sp, #68	; 0x44
 800d76e:	079b      	lsls	r3, r3, #30
 800d770:	d506      	bpl.n	800d780 <__smakebuf_r+0x18>
 800d772:	1c0b      	adds	r3, r1, #0
 800d774:	3347      	adds	r3, #71	; 0x47
 800d776:	600b      	str	r3, [r1, #0]
 800d778:	610b      	str	r3, [r1, #16]
 800d77a:	2301      	movs	r3, #1
 800d77c:	614b      	str	r3, [r1, #20]
 800d77e:	e045      	b.n	800d80c <__smakebuf_r+0xa4>
 800d780:	1c0c      	adds	r4, r1, #0
 800d782:	230e      	movs	r3, #14
 800d784:	5ec9      	ldrsh	r1, [r1, r3]
 800d786:	1c06      	adds	r6, r0, #0
 800d788:	2900      	cmp	r1, #0
 800d78a:	da04      	bge.n	800d796 <__smakebuf_r+0x2e>
 800d78c:	2380      	movs	r3, #128	; 0x80
 800d78e:	89a5      	ldrh	r5, [r4, #12]
 800d790:	401d      	ands	r5, r3
 800d792:	d110      	bne.n	800d7b6 <__smakebuf_r+0x4e>
 800d794:	e00c      	b.n	800d7b0 <__smakebuf_r+0x48>
 800d796:	aa01      	add	r2, sp, #4
 800d798:	f001 f840 	bl	800e81c <_fstat_r>
 800d79c:	2800      	cmp	r0, #0
 800d79e:	dbf5      	blt.n	800d78c <__smakebuf_r+0x24>
 800d7a0:	23f0      	movs	r3, #240	; 0xf0
 800d7a2:	9d02      	ldr	r5, [sp, #8]
 800d7a4:	021b      	lsls	r3, r3, #8
 800d7a6:	401d      	ands	r5, r3
 800d7a8:	4b19      	ldr	r3, [pc, #100]	; (800d810 <__smakebuf_r+0xa8>)
 800d7aa:	18ed      	adds	r5, r5, r3
 800d7ac:	426b      	negs	r3, r5
 800d7ae:	415d      	adcs	r5, r3
 800d7b0:	2780      	movs	r7, #128	; 0x80
 800d7b2:	00ff      	lsls	r7, r7, #3
 800d7b4:	e001      	b.n	800d7ba <__smakebuf_r+0x52>
 800d7b6:	2500      	movs	r5, #0
 800d7b8:	2740      	movs	r7, #64	; 0x40
 800d7ba:	1c30      	adds	r0, r6, #0
 800d7bc:	1c39      	adds	r1, r7, #0
 800d7be:	f7ff f8f5 	bl	800c9ac <_malloc_r>
 800d7c2:	2800      	cmp	r0, #0
 800d7c4:	d10c      	bne.n	800d7e0 <__smakebuf_r+0x78>
 800d7c6:	89a3      	ldrh	r3, [r4, #12]
 800d7c8:	059a      	lsls	r2, r3, #22
 800d7ca:	d41f      	bmi.n	800d80c <__smakebuf_r+0xa4>
 800d7cc:	2202      	movs	r2, #2
 800d7ce:	4313      	orrs	r3, r2
 800d7d0:	81a3      	strh	r3, [r4, #12]
 800d7d2:	1c23      	adds	r3, r4, #0
 800d7d4:	3347      	adds	r3, #71	; 0x47
 800d7d6:	6023      	str	r3, [r4, #0]
 800d7d8:	6123      	str	r3, [r4, #16]
 800d7da:	2301      	movs	r3, #1
 800d7dc:	6163      	str	r3, [r4, #20]
 800d7de:	e015      	b.n	800d80c <__smakebuf_r+0xa4>
 800d7e0:	2280      	movs	r2, #128	; 0x80
 800d7e2:	4b0c      	ldr	r3, [pc, #48]	; (800d814 <__smakebuf_r+0xac>)
 800d7e4:	62b3      	str	r3, [r6, #40]	; 0x28
 800d7e6:	89a3      	ldrh	r3, [r4, #12]
 800d7e8:	6020      	str	r0, [r4, #0]
 800d7ea:	4313      	orrs	r3, r2
 800d7ec:	81a3      	strh	r3, [r4, #12]
 800d7ee:	6120      	str	r0, [r4, #16]
 800d7f0:	6167      	str	r7, [r4, #20]
 800d7f2:	2d00      	cmp	r5, #0
 800d7f4:	d00a      	beq.n	800d80c <__smakebuf_r+0xa4>
 800d7f6:	230e      	movs	r3, #14
 800d7f8:	5ee1      	ldrsh	r1, [r4, r3]
 800d7fa:	1c30      	adds	r0, r6, #0
 800d7fc:	f001 f820 	bl	800e840 <_isatty_r>
 800d800:	2800      	cmp	r0, #0
 800d802:	d003      	beq.n	800d80c <__smakebuf_r+0xa4>
 800d804:	2201      	movs	r2, #1
 800d806:	89a3      	ldrh	r3, [r4, #12]
 800d808:	4313      	orrs	r3, r2
 800d80a:	81a3      	strh	r3, [r4, #12]
 800d80c:	b011      	add	sp, #68	; 0x44
 800d80e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d810:	ffffe000 	.word	0xffffe000
 800d814:	0800d599 	.word	0x0800d599

0800d818 <__ssputs_r>:
 800d818:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d81a:	688e      	ldr	r6, [r1, #8]
 800d81c:	b085      	sub	sp, #20
 800d81e:	1c07      	adds	r7, r0, #0
 800d820:	1c0c      	adds	r4, r1, #0
 800d822:	9203      	str	r2, [sp, #12]
 800d824:	9301      	str	r3, [sp, #4]
 800d826:	42b3      	cmp	r3, r6
 800d828:	d345      	bcc.n	800d8b6 <__ssputs_r+0x9e>
 800d82a:	2390      	movs	r3, #144	; 0x90
 800d82c:	898a      	ldrh	r2, [r1, #12]
 800d82e:	00db      	lsls	r3, r3, #3
 800d830:	421a      	tst	r2, r3
 800d832:	d03d      	beq.n	800d8b0 <__ssputs_r+0x98>
 800d834:	2503      	movs	r5, #3
 800d836:	6909      	ldr	r1, [r1, #16]
 800d838:	6823      	ldr	r3, [r4, #0]
 800d83a:	9801      	ldr	r0, [sp, #4]
 800d83c:	1a5b      	subs	r3, r3, r1
 800d83e:	9302      	str	r3, [sp, #8]
 800d840:	6963      	ldr	r3, [r4, #20]
 800d842:	435d      	muls	r5, r3
 800d844:	0feb      	lsrs	r3, r5, #31
 800d846:	195d      	adds	r5, r3, r5
 800d848:	9b02      	ldr	r3, [sp, #8]
 800d84a:	106d      	asrs	r5, r5, #1
 800d84c:	3301      	adds	r3, #1
 800d84e:	181b      	adds	r3, r3, r0
 800d850:	429d      	cmp	r5, r3
 800d852:	d200      	bcs.n	800d856 <__ssputs_r+0x3e>
 800d854:	1c1d      	adds	r5, r3, #0
 800d856:	1c38      	adds	r0, r7, #0
 800d858:	0553      	lsls	r3, r2, #21
 800d85a:	d50f      	bpl.n	800d87c <__ssputs_r+0x64>
 800d85c:	1c29      	adds	r1, r5, #0
 800d85e:	f7ff f8a5 	bl	800c9ac <_malloc_r>
 800d862:	1e06      	subs	r6, r0, #0
 800d864:	d013      	beq.n	800d88e <__ssputs_r+0x76>
 800d866:	9a02      	ldr	r2, [sp, #8]
 800d868:	6921      	ldr	r1, [r4, #16]
 800d86a:	f7ff f825 	bl	800c8b8 <memcpy>
 800d86e:	89a2      	ldrh	r2, [r4, #12]
 800d870:	4b18      	ldr	r3, [pc, #96]	; (800d8d4 <__ssputs_r+0xbc>)
 800d872:	4013      	ands	r3, r2
 800d874:	2280      	movs	r2, #128	; 0x80
 800d876:	4313      	orrs	r3, r2
 800d878:	81a3      	strh	r3, [r4, #12]
 800d87a:	e011      	b.n	800d8a0 <__ssputs_r+0x88>
 800d87c:	1c2a      	adds	r2, r5, #0
 800d87e:	f000 fffc 	bl	800e87a <_realloc_r>
 800d882:	1e06      	subs	r6, r0, #0
 800d884:	d10c      	bne.n	800d8a0 <__ssputs_r+0x88>
 800d886:	1c38      	adds	r0, r7, #0
 800d888:	6921      	ldr	r1, [r4, #16]
 800d88a:	f7ff f849 	bl	800c920 <_free_r>
 800d88e:	230c      	movs	r3, #12
 800d890:	2240      	movs	r2, #64	; 0x40
 800d892:	2001      	movs	r0, #1
 800d894:	603b      	str	r3, [r7, #0]
 800d896:	89a3      	ldrh	r3, [r4, #12]
 800d898:	4240      	negs	r0, r0
 800d89a:	4313      	orrs	r3, r2
 800d89c:	81a3      	strh	r3, [r4, #12]
 800d89e:	e017      	b.n	800d8d0 <__ssputs_r+0xb8>
 800d8a0:	9b02      	ldr	r3, [sp, #8]
 800d8a2:	6126      	str	r6, [r4, #16]
 800d8a4:	18f6      	adds	r6, r6, r3
 800d8a6:	6026      	str	r6, [r4, #0]
 800d8a8:	6165      	str	r5, [r4, #20]
 800d8aa:	9e01      	ldr	r6, [sp, #4]
 800d8ac:	1aed      	subs	r5, r5, r3
 800d8ae:	60a5      	str	r5, [r4, #8]
 800d8b0:	9b01      	ldr	r3, [sp, #4]
 800d8b2:	42b3      	cmp	r3, r6
 800d8b4:	d200      	bcs.n	800d8b8 <__ssputs_r+0xa0>
 800d8b6:	9e01      	ldr	r6, [sp, #4]
 800d8b8:	1c32      	adds	r2, r6, #0
 800d8ba:	6820      	ldr	r0, [r4, #0]
 800d8bc:	9903      	ldr	r1, [sp, #12]
 800d8be:	f7ff f804 	bl	800c8ca <memmove>
 800d8c2:	2000      	movs	r0, #0
 800d8c4:	68a3      	ldr	r3, [r4, #8]
 800d8c6:	1b9b      	subs	r3, r3, r6
 800d8c8:	60a3      	str	r3, [r4, #8]
 800d8ca:	6823      	ldr	r3, [r4, #0]
 800d8cc:	199e      	adds	r6, r3, r6
 800d8ce:	6026      	str	r6, [r4, #0]
 800d8d0:	b005      	add	sp, #20
 800d8d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d8d4:	fffffb7f 	.word	0xfffffb7f

0800d8d8 <_svfiprintf_r>:
 800d8d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d8da:	b09f      	sub	sp, #124	; 0x7c
 800d8dc:	9002      	str	r0, [sp, #8]
 800d8de:	9305      	str	r3, [sp, #20]
 800d8e0:	898b      	ldrh	r3, [r1, #12]
 800d8e2:	1c0e      	adds	r6, r1, #0
 800d8e4:	1c17      	adds	r7, r2, #0
 800d8e6:	061b      	lsls	r3, r3, #24
 800d8e8:	d510      	bpl.n	800d90c <_svfiprintf_r+0x34>
 800d8ea:	690b      	ldr	r3, [r1, #16]
 800d8ec:	2b00      	cmp	r3, #0
 800d8ee:	d10d      	bne.n	800d90c <_svfiprintf_r+0x34>
 800d8f0:	2140      	movs	r1, #64	; 0x40
 800d8f2:	f7ff f85b 	bl	800c9ac <_malloc_r>
 800d8f6:	6030      	str	r0, [r6, #0]
 800d8f8:	6130      	str	r0, [r6, #16]
 800d8fa:	2800      	cmp	r0, #0
 800d8fc:	d104      	bne.n	800d908 <_svfiprintf_r+0x30>
 800d8fe:	230c      	movs	r3, #12
 800d900:	9a02      	ldr	r2, [sp, #8]
 800d902:	3801      	subs	r0, #1
 800d904:	6013      	str	r3, [r2, #0]
 800d906:	e0d0      	b.n	800daaa <_svfiprintf_r+0x1d2>
 800d908:	2340      	movs	r3, #64	; 0x40
 800d90a:	6173      	str	r3, [r6, #20]
 800d90c:	2300      	movs	r3, #0
 800d90e:	ad06      	add	r5, sp, #24
 800d910:	616b      	str	r3, [r5, #20]
 800d912:	3320      	adds	r3, #32
 800d914:	766b      	strb	r3, [r5, #25]
 800d916:	3310      	adds	r3, #16
 800d918:	76ab      	strb	r3, [r5, #26]
 800d91a:	1c3c      	adds	r4, r7, #0
 800d91c:	7823      	ldrb	r3, [r4, #0]
 800d91e:	2b00      	cmp	r3, #0
 800d920:	d103      	bne.n	800d92a <_svfiprintf_r+0x52>
 800d922:	1be3      	subs	r3, r4, r7
 800d924:	9304      	str	r3, [sp, #16]
 800d926:	d012      	beq.n	800d94e <_svfiprintf_r+0x76>
 800d928:	e003      	b.n	800d932 <_svfiprintf_r+0x5a>
 800d92a:	2b25      	cmp	r3, #37	; 0x25
 800d92c:	d0f9      	beq.n	800d922 <_svfiprintf_r+0x4a>
 800d92e:	3401      	adds	r4, #1
 800d930:	e7f4      	b.n	800d91c <_svfiprintf_r+0x44>
 800d932:	9b04      	ldr	r3, [sp, #16]
 800d934:	9802      	ldr	r0, [sp, #8]
 800d936:	1c31      	adds	r1, r6, #0
 800d938:	1c3a      	adds	r2, r7, #0
 800d93a:	f7ff ff6d 	bl	800d818 <__ssputs_r>
 800d93e:	1c43      	adds	r3, r0, #1
 800d940:	d100      	bne.n	800d944 <_svfiprintf_r+0x6c>
 800d942:	e0ac      	b.n	800da9e <_svfiprintf_r+0x1c6>
 800d944:	696a      	ldr	r2, [r5, #20]
 800d946:	9b04      	ldr	r3, [sp, #16]
 800d948:	4694      	mov	ip, r2
 800d94a:	4463      	add	r3, ip
 800d94c:	616b      	str	r3, [r5, #20]
 800d94e:	7823      	ldrb	r3, [r4, #0]
 800d950:	2b00      	cmp	r3, #0
 800d952:	d100      	bne.n	800d956 <_svfiprintf_r+0x7e>
 800d954:	e0a3      	b.n	800da9e <_svfiprintf_r+0x1c6>
 800d956:	2201      	movs	r2, #1
 800d958:	2300      	movs	r3, #0
 800d95a:	4252      	negs	r2, r2
 800d95c:	606a      	str	r2, [r5, #4]
 800d95e:	a902      	add	r1, sp, #8
 800d960:	3254      	adds	r2, #84	; 0x54
 800d962:	1852      	adds	r2, r2, r1
 800d964:	3401      	adds	r4, #1
 800d966:	602b      	str	r3, [r5, #0]
 800d968:	60eb      	str	r3, [r5, #12]
 800d96a:	60ab      	str	r3, [r5, #8]
 800d96c:	7013      	strb	r3, [r2, #0]
 800d96e:	65ab      	str	r3, [r5, #88]	; 0x58
 800d970:	4f4f      	ldr	r7, [pc, #316]	; (800dab0 <_svfiprintf_r+0x1d8>)
 800d972:	7821      	ldrb	r1, [r4, #0]
 800d974:	1c38      	adds	r0, r7, #0
 800d976:	2205      	movs	r2, #5
 800d978:	f000 ff74 	bl	800e864 <memchr>
 800d97c:	2800      	cmp	r0, #0
 800d97e:	d008      	beq.n	800d992 <_svfiprintf_r+0xba>
 800d980:	1bc0      	subs	r0, r0, r7
 800d982:	2701      	movs	r7, #1
 800d984:	4087      	lsls	r7, r0
 800d986:	1c38      	adds	r0, r7, #0
 800d988:	682b      	ldr	r3, [r5, #0]
 800d98a:	3401      	adds	r4, #1
 800d98c:	4318      	orrs	r0, r3
 800d98e:	6028      	str	r0, [r5, #0]
 800d990:	e7ee      	b.n	800d970 <_svfiprintf_r+0x98>
 800d992:	682b      	ldr	r3, [r5, #0]
 800d994:	06da      	lsls	r2, r3, #27
 800d996:	d504      	bpl.n	800d9a2 <_svfiprintf_r+0xca>
 800d998:	2253      	movs	r2, #83	; 0x53
 800d99a:	2120      	movs	r1, #32
 800d99c:	a802      	add	r0, sp, #8
 800d99e:	1812      	adds	r2, r2, r0
 800d9a0:	7011      	strb	r1, [r2, #0]
 800d9a2:	071a      	lsls	r2, r3, #28
 800d9a4:	d504      	bpl.n	800d9b0 <_svfiprintf_r+0xd8>
 800d9a6:	2253      	movs	r2, #83	; 0x53
 800d9a8:	212b      	movs	r1, #43	; 0x2b
 800d9aa:	a802      	add	r0, sp, #8
 800d9ac:	1812      	adds	r2, r2, r0
 800d9ae:	7011      	strb	r1, [r2, #0]
 800d9b0:	7822      	ldrb	r2, [r4, #0]
 800d9b2:	2a2a      	cmp	r2, #42	; 0x2a
 800d9b4:	d001      	beq.n	800d9ba <_svfiprintf_r+0xe2>
 800d9b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d9b8:	e00e      	b.n	800d9d8 <_svfiprintf_r+0x100>
 800d9ba:	9a05      	ldr	r2, [sp, #20]
 800d9bc:	1d11      	adds	r1, r2, #4
 800d9be:	6812      	ldr	r2, [r2, #0]
 800d9c0:	9105      	str	r1, [sp, #20]
 800d9c2:	2a00      	cmp	r2, #0
 800d9c4:	db01      	blt.n	800d9ca <_svfiprintf_r+0xf2>
 800d9c6:	9209      	str	r2, [sp, #36]	; 0x24
 800d9c8:	e004      	b.n	800d9d4 <_svfiprintf_r+0xfc>
 800d9ca:	4252      	negs	r2, r2
 800d9cc:	60ea      	str	r2, [r5, #12]
 800d9ce:	2202      	movs	r2, #2
 800d9d0:	4313      	orrs	r3, r2
 800d9d2:	602b      	str	r3, [r5, #0]
 800d9d4:	3401      	adds	r4, #1
 800d9d6:	e009      	b.n	800d9ec <_svfiprintf_r+0x114>
 800d9d8:	7822      	ldrb	r2, [r4, #0]
 800d9da:	3a30      	subs	r2, #48	; 0x30
 800d9dc:	2a09      	cmp	r2, #9
 800d9de:	d804      	bhi.n	800d9ea <_svfiprintf_r+0x112>
 800d9e0:	210a      	movs	r1, #10
 800d9e2:	434b      	muls	r3, r1
 800d9e4:	3401      	adds	r4, #1
 800d9e6:	189b      	adds	r3, r3, r2
 800d9e8:	e7f6      	b.n	800d9d8 <_svfiprintf_r+0x100>
 800d9ea:	9309      	str	r3, [sp, #36]	; 0x24
 800d9ec:	7823      	ldrb	r3, [r4, #0]
 800d9ee:	2b2e      	cmp	r3, #46	; 0x2e
 800d9f0:	d118      	bne.n	800da24 <_svfiprintf_r+0x14c>
 800d9f2:	7863      	ldrb	r3, [r4, #1]
 800d9f4:	2b2a      	cmp	r3, #42	; 0x2a
 800d9f6:	d109      	bne.n	800da0c <_svfiprintf_r+0x134>
 800d9f8:	9b05      	ldr	r3, [sp, #20]
 800d9fa:	3402      	adds	r4, #2
 800d9fc:	1d1a      	adds	r2, r3, #4
 800d9fe:	681b      	ldr	r3, [r3, #0]
 800da00:	9205      	str	r2, [sp, #20]
 800da02:	2b00      	cmp	r3, #0
 800da04:	da0d      	bge.n	800da22 <_svfiprintf_r+0x14a>
 800da06:	2301      	movs	r3, #1
 800da08:	425b      	negs	r3, r3
 800da0a:	e00a      	b.n	800da22 <_svfiprintf_r+0x14a>
 800da0c:	2300      	movs	r3, #0
 800da0e:	3401      	adds	r4, #1
 800da10:	7822      	ldrb	r2, [r4, #0]
 800da12:	3a30      	subs	r2, #48	; 0x30
 800da14:	2a09      	cmp	r2, #9
 800da16:	d804      	bhi.n	800da22 <_svfiprintf_r+0x14a>
 800da18:	210a      	movs	r1, #10
 800da1a:	434b      	muls	r3, r1
 800da1c:	3401      	adds	r4, #1
 800da1e:	189b      	adds	r3, r3, r2
 800da20:	e7f6      	b.n	800da10 <_svfiprintf_r+0x138>
 800da22:	9307      	str	r3, [sp, #28]
 800da24:	4f23      	ldr	r7, [pc, #140]	; (800dab4 <_svfiprintf_r+0x1dc>)
 800da26:	7821      	ldrb	r1, [r4, #0]
 800da28:	1c38      	adds	r0, r7, #0
 800da2a:	2203      	movs	r2, #3
 800da2c:	f000 ff1a 	bl	800e864 <memchr>
 800da30:	2800      	cmp	r0, #0
 800da32:	d007      	beq.n	800da44 <_svfiprintf_r+0x16c>
 800da34:	1bc0      	subs	r0, r0, r7
 800da36:	2740      	movs	r7, #64	; 0x40
 800da38:	4087      	lsls	r7, r0
 800da3a:	1c38      	adds	r0, r7, #0
 800da3c:	682b      	ldr	r3, [r5, #0]
 800da3e:	3401      	adds	r4, #1
 800da40:	4318      	orrs	r0, r3
 800da42:	6028      	str	r0, [r5, #0]
 800da44:	7821      	ldrb	r1, [r4, #0]
 800da46:	481c      	ldr	r0, [pc, #112]	; (800dab8 <_svfiprintf_r+0x1e0>)
 800da48:	2206      	movs	r2, #6
 800da4a:	1c67      	adds	r7, r4, #1
 800da4c:	7629      	strb	r1, [r5, #24]
 800da4e:	f000 ff09 	bl	800e864 <memchr>
 800da52:	2800      	cmp	r0, #0
 800da54:	d012      	beq.n	800da7c <_svfiprintf_r+0x1a4>
 800da56:	4b19      	ldr	r3, [pc, #100]	; (800dabc <_svfiprintf_r+0x1e4>)
 800da58:	2b00      	cmp	r3, #0
 800da5a:	d106      	bne.n	800da6a <_svfiprintf_r+0x192>
 800da5c:	2207      	movs	r2, #7
 800da5e:	9b05      	ldr	r3, [sp, #20]
 800da60:	3307      	adds	r3, #7
 800da62:	4393      	bics	r3, r2
 800da64:	3308      	adds	r3, #8
 800da66:	9305      	str	r3, [sp, #20]
 800da68:	e014      	b.n	800da94 <_svfiprintf_r+0x1bc>
 800da6a:	ab05      	add	r3, sp, #20
 800da6c:	9300      	str	r3, [sp, #0]
 800da6e:	9802      	ldr	r0, [sp, #8]
 800da70:	1c29      	adds	r1, r5, #0
 800da72:	1c32      	adds	r2, r6, #0
 800da74:	4b12      	ldr	r3, [pc, #72]	; (800dac0 <_svfiprintf_r+0x1e8>)
 800da76:	e000      	b.n	800da7a <_svfiprintf_r+0x1a2>
 800da78:	bf00      	nop
 800da7a:	e007      	b.n	800da8c <_svfiprintf_r+0x1b4>
 800da7c:	ab05      	add	r3, sp, #20
 800da7e:	9300      	str	r3, [sp, #0]
 800da80:	9802      	ldr	r0, [sp, #8]
 800da82:	1c29      	adds	r1, r5, #0
 800da84:	1c32      	adds	r2, r6, #0
 800da86:	4b0e      	ldr	r3, [pc, #56]	; (800dac0 <_svfiprintf_r+0x1e8>)
 800da88:	f000 fb96 	bl	800e1b8 <_printf_i>
 800da8c:	9003      	str	r0, [sp, #12]
 800da8e:	9b03      	ldr	r3, [sp, #12]
 800da90:	3301      	adds	r3, #1
 800da92:	d004      	beq.n	800da9e <_svfiprintf_r+0x1c6>
 800da94:	696b      	ldr	r3, [r5, #20]
 800da96:	9a03      	ldr	r2, [sp, #12]
 800da98:	189b      	adds	r3, r3, r2
 800da9a:	616b      	str	r3, [r5, #20]
 800da9c:	e73d      	b.n	800d91a <_svfiprintf_r+0x42>
 800da9e:	89b3      	ldrh	r3, [r6, #12]
 800daa0:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800daa2:	065b      	lsls	r3, r3, #25
 800daa4:	d501      	bpl.n	800daaa <_svfiprintf_r+0x1d2>
 800daa6:	2001      	movs	r0, #1
 800daa8:	4240      	negs	r0, r0
 800daaa:	b01f      	add	sp, #124	; 0x7c
 800daac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800daae:	46c0      	nop			; (mov r8, r8)
 800dab0:	08015358 	.word	0x08015358
 800dab4:	0801535e 	.word	0x0801535e
 800dab8:	08015362 	.word	0x08015362
 800dabc:	00000000 	.word	0x00000000
 800dac0:	0800d819 	.word	0x0800d819

0800dac4 <_sungetc_r>:
 800dac4:	b538      	push	{r3, r4, r5, lr}
 800dac6:	1c14      	adds	r4, r2, #0
 800dac8:	1c4b      	adds	r3, r1, #1
 800daca:	d102      	bne.n	800dad2 <_sungetc_r+0xe>
 800dacc:	2001      	movs	r0, #1
 800dace:	4240      	negs	r0, r0
 800dad0:	e034      	b.n	800db3c <_sungetc_r+0x78>
 800dad2:	8993      	ldrh	r3, [r2, #12]
 800dad4:	2220      	movs	r2, #32
 800dad6:	4393      	bics	r3, r2
 800dad8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800dada:	81a3      	strh	r3, [r4, #12]
 800dadc:	b2cd      	uxtb	r5, r1
 800dade:	6863      	ldr	r3, [r4, #4]
 800dae0:	2a00      	cmp	r2, #0
 800dae2:	d00f      	beq.n	800db04 <_sungetc_r+0x40>
 800dae4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800dae6:	4293      	cmp	r3, r2
 800dae8:	da06      	bge.n	800daf8 <_sungetc_r+0x34>
 800daea:	6823      	ldr	r3, [r4, #0]
 800daec:	3b01      	subs	r3, #1
 800daee:	6023      	str	r3, [r4, #0]
 800daf0:	701d      	strb	r5, [r3, #0]
 800daf2:	6863      	ldr	r3, [r4, #4]
 800daf4:	3301      	adds	r3, #1
 800daf6:	e01f      	b.n	800db38 <_sungetc_r+0x74>
 800daf8:	1c21      	adds	r1, r4, #0
 800dafa:	f000 fe51 	bl	800e7a0 <__submore>
 800dafe:	2800      	cmp	r0, #0
 800db00:	d0f3      	beq.n	800daea <_sungetc_r+0x26>
 800db02:	e7e3      	b.n	800dacc <_sungetc_r+0x8>
 800db04:	6921      	ldr	r1, [r4, #16]
 800db06:	6822      	ldr	r2, [r4, #0]
 800db08:	2900      	cmp	r1, #0
 800db0a:	d009      	beq.n	800db20 <_sungetc_r+0x5c>
 800db0c:	428a      	cmp	r2, r1
 800db0e:	d907      	bls.n	800db20 <_sungetc_r+0x5c>
 800db10:	1e51      	subs	r1, r2, #1
 800db12:	7808      	ldrb	r0, [r1, #0]
 800db14:	42a8      	cmp	r0, r5
 800db16:	d103      	bne.n	800db20 <_sungetc_r+0x5c>
 800db18:	3301      	adds	r3, #1
 800db1a:	6021      	str	r1, [r4, #0]
 800db1c:	6063      	str	r3, [r4, #4]
 800db1e:	e00d      	b.n	800db3c <_sungetc_r+0x78>
 800db20:	6423      	str	r3, [r4, #64]	; 0x40
 800db22:	1c23      	adds	r3, r4, #0
 800db24:	3344      	adds	r3, #68	; 0x44
 800db26:	6363      	str	r3, [r4, #52]	; 0x34
 800db28:	2303      	movs	r3, #3
 800db2a:	63a3      	str	r3, [r4, #56]	; 0x38
 800db2c:	1c23      	adds	r3, r4, #0
 800db2e:	3346      	adds	r3, #70	; 0x46
 800db30:	63e2      	str	r2, [r4, #60]	; 0x3c
 800db32:	701d      	strb	r5, [r3, #0]
 800db34:	6023      	str	r3, [r4, #0]
 800db36:	2301      	movs	r3, #1
 800db38:	1c28      	adds	r0, r5, #0
 800db3a:	6063      	str	r3, [r4, #4]
 800db3c:	bd38      	pop	{r3, r4, r5, pc}

0800db3e <__ssrefill_r>:
 800db3e:	b510      	push	{r4, lr}
 800db40:	1c0c      	adds	r4, r1, #0
 800db42:	6b49      	ldr	r1, [r1, #52]	; 0x34
 800db44:	2900      	cmp	r1, #0
 800db46:	d00e      	beq.n	800db66 <__ssrefill_r+0x28>
 800db48:	1c23      	adds	r3, r4, #0
 800db4a:	3344      	adds	r3, #68	; 0x44
 800db4c:	4299      	cmp	r1, r3
 800db4e:	d001      	beq.n	800db54 <__ssrefill_r+0x16>
 800db50:	f7fe fee6 	bl	800c920 <_free_r>
 800db54:	2000      	movs	r0, #0
 800db56:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800db58:	6360      	str	r0, [r4, #52]	; 0x34
 800db5a:	6063      	str	r3, [r4, #4]
 800db5c:	4283      	cmp	r3, r0
 800db5e:	d002      	beq.n	800db66 <__ssrefill_r+0x28>
 800db60:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800db62:	6023      	str	r3, [r4, #0]
 800db64:	e009      	b.n	800db7a <__ssrefill_r+0x3c>
 800db66:	6923      	ldr	r3, [r4, #16]
 800db68:	2220      	movs	r2, #32
 800db6a:	6023      	str	r3, [r4, #0]
 800db6c:	2300      	movs	r3, #0
 800db6e:	2001      	movs	r0, #1
 800db70:	6063      	str	r3, [r4, #4]
 800db72:	89a3      	ldrh	r3, [r4, #12]
 800db74:	4240      	negs	r0, r0
 800db76:	4313      	orrs	r3, r2
 800db78:	81a3      	strh	r3, [r4, #12]
 800db7a:	bd10      	pop	{r4, pc}

0800db7c <__ssvfiscanf_r>:
 800db7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800db7e:	4cb5      	ldr	r4, [pc, #724]	; (800de54 <__ssvfiscanf_r+0x2d8>)
 800db80:	1c07      	adds	r7, r0, #0
 800db82:	44a5      	add	sp, r4
 800db84:	9303      	str	r3, [sp, #12]
 800db86:	2300      	movs	r3, #0
 800db88:	2086      	movs	r0, #134	; 0x86
 800db8a:	9348      	str	r3, [sp, #288]	; 0x120
 800db8c:	9349      	str	r3, [sp, #292]	; 0x124
 800db8e:	ab05      	add	r3, sp, #20
 800db90:	934a      	str	r3, [sp, #296]	; 0x128
 800db92:	23be      	movs	r3, #190	; 0xbe
 800db94:	0040      	lsls	r0, r0, #1
 800db96:	1c0d      	adds	r5, r1, #0
 800db98:	9201      	str	r2, [sp, #4]
 800db9a:	a902      	add	r1, sp, #8
 800db9c:	4aae      	ldr	r2, [pc, #696]	; (800de58 <__ssvfiscanf_r+0x2dc>)
 800db9e:	005b      	lsls	r3, r3, #1
 800dba0:	1809      	adds	r1, r1, r0
 800dba2:	50ca      	str	r2, [r1, r3]
 800dba4:	4aad      	ldr	r2, [pc, #692]	; (800de5c <__ssvfiscanf_r+0x2e0>)
 800dba6:	a902      	add	r1, sp, #8
 800dba8:	3304      	adds	r3, #4
 800dbaa:	1809      	adds	r1, r1, r0
 800dbac:	50ca      	str	r2, [r1, r3]
 800dbae:	9b01      	ldr	r3, [sp, #4]
 800dbb0:	781c      	ldrb	r4, [r3, #0]
 800dbb2:	2c00      	cmp	r4, #0
 800dbb4:	d100      	bne.n	800dbb8 <__ssvfiscanf_r+0x3c>
 800dbb6:	e144      	b.n	800de42 <__ssvfiscanf_r+0x2c6>
 800dbb8:	4ea9      	ldr	r6, [pc, #676]	; (800de60 <__ssvfiscanf_r+0x2e4>)
 800dbba:	6833      	ldr	r3, [r6, #0]
 800dbbc:	191b      	adds	r3, r3, r4
 800dbbe:	785a      	ldrb	r2, [r3, #1]
 800dbc0:	2308      	movs	r3, #8
 800dbc2:	4013      	ands	r3, r2
 800dbc4:	d023      	beq.n	800dc0e <__ssvfiscanf_r+0x92>
 800dbc6:	686b      	ldr	r3, [r5, #4]
 800dbc8:	2b00      	cmp	r3, #0
 800dbca:	dd10      	ble.n	800dbee <__ssvfiscanf_r+0x72>
 800dbcc:	682b      	ldr	r3, [r5, #0]
 800dbce:	6831      	ldr	r1, [r6, #0]
 800dbd0:	781a      	ldrb	r2, [r3, #0]
 800dbd2:	188a      	adds	r2, r1, r2
 800dbd4:	7852      	ldrb	r2, [r2, #1]
 800dbd6:	0712      	lsls	r2, r2, #28
 800dbd8:	d515      	bpl.n	800dc06 <__ssvfiscanf_r+0x8a>
 800dbda:	9a49      	ldr	r2, [sp, #292]	; 0x124
 800dbdc:	3301      	adds	r3, #1
 800dbde:	9202      	str	r2, [sp, #8]
 800dbe0:	3201      	adds	r2, #1
 800dbe2:	9249      	str	r2, [sp, #292]	; 0x124
 800dbe4:	686a      	ldr	r2, [r5, #4]
 800dbe6:	602b      	str	r3, [r5, #0]
 800dbe8:	3a01      	subs	r2, #1
 800dbea:	606a      	str	r2, [r5, #4]
 800dbec:	e7eb      	b.n	800dbc6 <__ssvfiscanf_r+0x4a>
 800dbee:	2186      	movs	r1, #134	; 0x86
 800dbf0:	23c0      	movs	r3, #192	; 0xc0
 800dbf2:	0049      	lsls	r1, r1, #1
 800dbf4:	aa02      	add	r2, sp, #8
 800dbf6:	1852      	adds	r2, r2, r1
 800dbf8:	005b      	lsls	r3, r3, #1
 800dbfa:	58d3      	ldr	r3, [r2, r3]
 800dbfc:	1c38      	adds	r0, r7, #0
 800dbfe:	1c29      	adds	r1, r5, #0
 800dc00:	4798      	blx	r3
 800dc02:	2800      	cmp	r0, #0
 800dc04:	d0e2      	beq.n	800dbcc <__ssvfiscanf_r+0x50>
 800dc06:	9e01      	ldr	r6, [sp, #4]
 800dc08:	3601      	adds	r6, #1
 800dc0a:	9601      	str	r6, [sp, #4]
 800dc0c:	e7cf      	b.n	800dbae <__ssvfiscanf_r+0x32>
 800dc0e:	9a01      	ldr	r2, [sp, #4]
 800dc10:	1c56      	adds	r6, r2, #1
 800dc12:	2c25      	cmp	r4, #37	; 0x25
 800dc14:	d14f      	bne.n	800dcb6 <__ssvfiscanf_r+0x13a>
 800dc16:	9347      	str	r3, [sp, #284]	; 0x11c
 800dc18:	9345      	str	r3, [sp, #276]	; 0x114
 800dc1a:	7853      	ldrb	r3, [r2, #1]
 800dc1c:	2b2a      	cmp	r3, #42	; 0x2a
 800dc1e:	d102      	bne.n	800dc26 <__ssvfiscanf_r+0xaa>
 800dc20:	3b1a      	subs	r3, #26
 800dc22:	9345      	str	r3, [sp, #276]	; 0x114
 800dc24:	3601      	adds	r6, #1
 800dc26:	1c34      	adds	r4, r6, #0
 800dc28:	7821      	ldrb	r1, [r4, #0]
 800dc2a:	1c0b      	adds	r3, r1, #0
 800dc2c:	3b30      	subs	r3, #48	; 0x30
 800dc2e:	2b09      	cmp	r3, #9
 800dc30:	d809      	bhi.n	800dc46 <__ssvfiscanf_r+0xca>
 800dc32:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 800dc34:	3401      	adds	r4, #1
 800dc36:	9301      	str	r3, [sp, #4]
 800dc38:	230a      	movs	r3, #10
 800dc3a:	9a01      	ldr	r2, [sp, #4]
 800dc3c:	4353      	muls	r3, r2
 800dc3e:	3b30      	subs	r3, #48	; 0x30
 800dc40:	1859      	adds	r1, r3, r1
 800dc42:	9147      	str	r1, [sp, #284]	; 0x11c
 800dc44:	e7f0      	b.n	800dc28 <__ssvfiscanf_r+0xac>
 800dc46:	4e87      	ldr	r6, [pc, #540]	; (800de64 <__ssvfiscanf_r+0x2e8>)
 800dc48:	2203      	movs	r2, #3
 800dc4a:	1c30      	adds	r0, r6, #0
 800dc4c:	f000 fe0a 	bl	800e864 <memchr>
 800dc50:	2800      	cmp	r0, #0
 800dc52:	d008      	beq.n	800dc66 <__ssvfiscanf_r+0xea>
 800dc54:	1b80      	subs	r0, r0, r6
 800dc56:	2601      	movs	r6, #1
 800dc58:	4086      	lsls	r6, r0
 800dc5a:	1c30      	adds	r0, r6, #0
 800dc5c:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800dc5e:	3401      	adds	r4, #1
 800dc60:	4318      	orrs	r0, r3
 800dc62:	9301      	str	r3, [sp, #4]
 800dc64:	9045      	str	r0, [sp, #276]	; 0x114
 800dc66:	1c66      	adds	r6, r4, #1
 800dc68:	7824      	ldrb	r4, [r4, #0]
 800dc6a:	2c67      	cmp	r4, #103	; 0x67
 800dc6c:	d810      	bhi.n	800dc90 <__ssvfiscanf_r+0x114>
 800dc6e:	2c65      	cmp	r4, #101	; 0x65
 800dc70:	d300      	bcc.n	800dc74 <__ssvfiscanf_r+0xf8>
 800dc72:	e084      	b.n	800dd7e <__ssvfiscanf_r+0x202>
 800dc74:	2c5b      	cmp	r4, #91	; 0x5b
 800dc76:	d05a      	beq.n	800dd2e <__ssvfiscanf_r+0x1b2>
 800dc78:	d805      	bhi.n	800dc86 <__ssvfiscanf_r+0x10a>
 800dc7a:	2c00      	cmp	r4, #0
 800dc7c:	d100      	bne.n	800dc80 <__ssvfiscanf_r+0x104>
 800dc7e:	e0e2      	b.n	800de46 <__ssvfiscanf_r+0x2ca>
 800dc80:	2c25      	cmp	r4, #37	; 0x25
 800dc82:	d018      	beq.n	800dcb6 <__ssvfiscanf_r+0x13a>
 800dc84:	e07d      	b.n	800dd82 <__ssvfiscanf_r+0x206>
 800dc86:	2c63      	cmp	r4, #99	; 0x63
 800dc88:	d05f      	beq.n	800dd4a <__ssvfiscanf_r+0x1ce>
 800dc8a:	2c64      	cmp	r4, #100	; 0x64
 800dc8c:	d046      	beq.n	800dd1c <__ssvfiscanf_r+0x1a0>
 800dc8e:	e078      	b.n	800dd82 <__ssvfiscanf_r+0x206>
 800dc90:	2c70      	cmp	r4, #112	; 0x70
 800dc92:	d034      	beq.n	800dcfe <__ssvfiscanf_r+0x182>
 800dc94:	d807      	bhi.n	800dca6 <__ssvfiscanf_r+0x12a>
 800dc96:	2c6e      	cmp	r4, #110	; 0x6e
 800dc98:	d05f      	beq.n	800dd5a <__ssvfiscanf_r+0x1de>
 800dc9a:	d841      	bhi.n	800dd20 <__ssvfiscanf_r+0x1a4>
 800dc9c:	2c69      	cmp	r4, #105	; 0x69
 800dc9e:	d170      	bne.n	800dd82 <__ssvfiscanf_r+0x206>
 800dca0:	2300      	movs	r3, #0
 800dca2:	9346      	str	r3, [sp, #280]	; 0x118
 800dca4:	e041      	b.n	800dd2a <__ssvfiscanf_r+0x1ae>
 800dca6:	2c75      	cmp	r4, #117	; 0x75
 800dca8:	d038      	beq.n	800dd1c <__ssvfiscanf_r+0x1a0>
 800dcaa:	2c78      	cmp	r4, #120	; 0x78
 800dcac:	d02d      	beq.n	800dd0a <__ssvfiscanf_r+0x18e>
 800dcae:	2c73      	cmp	r4, #115	; 0x73
 800dcb0:	d167      	bne.n	800dd82 <__ssvfiscanf_r+0x206>
 800dcb2:	2302      	movs	r3, #2
 800dcb4:	e047      	b.n	800dd46 <__ssvfiscanf_r+0x1ca>
 800dcb6:	686b      	ldr	r3, [r5, #4]
 800dcb8:	2b00      	cmp	r3, #0
 800dcba:	dd0e      	ble.n	800dcda <__ssvfiscanf_r+0x15e>
 800dcbc:	682b      	ldr	r3, [r5, #0]
 800dcbe:	781a      	ldrb	r2, [r3, #0]
 800dcc0:	42a2      	cmp	r2, r4
 800dcc2:	d000      	beq.n	800dcc6 <__ssvfiscanf_r+0x14a>
 800dcc4:	e0bd      	b.n	800de42 <__ssvfiscanf_r+0x2c6>
 800dcc6:	3301      	adds	r3, #1
 800dcc8:	686a      	ldr	r2, [r5, #4]
 800dcca:	602b      	str	r3, [r5, #0]
 800dccc:	9b49      	ldr	r3, [sp, #292]	; 0x124
 800dcce:	3a01      	subs	r2, #1
 800dcd0:	9301      	str	r3, [sp, #4]
 800dcd2:	3301      	adds	r3, #1
 800dcd4:	606a      	str	r2, [r5, #4]
 800dcd6:	9349      	str	r3, [sp, #292]	; 0x124
 800dcd8:	e797      	b.n	800dc0a <__ssvfiscanf_r+0x8e>
 800dcda:	2186      	movs	r1, #134	; 0x86
 800dcdc:	23c0      	movs	r3, #192	; 0xc0
 800dcde:	0049      	lsls	r1, r1, #1
 800dce0:	aa02      	add	r2, sp, #8
 800dce2:	1852      	adds	r2, r2, r1
 800dce4:	005b      	lsls	r3, r3, #1
 800dce6:	58d3      	ldr	r3, [r2, r3]
 800dce8:	1c38      	adds	r0, r7, #0
 800dcea:	1c29      	adds	r1, r5, #0
 800dcec:	4798      	blx	r3
 800dcee:	2800      	cmp	r0, #0
 800dcf0:	d0e4      	beq.n	800dcbc <__ssvfiscanf_r+0x140>
 800dcf2:	9848      	ldr	r0, [sp, #288]	; 0x120
 800dcf4:	2800      	cmp	r0, #0
 800dcf6:	d000      	beq.n	800dcfa <__ssvfiscanf_r+0x17e>
 800dcf8:	e09f      	b.n	800de3a <__ssvfiscanf_r+0x2be>
 800dcfa:	3801      	subs	r0, #1
 800dcfc:	e0a5      	b.n	800de4a <__ssvfiscanf_r+0x2ce>
 800dcfe:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800dd00:	9301      	str	r3, [sp, #4]
 800dd02:	2320      	movs	r3, #32
 800dd04:	9a01      	ldr	r2, [sp, #4]
 800dd06:	4313      	orrs	r3, r2
 800dd08:	9345      	str	r3, [sp, #276]	; 0x114
 800dd0a:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800dd0c:	9301      	str	r3, [sp, #4]
 800dd0e:	2380      	movs	r3, #128	; 0x80
 800dd10:	9a01      	ldr	r2, [sp, #4]
 800dd12:	009b      	lsls	r3, r3, #2
 800dd14:	4313      	orrs	r3, r2
 800dd16:	9345      	str	r3, [sp, #276]	; 0x114
 800dd18:	2310      	movs	r3, #16
 800dd1a:	e002      	b.n	800dd22 <__ssvfiscanf_r+0x1a6>
 800dd1c:	230a      	movs	r3, #10
 800dd1e:	e000      	b.n	800dd22 <__ssvfiscanf_r+0x1a6>
 800dd20:	2308      	movs	r3, #8
 800dd22:	9346      	str	r3, [sp, #280]	; 0x118
 800dd24:	2304      	movs	r3, #4
 800dd26:	2c6e      	cmp	r4, #110	; 0x6e
 800dd28:	dc0d      	bgt.n	800dd46 <__ssvfiscanf_r+0x1ca>
 800dd2a:	2303      	movs	r3, #3
 800dd2c:	e00b      	b.n	800dd46 <__ssvfiscanf_r+0x1ca>
 800dd2e:	1c31      	adds	r1, r6, #0
 800dd30:	a805      	add	r0, sp, #20
 800dd32:	f000 fd01 	bl	800e738 <__sccl>
 800dd36:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800dd38:	1c06      	adds	r6, r0, #0
 800dd3a:	9301      	str	r3, [sp, #4]
 800dd3c:	2340      	movs	r3, #64	; 0x40
 800dd3e:	9a01      	ldr	r2, [sp, #4]
 800dd40:	4313      	orrs	r3, r2
 800dd42:	9345      	str	r3, [sp, #276]	; 0x114
 800dd44:	2301      	movs	r3, #1
 800dd46:	934b      	str	r3, [sp, #300]	; 0x12c
 800dd48:	e01f      	b.n	800dd8a <__ssvfiscanf_r+0x20e>
 800dd4a:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800dd4c:	9301      	str	r3, [sp, #4]
 800dd4e:	2340      	movs	r3, #64	; 0x40
 800dd50:	9a01      	ldr	r2, [sp, #4]
 800dd52:	4313      	orrs	r3, r2
 800dd54:	9345      	str	r3, [sp, #276]	; 0x114
 800dd56:	2300      	movs	r3, #0
 800dd58:	e7f5      	b.n	800dd46 <__ssvfiscanf_r+0x1ca>
 800dd5a:	9945      	ldr	r1, [sp, #276]	; 0x114
 800dd5c:	06cb      	lsls	r3, r1, #27
 800dd5e:	d500      	bpl.n	800dd62 <__ssvfiscanf_r+0x1e6>
 800dd60:	e753      	b.n	800dc0a <__ssvfiscanf_r+0x8e>
 800dd62:	9b03      	ldr	r3, [sp, #12]
 800dd64:	9a49      	ldr	r2, [sp, #292]	; 0x124
 800dd66:	07c8      	lsls	r0, r1, #31
 800dd68:	d504      	bpl.n	800dd74 <__ssvfiscanf_r+0x1f8>
 800dd6a:	1d19      	adds	r1, r3, #4
 800dd6c:	9103      	str	r1, [sp, #12]
 800dd6e:	681b      	ldr	r3, [r3, #0]
 800dd70:	801a      	strh	r2, [r3, #0]
 800dd72:	e74a      	b.n	800dc0a <__ssvfiscanf_r+0x8e>
 800dd74:	1d19      	adds	r1, r3, #4
 800dd76:	9103      	str	r1, [sp, #12]
 800dd78:	681b      	ldr	r3, [r3, #0]
 800dd7a:	601a      	str	r2, [r3, #0]
 800dd7c:	e745      	b.n	800dc0a <__ssvfiscanf_r+0x8e>
 800dd7e:	2305      	movs	r3, #5
 800dd80:	e7e1      	b.n	800dd46 <__ssvfiscanf_r+0x1ca>
 800dd82:	2303      	movs	r3, #3
 800dd84:	934b      	str	r3, [sp, #300]	; 0x12c
 800dd86:	3307      	adds	r3, #7
 800dd88:	9346      	str	r3, [sp, #280]	; 0x118
 800dd8a:	686b      	ldr	r3, [r5, #4]
 800dd8c:	2b00      	cmp	r3, #0
 800dd8e:	dd04      	ble.n	800dd9a <__ssvfiscanf_r+0x21e>
 800dd90:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800dd92:	9301      	str	r3, [sp, #4]
 800dd94:	065b      	lsls	r3, r3, #25
 800dd96:	d518      	bpl.n	800ddca <__ssvfiscanf_r+0x24e>
 800dd98:	e01f      	b.n	800ddda <__ssvfiscanf_r+0x25e>
 800dd9a:	2186      	movs	r1, #134	; 0x86
 800dd9c:	23c0      	movs	r3, #192	; 0xc0
 800dd9e:	0049      	lsls	r1, r1, #1
 800dda0:	aa02      	add	r2, sp, #8
 800dda2:	1852      	adds	r2, r2, r1
 800dda4:	005b      	lsls	r3, r3, #1
 800dda6:	58d3      	ldr	r3, [r2, r3]
 800dda8:	1c38      	adds	r0, r7, #0
 800ddaa:	1c29      	adds	r1, r5, #0
 800ddac:	4798      	blx	r3
 800ddae:	2800      	cmp	r0, #0
 800ddb0:	d0ee      	beq.n	800dd90 <__ssvfiscanf_r+0x214>
 800ddb2:	e79e      	b.n	800dcf2 <__ssvfiscanf_r+0x176>
 800ddb4:	9a49      	ldr	r2, [sp, #292]	; 0x124
 800ddb6:	9201      	str	r2, [sp, #4]
 800ddb8:	3201      	adds	r2, #1
 800ddba:	9249      	str	r2, [sp, #292]	; 0x124
 800ddbc:	686a      	ldr	r2, [r5, #4]
 800ddbe:	3a01      	subs	r2, #1
 800ddc0:	606a      	str	r2, [r5, #4]
 800ddc2:	2a00      	cmp	r2, #0
 800ddc4:	dd13      	ble.n	800ddee <__ssvfiscanf_r+0x272>
 800ddc6:	3301      	adds	r3, #1
 800ddc8:	602b      	str	r3, [r5, #0]
 800ddca:	682b      	ldr	r3, [r5, #0]
 800ddcc:	4924      	ldr	r1, [pc, #144]	; (800de60 <__ssvfiscanf_r+0x2e4>)
 800ddce:	781a      	ldrb	r2, [r3, #0]
 800ddd0:	6809      	ldr	r1, [r1, #0]
 800ddd2:	188a      	adds	r2, r1, r2
 800ddd4:	7852      	ldrb	r2, [r2, #1]
 800ddd6:	0712      	lsls	r2, r2, #28
 800ddd8:	d4ec      	bmi.n	800ddb4 <__ssvfiscanf_r+0x238>
 800ddda:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
 800dddc:	2b02      	cmp	r3, #2
 800ddde:	dc13      	bgt.n	800de08 <__ssvfiscanf_r+0x28c>
 800dde0:	1c38      	adds	r0, r7, #0
 800dde2:	a945      	add	r1, sp, #276	; 0x114
 800dde4:	1c2a      	adds	r2, r5, #0
 800dde6:	ab03      	add	r3, sp, #12
 800dde8:	f000 fafe 	bl	800e3e8 <_scanf_chars>
 800ddec:	e01f      	b.n	800de2e <__ssvfiscanf_r+0x2b2>
 800ddee:	2186      	movs	r1, #134	; 0x86
 800ddf0:	23c0      	movs	r3, #192	; 0xc0
 800ddf2:	0049      	lsls	r1, r1, #1
 800ddf4:	aa02      	add	r2, sp, #8
 800ddf6:	1852      	adds	r2, r2, r1
 800ddf8:	005b      	lsls	r3, r3, #1
 800ddfa:	58d3      	ldr	r3, [r2, r3]
 800ddfc:	1c38      	adds	r0, r7, #0
 800ddfe:	1c29      	adds	r1, r5, #0
 800de00:	4798      	blx	r3
 800de02:	2800      	cmp	r0, #0
 800de04:	d0e1      	beq.n	800ddca <__ssvfiscanf_r+0x24e>
 800de06:	e774      	b.n	800dcf2 <__ssvfiscanf_r+0x176>
 800de08:	2b04      	cmp	r3, #4
 800de0a:	dc06      	bgt.n	800de1a <__ssvfiscanf_r+0x29e>
 800de0c:	1c38      	adds	r0, r7, #0
 800de0e:	a945      	add	r1, sp, #276	; 0x114
 800de10:	1c2a      	adds	r2, r5, #0
 800de12:	ab03      	add	r3, sp, #12
 800de14:	f000 fb46 	bl	800e4a4 <_scanf_i>
 800de18:	e009      	b.n	800de2e <__ssvfiscanf_r+0x2b2>
 800de1a:	4b13      	ldr	r3, [pc, #76]	; (800de68 <__ssvfiscanf_r+0x2ec>)
 800de1c:	2b00      	cmp	r3, #0
 800de1e:	d100      	bne.n	800de22 <__ssvfiscanf_r+0x2a6>
 800de20:	e6f3      	b.n	800dc0a <__ssvfiscanf_r+0x8e>
 800de22:	1c38      	adds	r0, r7, #0
 800de24:	a945      	add	r1, sp, #276	; 0x114
 800de26:	1c2a      	adds	r2, r5, #0
 800de28:	ab03      	add	r3, sp, #12
 800de2a:	e000      	b.n	800de2e <__ssvfiscanf_r+0x2b2>
 800de2c:	bf00      	nop
 800de2e:	2801      	cmp	r0, #1
 800de30:	d007      	beq.n	800de42 <__ssvfiscanf_r+0x2c6>
 800de32:	2802      	cmp	r0, #2
 800de34:	d000      	beq.n	800de38 <__ssvfiscanf_r+0x2bc>
 800de36:	e6e8      	b.n	800dc0a <__ssvfiscanf_r+0x8e>
 800de38:	e75b      	b.n	800dcf2 <__ssvfiscanf_r+0x176>
 800de3a:	89ab      	ldrh	r3, [r5, #12]
 800de3c:	065b      	lsls	r3, r3, #25
 800de3e:	d504      	bpl.n	800de4a <__ssvfiscanf_r+0x2ce>
 800de40:	e001      	b.n	800de46 <__ssvfiscanf_r+0x2ca>
 800de42:	9848      	ldr	r0, [sp, #288]	; 0x120
 800de44:	e001      	b.n	800de4a <__ssvfiscanf_r+0x2ce>
 800de46:	2001      	movs	r0, #1
 800de48:	4240      	negs	r0, r0
 800de4a:	23a7      	movs	r3, #167	; 0xa7
 800de4c:	009b      	lsls	r3, r3, #2
 800de4e:	449d      	add	sp, r3
 800de50:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800de52:	46c0      	nop			; (mov r8, r8)
 800de54:	fffffd64 	.word	0xfffffd64
 800de58:	0800dac5 	.word	0x0800dac5
 800de5c:	0800db3f 	.word	0x0800db3f
 800de60:	20000134 	.word	0x20000134
 800de64:	0801535e 	.word	0x0801535e
 800de68:	00000000 	.word	0x00000000

0800de6c <__sfputc_r>:
 800de6c:	6893      	ldr	r3, [r2, #8]
 800de6e:	b510      	push	{r4, lr}
 800de70:	3b01      	subs	r3, #1
 800de72:	6093      	str	r3, [r2, #8]
 800de74:	2b00      	cmp	r3, #0
 800de76:	da05      	bge.n	800de84 <__sfputc_r+0x18>
 800de78:	6994      	ldr	r4, [r2, #24]
 800de7a:	42a3      	cmp	r3, r4
 800de7c:	db08      	blt.n	800de90 <__sfputc_r+0x24>
 800de7e:	b2cb      	uxtb	r3, r1
 800de80:	2b0a      	cmp	r3, #10
 800de82:	d005      	beq.n	800de90 <__sfputc_r+0x24>
 800de84:	6813      	ldr	r3, [r2, #0]
 800de86:	1c58      	adds	r0, r3, #1
 800de88:	6010      	str	r0, [r2, #0]
 800de8a:	7019      	strb	r1, [r3, #0]
 800de8c:	b2c8      	uxtb	r0, r1
 800de8e:	e001      	b.n	800de94 <__sfputc_r+0x28>
 800de90:	f7ff f9da 	bl	800d248 <__swbuf_r>
 800de94:	bd10      	pop	{r4, pc}

0800de96 <__sfputs_r>:
 800de96:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800de98:	1c06      	adds	r6, r0, #0
 800de9a:	1c0f      	adds	r7, r1, #0
 800de9c:	1c14      	adds	r4, r2, #0
 800de9e:	18d5      	adds	r5, r2, r3
 800dea0:	42ac      	cmp	r4, r5
 800dea2:	d008      	beq.n	800deb6 <__sfputs_r+0x20>
 800dea4:	7821      	ldrb	r1, [r4, #0]
 800dea6:	1c30      	adds	r0, r6, #0
 800dea8:	1c3a      	adds	r2, r7, #0
 800deaa:	f7ff ffdf 	bl	800de6c <__sfputc_r>
 800deae:	3401      	adds	r4, #1
 800deb0:	1c43      	adds	r3, r0, #1
 800deb2:	d1f5      	bne.n	800dea0 <__sfputs_r+0xa>
 800deb4:	e000      	b.n	800deb8 <__sfputs_r+0x22>
 800deb6:	2000      	movs	r0, #0
 800deb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0800debc <_vfiprintf_r>:
 800debc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800debe:	b09f      	sub	sp, #124	; 0x7c
 800dec0:	1c06      	adds	r6, r0, #0
 800dec2:	1c0f      	adds	r7, r1, #0
 800dec4:	9202      	str	r2, [sp, #8]
 800dec6:	9305      	str	r3, [sp, #20]
 800dec8:	2800      	cmp	r0, #0
 800deca:	d004      	beq.n	800ded6 <_vfiprintf_r+0x1a>
 800decc:	6983      	ldr	r3, [r0, #24]
 800dece:	2b00      	cmp	r3, #0
 800ded0:	d101      	bne.n	800ded6 <_vfiprintf_r+0x1a>
 800ded2:	f7ff fba3 	bl	800d61c <__sinit>
 800ded6:	4b79      	ldr	r3, [pc, #484]	; (800e0bc <_vfiprintf_r+0x200>)
 800ded8:	429f      	cmp	r7, r3
 800deda:	d101      	bne.n	800dee0 <_vfiprintf_r+0x24>
 800dedc:	6877      	ldr	r7, [r6, #4]
 800dede:	e008      	b.n	800def2 <_vfiprintf_r+0x36>
 800dee0:	4b77      	ldr	r3, [pc, #476]	; (800e0c0 <_vfiprintf_r+0x204>)
 800dee2:	429f      	cmp	r7, r3
 800dee4:	d101      	bne.n	800deea <_vfiprintf_r+0x2e>
 800dee6:	68b7      	ldr	r7, [r6, #8]
 800dee8:	e003      	b.n	800def2 <_vfiprintf_r+0x36>
 800deea:	4b76      	ldr	r3, [pc, #472]	; (800e0c4 <_vfiprintf_r+0x208>)
 800deec:	429f      	cmp	r7, r3
 800deee:	d100      	bne.n	800def2 <_vfiprintf_r+0x36>
 800def0:	68f7      	ldr	r7, [r6, #12]
 800def2:	89bb      	ldrh	r3, [r7, #12]
 800def4:	071b      	lsls	r3, r3, #28
 800def6:	d50a      	bpl.n	800df0e <_vfiprintf_r+0x52>
 800def8:	693b      	ldr	r3, [r7, #16]
 800defa:	2b00      	cmp	r3, #0
 800defc:	d007      	beq.n	800df0e <_vfiprintf_r+0x52>
 800defe:	2300      	movs	r3, #0
 800df00:	ad06      	add	r5, sp, #24
 800df02:	616b      	str	r3, [r5, #20]
 800df04:	3320      	adds	r3, #32
 800df06:	766b      	strb	r3, [r5, #25]
 800df08:	3310      	adds	r3, #16
 800df0a:	76ab      	strb	r3, [r5, #26]
 800df0c:	e03d      	b.n	800df8a <_vfiprintf_r+0xce>
 800df0e:	1c30      	adds	r0, r6, #0
 800df10:	1c39      	adds	r1, r7, #0
 800df12:	f7ff fa05 	bl	800d320 <__swsetup_r>
 800df16:	2800      	cmp	r0, #0
 800df18:	d0f1      	beq.n	800defe <_vfiprintf_r+0x42>
 800df1a:	2001      	movs	r0, #1
 800df1c:	4240      	negs	r0, r0
 800df1e:	e0ca      	b.n	800e0b6 <_vfiprintf_r+0x1fa>
 800df20:	9a05      	ldr	r2, [sp, #20]
 800df22:	1d11      	adds	r1, r2, #4
 800df24:	6812      	ldr	r2, [r2, #0]
 800df26:	9105      	str	r1, [sp, #20]
 800df28:	2a00      	cmp	r2, #0
 800df2a:	db7e      	blt.n	800e02a <_vfiprintf_r+0x16e>
 800df2c:	9209      	str	r2, [sp, #36]	; 0x24
 800df2e:	3401      	adds	r4, #1
 800df30:	7823      	ldrb	r3, [r4, #0]
 800df32:	2b2e      	cmp	r3, #46	; 0x2e
 800df34:	d100      	bne.n	800df38 <_vfiprintf_r+0x7c>
 800df36:	e089      	b.n	800e04c <_vfiprintf_r+0x190>
 800df38:	7821      	ldrb	r1, [r4, #0]
 800df3a:	4863      	ldr	r0, [pc, #396]	; (800e0c8 <_vfiprintf_r+0x20c>)
 800df3c:	2203      	movs	r2, #3
 800df3e:	f000 fc91 	bl	800e864 <memchr>
 800df42:	2800      	cmp	r0, #0
 800df44:	d008      	beq.n	800df58 <_vfiprintf_r+0x9c>
 800df46:	4b60      	ldr	r3, [pc, #384]	; (800e0c8 <_vfiprintf_r+0x20c>)
 800df48:	3401      	adds	r4, #1
 800df4a:	1ac0      	subs	r0, r0, r3
 800df4c:	2340      	movs	r3, #64	; 0x40
 800df4e:	4083      	lsls	r3, r0
 800df50:	1c18      	adds	r0, r3, #0
 800df52:	682b      	ldr	r3, [r5, #0]
 800df54:	4318      	orrs	r0, r3
 800df56:	6028      	str	r0, [r5, #0]
 800df58:	7821      	ldrb	r1, [r4, #0]
 800df5a:	1c63      	adds	r3, r4, #1
 800df5c:	485b      	ldr	r0, [pc, #364]	; (800e0cc <_vfiprintf_r+0x210>)
 800df5e:	2206      	movs	r2, #6
 800df60:	9302      	str	r3, [sp, #8]
 800df62:	7629      	strb	r1, [r5, #24]
 800df64:	f000 fc7e 	bl	800e864 <memchr>
 800df68:	2800      	cmp	r0, #0
 800df6a:	d100      	bne.n	800df6e <_vfiprintf_r+0xb2>
 800df6c:	e091      	b.n	800e092 <_vfiprintf_r+0x1d6>
 800df6e:	4b58      	ldr	r3, [pc, #352]	; (800e0d0 <_vfiprintf_r+0x214>)
 800df70:	2b00      	cmp	r3, #0
 800df72:	d000      	beq.n	800df76 <_vfiprintf_r+0xba>
 800df74:	e084      	b.n	800e080 <_vfiprintf_r+0x1c4>
 800df76:	2207      	movs	r2, #7
 800df78:	9b05      	ldr	r3, [sp, #20]
 800df7a:	3307      	adds	r3, #7
 800df7c:	4393      	bics	r3, r2
 800df7e:	3308      	adds	r3, #8
 800df80:	9305      	str	r3, [sp, #20]
 800df82:	696b      	ldr	r3, [r5, #20]
 800df84:	9a03      	ldr	r2, [sp, #12]
 800df86:	189b      	adds	r3, r3, r2
 800df88:	616b      	str	r3, [r5, #20]
 800df8a:	9c02      	ldr	r4, [sp, #8]
 800df8c:	7823      	ldrb	r3, [r4, #0]
 800df8e:	2b00      	cmp	r3, #0
 800df90:	d104      	bne.n	800df9c <_vfiprintf_r+0xe0>
 800df92:	9b02      	ldr	r3, [sp, #8]
 800df94:	1ae3      	subs	r3, r4, r3
 800df96:	9304      	str	r3, [sp, #16]
 800df98:	d011      	beq.n	800dfbe <_vfiprintf_r+0x102>
 800df9a:	e003      	b.n	800dfa4 <_vfiprintf_r+0xe8>
 800df9c:	2b25      	cmp	r3, #37	; 0x25
 800df9e:	d0f8      	beq.n	800df92 <_vfiprintf_r+0xd6>
 800dfa0:	3401      	adds	r4, #1
 800dfa2:	e7f3      	b.n	800df8c <_vfiprintf_r+0xd0>
 800dfa4:	9b04      	ldr	r3, [sp, #16]
 800dfa6:	1c30      	adds	r0, r6, #0
 800dfa8:	1c39      	adds	r1, r7, #0
 800dfaa:	9a02      	ldr	r2, [sp, #8]
 800dfac:	f7ff ff73 	bl	800de96 <__sfputs_r>
 800dfb0:	1c43      	adds	r3, r0, #1
 800dfb2:	d07b      	beq.n	800e0ac <_vfiprintf_r+0x1f0>
 800dfb4:	696a      	ldr	r2, [r5, #20]
 800dfb6:	9b04      	ldr	r3, [sp, #16]
 800dfb8:	4694      	mov	ip, r2
 800dfba:	4463      	add	r3, ip
 800dfbc:	616b      	str	r3, [r5, #20]
 800dfbe:	7823      	ldrb	r3, [r4, #0]
 800dfc0:	2b00      	cmp	r3, #0
 800dfc2:	d073      	beq.n	800e0ac <_vfiprintf_r+0x1f0>
 800dfc4:	2201      	movs	r2, #1
 800dfc6:	2300      	movs	r3, #0
 800dfc8:	4252      	negs	r2, r2
 800dfca:	606a      	str	r2, [r5, #4]
 800dfcc:	a902      	add	r1, sp, #8
 800dfce:	3254      	adds	r2, #84	; 0x54
 800dfd0:	1852      	adds	r2, r2, r1
 800dfd2:	3401      	adds	r4, #1
 800dfd4:	602b      	str	r3, [r5, #0]
 800dfd6:	60eb      	str	r3, [r5, #12]
 800dfd8:	60ab      	str	r3, [r5, #8]
 800dfda:	7013      	strb	r3, [r2, #0]
 800dfdc:	65ab      	str	r3, [r5, #88]	; 0x58
 800dfde:	7821      	ldrb	r1, [r4, #0]
 800dfe0:	483c      	ldr	r0, [pc, #240]	; (800e0d4 <_vfiprintf_r+0x218>)
 800dfe2:	2205      	movs	r2, #5
 800dfe4:	f000 fc3e 	bl	800e864 <memchr>
 800dfe8:	2800      	cmp	r0, #0
 800dfea:	d009      	beq.n	800e000 <_vfiprintf_r+0x144>
 800dfec:	4b39      	ldr	r3, [pc, #228]	; (800e0d4 <_vfiprintf_r+0x218>)
 800dfee:	3401      	adds	r4, #1
 800dff0:	1ac0      	subs	r0, r0, r3
 800dff2:	2301      	movs	r3, #1
 800dff4:	4083      	lsls	r3, r0
 800dff6:	1c18      	adds	r0, r3, #0
 800dff8:	682b      	ldr	r3, [r5, #0]
 800dffa:	4318      	orrs	r0, r3
 800dffc:	6028      	str	r0, [r5, #0]
 800dffe:	e7ee      	b.n	800dfde <_vfiprintf_r+0x122>
 800e000:	682b      	ldr	r3, [r5, #0]
 800e002:	06da      	lsls	r2, r3, #27
 800e004:	d504      	bpl.n	800e010 <_vfiprintf_r+0x154>
 800e006:	2253      	movs	r2, #83	; 0x53
 800e008:	2120      	movs	r1, #32
 800e00a:	a802      	add	r0, sp, #8
 800e00c:	1812      	adds	r2, r2, r0
 800e00e:	7011      	strb	r1, [r2, #0]
 800e010:	071a      	lsls	r2, r3, #28
 800e012:	d504      	bpl.n	800e01e <_vfiprintf_r+0x162>
 800e014:	2253      	movs	r2, #83	; 0x53
 800e016:	212b      	movs	r1, #43	; 0x2b
 800e018:	a802      	add	r0, sp, #8
 800e01a:	1812      	adds	r2, r2, r0
 800e01c:	7011      	strb	r1, [r2, #0]
 800e01e:	7822      	ldrb	r2, [r4, #0]
 800e020:	2a2a      	cmp	r2, #42	; 0x2a
 800e022:	d100      	bne.n	800e026 <_vfiprintf_r+0x16a>
 800e024:	e77c      	b.n	800df20 <_vfiprintf_r+0x64>
 800e026:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e028:	e005      	b.n	800e036 <_vfiprintf_r+0x17a>
 800e02a:	4252      	negs	r2, r2
 800e02c:	60ea      	str	r2, [r5, #12]
 800e02e:	2202      	movs	r2, #2
 800e030:	4313      	orrs	r3, r2
 800e032:	602b      	str	r3, [r5, #0]
 800e034:	e77b      	b.n	800df2e <_vfiprintf_r+0x72>
 800e036:	7822      	ldrb	r2, [r4, #0]
 800e038:	3a30      	subs	r2, #48	; 0x30
 800e03a:	2a09      	cmp	r2, #9
 800e03c:	d804      	bhi.n	800e048 <_vfiprintf_r+0x18c>
 800e03e:	210a      	movs	r1, #10
 800e040:	434b      	muls	r3, r1
 800e042:	3401      	adds	r4, #1
 800e044:	189b      	adds	r3, r3, r2
 800e046:	e7f6      	b.n	800e036 <_vfiprintf_r+0x17a>
 800e048:	9309      	str	r3, [sp, #36]	; 0x24
 800e04a:	e771      	b.n	800df30 <_vfiprintf_r+0x74>
 800e04c:	7863      	ldrb	r3, [r4, #1]
 800e04e:	2b2a      	cmp	r3, #42	; 0x2a
 800e050:	d109      	bne.n	800e066 <_vfiprintf_r+0x1aa>
 800e052:	9b05      	ldr	r3, [sp, #20]
 800e054:	3402      	adds	r4, #2
 800e056:	1d1a      	adds	r2, r3, #4
 800e058:	681b      	ldr	r3, [r3, #0]
 800e05a:	9205      	str	r2, [sp, #20]
 800e05c:	2b00      	cmp	r3, #0
 800e05e:	da0d      	bge.n	800e07c <_vfiprintf_r+0x1c0>
 800e060:	2301      	movs	r3, #1
 800e062:	425b      	negs	r3, r3
 800e064:	e00a      	b.n	800e07c <_vfiprintf_r+0x1c0>
 800e066:	2300      	movs	r3, #0
 800e068:	3401      	adds	r4, #1
 800e06a:	7822      	ldrb	r2, [r4, #0]
 800e06c:	3a30      	subs	r2, #48	; 0x30
 800e06e:	2a09      	cmp	r2, #9
 800e070:	d804      	bhi.n	800e07c <_vfiprintf_r+0x1c0>
 800e072:	210a      	movs	r1, #10
 800e074:	434b      	muls	r3, r1
 800e076:	3401      	adds	r4, #1
 800e078:	189b      	adds	r3, r3, r2
 800e07a:	e7f6      	b.n	800e06a <_vfiprintf_r+0x1ae>
 800e07c:	9307      	str	r3, [sp, #28]
 800e07e:	e75b      	b.n	800df38 <_vfiprintf_r+0x7c>
 800e080:	ab05      	add	r3, sp, #20
 800e082:	9300      	str	r3, [sp, #0]
 800e084:	1c30      	adds	r0, r6, #0
 800e086:	1c29      	adds	r1, r5, #0
 800e088:	1c3a      	adds	r2, r7, #0
 800e08a:	4b13      	ldr	r3, [pc, #76]	; (800e0d8 <_vfiprintf_r+0x21c>)
 800e08c:	e000      	b.n	800e090 <_vfiprintf_r+0x1d4>
 800e08e:	bf00      	nop
 800e090:	e007      	b.n	800e0a2 <_vfiprintf_r+0x1e6>
 800e092:	ab05      	add	r3, sp, #20
 800e094:	9300      	str	r3, [sp, #0]
 800e096:	1c30      	adds	r0, r6, #0
 800e098:	1c29      	adds	r1, r5, #0
 800e09a:	1c3a      	adds	r2, r7, #0
 800e09c:	4b0e      	ldr	r3, [pc, #56]	; (800e0d8 <_vfiprintf_r+0x21c>)
 800e09e:	f000 f88b 	bl	800e1b8 <_printf_i>
 800e0a2:	9003      	str	r0, [sp, #12]
 800e0a4:	9b03      	ldr	r3, [sp, #12]
 800e0a6:	3301      	adds	r3, #1
 800e0a8:	d000      	beq.n	800e0ac <_vfiprintf_r+0x1f0>
 800e0aa:	e76a      	b.n	800df82 <_vfiprintf_r+0xc6>
 800e0ac:	89bb      	ldrh	r3, [r7, #12]
 800e0ae:	065b      	lsls	r3, r3, #25
 800e0b0:	d500      	bpl.n	800e0b4 <_vfiprintf_r+0x1f8>
 800e0b2:	e732      	b.n	800df1a <_vfiprintf_r+0x5e>
 800e0b4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800e0b6:	b01f      	add	sp, #124	; 0x7c
 800e0b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e0ba:	46c0      	nop			; (mov r8, r8)
 800e0bc:	080152f8 	.word	0x080152f8
 800e0c0:	08015318 	.word	0x08015318
 800e0c4:	08015338 	.word	0x08015338
 800e0c8:	0801535e 	.word	0x0801535e
 800e0cc:	08015362 	.word	0x08015362
 800e0d0:	00000000 	.word	0x00000000
 800e0d4:	08015358 	.word	0x08015358
 800e0d8:	0800de97 	.word	0x0800de97

0800e0dc <_printf_common>:
 800e0dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e0de:	1c17      	adds	r7, r2, #0
 800e0e0:	9301      	str	r3, [sp, #4]
 800e0e2:	690a      	ldr	r2, [r1, #16]
 800e0e4:	688b      	ldr	r3, [r1, #8]
 800e0e6:	9000      	str	r0, [sp, #0]
 800e0e8:	1c0c      	adds	r4, r1, #0
 800e0ea:	4293      	cmp	r3, r2
 800e0ec:	da00      	bge.n	800e0f0 <_printf_common+0x14>
 800e0ee:	1c13      	adds	r3, r2, #0
 800e0f0:	1c22      	adds	r2, r4, #0
 800e0f2:	603b      	str	r3, [r7, #0]
 800e0f4:	3243      	adds	r2, #67	; 0x43
 800e0f6:	7812      	ldrb	r2, [r2, #0]
 800e0f8:	2a00      	cmp	r2, #0
 800e0fa:	d001      	beq.n	800e100 <_printf_common+0x24>
 800e0fc:	3301      	adds	r3, #1
 800e0fe:	603b      	str	r3, [r7, #0]
 800e100:	6823      	ldr	r3, [r4, #0]
 800e102:	069b      	lsls	r3, r3, #26
 800e104:	d502      	bpl.n	800e10c <_printf_common+0x30>
 800e106:	683b      	ldr	r3, [r7, #0]
 800e108:	3302      	adds	r3, #2
 800e10a:	603b      	str	r3, [r7, #0]
 800e10c:	2506      	movs	r5, #6
 800e10e:	6823      	ldr	r3, [r4, #0]
 800e110:	401d      	ands	r5, r3
 800e112:	d01e      	beq.n	800e152 <_printf_common+0x76>
 800e114:	1c23      	adds	r3, r4, #0
 800e116:	3343      	adds	r3, #67	; 0x43
 800e118:	781b      	ldrb	r3, [r3, #0]
 800e11a:	1e5a      	subs	r2, r3, #1
 800e11c:	4193      	sbcs	r3, r2
 800e11e:	6822      	ldr	r2, [r4, #0]
 800e120:	0692      	lsls	r2, r2, #26
 800e122:	d51c      	bpl.n	800e15e <_printf_common+0x82>
 800e124:	2030      	movs	r0, #48	; 0x30
 800e126:	18e1      	adds	r1, r4, r3
 800e128:	3140      	adds	r1, #64	; 0x40
 800e12a:	70c8      	strb	r0, [r1, #3]
 800e12c:	1c21      	adds	r1, r4, #0
 800e12e:	1c5a      	adds	r2, r3, #1
 800e130:	3145      	adds	r1, #69	; 0x45
 800e132:	7809      	ldrb	r1, [r1, #0]
 800e134:	18a2      	adds	r2, r4, r2
 800e136:	3240      	adds	r2, #64	; 0x40
 800e138:	3302      	adds	r3, #2
 800e13a:	70d1      	strb	r1, [r2, #3]
 800e13c:	e00f      	b.n	800e15e <_printf_common+0x82>
 800e13e:	1c22      	adds	r2, r4, #0
 800e140:	2301      	movs	r3, #1
 800e142:	9800      	ldr	r0, [sp, #0]
 800e144:	9901      	ldr	r1, [sp, #4]
 800e146:	3219      	adds	r2, #25
 800e148:	9e08      	ldr	r6, [sp, #32]
 800e14a:	47b0      	blx	r6
 800e14c:	1c43      	adds	r3, r0, #1
 800e14e:	d00e      	beq.n	800e16e <_printf_common+0x92>
 800e150:	3501      	adds	r5, #1
 800e152:	68e3      	ldr	r3, [r4, #12]
 800e154:	683a      	ldr	r2, [r7, #0]
 800e156:	1a9b      	subs	r3, r3, r2
 800e158:	429d      	cmp	r5, r3
 800e15a:	dbf0      	blt.n	800e13e <_printf_common+0x62>
 800e15c:	e7da      	b.n	800e114 <_printf_common+0x38>
 800e15e:	1c22      	adds	r2, r4, #0
 800e160:	9800      	ldr	r0, [sp, #0]
 800e162:	9901      	ldr	r1, [sp, #4]
 800e164:	3243      	adds	r2, #67	; 0x43
 800e166:	9d08      	ldr	r5, [sp, #32]
 800e168:	47a8      	blx	r5
 800e16a:	1c43      	adds	r3, r0, #1
 800e16c:	d102      	bne.n	800e174 <_printf_common+0x98>
 800e16e:	2001      	movs	r0, #1
 800e170:	4240      	negs	r0, r0
 800e172:	e020      	b.n	800e1b6 <_printf_common+0xda>
 800e174:	2306      	movs	r3, #6
 800e176:	6820      	ldr	r0, [r4, #0]
 800e178:	68e1      	ldr	r1, [r4, #12]
 800e17a:	683a      	ldr	r2, [r7, #0]
 800e17c:	4003      	ands	r3, r0
 800e17e:	2500      	movs	r5, #0
 800e180:	2b04      	cmp	r3, #4
 800e182:	d103      	bne.n	800e18c <_printf_common+0xb0>
 800e184:	1a8d      	subs	r5, r1, r2
 800e186:	43eb      	mvns	r3, r5
 800e188:	17db      	asrs	r3, r3, #31
 800e18a:	401d      	ands	r5, r3
 800e18c:	68a3      	ldr	r3, [r4, #8]
 800e18e:	6922      	ldr	r2, [r4, #16]
 800e190:	4293      	cmp	r3, r2
 800e192:	dd01      	ble.n	800e198 <_printf_common+0xbc>
 800e194:	1a9b      	subs	r3, r3, r2
 800e196:	18ed      	adds	r5, r5, r3
 800e198:	2700      	movs	r7, #0
 800e19a:	42af      	cmp	r7, r5
 800e19c:	da0a      	bge.n	800e1b4 <_printf_common+0xd8>
 800e19e:	1c22      	adds	r2, r4, #0
 800e1a0:	2301      	movs	r3, #1
 800e1a2:	9800      	ldr	r0, [sp, #0]
 800e1a4:	9901      	ldr	r1, [sp, #4]
 800e1a6:	321a      	adds	r2, #26
 800e1a8:	9e08      	ldr	r6, [sp, #32]
 800e1aa:	47b0      	blx	r6
 800e1ac:	1c43      	adds	r3, r0, #1
 800e1ae:	d0de      	beq.n	800e16e <_printf_common+0x92>
 800e1b0:	3701      	adds	r7, #1
 800e1b2:	e7f2      	b.n	800e19a <_printf_common+0xbe>
 800e1b4:	2000      	movs	r0, #0
 800e1b6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800e1b8 <_printf_i>:
 800e1b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e1ba:	b08b      	sub	sp, #44	; 0x2c
 800e1bc:	9206      	str	r2, [sp, #24]
 800e1be:	1c0a      	adds	r2, r1, #0
 800e1c0:	3243      	adds	r2, #67	; 0x43
 800e1c2:	9307      	str	r3, [sp, #28]
 800e1c4:	9005      	str	r0, [sp, #20]
 800e1c6:	9204      	str	r2, [sp, #16]
 800e1c8:	7e0a      	ldrb	r2, [r1, #24]
 800e1ca:	1c0c      	adds	r4, r1, #0
 800e1cc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800e1ce:	2a6e      	cmp	r2, #110	; 0x6e
 800e1d0:	d100      	bne.n	800e1d4 <_printf_i+0x1c>
 800e1d2:	e0a8      	b.n	800e326 <_printf_i+0x16e>
 800e1d4:	d811      	bhi.n	800e1fa <_printf_i+0x42>
 800e1d6:	2a63      	cmp	r2, #99	; 0x63
 800e1d8:	d022      	beq.n	800e220 <_printf_i+0x68>
 800e1da:	d809      	bhi.n	800e1f0 <_printf_i+0x38>
 800e1dc:	2a00      	cmp	r2, #0
 800e1de:	d100      	bne.n	800e1e2 <_printf_i+0x2a>
 800e1e0:	e0b2      	b.n	800e348 <_printf_i+0x190>
 800e1e2:	2a58      	cmp	r2, #88	; 0x58
 800e1e4:	d000      	beq.n	800e1e8 <_printf_i+0x30>
 800e1e6:	e0c2      	b.n	800e36e <_printf_i+0x1b6>
 800e1e8:	3145      	adds	r1, #69	; 0x45
 800e1ea:	700a      	strb	r2, [r1, #0]
 800e1ec:	4a7c      	ldr	r2, [pc, #496]	; (800e3e0 <_printf_i+0x228>)
 800e1ee:	e04f      	b.n	800e290 <_printf_i+0xd8>
 800e1f0:	2a64      	cmp	r2, #100	; 0x64
 800e1f2:	d01d      	beq.n	800e230 <_printf_i+0x78>
 800e1f4:	2a69      	cmp	r2, #105	; 0x69
 800e1f6:	d01b      	beq.n	800e230 <_printf_i+0x78>
 800e1f8:	e0b9      	b.n	800e36e <_printf_i+0x1b6>
 800e1fa:	2a73      	cmp	r2, #115	; 0x73
 800e1fc:	d100      	bne.n	800e200 <_printf_i+0x48>
 800e1fe:	e0a7      	b.n	800e350 <_printf_i+0x198>
 800e200:	d809      	bhi.n	800e216 <_printf_i+0x5e>
 800e202:	2a6f      	cmp	r2, #111	; 0x6f
 800e204:	d029      	beq.n	800e25a <_printf_i+0xa2>
 800e206:	2a70      	cmp	r2, #112	; 0x70
 800e208:	d000      	beq.n	800e20c <_printf_i+0x54>
 800e20a:	e0b0      	b.n	800e36e <_printf_i+0x1b6>
 800e20c:	2220      	movs	r2, #32
 800e20e:	6809      	ldr	r1, [r1, #0]
 800e210:	430a      	orrs	r2, r1
 800e212:	6022      	str	r2, [r4, #0]
 800e214:	e037      	b.n	800e286 <_printf_i+0xce>
 800e216:	2a75      	cmp	r2, #117	; 0x75
 800e218:	d01f      	beq.n	800e25a <_printf_i+0xa2>
 800e21a:	2a78      	cmp	r2, #120	; 0x78
 800e21c:	d033      	beq.n	800e286 <_printf_i+0xce>
 800e21e:	e0a6      	b.n	800e36e <_printf_i+0x1b6>
 800e220:	1c0d      	adds	r5, r1, #0
 800e222:	681a      	ldr	r2, [r3, #0]
 800e224:	3542      	adds	r5, #66	; 0x42
 800e226:	1d11      	adds	r1, r2, #4
 800e228:	6019      	str	r1, [r3, #0]
 800e22a:	6813      	ldr	r3, [r2, #0]
 800e22c:	702b      	strb	r3, [r5, #0]
 800e22e:	e0a1      	b.n	800e374 <_printf_i+0x1bc>
 800e230:	6821      	ldr	r1, [r4, #0]
 800e232:	681a      	ldr	r2, [r3, #0]
 800e234:	0608      	lsls	r0, r1, #24
 800e236:	d503      	bpl.n	800e240 <_printf_i+0x88>
 800e238:	1d11      	adds	r1, r2, #4
 800e23a:	6019      	str	r1, [r3, #0]
 800e23c:	6816      	ldr	r6, [r2, #0]
 800e23e:	e005      	b.n	800e24c <_printf_i+0x94>
 800e240:	0649      	lsls	r1, r1, #25
 800e242:	d5f9      	bpl.n	800e238 <_printf_i+0x80>
 800e244:	1d11      	adds	r1, r2, #4
 800e246:	6019      	str	r1, [r3, #0]
 800e248:	2300      	movs	r3, #0
 800e24a:	5ed6      	ldrsh	r6, [r2, r3]
 800e24c:	2e00      	cmp	r6, #0
 800e24e:	da3b      	bge.n	800e2c8 <_printf_i+0x110>
 800e250:	232d      	movs	r3, #45	; 0x2d
 800e252:	9a04      	ldr	r2, [sp, #16]
 800e254:	4276      	negs	r6, r6
 800e256:	7013      	strb	r3, [r2, #0]
 800e258:	e036      	b.n	800e2c8 <_printf_i+0x110>
 800e25a:	6821      	ldr	r1, [r4, #0]
 800e25c:	681a      	ldr	r2, [r3, #0]
 800e25e:	0608      	lsls	r0, r1, #24
 800e260:	d503      	bpl.n	800e26a <_printf_i+0xb2>
 800e262:	1d11      	adds	r1, r2, #4
 800e264:	6019      	str	r1, [r3, #0]
 800e266:	6816      	ldr	r6, [r2, #0]
 800e268:	e005      	b.n	800e276 <_printf_i+0xbe>
 800e26a:	0649      	lsls	r1, r1, #25
 800e26c:	d5f9      	bpl.n	800e262 <_printf_i+0xaa>
 800e26e:	1d11      	adds	r1, r2, #4
 800e270:	6019      	str	r1, [r3, #0]
 800e272:	6816      	ldr	r6, [r2, #0]
 800e274:	b2b6      	uxth	r6, r6
 800e276:	4b5a      	ldr	r3, [pc, #360]	; (800e3e0 <_printf_i+0x228>)
 800e278:	7e22      	ldrb	r2, [r4, #24]
 800e27a:	9303      	str	r3, [sp, #12]
 800e27c:	270a      	movs	r7, #10
 800e27e:	2a6f      	cmp	r2, #111	; 0x6f
 800e280:	d11d      	bne.n	800e2be <_printf_i+0x106>
 800e282:	2708      	movs	r7, #8
 800e284:	e01b      	b.n	800e2be <_printf_i+0x106>
 800e286:	1c22      	adds	r2, r4, #0
 800e288:	2178      	movs	r1, #120	; 0x78
 800e28a:	3245      	adds	r2, #69	; 0x45
 800e28c:	7011      	strb	r1, [r2, #0]
 800e28e:	4a55      	ldr	r2, [pc, #340]	; (800e3e4 <_printf_i+0x22c>)
 800e290:	6819      	ldr	r1, [r3, #0]
 800e292:	9203      	str	r2, [sp, #12]
 800e294:	1d08      	adds	r0, r1, #4
 800e296:	6822      	ldr	r2, [r4, #0]
 800e298:	6018      	str	r0, [r3, #0]
 800e29a:	680e      	ldr	r6, [r1, #0]
 800e29c:	0610      	lsls	r0, r2, #24
 800e29e:	d402      	bmi.n	800e2a6 <_printf_i+0xee>
 800e2a0:	0650      	lsls	r0, r2, #25
 800e2a2:	d500      	bpl.n	800e2a6 <_printf_i+0xee>
 800e2a4:	b2b6      	uxth	r6, r6
 800e2a6:	07d3      	lsls	r3, r2, #31
 800e2a8:	d502      	bpl.n	800e2b0 <_printf_i+0xf8>
 800e2aa:	2320      	movs	r3, #32
 800e2ac:	431a      	orrs	r2, r3
 800e2ae:	6022      	str	r2, [r4, #0]
 800e2b0:	2710      	movs	r7, #16
 800e2b2:	2e00      	cmp	r6, #0
 800e2b4:	d103      	bne.n	800e2be <_printf_i+0x106>
 800e2b6:	2320      	movs	r3, #32
 800e2b8:	6822      	ldr	r2, [r4, #0]
 800e2ba:	439a      	bics	r2, r3
 800e2bc:	6022      	str	r2, [r4, #0]
 800e2be:	1c23      	adds	r3, r4, #0
 800e2c0:	2200      	movs	r2, #0
 800e2c2:	3343      	adds	r3, #67	; 0x43
 800e2c4:	701a      	strb	r2, [r3, #0]
 800e2c6:	e002      	b.n	800e2ce <_printf_i+0x116>
 800e2c8:	270a      	movs	r7, #10
 800e2ca:	4b45      	ldr	r3, [pc, #276]	; (800e3e0 <_printf_i+0x228>)
 800e2cc:	9303      	str	r3, [sp, #12]
 800e2ce:	6863      	ldr	r3, [r4, #4]
 800e2d0:	60a3      	str	r3, [r4, #8]
 800e2d2:	2b00      	cmp	r3, #0
 800e2d4:	db03      	blt.n	800e2de <_printf_i+0x126>
 800e2d6:	2204      	movs	r2, #4
 800e2d8:	6821      	ldr	r1, [r4, #0]
 800e2da:	4391      	bics	r1, r2
 800e2dc:	6021      	str	r1, [r4, #0]
 800e2de:	2e00      	cmp	r6, #0
 800e2e0:	d102      	bne.n	800e2e8 <_printf_i+0x130>
 800e2e2:	9d04      	ldr	r5, [sp, #16]
 800e2e4:	2b00      	cmp	r3, #0
 800e2e6:	d00e      	beq.n	800e306 <_printf_i+0x14e>
 800e2e8:	9d04      	ldr	r5, [sp, #16]
 800e2ea:	1c30      	adds	r0, r6, #0
 800e2ec:	1c39      	adds	r1, r7, #0
 800e2ee:	f000 fbd5 	bl	800ea9c <__aeabi_uidivmod>
 800e2f2:	9b03      	ldr	r3, [sp, #12]
 800e2f4:	3d01      	subs	r5, #1
 800e2f6:	5c5b      	ldrb	r3, [r3, r1]
 800e2f8:	1c30      	adds	r0, r6, #0
 800e2fa:	702b      	strb	r3, [r5, #0]
 800e2fc:	1c39      	adds	r1, r7, #0
 800e2fe:	f000 fb47 	bl	800e990 <__aeabi_uidiv>
 800e302:	1e06      	subs	r6, r0, #0
 800e304:	d1f1      	bne.n	800e2ea <_printf_i+0x132>
 800e306:	2f08      	cmp	r7, #8
 800e308:	d109      	bne.n	800e31e <_printf_i+0x166>
 800e30a:	6823      	ldr	r3, [r4, #0]
 800e30c:	07db      	lsls	r3, r3, #31
 800e30e:	d506      	bpl.n	800e31e <_printf_i+0x166>
 800e310:	6863      	ldr	r3, [r4, #4]
 800e312:	6922      	ldr	r2, [r4, #16]
 800e314:	4293      	cmp	r3, r2
 800e316:	dc02      	bgt.n	800e31e <_printf_i+0x166>
 800e318:	2330      	movs	r3, #48	; 0x30
 800e31a:	3d01      	subs	r5, #1
 800e31c:	702b      	strb	r3, [r5, #0]
 800e31e:	9b04      	ldr	r3, [sp, #16]
 800e320:	1b5b      	subs	r3, r3, r5
 800e322:	6123      	str	r3, [r4, #16]
 800e324:	e02b      	b.n	800e37e <_printf_i+0x1c6>
 800e326:	6809      	ldr	r1, [r1, #0]
 800e328:	681a      	ldr	r2, [r3, #0]
 800e32a:	0608      	lsls	r0, r1, #24
 800e32c:	d407      	bmi.n	800e33e <_printf_i+0x186>
 800e32e:	0649      	lsls	r1, r1, #25
 800e330:	d505      	bpl.n	800e33e <_printf_i+0x186>
 800e332:	1d11      	adds	r1, r2, #4
 800e334:	6019      	str	r1, [r3, #0]
 800e336:	6813      	ldr	r3, [r2, #0]
 800e338:	8aa2      	ldrh	r2, [r4, #20]
 800e33a:	801a      	strh	r2, [r3, #0]
 800e33c:	e004      	b.n	800e348 <_printf_i+0x190>
 800e33e:	1d11      	adds	r1, r2, #4
 800e340:	6019      	str	r1, [r3, #0]
 800e342:	6813      	ldr	r3, [r2, #0]
 800e344:	6962      	ldr	r2, [r4, #20]
 800e346:	601a      	str	r2, [r3, #0]
 800e348:	2300      	movs	r3, #0
 800e34a:	9d04      	ldr	r5, [sp, #16]
 800e34c:	6123      	str	r3, [r4, #16]
 800e34e:	e016      	b.n	800e37e <_printf_i+0x1c6>
 800e350:	681a      	ldr	r2, [r3, #0]
 800e352:	1d11      	adds	r1, r2, #4
 800e354:	6019      	str	r1, [r3, #0]
 800e356:	6815      	ldr	r5, [r2, #0]
 800e358:	2100      	movs	r1, #0
 800e35a:	1c28      	adds	r0, r5, #0
 800e35c:	6862      	ldr	r2, [r4, #4]
 800e35e:	f000 fa81 	bl	800e864 <memchr>
 800e362:	2800      	cmp	r0, #0
 800e364:	d001      	beq.n	800e36a <_printf_i+0x1b2>
 800e366:	1b40      	subs	r0, r0, r5
 800e368:	6060      	str	r0, [r4, #4]
 800e36a:	6863      	ldr	r3, [r4, #4]
 800e36c:	e003      	b.n	800e376 <_printf_i+0x1be>
 800e36e:	1c25      	adds	r5, r4, #0
 800e370:	3542      	adds	r5, #66	; 0x42
 800e372:	702a      	strb	r2, [r5, #0]
 800e374:	2301      	movs	r3, #1
 800e376:	6123      	str	r3, [r4, #16]
 800e378:	2300      	movs	r3, #0
 800e37a:	9a04      	ldr	r2, [sp, #16]
 800e37c:	7013      	strb	r3, [r2, #0]
 800e37e:	9b07      	ldr	r3, [sp, #28]
 800e380:	9805      	ldr	r0, [sp, #20]
 800e382:	9300      	str	r3, [sp, #0]
 800e384:	1c21      	adds	r1, r4, #0
 800e386:	9b06      	ldr	r3, [sp, #24]
 800e388:	aa09      	add	r2, sp, #36	; 0x24
 800e38a:	f7ff fea7 	bl	800e0dc <_printf_common>
 800e38e:	1c43      	adds	r3, r0, #1
 800e390:	d102      	bne.n	800e398 <_printf_i+0x1e0>
 800e392:	2001      	movs	r0, #1
 800e394:	4240      	negs	r0, r0
 800e396:	e021      	b.n	800e3dc <_printf_i+0x224>
 800e398:	1c2a      	adds	r2, r5, #0
 800e39a:	6923      	ldr	r3, [r4, #16]
 800e39c:	9805      	ldr	r0, [sp, #20]
 800e39e:	9906      	ldr	r1, [sp, #24]
 800e3a0:	9d07      	ldr	r5, [sp, #28]
 800e3a2:	47a8      	blx	r5
 800e3a4:	1c43      	adds	r3, r0, #1
 800e3a6:	d0f4      	beq.n	800e392 <_printf_i+0x1da>
 800e3a8:	6823      	ldr	r3, [r4, #0]
 800e3aa:	079b      	lsls	r3, r3, #30
 800e3ac:	d405      	bmi.n	800e3ba <_printf_i+0x202>
 800e3ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e3b0:	68e0      	ldr	r0, [r4, #12]
 800e3b2:	4298      	cmp	r0, r3
 800e3b4:	da12      	bge.n	800e3dc <_printf_i+0x224>
 800e3b6:	1c18      	adds	r0, r3, #0
 800e3b8:	e010      	b.n	800e3dc <_printf_i+0x224>
 800e3ba:	2500      	movs	r5, #0
 800e3bc:	68e3      	ldr	r3, [r4, #12]
 800e3be:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e3c0:	1a9b      	subs	r3, r3, r2
 800e3c2:	429d      	cmp	r5, r3
 800e3c4:	daf3      	bge.n	800e3ae <_printf_i+0x1f6>
 800e3c6:	1c22      	adds	r2, r4, #0
 800e3c8:	2301      	movs	r3, #1
 800e3ca:	9805      	ldr	r0, [sp, #20]
 800e3cc:	9906      	ldr	r1, [sp, #24]
 800e3ce:	3219      	adds	r2, #25
 800e3d0:	9e07      	ldr	r6, [sp, #28]
 800e3d2:	47b0      	blx	r6
 800e3d4:	1c43      	adds	r3, r0, #1
 800e3d6:	d0dc      	beq.n	800e392 <_printf_i+0x1da>
 800e3d8:	3501      	adds	r5, #1
 800e3da:	e7ef      	b.n	800e3bc <_printf_i+0x204>
 800e3dc:	b00b      	add	sp, #44	; 0x2c
 800e3de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e3e0:	08015369 	.word	0x08015369
 800e3e4:	0801537a 	.word	0x0801537a

0800e3e8 <_scanf_chars>:
 800e3e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e3ea:	1c15      	adds	r5, r2, #0
 800e3ec:	688a      	ldr	r2, [r1, #8]
 800e3ee:	9001      	str	r0, [sp, #4]
 800e3f0:	1c0c      	adds	r4, r1, #0
 800e3f2:	2a00      	cmp	r2, #0
 800e3f4:	d106      	bne.n	800e404 <_scanf_chars+0x1c>
 800e3f6:	698a      	ldr	r2, [r1, #24]
 800e3f8:	1e51      	subs	r1, r2, #1
 800e3fa:	418a      	sbcs	r2, r1
 800e3fc:	2101      	movs	r1, #1
 800e3fe:	4252      	negs	r2, r2
 800e400:	430a      	orrs	r2, r1
 800e402:	60a2      	str	r2, [r4, #8]
 800e404:	6822      	ldr	r2, [r4, #0]
 800e406:	06d2      	lsls	r2, r2, #27
 800e408:	d403      	bmi.n	800e412 <_scanf_chars+0x2a>
 800e40a:	681a      	ldr	r2, [r3, #0]
 800e40c:	1d11      	adds	r1, r2, #4
 800e40e:	6019      	str	r1, [r3, #0]
 800e410:	6817      	ldr	r7, [r2, #0]
 800e412:	2600      	movs	r6, #0
 800e414:	69a0      	ldr	r0, [r4, #24]
 800e416:	2800      	cmp	r0, #0
 800e418:	d11d      	bne.n	800e456 <_scanf_chars+0x6e>
 800e41a:	6823      	ldr	r3, [r4, #0]
 800e41c:	3601      	adds	r6, #1
 800e41e:	06db      	lsls	r3, r3, #27
 800e420:	d403      	bmi.n	800e42a <_scanf_chars+0x42>
 800e422:	682b      	ldr	r3, [r5, #0]
 800e424:	781b      	ldrb	r3, [r3, #0]
 800e426:	703b      	strb	r3, [r7, #0]
 800e428:	3701      	adds	r7, #1
 800e42a:	682a      	ldr	r2, [r5, #0]
 800e42c:	686b      	ldr	r3, [r5, #4]
 800e42e:	3201      	adds	r2, #1
 800e430:	602a      	str	r2, [r5, #0]
 800e432:	68a2      	ldr	r2, [r4, #8]
 800e434:	3b01      	subs	r3, #1
 800e436:	3a01      	subs	r2, #1
 800e438:	606b      	str	r3, [r5, #4]
 800e43a:	60a2      	str	r2, [r4, #8]
 800e43c:	2a00      	cmp	r2, #0
 800e43e:	d01f      	beq.n	800e480 <_scanf_chars+0x98>
 800e440:	2b00      	cmp	r3, #0
 800e442:	dce7      	bgt.n	800e414 <_scanf_chars+0x2c>
 800e444:	23c0      	movs	r3, #192	; 0xc0
 800e446:	005b      	lsls	r3, r3, #1
 800e448:	58e3      	ldr	r3, [r4, r3]
 800e44a:	9801      	ldr	r0, [sp, #4]
 800e44c:	1c29      	adds	r1, r5, #0
 800e44e:	4798      	blx	r3
 800e450:	2800      	cmp	r0, #0
 800e452:	d0df      	beq.n	800e414 <_scanf_chars+0x2c>
 800e454:	e014      	b.n	800e480 <_scanf_chars+0x98>
 800e456:	2801      	cmp	r0, #1
 800e458:	d108      	bne.n	800e46c <_scanf_chars+0x84>
 800e45a:	682b      	ldr	r3, [r5, #0]
 800e45c:	6962      	ldr	r2, [r4, #20]
 800e45e:	781b      	ldrb	r3, [r3, #0]
 800e460:	5cd3      	ldrb	r3, [r2, r3]
 800e462:	2b00      	cmp	r3, #0
 800e464:	d1d9      	bne.n	800e41a <_scanf_chars+0x32>
 800e466:	2e00      	cmp	r6, #0
 800e468:	d019      	beq.n	800e49e <_scanf_chars+0xb6>
 800e46a:	e009      	b.n	800e480 <_scanf_chars+0x98>
 800e46c:	2802      	cmp	r0, #2
 800e46e:	d107      	bne.n	800e480 <_scanf_chars+0x98>
 800e470:	682b      	ldr	r3, [r5, #0]
 800e472:	4a0b      	ldr	r2, [pc, #44]	; (800e4a0 <_scanf_chars+0xb8>)
 800e474:	781b      	ldrb	r3, [r3, #0]
 800e476:	6812      	ldr	r2, [r2, #0]
 800e478:	18d3      	adds	r3, r2, r3
 800e47a:	785b      	ldrb	r3, [r3, #1]
 800e47c:	071b      	lsls	r3, r3, #28
 800e47e:	d5cc      	bpl.n	800e41a <_scanf_chars+0x32>
 800e480:	2310      	movs	r3, #16
 800e482:	6822      	ldr	r2, [r4, #0]
 800e484:	4013      	ands	r3, r2
 800e486:	d106      	bne.n	800e496 <_scanf_chars+0xae>
 800e488:	68e2      	ldr	r2, [r4, #12]
 800e48a:	3201      	adds	r2, #1
 800e48c:	60e2      	str	r2, [r4, #12]
 800e48e:	69a2      	ldr	r2, [r4, #24]
 800e490:	2a00      	cmp	r2, #0
 800e492:	d000      	beq.n	800e496 <_scanf_chars+0xae>
 800e494:	703b      	strb	r3, [r7, #0]
 800e496:	2000      	movs	r0, #0
 800e498:	6923      	ldr	r3, [r4, #16]
 800e49a:	199e      	adds	r6, r3, r6
 800e49c:	6126      	str	r6, [r4, #16]
 800e49e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800e4a0:	20000134 	.word	0x20000134

0800e4a4 <_scanf_i>:
 800e4a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e4a6:	1c0c      	adds	r4, r1, #0
 800e4a8:	b08b      	sub	sp, #44	; 0x2c
 800e4aa:	9301      	str	r3, [sp, #4]
 800e4ac:	4b74      	ldr	r3, [pc, #464]	; (800e680 <_scanf_i+0x1dc>)
 800e4ae:	9004      	str	r0, [sp, #16]
 800e4b0:	1c16      	adds	r6, r2, #0
 800e4b2:	aa07      	add	r2, sp, #28
 800e4b4:	cb23      	ldmia	r3!, {r0, r1, r5}
 800e4b6:	c223      	stmia	r2!, {r0, r1, r5}
 800e4b8:	4b72      	ldr	r3, [pc, #456]	; (800e684 <_scanf_i+0x1e0>)
 800e4ba:	9305      	str	r3, [sp, #20]
 800e4bc:	69a3      	ldr	r3, [r4, #24]
 800e4be:	2b03      	cmp	r3, #3
 800e4c0:	d001      	beq.n	800e4c6 <_scanf_i+0x22>
 800e4c2:	4b71      	ldr	r3, [pc, #452]	; (800e688 <_scanf_i+0x1e4>)
 800e4c4:	9305      	str	r3, [sp, #20]
 800e4c6:	2200      	movs	r2, #0
 800e4c8:	68a3      	ldr	r3, [r4, #8]
 800e4ca:	9203      	str	r2, [sp, #12]
 800e4cc:	325d      	adds	r2, #93	; 0x5d
 800e4ce:	1e59      	subs	r1, r3, #1
 800e4d0:	32ff      	adds	r2, #255	; 0xff
 800e4d2:	4291      	cmp	r1, r2
 800e4d4:	d905      	bls.n	800e4e2 <_scanf_i+0x3e>
 800e4d6:	3b5e      	subs	r3, #94	; 0x5e
 800e4d8:	3bff      	subs	r3, #255	; 0xff
 800e4da:	9303      	str	r3, [sp, #12]
 800e4dc:	235e      	movs	r3, #94	; 0x5e
 800e4de:	33ff      	adds	r3, #255	; 0xff
 800e4e0:	60a3      	str	r3, [r4, #8]
 800e4e2:	1c23      	adds	r3, r4, #0
 800e4e4:	331c      	adds	r3, #28
 800e4e6:	9300      	str	r3, [sp, #0]
 800e4e8:	23d0      	movs	r3, #208	; 0xd0
 800e4ea:	2700      	movs	r7, #0
 800e4ec:	6822      	ldr	r2, [r4, #0]
 800e4ee:	011b      	lsls	r3, r3, #4
 800e4f0:	4313      	orrs	r3, r2
 800e4f2:	6023      	str	r3, [r4, #0]
 800e4f4:	9b00      	ldr	r3, [sp, #0]
 800e4f6:	9302      	str	r3, [sp, #8]
 800e4f8:	6832      	ldr	r2, [r6, #0]
 800e4fa:	00bb      	lsls	r3, r7, #2
 800e4fc:	7811      	ldrb	r1, [r2, #0]
 800e4fe:	aa07      	add	r2, sp, #28
 800e500:	5898      	ldr	r0, [r3, r2]
 800e502:	2202      	movs	r2, #2
 800e504:	f000 f9ae 	bl	800e864 <memchr>
 800e508:	2800      	cmp	r0, #0
 800e50a:	d039      	beq.n	800e580 <_scanf_i+0xdc>
 800e50c:	2f01      	cmp	r7, #1
 800e50e:	d10d      	bne.n	800e52c <_scanf_i+0x88>
 800e510:	6863      	ldr	r3, [r4, #4]
 800e512:	2b00      	cmp	r3, #0
 800e514:	d106      	bne.n	800e524 <_scanf_i+0x80>
 800e516:	3308      	adds	r3, #8
 800e518:	6822      	ldr	r2, [r4, #0]
 800e51a:	6063      	str	r3, [r4, #4]
 800e51c:	33f9      	adds	r3, #249	; 0xf9
 800e51e:	33ff      	adds	r3, #255	; 0xff
 800e520:	4313      	orrs	r3, r2
 800e522:	6023      	str	r3, [r4, #0]
 800e524:	4b59      	ldr	r3, [pc, #356]	; (800e68c <_scanf_i+0x1e8>)
 800e526:	6822      	ldr	r2, [r4, #0]
 800e528:	4013      	ands	r3, r2
 800e52a:	e00d      	b.n	800e548 <_scanf_i+0xa4>
 800e52c:	2f02      	cmp	r7, #2
 800e52e:	d10c      	bne.n	800e54a <_scanf_i+0xa6>
 800e530:	22c0      	movs	r2, #192	; 0xc0
 800e532:	2180      	movs	r1, #128	; 0x80
 800e534:	6823      	ldr	r3, [r4, #0]
 800e536:	00d2      	lsls	r2, r2, #3
 800e538:	401a      	ands	r2, r3
 800e53a:	0089      	lsls	r1, r1, #2
 800e53c:	428a      	cmp	r2, r1
 800e53e:	d122      	bne.n	800e586 <_scanf_i+0xe2>
 800e540:	2210      	movs	r2, #16
 800e542:	6062      	str	r2, [r4, #4]
 800e544:	32f0      	adds	r2, #240	; 0xf0
 800e546:	4313      	orrs	r3, r2
 800e548:	6023      	str	r3, [r4, #0]
 800e54a:	68a3      	ldr	r3, [r4, #8]
 800e54c:	1e5a      	subs	r2, r3, #1
 800e54e:	60a2      	str	r2, [r4, #8]
 800e550:	2b00      	cmp	r3, #0
 800e552:	d015      	beq.n	800e580 <_scanf_i+0xdc>
 800e554:	9b02      	ldr	r3, [sp, #8]
 800e556:	1c5d      	adds	r5, r3, #1
 800e558:	6833      	ldr	r3, [r6, #0]
 800e55a:	1c5a      	adds	r2, r3, #1
 800e55c:	6032      	str	r2, [r6, #0]
 800e55e:	781b      	ldrb	r3, [r3, #0]
 800e560:	9a02      	ldr	r2, [sp, #8]
 800e562:	9502      	str	r5, [sp, #8]
 800e564:	7013      	strb	r3, [r2, #0]
 800e566:	6873      	ldr	r3, [r6, #4]
 800e568:	3b01      	subs	r3, #1
 800e56a:	6073      	str	r3, [r6, #4]
 800e56c:	2b00      	cmp	r3, #0
 800e56e:	dc07      	bgt.n	800e580 <_scanf_i+0xdc>
 800e570:	23c0      	movs	r3, #192	; 0xc0
 800e572:	005b      	lsls	r3, r3, #1
 800e574:	58e3      	ldr	r3, [r4, r3]
 800e576:	9804      	ldr	r0, [sp, #16]
 800e578:	1c31      	adds	r1, r6, #0
 800e57a:	4798      	blx	r3
 800e57c:	2800      	cmp	r0, #0
 800e57e:	d144      	bne.n	800e60a <_scanf_i+0x166>
 800e580:	3701      	adds	r7, #1
 800e582:	2f03      	cmp	r7, #3
 800e584:	d1b8      	bne.n	800e4f8 <_scanf_i+0x54>
 800e586:	6863      	ldr	r3, [r4, #4]
 800e588:	2b00      	cmp	r3, #0
 800e58a:	d101      	bne.n	800e590 <_scanf_i+0xec>
 800e58c:	330a      	adds	r3, #10
 800e58e:	6063      	str	r3, [r4, #4]
 800e590:	2110      	movs	r1, #16
 800e592:	2700      	movs	r7, #0
 800e594:	6863      	ldr	r3, [r4, #4]
 800e596:	6960      	ldr	r0, [r4, #20]
 800e598:	1ac9      	subs	r1, r1, r3
 800e59a:	4b3d      	ldr	r3, [pc, #244]	; (800e690 <_scanf_i+0x1ec>)
 800e59c:	18c9      	adds	r1, r1, r3
 800e59e:	f000 f8cb 	bl	800e738 <__sccl>
 800e5a2:	9d02      	ldr	r5, [sp, #8]
 800e5a4:	68a3      	ldr	r3, [r4, #8]
 800e5a6:	2b00      	cmp	r3, #0
 800e5a8:	d030      	beq.n	800e60c <_scanf_i+0x168>
 800e5aa:	6832      	ldr	r2, [r6, #0]
 800e5ac:	6960      	ldr	r0, [r4, #20]
 800e5ae:	7811      	ldrb	r1, [r2, #0]
 800e5b0:	5c40      	ldrb	r0, [r0, r1]
 800e5b2:	2800      	cmp	r0, #0
 800e5b4:	d02a      	beq.n	800e60c <_scanf_i+0x168>
 800e5b6:	2930      	cmp	r1, #48	; 0x30
 800e5b8:	d10b      	bne.n	800e5d2 <_scanf_i+0x12e>
 800e5ba:	6821      	ldr	r1, [r4, #0]
 800e5bc:	0509      	lsls	r1, r1, #20
 800e5be:	d508      	bpl.n	800e5d2 <_scanf_i+0x12e>
 800e5c0:	9a03      	ldr	r2, [sp, #12]
 800e5c2:	3701      	adds	r7, #1
 800e5c4:	2a00      	cmp	r2, #0
 800e5c6:	d00b      	beq.n	800e5e0 <_scanf_i+0x13c>
 800e5c8:	3a01      	subs	r2, #1
 800e5ca:	3301      	adds	r3, #1
 800e5cc:	9203      	str	r2, [sp, #12]
 800e5ce:	60a3      	str	r3, [r4, #8]
 800e5d0:	e006      	b.n	800e5e0 <_scanf_i+0x13c>
 800e5d2:	6821      	ldr	r1, [r4, #0]
 800e5d4:	4b2f      	ldr	r3, [pc, #188]	; (800e694 <_scanf_i+0x1f0>)
 800e5d6:	400b      	ands	r3, r1
 800e5d8:	6023      	str	r3, [r4, #0]
 800e5da:	7813      	ldrb	r3, [r2, #0]
 800e5dc:	702b      	strb	r3, [r5, #0]
 800e5de:	3501      	adds	r5, #1
 800e5e0:	6873      	ldr	r3, [r6, #4]
 800e5e2:	3b01      	subs	r3, #1
 800e5e4:	6073      	str	r3, [r6, #4]
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	dd03      	ble.n	800e5f2 <_scanf_i+0x14e>
 800e5ea:	6833      	ldr	r3, [r6, #0]
 800e5ec:	3301      	adds	r3, #1
 800e5ee:	6033      	str	r3, [r6, #0]
 800e5f0:	e007      	b.n	800e602 <_scanf_i+0x15e>
 800e5f2:	23c0      	movs	r3, #192	; 0xc0
 800e5f4:	005b      	lsls	r3, r3, #1
 800e5f6:	58e3      	ldr	r3, [r4, r3]
 800e5f8:	9804      	ldr	r0, [sp, #16]
 800e5fa:	1c31      	adds	r1, r6, #0
 800e5fc:	4798      	blx	r3
 800e5fe:	2800      	cmp	r0, #0
 800e600:	d104      	bne.n	800e60c <_scanf_i+0x168>
 800e602:	68a3      	ldr	r3, [r4, #8]
 800e604:	3b01      	subs	r3, #1
 800e606:	60a3      	str	r3, [r4, #8]
 800e608:	e7cc      	b.n	800e5a4 <_scanf_i+0x100>
 800e60a:	2700      	movs	r7, #0
 800e60c:	6823      	ldr	r3, [r4, #0]
 800e60e:	05db      	lsls	r3, r3, #23
 800e610:	d50e      	bpl.n	800e630 <_scanf_i+0x18c>
 800e612:	9b00      	ldr	r3, [sp, #0]
 800e614:	429d      	cmp	r5, r3
 800e616:	d907      	bls.n	800e628 <_scanf_i+0x184>
 800e618:	23be      	movs	r3, #190	; 0xbe
 800e61a:	3d01      	subs	r5, #1
 800e61c:	005b      	lsls	r3, r3, #1
 800e61e:	7829      	ldrb	r1, [r5, #0]
 800e620:	58e3      	ldr	r3, [r4, r3]
 800e622:	9804      	ldr	r0, [sp, #16]
 800e624:	1c32      	adds	r2, r6, #0
 800e626:	4798      	blx	r3
 800e628:	9b00      	ldr	r3, [sp, #0]
 800e62a:	2001      	movs	r0, #1
 800e62c:	429d      	cmp	r5, r3
 800e62e:	d025      	beq.n	800e67c <_scanf_i+0x1d8>
 800e630:	2210      	movs	r2, #16
 800e632:	6823      	ldr	r3, [r4, #0]
 800e634:	401a      	ands	r2, r3
 800e636:	d11a      	bne.n	800e66e <_scanf_i+0x1ca>
 800e638:	702a      	strb	r2, [r5, #0]
 800e63a:	6863      	ldr	r3, [r4, #4]
 800e63c:	9804      	ldr	r0, [sp, #16]
 800e63e:	9900      	ldr	r1, [sp, #0]
 800e640:	9e05      	ldr	r6, [sp, #20]
 800e642:	47b0      	blx	r6
 800e644:	9b01      	ldr	r3, [sp, #4]
 800e646:	6822      	ldr	r2, [r4, #0]
 800e648:	681b      	ldr	r3, [r3, #0]
 800e64a:	0691      	lsls	r1, r2, #26
 800e64c:	d407      	bmi.n	800e65e <_scanf_i+0x1ba>
 800e64e:	07d1      	lsls	r1, r2, #31
 800e650:	d505      	bpl.n	800e65e <_scanf_i+0x1ba>
 800e652:	9901      	ldr	r1, [sp, #4]
 800e654:	1d1a      	adds	r2, r3, #4
 800e656:	600a      	str	r2, [r1, #0]
 800e658:	681b      	ldr	r3, [r3, #0]
 800e65a:	8018      	strh	r0, [r3, #0]
 800e65c:	e004      	b.n	800e668 <_scanf_i+0x1c4>
 800e65e:	9901      	ldr	r1, [sp, #4]
 800e660:	1d1a      	adds	r2, r3, #4
 800e662:	600a      	str	r2, [r1, #0]
 800e664:	681b      	ldr	r3, [r3, #0]
 800e666:	6018      	str	r0, [r3, #0]
 800e668:	68e3      	ldr	r3, [r4, #12]
 800e66a:	3301      	adds	r3, #1
 800e66c:	60e3      	str	r3, [r4, #12]
 800e66e:	2000      	movs	r0, #0
 800e670:	9b00      	ldr	r3, [sp, #0]
 800e672:	1aed      	subs	r5, r5, r3
 800e674:	6923      	ldr	r3, [r4, #16]
 800e676:	19ed      	adds	r5, r5, r7
 800e678:	195d      	adds	r5, r3, r5
 800e67a:	6125      	str	r5, [r4, #16]
 800e67c:	b00b      	add	sp, #44	; 0x2c
 800e67e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e680:	0801538c 	.word	0x0801538c
 800e684:	0800cf99 	.word	0x0800cf99
 800e688:	0800d0d5 	.word	0x0800d0d5
 800e68c:	fffffaff 	.word	0xfffffaff
 800e690:	08015398 	.word	0x08015398
 800e694:	fffff6ff 	.word	0xfffff6ff

0800e698 <_putc_r>:
 800e698:	b570      	push	{r4, r5, r6, lr}
 800e69a:	1c05      	adds	r5, r0, #0
 800e69c:	1c0e      	adds	r6, r1, #0
 800e69e:	1c14      	adds	r4, r2, #0
 800e6a0:	2800      	cmp	r0, #0
 800e6a2:	d004      	beq.n	800e6ae <_putc_r+0x16>
 800e6a4:	6983      	ldr	r3, [r0, #24]
 800e6a6:	2b00      	cmp	r3, #0
 800e6a8:	d101      	bne.n	800e6ae <_putc_r+0x16>
 800e6aa:	f7fe ffb7 	bl	800d61c <__sinit>
 800e6ae:	4b15      	ldr	r3, [pc, #84]	; (800e704 <_putc_r+0x6c>)
 800e6b0:	429c      	cmp	r4, r3
 800e6b2:	d101      	bne.n	800e6b8 <_putc_r+0x20>
 800e6b4:	686c      	ldr	r4, [r5, #4]
 800e6b6:	e008      	b.n	800e6ca <_putc_r+0x32>
 800e6b8:	4b13      	ldr	r3, [pc, #76]	; (800e708 <_putc_r+0x70>)
 800e6ba:	429c      	cmp	r4, r3
 800e6bc:	d101      	bne.n	800e6c2 <_putc_r+0x2a>
 800e6be:	68ac      	ldr	r4, [r5, #8]
 800e6c0:	e003      	b.n	800e6ca <_putc_r+0x32>
 800e6c2:	4b12      	ldr	r3, [pc, #72]	; (800e70c <_putc_r+0x74>)
 800e6c4:	429c      	cmp	r4, r3
 800e6c6:	d100      	bne.n	800e6ca <_putc_r+0x32>
 800e6c8:	68ec      	ldr	r4, [r5, #12]
 800e6ca:	68a3      	ldr	r3, [r4, #8]
 800e6cc:	3b01      	subs	r3, #1
 800e6ce:	60a3      	str	r3, [r4, #8]
 800e6d0:	2b00      	cmp	r3, #0
 800e6d2:	da10      	bge.n	800e6f6 <_putc_r+0x5e>
 800e6d4:	69a2      	ldr	r2, [r4, #24]
 800e6d6:	4293      	cmp	r3, r2
 800e6d8:	db07      	blt.n	800e6ea <_putc_r+0x52>
 800e6da:	6823      	ldr	r3, [r4, #0]
 800e6dc:	701e      	strb	r6, [r3, #0]
 800e6de:	6823      	ldr	r3, [r4, #0]
 800e6e0:	7819      	ldrb	r1, [r3, #0]
 800e6e2:	290a      	cmp	r1, #10
 800e6e4:	d10a      	bne.n	800e6fc <_putc_r+0x64>
 800e6e6:	1c28      	adds	r0, r5, #0
 800e6e8:	e001      	b.n	800e6ee <_putc_r+0x56>
 800e6ea:	1c28      	adds	r0, r5, #0
 800e6ec:	1c31      	adds	r1, r6, #0
 800e6ee:	1c22      	adds	r2, r4, #0
 800e6f0:	f7fe fdaa 	bl	800d248 <__swbuf_r>
 800e6f4:	e005      	b.n	800e702 <_putc_r+0x6a>
 800e6f6:	6823      	ldr	r3, [r4, #0]
 800e6f8:	701e      	strb	r6, [r3, #0]
 800e6fa:	6823      	ldr	r3, [r4, #0]
 800e6fc:	1c5a      	adds	r2, r3, #1
 800e6fe:	6022      	str	r2, [r4, #0]
 800e700:	7818      	ldrb	r0, [r3, #0]
 800e702:	bd70      	pop	{r4, r5, r6, pc}
 800e704:	080152f8 	.word	0x080152f8
 800e708:	08015318 	.word	0x08015318
 800e70c:	08015338 	.word	0x08015338

0800e710 <_read_r>:
 800e710:	b538      	push	{r3, r4, r5, lr}
 800e712:	1c05      	adds	r5, r0, #0
 800e714:	2000      	movs	r0, #0
 800e716:	4c07      	ldr	r4, [pc, #28]	; (800e734 <_read_r+0x24>)
 800e718:	6020      	str	r0, [r4, #0]
 800e71a:	1c08      	adds	r0, r1, #0
 800e71c:	1c11      	adds	r1, r2, #0
 800e71e:	1c1a      	adds	r2, r3, #0
 800e720:	f000 f90c 	bl	800e93c <_read>
 800e724:	1c43      	adds	r3, r0, #1
 800e726:	d103      	bne.n	800e730 <_read_r+0x20>
 800e728:	6823      	ldr	r3, [r4, #0]
 800e72a:	2b00      	cmp	r3, #0
 800e72c:	d000      	beq.n	800e730 <_read_r+0x20>
 800e72e:	602b      	str	r3, [r5, #0]
 800e730:	bd38      	pop	{r3, r4, r5, pc}
 800e732:	46c0      	nop			; (mov r8, r8)
 800e734:	20002190 	.word	0x20002190

0800e738 <__sccl>:
 800e738:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e73a:	780a      	ldrb	r2, [r1, #0]
 800e73c:	2a5e      	cmp	r2, #94	; 0x5e
 800e73e:	d002      	beq.n	800e746 <__sccl+0xe>
 800e740:	1c4b      	adds	r3, r1, #1
 800e742:	2400      	movs	r4, #0
 800e744:	e002      	b.n	800e74c <__sccl+0x14>
 800e746:	2401      	movs	r4, #1
 800e748:	784a      	ldrb	r2, [r1, #1]
 800e74a:	1c8b      	adds	r3, r1, #2
 800e74c:	1c01      	adds	r1, r0, #0
 800e74e:	1c45      	adds	r5, r0, #1
 800e750:	35ff      	adds	r5, #255	; 0xff
 800e752:	700c      	strb	r4, [r1, #0]
 800e754:	3101      	adds	r1, #1
 800e756:	42a9      	cmp	r1, r5
 800e758:	d1fb      	bne.n	800e752 <__sccl+0x1a>
 800e75a:	2a00      	cmp	r2, #0
 800e75c:	d101      	bne.n	800e762 <__sccl+0x2a>
 800e75e:	1e58      	subs	r0, r3, #1
 800e760:	e01c      	b.n	800e79c <__sccl+0x64>
 800e762:	2101      	movs	r1, #1
 800e764:	1b0c      	subs	r4, r1, r4
 800e766:	b2e7      	uxtb	r7, r4
 800e768:	5487      	strb	r7, [r0, r2]
 800e76a:	7819      	ldrb	r1, [r3, #0]
 800e76c:	1c5e      	adds	r6, r3, #1
 800e76e:	292d      	cmp	r1, #45	; 0x2d
 800e770:	d006      	beq.n	800e780 <__sccl+0x48>
 800e772:	295d      	cmp	r1, #93	; 0x5d
 800e774:	d00f      	beq.n	800e796 <__sccl+0x5e>
 800e776:	2900      	cmp	r1, #0
 800e778:	d00f      	beq.n	800e79a <__sccl+0x62>
 800e77a:	1c0a      	adds	r2, r1, #0
 800e77c:	1c33      	adds	r3, r6, #0
 800e77e:	e7f2      	b.n	800e766 <__sccl+0x2e>
 800e780:	785d      	ldrb	r5, [r3, #1]
 800e782:	2d5d      	cmp	r5, #93	; 0x5d
 800e784:	d0f9      	beq.n	800e77a <__sccl+0x42>
 800e786:	4295      	cmp	r5, r2
 800e788:	dbf7      	blt.n	800e77a <__sccl+0x42>
 800e78a:	3302      	adds	r3, #2
 800e78c:	3201      	adds	r2, #1
 800e78e:	5487      	strb	r7, [r0, r2]
 800e790:	42aa      	cmp	r2, r5
 800e792:	dbfb      	blt.n	800e78c <__sccl+0x54>
 800e794:	e7e9      	b.n	800e76a <__sccl+0x32>
 800e796:	1c30      	adds	r0, r6, #0
 800e798:	e000      	b.n	800e79c <__sccl+0x64>
 800e79a:	1c18      	adds	r0, r3, #0
 800e79c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0800e7a0 <__submore>:
 800e7a0:	1c0b      	adds	r3, r1, #0
 800e7a2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800e7a4:	6b4d      	ldr	r5, [r1, #52]	; 0x34
 800e7a6:	3344      	adds	r3, #68	; 0x44
 800e7a8:	1c0c      	adds	r4, r1, #0
 800e7aa:	429d      	cmp	r5, r3
 800e7ac:	d11b      	bne.n	800e7e6 <__submore+0x46>
 800e7ae:	2680      	movs	r6, #128	; 0x80
 800e7b0:	00f6      	lsls	r6, r6, #3
 800e7b2:	1c31      	adds	r1, r6, #0
 800e7b4:	f7fe f8fa 	bl	800c9ac <_malloc_r>
 800e7b8:	2800      	cmp	r0, #0
 800e7ba:	d102      	bne.n	800e7c2 <__submore+0x22>
 800e7bc:	2001      	movs	r0, #1
 800e7be:	4240      	negs	r0, r0
 800e7c0:	e025      	b.n	800e80e <__submore+0x6e>
 800e7c2:	1c23      	adds	r3, r4, #0
 800e7c4:	6360      	str	r0, [r4, #52]	; 0x34
 800e7c6:	63a6      	str	r6, [r4, #56]	; 0x38
 800e7c8:	3346      	adds	r3, #70	; 0x46
 800e7ca:	781a      	ldrb	r2, [r3, #0]
 800e7cc:	4b10      	ldr	r3, [pc, #64]	; (800e810 <__submore+0x70>)
 800e7ce:	54c2      	strb	r2, [r0, r3]
 800e7d0:	1c23      	adds	r3, r4, #0
 800e7d2:	3345      	adds	r3, #69	; 0x45
 800e7d4:	781a      	ldrb	r2, [r3, #0]
 800e7d6:	4b0f      	ldr	r3, [pc, #60]	; (800e814 <__submore+0x74>)
 800e7d8:	54c2      	strb	r2, [r0, r3]
 800e7da:	782a      	ldrb	r2, [r5, #0]
 800e7dc:	4b0e      	ldr	r3, [pc, #56]	; (800e818 <__submore+0x78>)
 800e7de:	54c2      	strb	r2, [r0, r3]
 800e7e0:	18c0      	adds	r0, r0, r3
 800e7e2:	6020      	str	r0, [r4, #0]
 800e7e4:	e012      	b.n	800e80c <__submore+0x6c>
 800e7e6:	6b8e      	ldr	r6, [r1, #56]	; 0x38
 800e7e8:	1c29      	adds	r1, r5, #0
 800e7ea:	0073      	lsls	r3, r6, #1
 800e7ec:	1c1a      	adds	r2, r3, #0
 800e7ee:	9301      	str	r3, [sp, #4]
 800e7f0:	f000 f843 	bl	800e87a <_realloc_r>
 800e7f4:	1e05      	subs	r5, r0, #0
 800e7f6:	d0e1      	beq.n	800e7bc <__submore+0x1c>
 800e7f8:	1987      	adds	r7, r0, r6
 800e7fa:	1c38      	adds	r0, r7, #0
 800e7fc:	1c29      	adds	r1, r5, #0
 800e7fe:	1c32      	adds	r2, r6, #0
 800e800:	f7fe f85a 	bl	800c8b8 <memcpy>
 800e804:	9b01      	ldr	r3, [sp, #4]
 800e806:	6027      	str	r7, [r4, #0]
 800e808:	6365      	str	r5, [r4, #52]	; 0x34
 800e80a:	63a3      	str	r3, [r4, #56]	; 0x38
 800e80c:	2000      	movs	r0, #0
 800e80e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800e810:	000003ff 	.word	0x000003ff
 800e814:	000003fe 	.word	0x000003fe
 800e818:	000003fd 	.word	0x000003fd

0800e81c <_fstat_r>:
 800e81c:	b538      	push	{r3, r4, r5, lr}
 800e81e:	2300      	movs	r3, #0
 800e820:	4c06      	ldr	r4, [pc, #24]	; (800e83c <_fstat_r+0x20>)
 800e822:	1c05      	adds	r5, r0, #0
 800e824:	1c08      	adds	r0, r1, #0
 800e826:	1c11      	adds	r1, r2, #0
 800e828:	6023      	str	r3, [r4, #0]
 800e82a:	f000 f85f 	bl	800e8ec <_fstat>
 800e82e:	1c43      	adds	r3, r0, #1
 800e830:	d103      	bne.n	800e83a <_fstat_r+0x1e>
 800e832:	6823      	ldr	r3, [r4, #0]
 800e834:	2b00      	cmp	r3, #0
 800e836:	d000      	beq.n	800e83a <_fstat_r+0x1e>
 800e838:	602b      	str	r3, [r5, #0]
 800e83a:	bd38      	pop	{r3, r4, r5, pc}
 800e83c:	20002190 	.word	0x20002190

0800e840 <_isatty_r>:
 800e840:	b538      	push	{r3, r4, r5, lr}
 800e842:	2300      	movs	r3, #0
 800e844:	4c06      	ldr	r4, [pc, #24]	; (800e860 <_isatty_r+0x20>)
 800e846:	1c05      	adds	r5, r0, #0
 800e848:	1c08      	adds	r0, r1, #0
 800e84a:	6023      	str	r3, [r4, #0]
 800e84c:	f000 f85e 	bl	800e90c <_isatty>
 800e850:	1c43      	adds	r3, r0, #1
 800e852:	d103      	bne.n	800e85c <_isatty_r+0x1c>
 800e854:	6823      	ldr	r3, [r4, #0]
 800e856:	2b00      	cmp	r3, #0
 800e858:	d000      	beq.n	800e85c <_isatty_r+0x1c>
 800e85a:	602b      	str	r3, [r5, #0]
 800e85c:	bd38      	pop	{r3, r4, r5, pc}
 800e85e:	46c0      	nop			; (mov r8, r8)
 800e860:	20002190 	.word	0x20002190

0800e864 <memchr>:
 800e864:	b2c9      	uxtb	r1, r1
 800e866:	1882      	adds	r2, r0, r2
 800e868:	4290      	cmp	r0, r2
 800e86a:	d004      	beq.n	800e876 <memchr+0x12>
 800e86c:	7803      	ldrb	r3, [r0, #0]
 800e86e:	428b      	cmp	r3, r1
 800e870:	d002      	beq.n	800e878 <memchr+0x14>
 800e872:	3001      	adds	r0, #1
 800e874:	e7f8      	b.n	800e868 <memchr+0x4>
 800e876:	2000      	movs	r0, #0
 800e878:	4770      	bx	lr

0800e87a <_realloc_r>:
 800e87a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e87c:	1c06      	adds	r6, r0, #0
 800e87e:	1c0c      	adds	r4, r1, #0
 800e880:	1c15      	adds	r5, r2, #0
 800e882:	2900      	cmp	r1, #0
 800e884:	d104      	bne.n	800e890 <_realloc_r+0x16>
 800e886:	1c11      	adds	r1, r2, #0
 800e888:	f7fe f890 	bl	800c9ac <_malloc_r>
 800e88c:	1c04      	adds	r4, r0, #0
 800e88e:	e018      	b.n	800e8c2 <_realloc_r+0x48>
 800e890:	2a00      	cmp	r2, #0
 800e892:	d103      	bne.n	800e89c <_realloc_r+0x22>
 800e894:	f7fe f844 	bl	800c920 <_free_r>
 800e898:	1c2c      	adds	r4, r5, #0
 800e89a:	e012      	b.n	800e8c2 <_realloc_r+0x48>
 800e89c:	f000 f813 	bl	800e8c6 <_malloc_usable_size_r>
 800e8a0:	42a8      	cmp	r0, r5
 800e8a2:	d20e      	bcs.n	800e8c2 <_realloc_r+0x48>
 800e8a4:	1c30      	adds	r0, r6, #0
 800e8a6:	1c29      	adds	r1, r5, #0
 800e8a8:	f7fe f880 	bl	800c9ac <_malloc_r>
 800e8ac:	1e07      	subs	r7, r0, #0
 800e8ae:	d007      	beq.n	800e8c0 <_realloc_r+0x46>
 800e8b0:	1c21      	adds	r1, r4, #0
 800e8b2:	1c2a      	adds	r2, r5, #0
 800e8b4:	f7fe f800 	bl	800c8b8 <memcpy>
 800e8b8:	1c30      	adds	r0, r6, #0
 800e8ba:	1c21      	adds	r1, r4, #0
 800e8bc:	f7fe f830 	bl	800c920 <_free_r>
 800e8c0:	1c3c      	adds	r4, r7, #0
 800e8c2:	1c20      	adds	r0, r4, #0
 800e8c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800e8c6 <_malloc_usable_size_r>:
 800e8c6:	1f0b      	subs	r3, r1, #4
 800e8c8:	681a      	ldr	r2, [r3, #0]
 800e8ca:	1f10      	subs	r0, r2, #4
 800e8cc:	2a00      	cmp	r2, #0
 800e8ce:	da04      	bge.n	800e8da <_malloc_usable_size_r+0x14>
 800e8d0:	1889      	adds	r1, r1, r2
 800e8d2:	3904      	subs	r1, #4
 800e8d4:	680b      	ldr	r3, [r1, #0]
 800e8d6:	18d0      	adds	r0, r2, r3
 800e8d8:	3804      	subs	r0, #4
 800e8da:	4770      	bx	lr

0800e8dc <_close>:
 800e8dc:	2258      	movs	r2, #88	; 0x58
 800e8de:	2001      	movs	r0, #1
 800e8e0:	4b01      	ldr	r3, [pc, #4]	; (800e8e8 <_close+0xc>)
 800e8e2:	4240      	negs	r0, r0
 800e8e4:	601a      	str	r2, [r3, #0]
 800e8e6:	4770      	bx	lr
 800e8e8:	20002190 	.word	0x20002190

0800e8ec <_fstat>:
 800e8ec:	2258      	movs	r2, #88	; 0x58
 800e8ee:	2001      	movs	r0, #1
 800e8f0:	4b01      	ldr	r3, [pc, #4]	; (800e8f8 <_fstat+0xc>)
 800e8f2:	4240      	negs	r0, r0
 800e8f4:	601a      	str	r2, [r3, #0]
 800e8f6:	4770      	bx	lr
 800e8f8:	20002190 	.word	0x20002190

0800e8fc <_getpid>:
 800e8fc:	2258      	movs	r2, #88	; 0x58
 800e8fe:	2001      	movs	r0, #1
 800e900:	4b01      	ldr	r3, [pc, #4]	; (800e908 <_getpid+0xc>)
 800e902:	4240      	negs	r0, r0
 800e904:	601a      	str	r2, [r3, #0]
 800e906:	4770      	bx	lr
 800e908:	20002190 	.word	0x20002190

0800e90c <_isatty>:
 800e90c:	2258      	movs	r2, #88	; 0x58
 800e90e:	4b02      	ldr	r3, [pc, #8]	; (800e918 <_isatty+0xc>)
 800e910:	2000      	movs	r0, #0
 800e912:	601a      	str	r2, [r3, #0]
 800e914:	4770      	bx	lr
 800e916:	46c0      	nop			; (mov r8, r8)
 800e918:	20002190 	.word	0x20002190

0800e91c <_kill>:
 800e91c:	2258      	movs	r2, #88	; 0x58
 800e91e:	2001      	movs	r0, #1
 800e920:	4b01      	ldr	r3, [pc, #4]	; (800e928 <_kill+0xc>)
 800e922:	4240      	negs	r0, r0
 800e924:	601a      	str	r2, [r3, #0]
 800e926:	4770      	bx	lr
 800e928:	20002190 	.word	0x20002190

0800e92c <_lseek>:
 800e92c:	2258      	movs	r2, #88	; 0x58
 800e92e:	2001      	movs	r0, #1
 800e930:	4b01      	ldr	r3, [pc, #4]	; (800e938 <_lseek+0xc>)
 800e932:	4240      	negs	r0, r0
 800e934:	601a      	str	r2, [r3, #0]
 800e936:	4770      	bx	lr
 800e938:	20002190 	.word	0x20002190

0800e93c <_read>:
 800e93c:	2258      	movs	r2, #88	; 0x58
 800e93e:	2001      	movs	r0, #1
 800e940:	4b01      	ldr	r3, [pc, #4]	; (800e948 <_read+0xc>)
 800e942:	4240      	negs	r0, r0
 800e944:	601a      	str	r2, [r3, #0]
 800e946:	4770      	bx	lr
 800e948:	20002190 	.word	0x20002190

0800e94c <_sbrk>:
 800e94c:	4a04      	ldr	r2, [pc, #16]	; (800e960 <_sbrk+0x14>)
 800e94e:	6813      	ldr	r3, [r2, #0]
 800e950:	2b00      	cmp	r3, #0
 800e952:	d003      	beq.n	800e95c <_sbrk+0x10>
 800e954:	1818      	adds	r0, r3, r0
 800e956:	6010      	str	r0, [r2, #0]
 800e958:	1c18      	adds	r0, r3, #0
 800e95a:	4770      	bx	lr
 800e95c:	4b01      	ldr	r3, [pc, #4]	; (800e964 <_sbrk+0x18>)
 800e95e:	e7f9      	b.n	800e954 <_sbrk+0x8>
 800e960:	20001d90 	.word	0x20001d90
 800e964:	20002194 	.word	0x20002194

0800e968 <_write>:
 800e968:	2258      	movs	r2, #88	; 0x58
 800e96a:	2001      	movs	r0, #1
 800e96c:	4b01      	ldr	r3, [pc, #4]	; (800e974 <_write+0xc>)
 800e96e:	4240      	negs	r0, r0
 800e970:	601a      	str	r2, [r3, #0]
 800e972:	4770      	bx	lr
 800e974:	20002190 	.word	0x20002190

0800e978 <_exit>:
 800e978:	e7fe      	b.n	800e978 <_exit>
 800e97a:	46c0      	nop			; (mov r8, r8)

0800e97c <__gnu_thumb1_case_uqi>:
 800e97c:	b402      	push	{r1}
 800e97e:	4671      	mov	r1, lr
 800e980:	0849      	lsrs	r1, r1, #1
 800e982:	0049      	lsls	r1, r1, #1
 800e984:	5c09      	ldrb	r1, [r1, r0]
 800e986:	0049      	lsls	r1, r1, #1
 800e988:	448e      	add	lr, r1
 800e98a:	bc02      	pop	{r1}
 800e98c:	4770      	bx	lr
 800e98e:	46c0      	nop			; (mov r8, r8)

0800e990 <__aeabi_uidiv>:
 800e990:	2200      	movs	r2, #0
 800e992:	0843      	lsrs	r3, r0, #1
 800e994:	428b      	cmp	r3, r1
 800e996:	d374      	bcc.n	800ea82 <__aeabi_uidiv+0xf2>
 800e998:	0903      	lsrs	r3, r0, #4
 800e99a:	428b      	cmp	r3, r1
 800e99c:	d35f      	bcc.n	800ea5e <__aeabi_uidiv+0xce>
 800e99e:	0a03      	lsrs	r3, r0, #8
 800e9a0:	428b      	cmp	r3, r1
 800e9a2:	d344      	bcc.n	800ea2e <__aeabi_uidiv+0x9e>
 800e9a4:	0b03      	lsrs	r3, r0, #12
 800e9a6:	428b      	cmp	r3, r1
 800e9a8:	d328      	bcc.n	800e9fc <__aeabi_uidiv+0x6c>
 800e9aa:	0c03      	lsrs	r3, r0, #16
 800e9ac:	428b      	cmp	r3, r1
 800e9ae:	d30d      	bcc.n	800e9cc <__aeabi_uidiv+0x3c>
 800e9b0:	22ff      	movs	r2, #255	; 0xff
 800e9b2:	0209      	lsls	r1, r1, #8
 800e9b4:	ba12      	rev	r2, r2
 800e9b6:	0c03      	lsrs	r3, r0, #16
 800e9b8:	428b      	cmp	r3, r1
 800e9ba:	d302      	bcc.n	800e9c2 <__aeabi_uidiv+0x32>
 800e9bc:	1212      	asrs	r2, r2, #8
 800e9be:	0209      	lsls	r1, r1, #8
 800e9c0:	d065      	beq.n	800ea8e <__aeabi_uidiv+0xfe>
 800e9c2:	0b03      	lsrs	r3, r0, #12
 800e9c4:	428b      	cmp	r3, r1
 800e9c6:	d319      	bcc.n	800e9fc <__aeabi_uidiv+0x6c>
 800e9c8:	e000      	b.n	800e9cc <__aeabi_uidiv+0x3c>
 800e9ca:	0a09      	lsrs	r1, r1, #8
 800e9cc:	0bc3      	lsrs	r3, r0, #15
 800e9ce:	428b      	cmp	r3, r1
 800e9d0:	d301      	bcc.n	800e9d6 <__aeabi_uidiv+0x46>
 800e9d2:	03cb      	lsls	r3, r1, #15
 800e9d4:	1ac0      	subs	r0, r0, r3
 800e9d6:	4152      	adcs	r2, r2
 800e9d8:	0b83      	lsrs	r3, r0, #14
 800e9da:	428b      	cmp	r3, r1
 800e9dc:	d301      	bcc.n	800e9e2 <__aeabi_uidiv+0x52>
 800e9de:	038b      	lsls	r3, r1, #14
 800e9e0:	1ac0      	subs	r0, r0, r3
 800e9e2:	4152      	adcs	r2, r2
 800e9e4:	0b43      	lsrs	r3, r0, #13
 800e9e6:	428b      	cmp	r3, r1
 800e9e8:	d301      	bcc.n	800e9ee <__aeabi_uidiv+0x5e>
 800e9ea:	034b      	lsls	r3, r1, #13
 800e9ec:	1ac0      	subs	r0, r0, r3
 800e9ee:	4152      	adcs	r2, r2
 800e9f0:	0b03      	lsrs	r3, r0, #12
 800e9f2:	428b      	cmp	r3, r1
 800e9f4:	d301      	bcc.n	800e9fa <__aeabi_uidiv+0x6a>
 800e9f6:	030b      	lsls	r3, r1, #12
 800e9f8:	1ac0      	subs	r0, r0, r3
 800e9fa:	4152      	adcs	r2, r2
 800e9fc:	0ac3      	lsrs	r3, r0, #11
 800e9fe:	428b      	cmp	r3, r1
 800ea00:	d301      	bcc.n	800ea06 <__aeabi_uidiv+0x76>
 800ea02:	02cb      	lsls	r3, r1, #11
 800ea04:	1ac0      	subs	r0, r0, r3
 800ea06:	4152      	adcs	r2, r2
 800ea08:	0a83      	lsrs	r3, r0, #10
 800ea0a:	428b      	cmp	r3, r1
 800ea0c:	d301      	bcc.n	800ea12 <__aeabi_uidiv+0x82>
 800ea0e:	028b      	lsls	r3, r1, #10
 800ea10:	1ac0      	subs	r0, r0, r3
 800ea12:	4152      	adcs	r2, r2
 800ea14:	0a43      	lsrs	r3, r0, #9
 800ea16:	428b      	cmp	r3, r1
 800ea18:	d301      	bcc.n	800ea1e <__aeabi_uidiv+0x8e>
 800ea1a:	024b      	lsls	r3, r1, #9
 800ea1c:	1ac0      	subs	r0, r0, r3
 800ea1e:	4152      	adcs	r2, r2
 800ea20:	0a03      	lsrs	r3, r0, #8
 800ea22:	428b      	cmp	r3, r1
 800ea24:	d301      	bcc.n	800ea2a <__aeabi_uidiv+0x9a>
 800ea26:	020b      	lsls	r3, r1, #8
 800ea28:	1ac0      	subs	r0, r0, r3
 800ea2a:	4152      	adcs	r2, r2
 800ea2c:	d2cd      	bcs.n	800e9ca <__aeabi_uidiv+0x3a>
 800ea2e:	09c3      	lsrs	r3, r0, #7
 800ea30:	428b      	cmp	r3, r1
 800ea32:	d301      	bcc.n	800ea38 <__aeabi_uidiv+0xa8>
 800ea34:	01cb      	lsls	r3, r1, #7
 800ea36:	1ac0      	subs	r0, r0, r3
 800ea38:	4152      	adcs	r2, r2
 800ea3a:	0983      	lsrs	r3, r0, #6
 800ea3c:	428b      	cmp	r3, r1
 800ea3e:	d301      	bcc.n	800ea44 <__aeabi_uidiv+0xb4>
 800ea40:	018b      	lsls	r3, r1, #6
 800ea42:	1ac0      	subs	r0, r0, r3
 800ea44:	4152      	adcs	r2, r2
 800ea46:	0943      	lsrs	r3, r0, #5
 800ea48:	428b      	cmp	r3, r1
 800ea4a:	d301      	bcc.n	800ea50 <__aeabi_uidiv+0xc0>
 800ea4c:	014b      	lsls	r3, r1, #5
 800ea4e:	1ac0      	subs	r0, r0, r3
 800ea50:	4152      	adcs	r2, r2
 800ea52:	0903      	lsrs	r3, r0, #4
 800ea54:	428b      	cmp	r3, r1
 800ea56:	d301      	bcc.n	800ea5c <__aeabi_uidiv+0xcc>
 800ea58:	010b      	lsls	r3, r1, #4
 800ea5a:	1ac0      	subs	r0, r0, r3
 800ea5c:	4152      	adcs	r2, r2
 800ea5e:	08c3      	lsrs	r3, r0, #3
 800ea60:	428b      	cmp	r3, r1
 800ea62:	d301      	bcc.n	800ea68 <__aeabi_uidiv+0xd8>
 800ea64:	00cb      	lsls	r3, r1, #3
 800ea66:	1ac0      	subs	r0, r0, r3
 800ea68:	4152      	adcs	r2, r2
 800ea6a:	0883      	lsrs	r3, r0, #2
 800ea6c:	428b      	cmp	r3, r1
 800ea6e:	d301      	bcc.n	800ea74 <__aeabi_uidiv+0xe4>
 800ea70:	008b      	lsls	r3, r1, #2
 800ea72:	1ac0      	subs	r0, r0, r3
 800ea74:	4152      	adcs	r2, r2
 800ea76:	0843      	lsrs	r3, r0, #1
 800ea78:	428b      	cmp	r3, r1
 800ea7a:	d301      	bcc.n	800ea80 <__aeabi_uidiv+0xf0>
 800ea7c:	004b      	lsls	r3, r1, #1
 800ea7e:	1ac0      	subs	r0, r0, r3
 800ea80:	4152      	adcs	r2, r2
 800ea82:	1a41      	subs	r1, r0, r1
 800ea84:	d200      	bcs.n	800ea88 <__aeabi_uidiv+0xf8>
 800ea86:	4601      	mov	r1, r0
 800ea88:	4152      	adcs	r2, r2
 800ea8a:	4610      	mov	r0, r2
 800ea8c:	4770      	bx	lr
 800ea8e:	e7ff      	b.n	800ea90 <__aeabi_uidiv+0x100>
 800ea90:	b501      	push	{r0, lr}
 800ea92:	2000      	movs	r0, #0
 800ea94:	f000 f8fc 	bl	800ec90 <__aeabi_idiv0>
 800ea98:	bd02      	pop	{r1, pc}
 800ea9a:	46c0      	nop			; (mov r8, r8)

0800ea9c <__aeabi_uidivmod>:
 800ea9c:	2900      	cmp	r1, #0
 800ea9e:	d0f7      	beq.n	800ea90 <__aeabi_uidiv+0x100>
 800eaa0:	b503      	push	{r0, r1, lr}
 800eaa2:	f7ff ff75 	bl	800e990 <__aeabi_uidiv>
 800eaa6:	bc0e      	pop	{r1, r2, r3}
 800eaa8:	4342      	muls	r2, r0
 800eaaa:	1a89      	subs	r1, r1, r2
 800eaac:	4718      	bx	r3
 800eaae:	46c0      	nop			; (mov r8, r8)

0800eab0 <__aeabi_idiv>:
 800eab0:	4603      	mov	r3, r0
 800eab2:	430b      	orrs	r3, r1
 800eab4:	d47f      	bmi.n	800ebb6 <__aeabi_idiv+0x106>
 800eab6:	2200      	movs	r2, #0
 800eab8:	0843      	lsrs	r3, r0, #1
 800eaba:	428b      	cmp	r3, r1
 800eabc:	d374      	bcc.n	800eba8 <__aeabi_idiv+0xf8>
 800eabe:	0903      	lsrs	r3, r0, #4
 800eac0:	428b      	cmp	r3, r1
 800eac2:	d35f      	bcc.n	800eb84 <__aeabi_idiv+0xd4>
 800eac4:	0a03      	lsrs	r3, r0, #8
 800eac6:	428b      	cmp	r3, r1
 800eac8:	d344      	bcc.n	800eb54 <__aeabi_idiv+0xa4>
 800eaca:	0b03      	lsrs	r3, r0, #12
 800eacc:	428b      	cmp	r3, r1
 800eace:	d328      	bcc.n	800eb22 <__aeabi_idiv+0x72>
 800ead0:	0c03      	lsrs	r3, r0, #16
 800ead2:	428b      	cmp	r3, r1
 800ead4:	d30d      	bcc.n	800eaf2 <__aeabi_idiv+0x42>
 800ead6:	22ff      	movs	r2, #255	; 0xff
 800ead8:	0209      	lsls	r1, r1, #8
 800eada:	ba12      	rev	r2, r2
 800eadc:	0c03      	lsrs	r3, r0, #16
 800eade:	428b      	cmp	r3, r1
 800eae0:	d302      	bcc.n	800eae8 <__aeabi_idiv+0x38>
 800eae2:	1212      	asrs	r2, r2, #8
 800eae4:	0209      	lsls	r1, r1, #8
 800eae6:	d065      	beq.n	800ebb4 <__aeabi_idiv+0x104>
 800eae8:	0b03      	lsrs	r3, r0, #12
 800eaea:	428b      	cmp	r3, r1
 800eaec:	d319      	bcc.n	800eb22 <__aeabi_idiv+0x72>
 800eaee:	e000      	b.n	800eaf2 <__aeabi_idiv+0x42>
 800eaf0:	0a09      	lsrs	r1, r1, #8
 800eaf2:	0bc3      	lsrs	r3, r0, #15
 800eaf4:	428b      	cmp	r3, r1
 800eaf6:	d301      	bcc.n	800eafc <__aeabi_idiv+0x4c>
 800eaf8:	03cb      	lsls	r3, r1, #15
 800eafa:	1ac0      	subs	r0, r0, r3
 800eafc:	4152      	adcs	r2, r2
 800eafe:	0b83      	lsrs	r3, r0, #14
 800eb00:	428b      	cmp	r3, r1
 800eb02:	d301      	bcc.n	800eb08 <__aeabi_idiv+0x58>
 800eb04:	038b      	lsls	r3, r1, #14
 800eb06:	1ac0      	subs	r0, r0, r3
 800eb08:	4152      	adcs	r2, r2
 800eb0a:	0b43      	lsrs	r3, r0, #13
 800eb0c:	428b      	cmp	r3, r1
 800eb0e:	d301      	bcc.n	800eb14 <__aeabi_idiv+0x64>
 800eb10:	034b      	lsls	r3, r1, #13
 800eb12:	1ac0      	subs	r0, r0, r3
 800eb14:	4152      	adcs	r2, r2
 800eb16:	0b03      	lsrs	r3, r0, #12
 800eb18:	428b      	cmp	r3, r1
 800eb1a:	d301      	bcc.n	800eb20 <__aeabi_idiv+0x70>
 800eb1c:	030b      	lsls	r3, r1, #12
 800eb1e:	1ac0      	subs	r0, r0, r3
 800eb20:	4152      	adcs	r2, r2
 800eb22:	0ac3      	lsrs	r3, r0, #11
 800eb24:	428b      	cmp	r3, r1
 800eb26:	d301      	bcc.n	800eb2c <__aeabi_idiv+0x7c>
 800eb28:	02cb      	lsls	r3, r1, #11
 800eb2a:	1ac0      	subs	r0, r0, r3
 800eb2c:	4152      	adcs	r2, r2
 800eb2e:	0a83      	lsrs	r3, r0, #10
 800eb30:	428b      	cmp	r3, r1
 800eb32:	d301      	bcc.n	800eb38 <__aeabi_idiv+0x88>
 800eb34:	028b      	lsls	r3, r1, #10
 800eb36:	1ac0      	subs	r0, r0, r3
 800eb38:	4152      	adcs	r2, r2
 800eb3a:	0a43      	lsrs	r3, r0, #9
 800eb3c:	428b      	cmp	r3, r1
 800eb3e:	d301      	bcc.n	800eb44 <__aeabi_idiv+0x94>
 800eb40:	024b      	lsls	r3, r1, #9
 800eb42:	1ac0      	subs	r0, r0, r3
 800eb44:	4152      	adcs	r2, r2
 800eb46:	0a03      	lsrs	r3, r0, #8
 800eb48:	428b      	cmp	r3, r1
 800eb4a:	d301      	bcc.n	800eb50 <__aeabi_idiv+0xa0>
 800eb4c:	020b      	lsls	r3, r1, #8
 800eb4e:	1ac0      	subs	r0, r0, r3
 800eb50:	4152      	adcs	r2, r2
 800eb52:	d2cd      	bcs.n	800eaf0 <__aeabi_idiv+0x40>
 800eb54:	09c3      	lsrs	r3, r0, #7
 800eb56:	428b      	cmp	r3, r1
 800eb58:	d301      	bcc.n	800eb5e <__aeabi_idiv+0xae>
 800eb5a:	01cb      	lsls	r3, r1, #7
 800eb5c:	1ac0      	subs	r0, r0, r3
 800eb5e:	4152      	adcs	r2, r2
 800eb60:	0983      	lsrs	r3, r0, #6
 800eb62:	428b      	cmp	r3, r1
 800eb64:	d301      	bcc.n	800eb6a <__aeabi_idiv+0xba>
 800eb66:	018b      	lsls	r3, r1, #6
 800eb68:	1ac0      	subs	r0, r0, r3
 800eb6a:	4152      	adcs	r2, r2
 800eb6c:	0943      	lsrs	r3, r0, #5
 800eb6e:	428b      	cmp	r3, r1
 800eb70:	d301      	bcc.n	800eb76 <__aeabi_idiv+0xc6>
 800eb72:	014b      	lsls	r3, r1, #5
 800eb74:	1ac0      	subs	r0, r0, r3
 800eb76:	4152      	adcs	r2, r2
 800eb78:	0903      	lsrs	r3, r0, #4
 800eb7a:	428b      	cmp	r3, r1
 800eb7c:	d301      	bcc.n	800eb82 <__aeabi_idiv+0xd2>
 800eb7e:	010b      	lsls	r3, r1, #4
 800eb80:	1ac0      	subs	r0, r0, r3
 800eb82:	4152      	adcs	r2, r2
 800eb84:	08c3      	lsrs	r3, r0, #3
 800eb86:	428b      	cmp	r3, r1
 800eb88:	d301      	bcc.n	800eb8e <__aeabi_idiv+0xde>
 800eb8a:	00cb      	lsls	r3, r1, #3
 800eb8c:	1ac0      	subs	r0, r0, r3
 800eb8e:	4152      	adcs	r2, r2
 800eb90:	0883      	lsrs	r3, r0, #2
 800eb92:	428b      	cmp	r3, r1
 800eb94:	d301      	bcc.n	800eb9a <__aeabi_idiv+0xea>
 800eb96:	008b      	lsls	r3, r1, #2
 800eb98:	1ac0      	subs	r0, r0, r3
 800eb9a:	4152      	adcs	r2, r2
 800eb9c:	0843      	lsrs	r3, r0, #1
 800eb9e:	428b      	cmp	r3, r1
 800eba0:	d301      	bcc.n	800eba6 <__aeabi_idiv+0xf6>
 800eba2:	004b      	lsls	r3, r1, #1
 800eba4:	1ac0      	subs	r0, r0, r3
 800eba6:	4152      	adcs	r2, r2
 800eba8:	1a41      	subs	r1, r0, r1
 800ebaa:	d200      	bcs.n	800ebae <__aeabi_idiv+0xfe>
 800ebac:	4601      	mov	r1, r0
 800ebae:	4152      	adcs	r2, r2
 800ebb0:	4610      	mov	r0, r2
 800ebb2:	4770      	bx	lr
 800ebb4:	e05d      	b.n	800ec72 <__aeabi_idiv+0x1c2>
 800ebb6:	0fca      	lsrs	r2, r1, #31
 800ebb8:	d000      	beq.n	800ebbc <__aeabi_idiv+0x10c>
 800ebba:	4249      	negs	r1, r1
 800ebbc:	1003      	asrs	r3, r0, #32
 800ebbe:	d300      	bcc.n	800ebc2 <__aeabi_idiv+0x112>
 800ebc0:	4240      	negs	r0, r0
 800ebc2:	4053      	eors	r3, r2
 800ebc4:	2200      	movs	r2, #0
 800ebc6:	469c      	mov	ip, r3
 800ebc8:	0903      	lsrs	r3, r0, #4
 800ebca:	428b      	cmp	r3, r1
 800ebcc:	d32d      	bcc.n	800ec2a <__aeabi_idiv+0x17a>
 800ebce:	0a03      	lsrs	r3, r0, #8
 800ebd0:	428b      	cmp	r3, r1
 800ebd2:	d312      	bcc.n	800ebfa <__aeabi_idiv+0x14a>
 800ebd4:	22fc      	movs	r2, #252	; 0xfc
 800ebd6:	0189      	lsls	r1, r1, #6
 800ebd8:	ba12      	rev	r2, r2
 800ebda:	0a03      	lsrs	r3, r0, #8
 800ebdc:	428b      	cmp	r3, r1
 800ebde:	d30c      	bcc.n	800ebfa <__aeabi_idiv+0x14a>
 800ebe0:	0189      	lsls	r1, r1, #6
 800ebe2:	1192      	asrs	r2, r2, #6
 800ebe4:	428b      	cmp	r3, r1
 800ebe6:	d308      	bcc.n	800ebfa <__aeabi_idiv+0x14a>
 800ebe8:	0189      	lsls	r1, r1, #6
 800ebea:	1192      	asrs	r2, r2, #6
 800ebec:	428b      	cmp	r3, r1
 800ebee:	d304      	bcc.n	800ebfa <__aeabi_idiv+0x14a>
 800ebf0:	0189      	lsls	r1, r1, #6
 800ebf2:	d03a      	beq.n	800ec6a <__aeabi_idiv+0x1ba>
 800ebf4:	1192      	asrs	r2, r2, #6
 800ebf6:	e000      	b.n	800ebfa <__aeabi_idiv+0x14a>
 800ebf8:	0989      	lsrs	r1, r1, #6
 800ebfa:	09c3      	lsrs	r3, r0, #7
 800ebfc:	428b      	cmp	r3, r1
 800ebfe:	d301      	bcc.n	800ec04 <__aeabi_idiv+0x154>
 800ec00:	01cb      	lsls	r3, r1, #7
 800ec02:	1ac0      	subs	r0, r0, r3
 800ec04:	4152      	adcs	r2, r2
 800ec06:	0983      	lsrs	r3, r0, #6
 800ec08:	428b      	cmp	r3, r1
 800ec0a:	d301      	bcc.n	800ec10 <__aeabi_idiv+0x160>
 800ec0c:	018b      	lsls	r3, r1, #6
 800ec0e:	1ac0      	subs	r0, r0, r3
 800ec10:	4152      	adcs	r2, r2
 800ec12:	0943      	lsrs	r3, r0, #5
 800ec14:	428b      	cmp	r3, r1
 800ec16:	d301      	bcc.n	800ec1c <__aeabi_idiv+0x16c>
 800ec18:	014b      	lsls	r3, r1, #5
 800ec1a:	1ac0      	subs	r0, r0, r3
 800ec1c:	4152      	adcs	r2, r2
 800ec1e:	0903      	lsrs	r3, r0, #4
 800ec20:	428b      	cmp	r3, r1
 800ec22:	d301      	bcc.n	800ec28 <__aeabi_idiv+0x178>
 800ec24:	010b      	lsls	r3, r1, #4
 800ec26:	1ac0      	subs	r0, r0, r3
 800ec28:	4152      	adcs	r2, r2
 800ec2a:	08c3      	lsrs	r3, r0, #3
 800ec2c:	428b      	cmp	r3, r1
 800ec2e:	d301      	bcc.n	800ec34 <__aeabi_idiv+0x184>
 800ec30:	00cb      	lsls	r3, r1, #3
 800ec32:	1ac0      	subs	r0, r0, r3
 800ec34:	4152      	adcs	r2, r2
 800ec36:	0883      	lsrs	r3, r0, #2
 800ec38:	428b      	cmp	r3, r1
 800ec3a:	d301      	bcc.n	800ec40 <__aeabi_idiv+0x190>
 800ec3c:	008b      	lsls	r3, r1, #2
 800ec3e:	1ac0      	subs	r0, r0, r3
 800ec40:	4152      	adcs	r2, r2
 800ec42:	d2d9      	bcs.n	800ebf8 <__aeabi_idiv+0x148>
 800ec44:	0843      	lsrs	r3, r0, #1
 800ec46:	428b      	cmp	r3, r1
 800ec48:	d301      	bcc.n	800ec4e <__aeabi_idiv+0x19e>
 800ec4a:	004b      	lsls	r3, r1, #1
 800ec4c:	1ac0      	subs	r0, r0, r3
 800ec4e:	4152      	adcs	r2, r2
 800ec50:	1a41      	subs	r1, r0, r1
 800ec52:	d200      	bcs.n	800ec56 <__aeabi_idiv+0x1a6>
 800ec54:	4601      	mov	r1, r0
 800ec56:	4663      	mov	r3, ip
 800ec58:	4152      	adcs	r2, r2
 800ec5a:	105b      	asrs	r3, r3, #1
 800ec5c:	4610      	mov	r0, r2
 800ec5e:	d301      	bcc.n	800ec64 <__aeabi_idiv+0x1b4>
 800ec60:	4240      	negs	r0, r0
 800ec62:	2b00      	cmp	r3, #0
 800ec64:	d500      	bpl.n	800ec68 <__aeabi_idiv+0x1b8>
 800ec66:	4249      	negs	r1, r1
 800ec68:	4770      	bx	lr
 800ec6a:	4663      	mov	r3, ip
 800ec6c:	105b      	asrs	r3, r3, #1
 800ec6e:	d300      	bcc.n	800ec72 <__aeabi_idiv+0x1c2>
 800ec70:	4240      	negs	r0, r0
 800ec72:	b501      	push	{r0, lr}
 800ec74:	2000      	movs	r0, #0
 800ec76:	f000 f80b 	bl	800ec90 <__aeabi_idiv0>
 800ec7a:	bd02      	pop	{r1, pc}

0800ec7c <__aeabi_idivmod>:
 800ec7c:	2900      	cmp	r1, #0
 800ec7e:	d0f8      	beq.n	800ec72 <__aeabi_idiv+0x1c2>
 800ec80:	b503      	push	{r0, r1, lr}
 800ec82:	f7ff ff15 	bl	800eab0 <__aeabi_idiv>
 800ec86:	bc0e      	pop	{r1, r2, r3}
 800ec88:	4342      	muls	r2, r0
 800ec8a:	1a89      	subs	r1, r1, r2
 800ec8c:	4718      	bx	r3
 800ec8e:	46c0      	nop			; (mov r8, r8)

0800ec90 <__aeabi_idiv0>:
 800ec90:	4770      	bx	lr
 800ec92:	46c0      	nop			; (mov r8, r8)

0800ec94 <__aeabi_llsl>:
 800ec94:	4091      	lsls	r1, r2
 800ec96:	1c03      	adds	r3, r0, #0
 800ec98:	4090      	lsls	r0, r2
 800ec9a:	469c      	mov	ip, r3
 800ec9c:	3a20      	subs	r2, #32
 800ec9e:	4093      	lsls	r3, r2
 800eca0:	4319      	orrs	r1, r3
 800eca2:	4252      	negs	r2, r2
 800eca4:	4663      	mov	r3, ip
 800eca6:	40d3      	lsrs	r3, r2
 800eca8:	4319      	orrs	r1, r3
 800ecaa:	4770      	bx	lr

0800ecac <__aeabi_ldivmod>:
 800ecac:	2b00      	cmp	r3, #0
 800ecae:	d115      	bne.n	800ecdc <__aeabi_ldivmod+0x30>
 800ecb0:	2a00      	cmp	r2, #0
 800ecb2:	d113      	bne.n	800ecdc <__aeabi_ldivmod+0x30>
 800ecb4:	2900      	cmp	r1, #0
 800ecb6:	d100      	bne.n	800ecba <__aeabi_ldivmod+0xe>
 800ecb8:	2800      	cmp	r0, #0
 800ecba:	d007      	beq.n	800eccc <__aeabi_ldivmod+0x20>
 800ecbc:	db03      	blt.n	800ecc6 <__aeabi_ldivmod+0x1a>
 800ecbe:	2000      	movs	r0, #0
 800ecc0:	43c0      	mvns	r0, r0
 800ecc2:	0841      	lsrs	r1, r0, #1
 800ecc4:	e002      	b.n	800eccc <__aeabi_ldivmod+0x20>
 800ecc6:	2180      	movs	r1, #128	; 0x80
 800ecc8:	0609      	lsls	r1, r1, #24
 800ecca:	2000      	movs	r0, #0
 800eccc:	b407      	push	{r0, r1, r2}
 800ecce:	4802      	ldr	r0, [pc, #8]	; (800ecd8 <__aeabi_ldivmod+0x2c>)
 800ecd0:	a101      	add	r1, pc, #4	; (adr r1, 800ecd8 <__aeabi_ldivmod+0x2c>)
 800ecd2:	1840      	adds	r0, r0, r1
 800ecd4:	9002      	str	r0, [sp, #8]
 800ecd6:	bd03      	pop	{r0, r1, pc}
 800ecd8:	ffffffb9 	.word	0xffffffb9
 800ecdc:	b403      	push	{r0, r1}
 800ecde:	4668      	mov	r0, sp
 800ece0:	b501      	push	{r0, lr}
 800ece2:	9802      	ldr	r0, [sp, #8]
 800ece4:	f000 f850 	bl	800ed88 <__gnu_ldivmod_helper>
 800ece8:	9b01      	ldr	r3, [sp, #4]
 800ecea:	469e      	mov	lr, r3
 800ecec:	b002      	add	sp, #8
 800ecee:	bc0c      	pop	{r2, r3}
 800ecf0:	4770      	bx	lr
 800ecf2:	46c0      	nop			; (mov r8, r8)

0800ecf4 <__aeabi_uldivmod>:
 800ecf4:	2b00      	cmp	r3, #0
 800ecf6:	d111      	bne.n	800ed1c <__aeabi_uldivmod+0x28>
 800ecf8:	2a00      	cmp	r2, #0
 800ecfa:	d10f      	bne.n	800ed1c <__aeabi_uldivmod+0x28>
 800ecfc:	2900      	cmp	r1, #0
 800ecfe:	d100      	bne.n	800ed02 <__aeabi_uldivmod+0xe>
 800ed00:	2800      	cmp	r0, #0
 800ed02:	d002      	beq.n	800ed0a <__aeabi_uldivmod+0x16>
 800ed04:	2100      	movs	r1, #0
 800ed06:	43c9      	mvns	r1, r1
 800ed08:	1c08      	adds	r0, r1, #0
 800ed0a:	b407      	push	{r0, r1, r2}
 800ed0c:	4802      	ldr	r0, [pc, #8]	; (800ed18 <__aeabi_uldivmod+0x24>)
 800ed0e:	a102      	add	r1, pc, #8	; (adr r1, 800ed18 <__aeabi_uldivmod+0x24>)
 800ed10:	1840      	adds	r0, r0, r1
 800ed12:	9002      	str	r0, [sp, #8]
 800ed14:	bd03      	pop	{r0, r1, pc}
 800ed16:	46c0      	nop			; (mov r8, r8)
 800ed18:	ffffff79 	.word	0xffffff79
 800ed1c:	b403      	push	{r0, r1}
 800ed1e:	4668      	mov	r0, sp
 800ed20:	b501      	push	{r0, lr}
 800ed22:	9802      	ldr	r0, [sp, #8]
 800ed24:	f000 f84c 	bl	800edc0 <__gnu_uldivmod_helper>
 800ed28:	9b01      	ldr	r3, [sp, #4]
 800ed2a:	469e      	mov	lr, r3
 800ed2c:	b002      	add	sp, #8
 800ed2e:	bc0c      	pop	{r2, r3}
 800ed30:	4770      	bx	lr
 800ed32:	46c0      	nop			; (mov r8, r8)

0800ed34 <__aeabi_lmul>:
 800ed34:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ed36:	464f      	mov	r7, r9
 800ed38:	4646      	mov	r6, r8
 800ed3a:	0405      	lsls	r5, r0, #16
 800ed3c:	0c2d      	lsrs	r5, r5, #16
 800ed3e:	1c2c      	adds	r4, r5, #0
 800ed40:	b4c0      	push	{r6, r7}
 800ed42:	0417      	lsls	r7, r2, #16
 800ed44:	0c16      	lsrs	r6, r2, #16
 800ed46:	0c3f      	lsrs	r7, r7, #16
 800ed48:	4699      	mov	r9, r3
 800ed4a:	0c03      	lsrs	r3, r0, #16
 800ed4c:	437c      	muls	r4, r7
 800ed4e:	4375      	muls	r5, r6
 800ed50:	435f      	muls	r7, r3
 800ed52:	4373      	muls	r3, r6
 800ed54:	197d      	adds	r5, r7, r5
 800ed56:	0c26      	lsrs	r6, r4, #16
 800ed58:	19ad      	adds	r5, r5, r6
 800ed5a:	469c      	mov	ip, r3
 800ed5c:	42af      	cmp	r7, r5
 800ed5e:	d903      	bls.n	800ed68 <__aeabi_lmul+0x34>
 800ed60:	2380      	movs	r3, #128	; 0x80
 800ed62:	025b      	lsls	r3, r3, #9
 800ed64:	4698      	mov	r8, r3
 800ed66:	44c4      	add	ip, r8
 800ed68:	464b      	mov	r3, r9
 800ed6a:	4351      	muls	r1, r2
 800ed6c:	4343      	muls	r3, r0
 800ed6e:	0424      	lsls	r4, r4, #16
 800ed70:	0c2e      	lsrs	r6, r5, #16
 800ed72:	0c24      	lsrs	r4, r4, #16
 800ed74:	042d      	lsls	r5, r5, #16
 800ed76:	4466      	add	r6, ip
 800ed78:	192c      	adds	r4, r5, r4
 800ed7a:	1859      	adds	r1, r3, r1
 800ed7c:	1989      	adds	r1, r1, r6
 800ed7e:	1c20      	adds	r0, r4, #0
 800ed80:	bc0c      	pop	{r2, r3}
 800ed82:	4690      	mov	r8, r2
 800ed84:	4699      	mov	r9, r3
 800ed86:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800ed88 <__gnu_ldivmod_helper>:
 800ed88:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ed8a:	b083      	sub	sp, #12
 800ed8c:	1c16      	adds	r6, r2, #0
 800ed8e:	1c1f      	adds	r7, r3, #0
 800ed90:	9000      	str	r0, [sp, #0]
 800ed92:	9101      	str	r1, [sp, #4]
 800ed94:	f000 f82e 	bl	800edf4 <__divdi3>
 800ed98:	1c04      	adds	r4, r0, #0
 800ed9a:	1c0d      	adds	r5, r1, #0
 800ed9c:	1c22      	adds	r2, r4, #0
 800ed9e:	1c2b      	adds	r3, r5, #0
 800eda0:	1c30      	adds	r0, r6, #0
 800eda2:	1c39      	adds	r1, r7, #0
 800eda4:	f7ff ffc6 	bl	800ed34 <__aeabi_lmul>
 800eda8:	9a00      	ldr	r2, [sp, #0]
 800edaa:	9b01      	ldr	r3, [sp, #4]
 800edac:	1a12      	subs	r2, r2, r0
 800edae:	418b      	sbcs	r3, r1
 800edb0:	9908      	ldr	r1, [sp, #32]
 800edb2:	1c20      	adds	r0, r4, #0
 800edb4:	600a      	str	r2, [r1, #0]
 800edb6:	604b      	str	r3, [r1, #4]
 800edb8:	1c29      	adds	r1, r5, #0
 800edba:	b003      	add	sp, #12
 800edbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800edbe:	46c0      	nop			; (mov r8, r8)

0800edc0 <__gnu_uldivmod_helper>:
 800edc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800edc2:	1c14      	adds	r4, r2, #0
 800edc4:	b083      	sub	sp, #12
 800edc6:	1c1d      	adds	r5, r3, #0
 800edc8:	9000      	str	r0, [sp, #0]
 800edca:	9101      	str	r1, [sp, #4]
 800edcc:	f000 f90a 	bl	800efe4 <__udivdi3>
 800edd0:	1c22      	adds	r2, r4, #0
 800edd2:	1c2b      	adds	r3, r5, #0
 800edd4:	1c06      	adds	r6, r0, #0
 800edd6:	1c0f      	adds	r7, r1, #0
 800edd8:	f7ff ffac 	bl	800ed34 <__aeabi_lmul>
 800eddc:	9a00      	ldr	r2, [sp, #0]
 800edde:	9b01      	ldr	r3, [sp, #4]
 800ede0:	1a12      	subs	r2, r2, r0
 800ede2:	418b      	sbcs	r3, r1
 800ede4:	9908      	ldr	r1, [sp, #32]
 800ede6:	1c30      	adds	r0, r6, #0
 800ede8:	600a      	str	r2, [r1, #0]
 800edea:	604b      	str	r3, [r1, #4]
 800edec:	1c39      	adds	r1, r7, #0
 800edee:	b003      	add	sp, #12
 800edf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800edf2:	46c0      	nop			; (mov r8, r8)

0800edf4 <__divdi3>:
 800edf4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800edf6:	4644      	mov	r4, r8
 800edf8:	465f      	mov	r7, fp
 800edfa:	4656      	mov	r6, sl
 800edfc:	464d      	mov	r5, r9
 800edfe:	b4f0      	push	{r4, r5, r6, r7}
 800ee00:	1c1c      	adds	r4, r3, #0
 800ee02:	b085      	sub	sp, #20
 800ee04:	2900      	cmp	r1, #0
 800ee06:	da00      	bge.n	800ee0a <__divdi3+0x16>
 800ee08:	e0a9      	b.n	800ef5e <__divdi3+0x16a>
 800ee0a:	1c0f      	adds	r7, r1, #0
 800ee0c:	2100      	movs	r1, #0
 800ee0e:	1c06      	adds	r6, r0, #0
 800ee10:	4688      	mov	r8, r1
 800ee12:	1c10      	adds	r0, r2, #0
 800ee14:	1c19      	adds	r1, r3, #0
 800ee16:	2c00      	cmp	r4, #0
 800ee18:	da00      	bge.n	800ee1c <__divdi3+0x28>
 800ee1a:	e097      	b.n	800ef4c <__divdi3+0x158>
 800ee1c:	1c34      	adds	r4, r6, #0
 800ee1e:	1c3d      	adds	r5, r7, #0
 800ee20:	4682      	mov	sl, r0
 800ee22:	4689      	mov	r9, r1
 800ee24:	42b9      	cmp	r1, r7
 800ee26:	d873      	bhi.n	800ef10 <__divdi3+0x11c>
 800ee28:	d070      	beq.n	800ef0c <__divdi3+0x118>
 800ee2a:	4649      	mov	r1, r9
 800ee2c:	4650      	mov	r0, sl
 800ee2e:	f000 f985 	bl	800f13c <__clzdi2>
 800ee32:	4683      	mov	fp, r0
 800ee34:	1c39      	adds	r1, r7, #0
 800ee36:	1c30      	adds	r0, r6, #0
 800ee38:	f000 f980 	bl	800f13c <__clzdi2>
 800ee3c:	465b      	mov	r3, fp
 800ee3e:	1a18      	subs	r0, r3, r0
 800ee40:	1c03      	adds	r3, r0, #0
 800ee42:	4683      	mov	fp, r0
 800ee44:	3b20      	subs	r3, #32
 800ee46:	469c      	mov	ip, r3
 800ee48:	d500      	bpl.n	800ee4c <__divdi3+0x58>
 800ee4a:	e09c      	b.n	800ef86 <__divdi3+0x192>
 800ee4c:	2300      	movs	r3, #0
 800ee4e:	2200      	movs	r2, #0
 800ee50:	4651      	mov	r1, sl
 800ee52:	9200      	str	r2, [sp, #0]
 800ee54:	9301      	str	r3, [sp, #4]
 800ee56:	4663      	mov	r3, ip
 800ee58:	4099      	lsls	r1, r3
 800ee5a:	9101      	str	r1, [sp, #4]
 800ee5c:	4651      	mov	r1, sl
 800ee5e:	4081      	lsls	r1, r0
 800ee60:	9b01      	ldr	r3, [sp, #4]
 800ee62:	9100      	str	r1, [sp, #0]
 800ee64:	42bb      	cmp	r3, r7
 800ee66:	d900      	bls.n	800ee6a <__divdi3+0x76>
 800ee68:	e083      	b.n	800ef72 <__divdi3+0x17e>
 800ee6a:	d100      	bne.n	800ee6e <__divdi3+0x7a>
 800ee6c:	e07e      	b.n	800ef6c <__divdi3+0x178>
 800ee6e:	9a00      	ldr	r2, [sp, #0]
 800ee70:	9b01      	ldr	r3, [sp, #4]
 800ee72:	1c34      	adds	r4, r6, #0
 800ee74:	1c3d      	adds	r5, r7, #0
 800ee76:	1aa4      	subs	r4, r4, r2
 800ee78:	419d      	sbcs	r5, r3
 800ee7a:	4663      	mov	r3, ip
 800ee7c:	2b00      	cmp	r3, #0
 800ee7e:	da00      	bge.n	800ee82 <__divdi3+0x8e>
 800ee80:	e09a      	b.n	800efb8 <__divdi3+0x1c4>
 800ee82:	2600      	movs	r6, #0
 800ee84:	2700      	movs	r7, #0
 800ee86:	9602      	str	r6, [sp, #8]
 800ee88:	9703      	str	r7, [sp, #12]
 800ee8a:	3601      	adds	r6, #1
 800ee8c:	409e      	lsls	r6, r3
 800ee8e:	9603      	str	r6, [sp, #12]
 800ee90:	2601      	movs	r6, #1
 800ee92:	4086      	lsls	r6, r0
 800ee94:	9602      	str	r6, [sp, #8]
 800ee96:	2800      	cmp	r0, #0
 800ee98:	d100      	bne.n	800ee9c <__divdi3+0xa8>
 800ee9a:	e071      	b.n	800ef80 <__divdi3+0x18c>
 800ee9c:	9900      	ldr	r1, [sp, #0]
 800ee9e:	9a01      	ldr	r2, [sp, #4]
 800eea0:	07d3      	lsls	r3, r2, #31
 800eea2:	4699      	mov	r9, r3
 800eea4:	464b      	mov	r3, r9
 800eea6:	084e      	lsrs	r6, r1, #1
 800eea8:	431e      	orrs	r6, r3
 800eeaa:	0857      	lsrs	r7, r2, #1
 800eeac:	2300      	movs	r3, #0
 800eeae:	2201      	movs	r2, #1
 800eeb0:	e00c      	b.n	800eecc <__divdi3+0xd8>
 800eeb2:	42af      	cmp	r7, r5
 800eeb4:	d101      	bne.n	800eeba <__divdi3+0xc6>
 800eeb6:	42a6      	cmp	r6, r4
 800eeb8:	d80a      	bhi.n	800eed0 <__divdi3+0xdc>
 800eeba:	1ba4      	subs	r4, r4, r6
 800eebc:	41bd      	sbcs	r5, r7
 800eebe:	1924      	adds	r4, r4, r4
 800eec0:	416d      	adcs	r5, r5
 800eec2:	3801      	subs	r0, #1
 800eec4:	18a4      	adds	r4, r4, r2
 800eec6:	415d      	adcs	r5, r3
 800eec8:	2800      	cmp	r0, #0
 800eeca:	d006      	beq.n	800eeda <__divdi3+0xe6>
 800eecc:	42af      	cmp	r7, r5
 800eece:	d9f0      	bls.n	800eeb2 <__divdi3+0xbe>
 800eed0:	3801      	subs	r0, #1
 800eed2:	1924      	adds	r4, r4, r4
 800eed4:	416d      	adcs	r5, r5
 800eed6:	2800      	cmp	r0, #0
 800eed8:	d1f8      	bne.n	800eecc <__divdi3+0xd8>
 800eeda:	2220      	movs	r2, #32
 800eedc:	9e02      	ldr	r6, [sp, #8]
 800eede:	9f03      	ldr	r7, [sp, #12]
 800eee0:	465b      	mov	r3, fp
 800eee2:	4252      	negs	r2, r2
 800eee4:	1936      	adds	r6, r6, r4
 800eee6:	416f      	adcs	r7, r5
 800eee8:	1899      	adds	r1, r3, r2
 800eeea:	d45a      	bmi.n	800efa2 <__divdi3+0x1ae>
 800eeec:	1c28      	adds	r0, r5, #0
 800eeee:	40c8      	lsrs	r0, r1
 800eef0:	1c2c      	adds	r4, r5, #0
 800eef2:	465b      	mov	r3, fp
 800eef4:	40dc      	lsrs	r4, r3
 800eef6:	2900      	cmp	r1, #0
 800eef8:	db68      	blt.n	800efcc <__divdi3+0x1d8>
 800eefa:	1c04      	adds	r4, r0, #0
 800eefc:	408c      	lsls	r4, r1
 800eefe:	1c23      	adds	r3, r4, #0
 800ef00:	4659      	mov	r1, fp
 800ef02:	4088      	lsls	r0, r1
 800ef04:	1c02      	adds	r2, r0, #0
 800ef06:	1ab6      	subs	r6, r6, r2
 800ef08:	419f      	sbcs	r7, r3
 800ef0a:	e003      	b.n	800ef14 <__divdi3+0x120>
 800ef0c:	42b0      	cmp	r0, r6
 800ef0e:	d98c      	bls.n	800ee2a <__divdi3+0x36>
 800ef10:	2600      	movs	r6, #0
 800ef12:	2700      	movs	r7, #0
 800ef14:	4641      	mov	r1, r8
 800ef16:	1e4b      	subs	r3, r1, #1
 800ef18:	4199      	sbcs	r1, r3
 800ef1a:	2300      	movs	r3, #0
 800ef1c:	9100      	str	r1, [sp, #0]
 800ef1e:	9301      	str	r3, [sp, #4]
 800ef20:	9a00      	ldr	r2, [sp, #0]
 800ef22:	9b01      	ldr	r3, [sp, #4]
 800ef24:	2500      	movs	r5, #0
 800ef26:	4254      	negs	r4, r2
 800ef28:	419d      	sbcs	r5, r3
 800ef2a:	1c33      	adds	r3, r6, #0
 800ef2c:	4063      	eors	r3, r4
 800ef2e:	1c18      	adds	r0, r3, #0
 800ef30:	1c3b      	adds	r3, r7, #0
 800ef32:	406b      	eors	r3, r5
 800ef34:	1c19      	adds	r1, r3, #0
 800ef36:	9b00      	ldr	r3, [sp, #0]
 800ef38:	9c01      	ldr	r4, [sp, #4]
 800ef3a:	18c0      	adds	r0, r0, r3
 800ef3c:	4161      	adcs	r1, r4
 800ef3e:	b005      	add	sp, #20
 800ef40:	bc3c      	pop	{r2, r3, r4, r5}
 800ef42:	4690      	mov	r8, r2
 800ef44:	4699      	mov	r9, r3
 800ef46:	46a2      	mov	sl, r4
 800ef48:	46ab      	mov	fp, r5
 800ef4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ef4c:	4643      	mov	r3, r8
 800ef4e:	43db      	mvns	r3, r3
 800ef50:	1c0c      	adds	r4, r1, #0
 800ef52:	4698      	mov	r8, r3
 800ef54:	1c13      	adds	r3, r2, #0
 800ef56:	2100      	movs	r1, #0
 800ef58:	4258      	negs	r0, r3
 800ef5a:	41a1      	sbcs	r1, r4
 800ef5c:	e75e      	b.n	800ee1c <__divdi3+0x28>
 800ef5e:	2700      	movs	r7, #0
 800ef60:	4246      	negs	r6, r0
 800ef62:	418f      	sbcs	r7, r1
 800ef64:	2101      	movs	r1, #1
 800ef66:	4249      	negs	r1, r1
 800ef68:	4688      	mov	r8, r1
 800ef6a:	e752      	b.n	800ee12 <__divdi3+0x1e>
 800ef6c:	42b1      	cmp	r1, r6
 800ef6e:	d800      	bhi.n	800ef72 <__divdi3+0x17e>
 800ef70:	e77d      	b.n	800ee6e <__divdi3+0x7a>
 800ef72:	2600      	movs	r6, #0
 800ef74:	2700      	movs	r7, #0
 800ef76:	9602      	str	r6, [sp, #8]
 800ef78:	9703      	str	r7, [sp, #12]
 800ef7a:	2800      	cmp	r0, #0
 800ef7c:	d000      	beq.n	800ef80 <__divdi3+0x18c>
 800ef7e:	e78d      	b.n	800ee9c <__divdi3+0xa8>
 800ef80:	9e02      	ldr	r6, [sp, #8]
 800ef82:	9f03      	ldr	r7, [sp, #12]
 800ef84:	e7c6      	b.n	800ef14 <__divdi3+0x120>
 800ef86:	2120      	movs	r1, #32
 800ef88:	4653      	mov	r3, sl
 800ef8a:	1a09      	subs	r1, r1, r0
 800ef8c:	40cb      	lsrs	r3, r1
 800ef8e:	2200      	movs	r2, #0
 800ef90:	1c19      	adds	r1, r3, #0
 800ef92:	2300      	movs	r3, #0
 800ef94:	9200      	str	r2, [sp, #0]
 800ef96:	9301      	str	r3, [sp, #4]
 800ef98:	464b      	mov	r3, r9
 800ef9a:	4083      	lsls	r3, r0
 800ef9c:	430b      	orrs	r3, r1
 800ef9e:	9301      	str	r3, [sp, #4]
 800efa0:	e75c      	b.n	800ee5c <__divdi3+0x68>
 800efa2:	465a      	mov	r2, fp
 800efa4:	2320      	movs	r3, #32
 800efa6:	1a9b      	subs	r3, r3, r2
 800efa8:	1c2a      	adds	r2, r5, #0
 800efaa:	409a      	lsls	r2, r3
 800efac:	1c20      	adds	r0, r4, #0
 800efae:	1c13      	adds	r3, r2, #0
 800efb0:	465a      	mov	r2, fp
 800efb2:	40d0      	lsrs	r0, r2
 800efb4:	4318      	orrs	r0, r3
 800efb6:	e79b      	b.n	800eef0 <__divdi3+0xfc>
 800efb8:	2620      	movs	r6, #32
 800efba:	2700      	movs	r7, #0
 800efbc:	1a33      	subs	r3, r6, r0
 800efbe:	2600      	movs	r6, #0
 800efc0:	9602      	str	r6, [sp, #8]
 800efc2:	9703      	str	r7, [sp, #12]
 800efc4:	2701      	movs	r7, #1
 800efc6:	40df      	lsrs	r7, r3
 800efc8:	9703      	str	r7, [sp, #12]
 800efca:	e761      	b.n	800ee90 <__divdi3+0x9c>
 800efcc:	465b      	mov	r3, fp
 800efce:	2120      	movs	r1, #32
 800efd0:	465d      	mov	r5, fp
 800efd2:	1ac9      	subs	r1, r1, r3
 800efd4:	1c03      	adds	r3, r0, #0
 800efd6:	40ac      	lsls	r4, r5
 800efd8:	40cb      	lsrs	r3, r1
 800efda:	1c19      	adds	r1, r3, #0
 800efdc:	1c23      	adds	r3, r4, #0
 800efde:	430b      	orrs	r3, r1
 800efe0:	e78e      	b.n	800ef00 <__divdi3+0x10c>
 800efe2:	46c0      	nop			; (mov r8, r8)

0800efe4 <__udivdi3>:
 800efe4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800efe6:	4645      	mov	r5, r8
 800efe8:	464e      	mov	r6, r9
 800efea:	4657      	mov	r7, sl
 800efec:	b4e0      	push	{r5, r6, r7}
 800efee:	1c04      	adds	r4, r0, #0
 800eff0:	b082      	sub	sp, #8
 800eff2:	1c0d      	adds	r5, r1, #0
 800eff4:	4691      	mov	r9, r2
 800eff6:	4698      	mov	r8, r3
 800eff8:	428b      	cmp	r3, r1
 800effa:	d862      	bhi.n	800f0c2 <__udivdi3+0xde>
 800effc:	d05f      	beq.n	800f0be <__udivdi3+0xda>
 800effe:	4641      	mov	r1, r8
 800f000:	4648      	mov	r0, r9
 800f002:	f000 f89b 	bl	800f13c <__clzdi2>
 800f006:	1c29      	adds	r1, r5, #0
 800f008:	1c06      	adds	r6, r0, #0
 800f00a:	1c20      	adds	r0, r4, #0
 800f00c:	f000 f896 	bl	800f13c <__clzdi2>
 800f010:	2320      	movs	r3, #32
 800f012:	1a31      	subs	r1, r6, r0
 800f014:	425b      	negs	r3, r3
 800f016:	468a      	mov	sl, r1
 800f018:	18c8      	adds	r0, r1, r3
 800f01a:	d465      	bmi.n	800f0e8 <__udivdi3+0x104>
 800f01c:	464b      	mov	r3, r9
 800f01e:	4083      	lsls	r3, r0
 800f020:	1c1f      	adds	r7, r3, #0
 800f022:	464b      	mov	r3, r9
 800f024:	408b      	lsls	r3, r1
 800f026:	1c1e      	adds	r6, r3, #0
 800f028:	42af      	cmp	r7, r5
 800f02a:	d858      	bhi.n	800f0de <__udivdi3+0xfa>
 800f02c:	d055      	beq.n	800f0da <__udivdi3+0xf6>
 800f02e:	1ba4      	subs	r4, r4, r6
 800f030:	41bd      	sbcs	r5, r7
 800f032:	2800      	cmp	r0, #0
 800f034:	da00      	bge.n	800f038 <__udivdi3+0x54>
 800f036:	e077      	b.n	800f128 <__udivdi3+0x144>
 800f038:	2200      	movs	r2, #0
 800f03a:	2300      	movs	r3, #0
 800f03c:	9200      	str	r2, [sp, #0]
 800f03e:	9301      	str	r3, [sp, #4]
 800f040:	3201      	adds	r2, #1
 800f042:	4082      	lsls	r2, r0
 800f044:	9201      	str	r2, [sp, #4]
 800f046:	2301      	movs	r3, #1
 800f048:	408b      	lsls	r3, r1
 800f04a:	9300      	str	r3, [sp, #0]
 800f04c:	2900      	cmp	r1, #0
 800f04e:	d03c      	beq.n	800f0ca <__udivdi3+0xe6>
 800f050:	07fb      	lsls	r3, r7, #31
 800f052:	4698      	mov	r8, r3
 800f054:	4640      	mov	r0, r8
 800f056:	0872      	lsrs	r2, r6, #1
 800f058:	087b      	lsrs	r3, r7, #1
 800f05a:	4302      	orrs	r2, r0
 800f05c:	2601      	movs	r6, #1
 800f05e:	2700      	movs	r7, #0
 800f060:	e00c      	b.n	800f07c <__udivdi3+0x98>
 800f062:	42ab      	cmp	r3, r5
 800f064:	d101      	bne.n	800f06a <__udivdi3+0x86>
 800f066:	42a2      	cmp	r2, r4
 800f068:	d80a      	bhi.n	800f080 <__udivdi3+0x9c>
 800f06a:	1aa4      	subs	r4, r4, r2
 800f06c:	419d      	sbcs	r5, r3
 800f06e:	1924      	adds	r4, r4, r4
 800f070:	416d      	adcs	r5, r5
 800f072:	3901      	subs	r1, #1
 800f074:	19a4      	adds	r4, r4, r6
 800f076:	417d      	adcs	r5, r7
 800f078:	2900      	cmp	r1, #0
 800f07a:	d006      	beq.n	800f08a <__udivdi3+0xa6>
 800f07c:	42ab      	cmp	r3, r5
 800f07e:	d9f0      	bls.n	800f062 <__udivdi3+0x7e>
 800f080:	3901      	subs	r1, #1
 800f082:	1924      	adds	r4, r4, r4
 800f084:	416d      	adcs	r5, r5
 800f086:	2900      	cmp	r1, #0
 800f088:	d1f8      	bne.n	800f07c <__udivdi3+0x98>
 800f08a:	2220      	movs	r2, #32
 800f08c:	9800      	ldr	r0, [sp, #0]
 800f08e:	9901      	ldr	r1, [sp, #4]
 800f090:	4653      	mov	r3, sl
 800f092:	4252      	negs	r2, r2
 800f094:	1900      	adds	r0, r0, r4
 800f096:	4169      	adcs	r1, r5
 800f098:	189e      	adds	r6, r3, r2
 800f09a:	d43a      	bmi.n	800f112 <__udivdi3+0x12e>
 800f09c:	1c2f      	adds	r7, r5, #0
 800f09e:	40f7      	lsrs	r7, r6
 800f0a0:	4653      	mov	r3, sl
 800f0a2:	40dd      	lsrs	r5, r3
 800f0a4:	2e00      	cmp	r6, #0
 800f0a6:	db29      	blt.n	800f0fc <__udivdi3+0x118>
 800f0a8:	1c3c      	adds	r4, r7, #0
 800f0aa:	40b4      	lsls	r4, r6
 800f0ac:	1c23      	adds	r3, r4, #0
 800f0ae:	4654      	mov	r4, sl
 800f0b0:	40a7      	lsls	r7, r4
 800f0b2:	1c3a      	adds	r2, r7, #0
 800f0b4:	1a80      	subs	r0, r0, r2
 800f0b6:	4199      	sbcs	r1, r3
 800f0b8:	9000      	str	r0, [sp, #0]
 800f0ba:	9101      	str	r1, [sp, #4]
 800f0bc:	e005      	b.n	800f0ca <__udivdi3+0xe6>
 800f0be:	4282      	cmp	r2, r0
 800f0c0:	d99d      	bls.n	800effe <__udivdi3+0x1a>
 800f0c2:	2300      	movs	r3, #0
 800f0c4:	2400      	movs	r4, #0
 800f0c6:	9300      	str	r3, [sp, #0]
 800f0c8:	9401      	str	r4, [sp, #4]
 800f0ca:	9800      	ldr	r0, [sp, #0]
 800f0cc:	9901      	ldr	r1, [sp, #4]
 800f0ce:	b002      	add	sp, #8
 800f0d0:	bc1c      	pop	{r2, r3, r4}
 800f0d2:	4690      	mov	r8, r2
 800f0d4:	4699      	mov	r9, r3
 800f0d6:	46a2      	mov	sl, r4
 800f0d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800f0da:	42a3      	cmp	r3, r4
 800f0dc:	d9a7      	bls.n	800f02e <__udivdi3+0x4a>
 800f0de:	2200      	movs	r2, #0
 800f0e0:	2300      	movs	r3, #0
 800f0e2:	9200      	str	r2, [sp, #0]
 800f0e4:	9301      	str	r3, [sp, #4]
 800f0e6:	e7b1      	b.n	800f04c <__udivdi3+0x68>
 800f0e8:	2220      	movs	r2, #32
 800f0ea:	464b      	mov	r3, r9
 800f0ec:	1a52      	subs	r2, r2, r1
 800f0ee:	40d3      	lsrs	r3, r2
 800f0f0:	1c1a      	adds	r2, r3, #0
 800f0f2:	4643      	mov	r3, r8
 800f0f4:	408b      	lsls	r3, r1
 800f0f6:	1c1f      	adds	r7, r3, #0
 800f0f8:	4317      	orrs	r7, r2
 800f0fa:	e792      	b.n	800f022 <__udivdi3+0x3e>
 800f0fc:	4653      	mov	r3, sl
 800f0fe:	2420      	movs	r4, #32
 800f100:	4656      	mov	r6, sl
 800f102:	1ae4      	subs	r4, r4, r3
 800f104:	1c3b      	adds	r3, r7, #0
 800f106:	40b5      	lsls	r5, r6
 800f108:	40e3      	lsrs	r3, r4
 800f10a:	1c1c      	adds	r4, r3, #0
 800f10c:	1c2b      	adds	r3, r5, #0
 800f10e:	4323      	orrs	r3, r4
 800f110:	e7cd      	b.n	800f0ae <__udivdi3+0xca>
 800f112:	4652      	mov	r2, sl
 800f114:	2320      	movs	r3, #32
 800f116:	1a9b      	subs	r3, r3, r2
 800f118:	1c2a      	adds	r2, r5, #0
 800f11a:	409a      	lsls	r2, r3
 800f11c:	1c27      	adds	r7, r4, #0
 800f11e:	1c13      	adds	r3, r2, #0
 800f120:	4652      	mov	r2, sl
 800f122:	40d7      	lsrs	r7, r2
 800f124:	431f      	orrs	r7, r3
 800f126:	e7bb      	b.n	800f0a0 <__udivdi3+0xbc>
 800f128:	2320      	movs	r3, #32
 800f12a:	2200      	movs	r2, #0
 800f12c:	1a58      	subs	r0, r3, r1
 800f12e:	2300      	movs	r3, #0
 800f130:	9200      	str	r2, [sp, #0]
 800f132:	9301      	str	r3, [sp, #4]
 800f134:	3201      	adds	r2, #1
 800f136:	40c2      	lsrs	r2, r0
 800f138:	9201      	str	r2, [sp, #4]
 800f13a:	e784      	b.n	800f046 <__udivdi3+0x62>

0800f13c <__clzdi2>:
 800f13c:	b510      	push	{r4, lr}
 800f13e:	2900      	cmp	r1, #0
 800f140:	d103      	bne.n	800f14a <__clzdi2+0xe>
 800f142:	f000 f807 	bl	800f154 <__clzsi2>
 800f146:	3020      	adds	r0, #32
 800f148:	e002      	b.n	800f150 <__clzdi2+0x14>
 800f14a:	1c08      	adds	r0, r1, #0
 800f14c:	f000 f802 	bl	800f154 <__clzsi2>
 800f150:	bd10      	pop	{r4, pc}
 800f152:	46c0      	nop			; (mov r8, r8)

0800f154 <__clzsi2>:
 800f154:	211c      	movs	r1, #28
 800f156:	2301      	movs	r3, #1
 800f158:	041b      	lsls	r3, r3, #16
 800f15a:	4298      	cmp	r0, r3
 800f15c:	d301      	bcc.n	800f162 <__clzsi2+0xe>
 800f15e:	0c00      	lsrs	r0, r0, #16
 800f160:	3910      	subs	r1, #16
 800f162:	0a1b      	lsrs	r3, r3, #8
 800f164:	4298      	cmp	r0, r3
 800f166:	d301      	bcc.n	800f16c <__clzsi2+0x18>
 800f168:	0a00      	lsrs	r0, r0, #8
 800f16a:	3908      	subs	r1, #8
 800f16c:	091b      	lsrs	r3, r3, #4
 800f16e:	4298      	cmp	r0, r3
 800f170:	d301      	bcc.n	800f176 <__clzsi2+0x22>
 800f172:	0900      	lsrs	r0, r0, #4
 800f174:	3904      	subs	r1, #4
 800f176:	a202      	add	r2, pc, #8	; (adr r2, 800f180 <__clzsi2+0x2c>)
 800f178:	5c10      	ldrb	r0, [r2, r0]
 800f17a:	1840      	adds	r0, r0, r1
 800f17c:	4770      	bx	lr
 800f17e:	46c0      	nop			; (mov r8, r8)
 800f180:	02020304 	.word	0x02020304
 800f184:	01010101 	.word	0x01010101
	...

0800f190 <pidr_pn_bits>:
 800f190:	0e010000 0800f556 0800f564 10000001     ....V...d.......
 800f1a0:	0800f57b 0800f589 10000002 0800f5a8     {...............
 800f1b0:	0800f5b6 10000003 0800f5d2 0800f5e0     ................
 800f1c0:	0e010008 0800f5fd 0800f564 1000000a     ........d.......
 800f1d0:	0800f60b 0800f5b6 1000000b 0800f619     ................
 800f1e0:	0800f627 0e01000c 0800f639 0800f564     '.......9...d...
 800f1f0:	1000000d 0800f647 0800f657 10000490     ....G...W.......
 800f200:	0800f668 0800f677 100004c7 0800f696     h...w...........
 800f210:	0800f6a4 10000906 0800f6c7 0800f6d5     ................
 800f220:	10000907 0800f6e5 0800f6f3 10000908     ................
 800f230:	0800f702 0800f711 10000910 0800f720     ............ ...
 800f240:	0800f657 10000912 0800f72f 0800f73e     W......./...>...
 800f250:	10000913 0800f75a 0800f768 10000914     ....Z...h.......
 800f260:	0800f78a 0800f798 10000917 0800f7ad     ................
 800f270:	0800f7bb 10000920 0800f647 0800f657     .... ...G...W...
 800f280:	10000921 0800f7d1 0800f657 10000922     !.......W..."...
 800f290:	0800f7df 0800f6d5 10000923 0800f7ed     ........#.......
 800f2a0:	0800f73e 10000924 0800f7fc 0800f657     >...$.......W...
 800f2b0:	10000925 0800f80a 0800f657 10000930     %.......W...0...
 800f2c0:	0800f818 0800f657 10000941 0800f826     ....W...A...&...
 800f2d0:	0800f73e 10000950 0800f83a 0800f84e     >...P...:...N...
 800f2e0:	10000955 0800f83a 0800f871 1000095f     U...:...q..._...
 800f2f0:	0800f894 0800f8a3 10000961 0800f8bd     ........a.......
 800f300:	0800f8cb 10000962 0800f8e5 0800f8f3     ....b...........
 800f310:	100009a0 0800f90c 0800f91a 100009a1     ................
 800f320:	0800f938 0800f73e 100009a5 0800f947     8...>.......G...
 800f330:	0800f657 100009a7 0800f955 0800f963     W.......U...c...
 800f340:	100009af 0800f97e 0800f963 09020c05     ....~...c.......
 800f350:	0800f98d 0800f99d 09020c07 0800f9aa     ................
 800f360:	0800f99d 09020c08 0800f9ba 0800f99d     ................
 800f370:	09020c09 0800f9ca 0800f99d 10000c0f     ................
 800f380:	0800f9da 0800f99d 10000c14 0800f9eb     ................
 800f390:	0800f99d 10030fff 0800f9fb 0800f9fb     ................

0800f3a0 <cidc_debug_strings>:
 800f3a0:	0800f9ff 0800fa1e 080121a7 080121a7     .........!...!..
 800f3b0:	080121a7 080121a7 080121a7 080121a7     .!...!...!...!..
 800f3c0:	080121a7 0800fa28 080121a7 0800fa38     .!..(....!..8...
 800f3d0:	080121a7 0800fa4e 0800fa77 0800fa8c     .!..N...w.......
 800f3e0:	0800faa1 6c257830 30203a78 786c2578     ....0x%lx: 0x%lx
 800f3f0:	202d3c20 73656f64 746f6e20 74616d20      <- does not mat
 800f400:	70206863 6d616572 20656c62 25783028     ch preamble (0x%
 800f410:	000a2958 6c257830 30203a78 6c6c2578     X)..0x%lx: 0x%ll
 800f420:	2d3c2078 656f6420 6f6e2073 616d2074     x <- does not ma
 800f430:	20686374 204d5241 2d50454a 0a363031     tch ARM JEP-106.
 800f440:	25783000 203a786c 2d207325 20732520     .0x%lx: %s - %s 
 800f450:	000a7325 4e524157 3a474e49 73252220     %s..WARNING: "%s
 800f460:	6d212022 68637461 70786520 65746365     " !match expecte
 800f470:	25222064 000a2273 63203e2d 6574726f     d "%s"..-> corte
 800f480:	705f6d78 65626f72 203e2d00 74726f63     xm_probe.-> cort
 800f490:	5f617865 626f7270 78300065 3a786c25     exa_probe.0x%lx:
 800f4a0:	20732520 6e55202d 776f6e6b 5028206e      %s - Unknown (P
 800f4b0:	20524449 7830203d 786c6c25 41000a29     IDR = 0x%llx)..A
 800f4c0:	72742050 61736e61 6f697463 6e69206e     P transaction in
 800f4d0:	6f727020 73657267 20202e73 67726154      progress.  Targ
 800f4e0:	6d207465 6e207961 6220746f 73752065     et may not be us
 800f4f0:	656c6261 4120002e 33252050 49203a64     able.. AP %3d: I
 800f500:	253d5244 786c3830 47464320 3830253d     DR=%08lx CFG=%08
 800f510:	4220786c 3d455341 6c383025 53432078     lx BASE=%08lx CS
 800f520:	30253d57 0a786c38 20504400 20746f6e     W=%08lx..DP not 
 800f530:	70736572 69646e6f 2021676e 79725420     responding!  Try
 800f540:	20676e69 726f6261 65732074 6e657571     ing abort sequen
 800f550:	2e2e6563 6f43002e 78657472 20334d2d     ce....Cortex-M3 
 800f560:	00534353 73795328 206d6574 746e6f43     SCS.(System Cont
 800f570:	206c6f72 63617053 43002965 6574726f     rol Space).Corte
 800f580:	334d2d78 4d544920 6e492800 75727473     x-M3 ITM.(Instru
 800f590:	746e656d 6f697461 7254206e 20656361     mentation Trace 
 800f5a0:	75646f4d 0029656c 74726f43 4d2d7865     Module).Cortex-M
 800f5b0:	57442033 44280054 20617461 63746157     3 DWT.(Data Watc
 800f5c0:	696f7068 6120746e 5420646e 65636172     hpoint and Trace
 800f5d0:	6f430029 78657472 20334d2d 00504246     ).Cortex-M3 FBP.
 800f5e0:	616c4628 50206873 68637461 646e6120     (Flash Patch and
 800f5f0:	65724220 6f706b61 29746e69 726f4300      Breakpoint).Cor
 800f600:	2d786574 5320304d 43005343 6574726f     tex-M0 SCS.Corte
 800f610:	304d2d78 54574420 726f4300 2d786574     x-M0 DWT.Cortex-
 800f620:	4220304d 28005550 61657242 696f706b     M0 BPU.(Breakpoi
 800f630:	5520746e 2974696e 726f4300 2d786574     nt Unit).Cortex-
 800f640:	5320344d 43005343 5365726f 74686769     M4 SCS.CoreSight
 800f650:	4d544520 28003131 65626d45 64656464      ETM11.(Embedded
 800f660:	61725420 00296563 74726f43 412d7865      Trace).Cortex-A
 800f670:	47203531 28004349 656e6547 20636972     15 GIC.(Generic 
 800f680:	65746e49 70757272 6f432074 6f72746e     Interrupt Contro
 800f690:	72656c6c 6f430029 78657472 20374d2d     ller).Cortex-M7 
 800f6a0:	00425050 69725028 65746176 72655020     PPB.(Private Per
 800f6b0:	65687069 206c6172 20737542 204d4f52     ipheral Bus ROM 
 800f6c0:	6c626154 43002965 5365726f 74686769     Table).CoreSight
 800f6d0:	49544320 72432800 2073736f 67697254      CTI.(Cross Trig
 800f6e0:	29726567 726f4300 67695365 45207468     ger).CoreSight E
 800f6f0:	28004254 63617254 75422065 72656666     TB.(Trace Buffer
 800f700:	6f430029 69536572 20746867 46545343     ).CoreSight CSTF
 800f710:	72542800 20656361 6e6e7546 00296c65     .(Trace Funnel).
 800f720:	65726f43 68676953 54452074 4300394d     CoreSight ETM9.C
 800f730:	5365726f 74686769 49505420 54280055     oreSight TPIU.(T
 800f740:	65636172 726f5020 6e492074 66726574     race Port Interf
 800f750:	20656361 74696e55 6f430029 69536572     ace Unit).CoreSi
 800f760:	20746867 004d5449 736e4928 6d757274     ght ITM.(Instrum
 800f770:	61746e65 6e6f6974 61725420 4d206563     entation Trace M
 800f780:	6f726361 6c6c6563 6f430029 69536572     acrocell).CoreSi
 800f790:	20746867 004f5753 6e695328 20656c67     ght SWO.(Single 
 800f7a0:	65726957 74754f20 29747570 726f4300     Wire Output).Cor
 800f7b0:	67695365 48207468 28004d54 20424841     eSight HTM.(AHB 
 800f7c0:	63617254 614d2065 636f7263 296c6c65     Trace Macrocell)
 800f7d0:	726f4300 2d786574 45203841 43004d54     .Cortex-A8 ETM.C
 800f7e0:	6574726f 38412d78 49544320 726f4300     ortex-A8 CTI.Cor
 800f7f0:	2d786574 5420334d 00554950 74726f43     tex-M3 TPIU.Cort
 800f800:	4d2d7865 54452033 6f43004d 78657472     ex-M3 ETM.Cortex
 800f810:	20344d2d 004d5445 74726f43 522d7865     -M4 ETM.Cortex-R
 800f820:	54452034 6f43004d 69536572 20746867     4 ETM.CoreSight 
 800f830:	55495054 74694c2d 6f430065 69536572     TPIU-Lite.CoreSi
 800f840:	20746867 706d6f43 6e656e6f 75280074     ght Component.(u
 800f850:	6564696e 6669746e 20646569 74726f43     nidentified Cort
 800f860:	412d7865 6f632039 6e6f706d 29746e65     ex-A9 component)
 800f870:	6e752800 6e656469 69666974 43206465     .(unidentified C
 800f880:	6574726f 35412d78 6d6f6320 656e6f70     ortex-A5 compone
 800f890:	0029746e 74726f43 412d7865 50203531     nt).Cortex-A15 P
 800f8a0:	28004d54 676f7250 206d6172 63617254     TM.(Program Trac
 800f8b0:	614d2065 636f7263 296c6c65 726f4300     e Macrocell).Cor
 800f8c0:	67695365 54207468 2800434d 63617254     eSight TMC.(Trac
 800f8d0:	654d2065 79726f6d 6e6f4320 6c6f7274     e Memory Control
 800f8e0:	2972656c 726f4300 67695365 53207468     ler).CoreSight S
 800f8f0:	28004d54 74737953 54206d65 65636172     TM.(System Trace
 800f900:	63614d20 65636f72 00296c6c 65726f43      Macrocell).Core
 800f910:	68676953 4d502074 50280055 6f667265     Sight PMU.(Perfo
 800f920:	6e616d72 4d206563 74696e6f 6e69726f     rmance Monitorin
 800f930:	6e552067 00297469 74726f43 4d2d7865     g Unit).Cortex-M
 800f940:	50542034 43005549 6574726f 35412d78     4 TPIU.Cortex-A5
 800f950:	4d544520 726f4300 2d786574 50203741      ETM.Cortex-A7 P
 800f960:	2800554d 66726550 616d726f 2065636e     MU.(Performance 
 800f970:	696e6f4d 20726f74 74696e55 6f430029     Monitor Unit).Co
 800f980:	78657472 3531412d 554d5020 726f4300     rtex-A15 PMU.Cor
 800f990:	2d786574 44203541 67756265 65442800     tex-A5 Debug.(De
 800f9a0:	20677562 74696e55 6f430029 78657472     bug Unit).Cortex
 800f9b0:	2037412d 75626544 6f430067 78657472     -A7 Debug.Cortex
 800f9c0:	2038412d 75626544 6f430067 78657472     -A8 Debug.Cortex
 800f9d0:	2039412d 75626544 6f430067 78657472     -A9 Debug.Cortex
 800f9e0:	3531412d 62654420 43006775 6574726f     -A15 Debug.Corte
 800f9f0:	34522d78 62654420 65006775 4700646e     x-R4 Debug.end.G
 800fa00:	72656e65 76206369 66697265 74616369     eneric verificat
 800fa10:	206e6f69 706d6f63 6e656e6f 4f520074     ion component.RO
 800fa20:	6154204d 00656c62 75626544 6f632067     M Table.Debug co
 800fa30:	6e6f706d 00746e65 69726550 72656870     mponent.Peripher
 800fa40:	54206c61 20747365 636f6c42 704f006b     al Test Block.Op
 800fa50:	6f6d6974 44204544 20617461 69676e45     timoDE Data Engi
 800fa60:	5320656e 79536275 6d657473 6d6f6320     ne SubSystem com
 800fa70:	656e6f70 4700746e 72656e65 49206369     ponent.Generic I
 800fa80:	6f632050 6e6f706d 00746e65 6d697250     P component.Prim
 800fa90:	6c654365 6570206c 68706972 6c617265     eCell peripheral
 800faa0:	6b6e5500 6e776f6e 6d6f6320 656e6f70     .Unknown compone
 800fab0:	6320746e 7373616c 41544a00 50442d47     nt class.JTAG-DP
 800fac0:	4b434120 6d697420 74756f65 41544a00      ACK timeout.JTA
 800fad0:	50442d47 766e6920 64696c61 4b434120     G-DP invalid ACK
 800fae0:	44575300 61502050 79746972 72726520     .SWDP Parity err
 800faf0:	5300726f 20504457 61766e69 2064696c     or.SWDP invalid 
 800fb00:	004b4341 50445753 4b434120 6d697420     ACK.SWDP ACK tim
 800fb10:	74756f65 00000000                       eout....

0800fb18 <cmd_list>:
 800fb18:	0800fd9a 08000ab3 0800fda2 0800fdc0     ................
 800fb28:	08000ced 0800fdc5 0800fde7 08000be9     ................
 800fb38:	0800fdf1 0800fe0d 08000b39 0800fe17     ........9.......
 800fb48:	0800fe48 08000ad9 0800fe2e 0800fe50     H...........P...
 800fb58:	08000a81 0800fe56 0800fe72 08000d2d     ....V...r...-...
 800fb68:	0800fe7f 0800feae 08000a9d 0800feb8     ................
 800fb78:	0800fef1 08000a41 0800fefb 00000000     ....A...........
	...
 800fb90:	62616e65 0064656c 61736964 64656c62     enabled.disabled
 800fba0:	616e6500 00656c62 75626544 6f6d2067     .enable.Debug mo
 800fbb0:	69206564 73252073 6c42000a 206b6361     de is %s..Black 
 800fbc0:	6967614d 72502063 2065626f 72694628     Magic Probe (Fir
 800fbd0:	7261776d 31762065 722d362e 332d3063     mware v1.6-rc0-3
 800fbe0:	672d3831 30626663 2d323139 74726964     18-gcfb0912-dirt
 800fbf0:	28202979 64726148 65726177 72655620     y) (Hardware Ver
 800fc00:	6e6f6973 29642520 6f43000a 69727970     sion %d)..Copyri
 800fc10:	20746867 20294328 35313032 6c422020     ght (C) 2015  Bl
 800fc20:	206b6361 65687053 54206572 6e686365     ack Sphere Techn
 800fc30:	676f6c6f 20736569 2e64744c 694c000a     ologies Ltd...Li
 800fc40:	736e6563 50472065 2b33764c 4e47203a     cense GPLv3+: GN
 800fc50:	50472055 6576204c 6f697372 2033206e     U GPL version 3 
 800fc60:	6c20726f 72657461 74683c20 2f3a7074     or later <http:/
 800fc70:	756e672f 67726f2e 63696c2f 65736e65     /gnu.org/license
 800fc80:	70672f73 74682e6c 0a3e6c6d 7641000a     s/gpl.html>...Av
 800fc90:	616c6961 20656c62 67726154 3a737465     ailable Targets:
 800fca0:	6f4e000a 7441202e 72442074 72657669     ..No. Att Driver
 800fcb0:	6f4e000a 61737520 20656c62 67726174     ..No usable targ
 800fcc0:	20737465 6e756f66 000a2e64 20643225     ets found...%2d 
 800fcd0:	63252020 73252020 6154000a 74656772       %c  %s..Target
 800fce0:	6c6f7620 65676174 7325203a 6954000a      voltage: %s..Ti
 800fcf0:	756f656d 75642074 676e6972 61637320     meout during sca
 800fd00:	49202e6e 61742073 74656772 75747320     n. Is target stu
 800fd10:	69206b63 4657206e 000a3f49 65637845     ck in WFI?..Exce
 800fd20:	6f697470 25203a6e 53000a73 50442d57     ption: %s..SW-DP
 800fd30:	61637320 6166206e 64656c69 4a000a21      scan failed!..J
 800fd40:	20474154 69766564 73206563 206e6163     TAG device scan 
 800fd50:	6c696166 0a216465 6e654700 6c617265     failed!..General
 800fd60:	6d6f6320 646e616d 000a3a73 20732509      commands:...%s 
 800fd70:	25202d2d 41000a73 72657373 52532074     -- %s..Assert SR
 800fd80:	64205453 6e697275 6f632067 63656e6e     ST during connec
 800fd90:	25203a74 20000a73 65760009 6f697372     t: %s.. ..versio
 800fda0:	6944006e 616c7073 69662079 61776d72     n.Display firmwa
 800fdb0:	76206572 69737265 69206e6f 006f666e     re version info.
 800fdc0:	706c6568 73694400 79616c70 6c656820     help.Display hel
 800fdd0:	6f662070 6f6d2072 6f74696e 6f632072     p for monitor co
 800fde0:	6e616d6d 6a007364 5f676174 6e616373     mmands.jtag_scan
 800fdf0:	61635300 544a206e 63204741 6e696168     .Scan JTAG chain
 800fe00:	726f6620 76656420 73656369 64777300      for devices.swd
 800fe10:	63735f70 53006e61 206e6163 442d5753     p_scan.Scan SW-D
 800fe20:	6f662050 65642072 65636976 69440073     P for devices.Di
 800fe30:	616c7073 696c2079 6f207473 76612066     splay list of av
 800fe40:	616c6961 20656c62 67726174 00737465     ailable targets.
 800fe50:	73726f6d 69440065 616c7073 6f6d2079     morse.Display mo
 800fe60:	20657372 6f727265 656d2072 67617373     rse error messag
 800fe70:	6f630065 63656e6e 72735f74 43007473     e.connect_srst.C
 800fe80:	69666e6f 65727567 6e6f6320 7463656e     onfigure connect
 800fe90:	646e7520 53207265 3a545352 6e652820      under SRST: (en
 800fea0:	656c6261 7369647c 656c6261 61680029     able|disable).ha
 800feb0:	735f6472 00747372 63726f46 20612065     rd_srst.Force a 
 800fec0:	736c7570 6e6f2065 65687420 72616820     pulse on the har
 800fed0:	52532064 6c205453 20656e69 6964202d     d SRST line - di
 800fee0:	6e6f6373 7463656e 61742073 74656772     sconnects target
 800fef0:	62656400 625f6775 4f00706d 75707475     .debug_bmp.Outpu
 800ff00:	4d422074 64222050 67756265 74732022     t BMP "debug" st
 800ff10:	676e6972 6f742073 65687420 63657320     rings to the sec
 800ff20:	20646e6f 6d6f6376 6528203a 6c62616e     ond vcom: (enabl
 800ff30:	69647c65 6c626173 63002965                       e|disable).

0800ff3b <__func__.6696>:
 800ff3b:	74726f63 5f617865 746c6168 7365725f     cortexa_halt_res
 800ff4b:	00656d75                                ume.

0800ff4f <__func__.6680>:
 800ff4f:	74726f63 5f617865 746c6168 6c6f705f     cortexa_halt_pol
 800ff5f:	6176006c                                         l.

0800ff61 <__func__.6509>:
 800ff61:	745f6176 61705f6f 783f3c00                       va_to_pa.

0800ff6a <tdesc_cortex_a>:
 800ff6a:	6d783f3c 6576206c 6f697372 31223d6e     <?xml version="1
 800ff7a:	3f22302e 44213c3e 5954434f 66204550     .0"?><!DOCTYPE f
 800ff8a:	75746165 53206572 45545359 6722204d     eature SYSTEM "g
 800ff9a:	742d6264 65677261 74642e74 3c3e2264     db-target.dtd"><
 800ffaa:	67726174 203e7465 72613c20 74696863     target>  <archit
 800ffba:	75746365 613e6572 2f3c6d72 68637261     ecture>arm</arch
 800ffca:	63657469 65727574 3c20203e 74616566     itecture>  <feat
 800ffda:	20657275 656d616e 726f223d 6e672e67     ure name="org.gn
 800ffea:	64672e75 72612e62 6f632e6d 3e226572     u.gdb.arm.core">
 800fffa:	20202020 6765723c 6d616e20 72223d65         <reg name="r
 801000a:	62202230 69737469 223d657a 2f223233     0" bitsize="32"/
 801001a:	2020203e 65723c20 616e2067 223d656d     >    <reg name="
 801002a:	20223172 73746962 3d657a69 22323322     r1" bitsize="32"
 801003a:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 801004a:	22327222 74696220 657a6973 3233223d     "r2" bitsize="32
 801005a:	203e2f22 3c202020 20676572 656d616e     "/>    <reg name
 801006a:	3372223d 69622022 7a697374 33223d65     ="r3" bitsize="3
 801007a:	3e2f2232 20202020 6765723c 6d616e20     2"/>    <reg nam
 801008a:	72223d65 62202234 69737469 223d657a     e="r4" bitsize="
 801009a:	2f223233 2020203e 65723c20 616e2067     32"/>    <reg na
 80100aa:	223d656d 20223572 73746962 3d657a69     me="r5" bitsize=
 80100ba:	22323322 20203e2f 723c2020 6e206765     "32"/>    <reg n
 80100ca:	3d656d61 22367222 74696220 657a6973     ame="r6" bitsize
 80100da:	3233223d 203e2f22 3c202020 20676572     ="32"/>    <reg 
 80100ea:	656d616e 3772223d 69622022 7a697374     name="r7" bitsiz
 80100fa:	33223d65 3e2f2232 20202020 6765723c     e="32"/>    <reg
 801010a:	6d616e20 72223d65 62202238 69737469      name="r8" bitsi
 801011a:	223d657a 2f223233 2020203e 65723c20     ze="32"/>    <re
 801012a:	616e2067 223d656d 20223972 73746962     g name="r9" bits
 801013a:	3d657a69 22323322 20203e2f 723c2020     ize="32"/>    <r
 801014a:	6e206765 3d656d61 30317222 69622022     eg name="r10" bi
 801015a:	7a697374 33223d65 3e2f2232 20202020     tsize="32"/>    
 801016a:	6765723c 6d616e20 72223d65 20223131     <reg name="r11" 
 801017a:	73746962 3d657a69 22323322 20203e2f     bitsize="32"/>  
 801018a:	723c2020 6e206765 3d656d61 32317222       <reg name="r12
 801019a:	69622022 7a697374 33223d65 3e2f2232     " bitsize="32"/>
 80101aa:	20202020 6765723c 6d616e20 73223d65         <reg name="s
 80101ba:	62202270 69737469 223d657a 20223233     p" bitsize="32" 
 80101ca:	65707974 6164223d 705f6174 2f227274     type="data_ptr"/
 80101da:	2020203e 65723c20 616e2067 223d656d     >    <reg name="
 80101ea:	2022726c 73746962 3d657a69 22323322     lr" bitsize="32"
 80101fa:	70797420 63223d65 5f65646f 22727470      type="code_ptr"
 801020a:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 801021a:	22637022 74696220 657a6973 3233223d     "pc" bitsize="32
 801022a:	79742022 223d6570 65646f63 7274705f     " type="code_ptr
 801023a:	203e2f22 3c202020 20676572 656d616e     "/>    <reg name
 801024a:	7063223d 20227273 73746962 3d657a69     ="cpsr" bitsize=
 801025a:	22323322 20203e2f 65662f3c 72757461     "32"/>  </featur
 801026a:	20203e65 6165663c 65727574 6d616e20     e>  <feature nam
 801027a:	6f223d65 672e6772 672e756e 612e6264     e="org.gnu.gdb.a
 801028a:	762e6d72 3e227066 20202020 6765723c     rm.vfp">    <reg
 801029a:	6d616e20 66223d65 72637370 69622022      name="fpscr" bi
 80102aa:	7a697374 33223d65 3e2f2232 20202020     tsize="32"/>    
 80102ba:	6765723c 6d616e20 64223d65 62202230     <reg name="d0" b
 80102ca:	69737469 223d657a 20223436 65707974     itsize="64" type
 80102da:	6c66223d 2274616f 20203e2f 723c2020     ="float"/>    <r
 80102ea:	6e206765 3d656d61 22316422 74696220     eg name="d1" bit
 80102fa:	657a6973 3436223d 79742022 223d6570     size="64" type="
 801030a:	616f6c66 3e2f2274 20202020 6765723c     float"/>    <reg
 801031a:	6d616e20 64223d65 62202232 69737469      name="d2" bitsi
 801032a:	223d657a 20223436 65707974 6c66223d     ze="64" type="fl
 801033a:	2274616f 20203e2f 723c2020 6e206765     oat"/>    <reg n
 801034a:	3d656d61 22336422 74696220 657a6973     ame="d3" bitsize
 801035a:	3436223d 79742022 223d6570 616f6c66     ="64" type="floa
 801036a:	3e2f2274 20202020 6765723c 6d616e20     t"/>    <reg nam
 801037a:	64223d65 62202234 69737469 223d657a     e="d4" bitsize="
 801038a:	20223436 65707974 6c66223d 2274616f     64" type="float"
 801039a:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 80103aa:	22356422 74696220 657a6973 3436223d     "d5" bitsize="64
 80103ba:	79742022 223d6570 616f6c66 3e2f2274     " type="float"/>
 80103ca:	20202020 6765723c 6d616e20 64223d65         <reg name="d
 80103da:	62202236 69737469 223d657a 20223436     6" bitsize="64" 
 80103ea:	65707974 6c66223d 2274616f 20203e2f     type="float"/>  
 80103fa:	723c2020 6e206765 3d656d61 22376422       <reg name="d7"
 801040a:	74696220 657a6973 3436223d 79742022      bitsize="64" ty
 801041a:	223d6570 616f6c66 3e2f2274 20202020     pe="float"/>    
 801042a:	6765723c 6d616e20 64223d65 62202238     <reg name="d8" b
 801043a:	69737469 223d657a 20223436 65707974     itsize="64" type
 801044a:	6c66223d 2274616f 20203e2f 723c2020     ="float"/>    <r
 801045a:	6e206765 3d656d61 22396422 74696220     eg name="d9" bit
 801046a:	657a6973 3436223d 79742022 223d6570     size="64" type="
 801047a:	616f6c66 3e2f2274 20202020 6765723c     float"/>    <reg
 801048a:	6d616e20 64223d65 20223031 73746962      name="d10" bits
 801049a:	3d657a69 22343622 70797420 66223d65     ize="64" type="f
 80104aa:	74616f6c 203e2f22 3c202020 20676572     loat"/>    <reg 
 80104ba:	656d616e 3164223d 62202231 69737469     name="d11" bitsi
 80104ca:	223d657a 20223436 65707974 6c66223d     ze="64" type="fl
 80104da:	2274616f 20203e2f 723c2020 6e206765     oat"/>    <reg n
 80104ea:	3d656d61 32316422 69622022 7a697374     ame="d12" bitsiz
 80104fa:	36223d65 74202234 3d657079 6f6c6622     e="64" type="flo
 801050a:	2f227461 2020203e 65723c20 616e2067     at"/>    <reg na
 801051a:	223d656d 22333164 74696220 657a6973     me="d13" bitsize
 801052a:	3436223d 79742022 223d6570 616f6c66     ="64" type="floa
 801053a:	3e2f2274 20202020 6765723c 6d616e20     t"/>    <reg nam
 801054a:	64223d65 20223431 73746962 3d657a69     e="d14" bitsize=
 801055a:	22343622 70797420 66223d65 74616f6c     "64" type="float
 801056a:	203e2f22 3c202020 20676572 656d616e     "/>    <reg name
 801057a:	3164223d 62202235 69737469 223d657a     ="d15" bitsize="
 801058a:	20223436 65707974 6c66223d 2274616f     64" type="float"
 801059a:	20203e2f 65662f3c 72757461 2f3c3e65     />  </feature></
 80105aa:	67726174 003e7465 656d6954 2074756f     target>.Timeout 
 80105ba:	646e6573 20676e69 65746e69 70757272     sending interrup
 80105ca:	69202c74 61742073 74656772 206e6920     t, is target in 
 80105da:	3f494657 7473000a 30207065 38302578     WFI?..step 0x%08
 80105ea:	2020786c 0a786c25 3a732500 47424420     lx  %lx..%s: DBG
 80105fa:	52435344 30203d20 38302578 000a786c     DSCR = 0x%08lx..
 801060a:	203a7325 3d204156 25783020 786c3830     %s: VA = 0x%08lx
 801061a:	4150202c 203d2052 30257830 2c786c38     , PAR = 0x%08lx,
 801062a:	20415020 7830203d 6c383025 00000a58      PA = 0x%08lX...
 801063a:	12e90000 00000801 00000000 00000000     ................
 801064a:	12ef0000 12f20801 12f70801 12fb0801     ................
 801065a:	13000801 13040801 13080801 00000801     ................
 801066a:	00020000 06010000 06020000 02090000     ................
 801067a:	020a0000 00000000                                ......

08010680 <CSWTCH.30>:
 8010680:	00000000 00000001 ffffffff 00000003     ................

08010690 <regnum_cortex_m>:
 8010690:	00000000 00000001 00000002 00000003     ................
 80106a0:	00000004 00000005 00000006 00000007     ................
 80106b0:	00000008 00000009 0000000a 0000000b     ................
 80106c0:	0000000c 0000000d 0000000e 0000000f     ................
 80106d0:	00000010 00000011 00000012 00000014     ................

080106e0 <regnum_cortex_mf>:
 80106e0:	00000021 00000040 00000041 00000042     !...@...A...B...
 80106f0:	00000043 00000044 00000045 00000046     C...D...E...F...
 8010700:	00000047 00000048 00000049 0000004a     G...H...I...J...
 8010710:	0000004b 0000004c 0000004d 0000004e     K...L...M...N...
 8010720:	0000004f 00000050 00000051 00000052     O...P...Q...R...
 8010730:	00000053 00000054 00000055 00000056     S...T...U...V...
 8010740:	00000057 00000058 00000059 0000005a     W...X...Y...Z...
 8010750:	0000005b 0000005c 0000005d 0000005e     [...\...]...^...
 8010760:	0000005f                                _...

08010764 <tdesc_cortex_m>:
 8010764:	6d783f3c 6576206c 6f697372 31223d6e     <?xml version="1
 8010774:	3f22302e 44213c3e 5954434f 74204550     .0"?><!DOCTYPE t
 8010784:	65677261 59532074 4d455453 64672220     arget SYSTEM "gd
 8010794:	61742d62 74656772 6474642e 743c3e22     b-target.dtd"><t
 80107a4:	65677261 20203e74 6372613c 65746968     arget>  <archite
 80107b4:	72757463 72613e65 612f3c6d 69686372     cture>arm</archi
 80107c4:	74636574 3e657275 663c2020 75746165     tecture>  <featu
 80107d4:	6e206572 3d656d61 67726f22 756e672e     re name="org.gnu
 80107e4:	6264672e 6d72612e 702d6d2e 69666f72     .gdb.arm.m-profi
 80107f4:	3e22656c 20202020 6765723c 6d616e20     le">    <reg nam
 8010804:	72223d65 62202230 69737469 223d657a     e="r0" bitsize="
 8010814:	2f223233 2020203e 65723c20 616e2067     32"/>    <reg na
 8010824:	223d656d 20223172 73746962 3d657a69     me="r1" bitsize=
 8010834:	22323322 20203e2f 723c2020 6e206765     "32"/>    <reg n
 8010844:	3d656d61 22327222 74696220 657a6973     ame="r2" bitsize
 8010854:	3233223d 203e2f22 3c202020 20676572     ="32"/>    <reg 
 8010864:	656d616e 3372223d 69622022 7a697374     name="r3" bitsiz
 8010874:	33223d65 3e2f2232 20202020 6765723c     e="32"/>    <reg
 8010884:	6d616e20 72223d65 62202234 69737469      name="r4" bitsi
 8010894:	223d657a 2f223233 2020203e 65723c20     ze="32"/>    <re
 80108a4:	616e2067 223d656d 20223572 73746962     g name="r5" bits
 80108b4:	3d657a69 22323322 20203e2f 723c2020     ize="32"/>    <r
 80108c4:	6e206765 3d656d61 22367222 74696220     eg name="r6" bit
 80108d4:	657a6973 3233223d 203e2f22 3c202020     size="32"/>    <
 80108e4:	20676572 656d616e 3772223d 69622022     reg name="r7" bi
 80108f4:	7a697374 33223d65 3e2f2232 20202020     tsize="32"/>    
 8010904:	6765723c 6d616e20 72223d65 62202238     <reg name="r8" b
 8010914:	69737469 223d657a 2f223233 2020203e     itsize="32"/>   
 8010924:	65723c20 616e2067 223d656d 20223972      <reg name="r9" 
 8010934:	73746962 3d657a69 22323322 20203e2f     bitsize="32"/>  
 8010944:	723c2020 6e206765 3d656d61 30317222       <reg name="r10
 8010954:	69622022 7a697374 33223d65 3e2f2232     " bitsize="32"/>
 8010964:	20202020 6765723c 6d616e20 72223d65         <reg name="r
 8010974:	20223131 73746962 3d657a69 22323322     11" bitsize="32"
 8010984:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 8010994:	32317222 69622022 7a697374 33223d65     "r12" bitsize="3
 80109a4:	3e2f2232 20202020 6765723c 6d616e20     2"/>    <reg nam
 80109b4:	73223d65 62202270 69737469 223d657a     e="sp" bitsize="
 80109c4:	20223233 65707974 6164223d 705f6174     32" type="data_p
 80109d4:	2f227274 2020203e 65723c20 616e2067     tr"/>    <reg na
 80109e4:	223d656d 2022726c 73746962 3d657a69     me="lr" bitsize=
 80109f4:	22323322 70797420 63223d65 5f65646f     "32" type="code_
 8010a04:	22727470 20203e2f 723c2020 6e206765     ptr"/>    <reg n
 8010a14:	3d656d61 22637022 74696220 657a6973     ame="pc" bitsize
 8010a24:	3233223d 79742022 223d6570 65646f63     ="32" type="code
 8010a34:	7274705f 203e2f22 3c202020 20676572     _ptr"/>    <reg 
 8010a44:	656d616e 7078223d 20227273 73746962     name="xpsr" bits
 8010a54:	3d657a69 22323322 20203e2f 723c2020     ize="32"/>    <r
 8010a64:	6e206765 3d656d61 70736d22 69622022     eg name="msp" bi
 8010a74:	7a697374 33223d65 73202232 2d657661     tsize="32" save-
 8010a84:	74736572 3d65726f 226f6e22 70797420     restore="no" typ
 8010a94:	64223d65 5f617461 22727470 20203e2f     e="data_ptr"/>  
 8010aa4:	723c2020 6e206765 3d656d61 70737022       <reg name="psp
 8010ab4:	69622022 7a697374 33223d65 73202232     " bitsize="32" s
 8010ac4:	2d657661 74736572 3d65726f 226f6e22     ave-restore="no"
 8010ad4:	70797420 64223d65 5f617461 22727470      type="data_ptr"
 8010ae4:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 8010af4:	65707322 6c616963 69622022 7a697374     "special" bitsiz
 8010b04:	33223d65 73202232 2d657661 74736572     e="32" save-rest
 8010b14:	3d65726f 226f6e22 20203e2f 65662f3c     ore="no"/>  </fe
 8010b24:	72757461 2f3c3e65 67726174 003e7465     ature></target>.

08010b34 <cortexm_cmd_list>:
 8010b34:	0801130d 08001841 0801131a 00000000     ....A...........
	...

08010b4c <tdesc_cortex_mf>:
 8010b4c:	6d783f3c 6576206c 6f697372 31223d6e     <?xml version="1
 8010b5c:	3f22302e 44213c3e 5954434f 74204550     .0"?><!DOCTYPE t
 8010b6c:	65677261 59532074 4d455453 64672220     arget SYSTEM "gd
 8010b7c:	61742d62 74656772 6474642e 743c3e22     b-target.dtd"><t
 8010b8c:	65677261 20203e74 6372613c 65746968     arget>  <archite
 8010b9c:	72757463 72613e65 612f3c6d 69686372     cture>arm</archi
 8010bac:	74636574 3e657275 663c2020 75746165     tecture>  <featu
 8010bbc:	6e206572 3d656d61 67726f22 756e672e     re name="org.gnu
 8010bcc:	6264672e 6d72612e 702d6d2e 69666f72     .gdb.arm.m-profi
 8010bdc:	3e22656c 20202020 6765723c 6d616e20     le">    <reg nam
 8010bec:	72223d65 62202230 69737469 223d657a     e="r0" bitsize="
 8010bfc:	2f223233 2020203e 65723c20 616e2067     32"/>    <reg na
 8010c0c:	223d656d 20223172 73746962 3d657a69     me="r1" bitsize=
 8010c1c:	22323322 20203e2f 723c2020 6e206765     "32"/>    <reg n
 8010c2c:	3d656d61 22327222 74696220 657a6973     ame="r2" bitsize
 8010c3c:	3233223d 203e2f22 3c202020 20676572     ="32"/>    <reg 
 8010c4c:	656d616e 3372223d 69622022 7a697374     name="r3" bitsiz
 8010c5c:	33223d65 3e2f2232 20202020 6765723c     e="32"/>    <reg
 8010c6c:	6d616e20 72223d65 62202234 69737469      name="r4" bitsi
 8010c7c:	223d657a 2f223233 2020203e 65723c20     ze="32"/>    <re
 8010c8c:	616e2067 223d656d 20223572 73746962     g name="r5" bits
 8010c9c:	3d657a69 22323322 20203e2f 723c2020     ize="32"/>    <r
 8010cac:	6e206765 3d656d61 22367222 74696220     eg name="r6" bit
 8010cbc:	657a6973 3233223d 203e2f22 3c202020     size="32"/>    <
 8010ccc:	20676572 656d616e 3772223d 69622022     reg name="r7" bi
 8010cdc:	7a697374 33223d65 3e2f2232 20202020     tsize="32"/>    
 8010cec:	6765723c 6d616e20 72223d65 62202238     <reg name="r8" b
 8010cfc:	69737469 223d657a 2f223233 2020203e     itsize="32"/>   
 8010d0c:	65723c20 616e2067 223d656d 20223972      <reg name="r9" 
 8010d1c:	73746962 3d657a69 22323322 20203e2f     bitsize="32"/>  
 8010d2c:	723c2020 6e206765 3d656d61 30317222       <reg name="r10
 8010d3c:	69622022 7a697374 33223d65 3e2f2232     " bitsize="32"/>
 8010d4c:	20202020 6765723c 6d616e20 72223d65         <reg name="r
 8010d5c:	20223131 73746962 3d657a69 22323322     11" bitsize="32"
 8010d6c:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 8010d7c:	32317222 69622022 7a697374 33223d65     "r12" bitsize="3
 8010d8c:	3e2f2232 20202020 6765723c 6d616e20     2"/>    <reg nam
 8010d9c:	73223d65 62202270 69737469 223d657a     e="sp" bitsize="
 8010dac:	20223233 65707974 6164223d 705f6174     32" type="data_p
 8010dbc:	2f227274 2020203e 65723c20 616e2067     tr"/>    <reg na
 8010dcc:	223d656d 2022726c 73746962 3d657a69     me="lr" bitsize=
 8010ddc:	22323322 70797420 63223d65 5f65646f     "32" type="code_
 8010dec:	22727470 20203e2f 723c2020 6e206765     ptr"/>    <reg n
 8010dfc:	3d656d61 22637022 74696220 657a6973     ame="pc" bitsize
 8010e0c:	3233223d 79742022 223d6570 65646f63     ="32" type="code
 8010e1c:	7274705f 203e2f22 3c202020 20676572     _ptr"/>    <reg 
 8010e2c:	656d616e 7078223d 20227273 73746962     name="xpsr" bits
 8010e3c:	3d657a69 22323322 20203e2f 723c2020     ize="32"/>    <r
 8010e4c:	6e206765 3d656d61 70736d22 69622022     eg name="msp" bi
 8010e5c:	7a697374 33223d65 73202232 2d657661     tsize="32" save-
 8010e6c:	74736572 3d65726f 226f6e22 70797420     restore="no" typ
 8010e7c:	64223d65 5f617461 22727470 20203e2f     e="data_ptr"/>  
 8010e8c:	723c2020 6e206765 3d656d61 70737022       <reg name="psp
 8010e9c:	69622022 7a697374 33223d65 73202232     " bitsize="32" s
 8010eac:	2d657661 74736572 3d65726f 226f6e22     ave-restore="no"
 8010ebc:	70797420 64223d65 5f617461 22727470      type="data_ptr"
 8010ecc:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 8010edc:	65707322 6c616963 69622022 7a697374     "special" bitsiz
 8010eec:	33223d65 73202232 2d657661 74736572     e="32" save-rest
 8010efc:	3d65726f 226f6e22 20203e2f 65662f3c     ore="no"/>  </fe
 8010f0c:	72757461 20203e65 6165663c 65727574     ature>  <feature
 8010f1c:	6d616e20 6f223d65 672e6772 672e756e      name="org.gnu.g
 8010f2c:	612e6264 762e6d72 3e227066 20202020     db.arm.vfp">    
 8010f3c:	6765723c 6d616e20 66223d65 72637370     <reg name="fpscr
 8010f4c:	69622022 7a697374 33223d65 3e2f2232     " bitsize="32"/>
 8010f5c:	20202020 6765723c 6d616e20 64223d65         <reg name="d
 8010f6c:	62202230 69737469 223d657a 20223436     0" bitsize="64" 
 8010f7c:	65707974 6c66223d 2274616f 20203e2f     type="float"/>  
 8010f8c:	723c2020 6e206765 3d656d61 22316422       <reg name="d1"
 8010f9c:	74696220 657a6973 3436223d 79742022      bitsize="64" ty
 8010fac:	223d6570 616f6c66 3e2f2274 20202020     pe="float"/>    
 8010fbc:	6765723c 6d616e20 64223d65 62202232     <reg name="d2" b
 8010fcc:	69737469 223d657a 20223436 65707974     itsize="64" type
 8010fdc:	6c66223d 2274616f 20203e2f 723c2020     ="float"/>    <r
 8010fec:	6e206765 3d656d61 22336422 74696220     eg name="d3" bit
 8010ffc:	657a6973 3436223d 79742022 223d6570     size="64" type="
 801100c:	616f6c66 3e2f2274 20202020 6765723c     float"/>    <reg
 801101c:	6d616e20 64223d65 62202234 69737469      name="d4" bitsi
 801102c:	223d657a 20223436 65707974 6c66223d     ze="64" type="fl
 801103c:	2274616f 20203e2f 723c2020 6e206765     oat"/>    <reg n
 801104c:	3d656d61 22356422 74696220 657a6973     ame="d5" bitsize
 801105c:	3436223d 79742022 223d6570 616f6c66     ="64" type="floa
 801106c:	3e2f2274 20202020 6765723c 6d616e20     t"/>    <reg nam
 801107c:	64223d65 62202236 69737469 223d657a     e="d6" bitsize="
 801108c:	20223436 65707974 6c66223d 2274616f     64" type="float"
 801109c:	20203e2f 723c2020 6e206765 3d656d61     />    <reg name=
 80110ac:	22376422 74696220 657a6973 3436223d     "d7" bitsize="64
 80110bc:	79742022 223d6570 616f6c66 3e2f2274     " type="float"/>
 80110cc:	20202020 6765723c 6d616e20 64223d65         <reg name="d
 80110dc:	62202238 69737469 223d657a 20223436     8" bitsize="64" 
 80110ec:	65707974 6c66223d 2274616f 20203e2f     type="float"/>  
 80110fc:	723c2020 6e206765 3d656d61 22396422       <reg name="d9"
 801110c:	74696220 657a6973 3436223d 79742022      bitsize="64" ty
 801111c:	223d6570 616f6c66 3e2f2274 20202020     pe="float"/>    
 801112c:	6765723c 6d616e20 64223d65 20223031     <reg name="d10" 
 801113c:	73746962 3d657a69 22343622 70797420     bitsize="64" typ
 801114c:	66223d65 74616f6c 203e2f22 3c202020     e="float"/>    <
 801115c:	20676572 656d616e 3164223d 62202231     reg name="d11" b
 801116c:	69737469 223d657a 20223436 65707974     itsize="64" type
 801117c:	6c66223d 2274616f 20203e2f 723c2020     ="float"/>    <r
 801118c:	6e206765 3d656d61 32316422 69622022     eg name="d12" bi
 801119c:	7a697374 36223d65 74202234 3d657079     tsize="64" type=
 80111ac:	6f6c6622 2f227461 2020203e 65723c20     "float"/>    <re
 80111bc:	616e2067 223d656d 22333164 74696220     g name="d13" bit
 80111cc:	657a6973 3436223d 79742022 223d6570     size="64" type="
 80111dc:	616f6c66 3e2f2274 20202020 6765723c     float"/>    <reg
 80111ec:	6d616e20 64223d65 20223431 73746962      name="d14" bits
 80111fc:	3d657a69 22343622 70797420 66223d65     ize="64" type="f
 801120c:	74616f6c 203e2f22 3c202020 20676572     loat"/>    <reg 
 801121c:	656d616e 3164223d 62202235 69737469     name="d15" bitsi
 801122c:	223d657a 20223436 65707974 6c66223d     ze="64" type="fl
 801123c:	2274616f 20203e2f 65662f3c 72757461     oat"/>  </featur
 801124c:	2f3c3e65 67726174 003e7465 67617375     e></target>.usag
 801125c:	6d203a65 74696e6f 7620726f 6f746365     e: monitor vecto
 801126c:	61635f72 20686374 616e6528 7c656c62     r_catch (enable|
 801127c:	61736964 29656c62 61682820 697c6472     disable) (hard|i
 801128c:	627c746e 737c7375 7c746174 7c6b6863     nt|bus|stat|chk|
 801129c:	70636f6e 7c6d6d7c 65736572 000a2974     nocp|mm|reset)..
 80112ac:	63746143 676e6968 63657620 73726f74     Catching vectors
 80112bc:	2500203a 73002073 61637379 30206c6c     : .%s .syscall 0
 80112cc:	6c25786c 25282078 2520786c 2520786c     lx%lx (%lx %lx %
 80112dc:	2520786c 0a29786c 74743a00 73657200     lx %lx)..:tt.res
 80112ec:	6d007465 6f6e006d 63007063 73006b68     et.mm.nocp.chk.s
 80112fc:	00746174 00737562 00746e69 64726168     tat.bus.int.hard
 801130c:	63657600 5f726f74 63746163 61430068     .vector_catch.Ca
 801131c:	20686374 65637865 6f697470 6576206e     tch exception ve
 801132c:	726f7463 00000073                       ctors...

08011334 <crc32_table>:
 8011334:	00000000 04c11db7 09823b6e 0d4326d9     ........n;...&C.
 8011344:	130476dc 17c56b6b 1a864db2 1e475005     .v..kk...M...PG.
 8011354:	2608edb8 22c9f00f 2f8ad6d6 2b4bcb61     ...&...".../a.K+
 8011364:	350c9b64 31cd86d3 3c8ea00a 384fbdbd     d..5...1...<..O8
 8011374:	4c11db70 48d0c6c7 4593e01e 4152fda9     p..L...H...E..RA
 8011384:	5f15adac 5bd4b01b 569796c2 52568b75     ..._...[...Vu.VR
 8011394:	6a1936c8 6ed82b7f 639b0da6 675a1011     .6.j.+.n...c..Zg
 80113a4:	791d4014 7ddc5da3 709f7b7a 745e66cd     .@.y.].}z{.p.f^t
 80113b4:	9823b6e0 9ce2ab57 91a18d8e 95609039     ..#.W.......9.`.
 80113c4:	8b27c03c 8fe6dd8b 82a5fb52 8664e6e5     <.'.....R.....d.
 80113d4:	be2b5b58 baea46ef b7a96036 b3687d81     X[+..F..6`...}h.
 80113e4:	ad2f2d84 a9ee3033 a4ad16ea a06c0b5d     .-/.30......].l.
 80113f4:	d4326d90 d0f37027 ddb056fe d9714b49     .m2.'p...V..IKq.
 8011404:	c7361b4c c3f706fb ceb42022 ca753d95     L.6....." ...=u.
 8011414:	f23a8028 f6fb9d9f fbb8bb46 ff79a6f1     (.:.....F.....y.
 8011424:	e13ef6f4 e5ffeb43 e8bccd9a ec7dd02d     ..>.C.......-.}.
 8011434:	34867077 30476dc0 3d044b19 39c556ae     wp.4.mG0.K.=.V.9
 8011444:	278206ab 23431b1c 2e003dc5 2ac12072     ...'..C#.=..r .*
 8011454:	128e9dcf 164f8078 1b0ca6a1 1fcdbb16     ....x.O.........
 8011464:	018aeb13 054bf6a4 0808d07d 0cc9cdca     ......K.}.......
 8011474:	7897ab07 7c56b6b0 71159069 75d48dde     ...x..V|i..q...u
 8011484:	6b93dddb 6f52c06c 6211e6b5 66d0fb02     ...kl.Ro...b...f
 8011494:	5e9f46bf 5a5e5b08 571d7dd1 53dc6066     .F.^.[^Z.}.Wf`.S
 80114a4:	4d9b3063 495a2dd4 44190b0d 40d816ba     c0.M.-ZI...D...@
 80114b4:	aca5c697 a864db20 a527fdf9 a1e6e04e     .... .d...'.N...
 80114c4:	bfa1b04b bb60adfc b6238b25 b2e29692     K.....`.%.#.....
 80114d4:	8aad2b2f 8e6c3698 832f1041 87ee0df6     /+...6l.A./.....
 80114e4:	99a95df3 9d684044 902b669d 94ea7b2a     .]..D@h..f+.*{..
 80114f4:	e0b41de7 e4750050 e9362689 edf73b3e     ....P.u..&6.>;..
 8011504:	f3b06b3b f771768c fa325055 fef34de2     ;k...vq.UP2..M..
 8011514:	c6bcf05f c27dede8 cf3ecb31 cbffd686     _.....}.1.>.....
 8011524:	d5b88683 d1799b34 dc3abded d8fba05a     ....4.y...:.Z...
 8011534:	690ce0ee 6dcdfd59 608edb80 644fc637     ...iY..m...`7.Od
 8011544:	7a089632 7ec98b85 738aad5c 774bb0eb     2..z...~\..s..Kw
 8011554:	4f040d56 4bc510e1 46863638 42472b8f     V..O...K86.F.+GB
 8011564:	5c007b8a 58c1663d 558240e4 51435d53     .{.\=f.X.@.US]CQ
 8011574:	251d3b9e 21dc2629 2c9f00f0 285e1d47     .;.%)&.!...,G.^(
 8011584:	36194d42 32d850f5 3f9b762c 3b5a6b9b     BM.6.P.2,v.?.kZ;
 8011594:	0315d626 07d4cb91 0a97ed48 0e56f0ff     &.......H.....V.
 80115a4:	1011a0fa 14d0bd4d 19939b94 1d528623     ....M.......#.R.
 80115b4:	f12f560e f5ee4bb9 f8ad6d60 fc6c70d7     .V/..K..`m...pl.
 80115c4:	e22b20d2 e6ea3d65 eba91bbc ef68060b     . +.e=........h.
 80115d4:	d727bbb6 d3e6a601 dea580d8 da649d6f     ..'.........o.d.
 80115e4:	c423cd6a c0e2d0dd cda1f604 c960ebb3     j.#...........`.
 80115f4:	bd3e8d7e b9ff90c9 b4bcb610 b07daba7     ~.>...........}.
 8011604:	ae3afba2 aafbe615 a7b8c0cc a379dd7b     ..:.........{.y.
 8011614:	9b3660c6 9ff77d71 92b45ba8 9675461f     .`6.q}...[...Fu.
 8011624:	8832161a 8cf30bad 81b02d74 857130c3     ..2.....t-...0q.
 8011634:	5d8a9099 594b8d2e 5408abf7 50c9b640     ...]..KY...T@..P
 8011644:	4e8ee645 4a4ffbf2 470cdd2b 43cdc09c     E..N..OJ+..G...C
 8011654:	7b827d21 7f436096 7200464f 76c15bf8     !}.{.`C.OF.r.[.v
 8011664:	68860bfd 6c47164a 61043093 65c52d24     ...hJ.Gl.0.a$-.e
 8011674:	119b4be9 155a565e 18197087 1cd86d30     .K..^VZ..p..0m..
 8011684:	029f3d35 065e2082 0b1d065b 0fdc1bec     5=... ^.[.......
 8011694:	3793a651 3352bbe6 3e119d3f 3ad08088     Q..7..R3?..>...:
 80116a4:	2497d08d 2056cd3a 2d15ebe3 29d4f654     ...$:.V ...-T..)
 80116b4:	c5a92679 c1683bce cc2b1d17 c8ea00a0     y&...;h...+.....
 80116c4:	d6ad50a5 d26c4d12 df2f6bcb dbee767c     .P...Ml..k/.|v..
 80116d4:	e3a1cbc1 e760d676 ea23f0af eee2ed18     ....v.`...#.....
 80116e4:	f0a5bd1d f464a0aa f9278673 fde69bc4     ......d.s.'.....
 80116f4:	89b8fd09 8d79e0be 803ac667 84fbdbd0     ......y.g.:.....
 8011704:	9abc8bd5 9e7d9662 933eb0bb 97ffad0c     ....b.}...>.....
 8011714:	afb010b1 ab710d06 a6322bdf a2f33668     ......q..+2.h6..
 8011724:	bcb4666d b8757bda b5365d03 b1f740b4     mf...{u..]6..@..

08011734 <efm32_flash_write_stub>:
 8011734:	4b114c10 601c0892 4b102401 601c0092     .L.K...`.$.K...`
 8011744:	42942400 4d0ed015 602b1903 4b0d2501     .$.B...M..+`.%.K
 8011754:	2608601d 682f4d0c 423746ac 590dd0f9     .`.&.M/h.F7B...Y
 8011764:	603d4f0a 4663601e 07db681b 3404d4fb     .O=`.`cF.h.....4
 8011774:	be00e7e7 00001b71 400c003c 400c0008     ....q...<..@...@
 8011784:	400c0010 400c000c 400c001c 400c0018     ...@...@...@...@

08011794 <efm32_cmd_list>:
 8011794:	080118ba 0800263d 080118c5 080118df     ....=&..........
 80117a4:	080026c9 080118e6 00000000 00000000     .&..............
 80117b4:	00000000 73617245 75732065 73656363     ....Erase succes
 80117c4:	6c756673 55000a21 7571696e 754e2065     sful!..Unique Nu
 80117d4:	7265626d 7830203a 36313025 0a786c6c     mber: 0x%016llx.
 80117e4:	4d464500 47203233 6f6b6365 4d464500     .EFM32 Gecko.EFM
 80117f4:	47203233 746e6169 63654720 45006f6b     32 Giant Gecko.E
 8011804:	32334d46 6e695420 65472079 006f6b63     FM32 Tiny Gecko.
 8011814:	334d4645 654c2032 7261706f 65472064     EFM32 Leopard Ge
 8011824:	006f6b63 334d4645 6f572032 7265646e     cko.EFM32 Wonder
 8011834:	63654720 45006f6b 32334d46 72655a20      Gecko.EFM32 Zer
 8011844:	6547206f 006f6b63 334d4645 61482032     o Gecko.EFM32 Ha
 8011854:	20797070 6b636547 5a45006f 57323352     ppy Gecko.EZR32W
 8011864:	46642547 25526425 72282064 6f696461     G%dF%dR%d (radio
 8011874:	25697320 45002964 3233525a 6425474c      si%d).EZR32LG%d
 8011884:	52642546 28206425 69646172 6973206f     F%dR%d (radio si
 8011894:	00296425 73616c66 69732068 2520657a     %d).flash size %
 80118a4:	61702064 73206567 20657a69 000a6425     d page size %d..
 80118b4:	334d4645 72650032 5f657361 7373616d     EFM32.erase_mass
 80118c4:	61724500 65206573 7269746e 6c662065     .Erase entire fl
 80118d4:	20687361 6f6d656d 73007972 61697265     ash memory.seria
 80118e4:	7250006c 73746e69 696e7520 20657571     l.Prints unique 
 80118f4:	626d756e 00007265 00000000              number......

08011900 <custom_dict>:
 8011900:	20000058 08011aac 00000000 08002ced     X.. .........,..
 8011910:	08011900 08011aa0 00000000 08002ccd     .............,..
 8011920:	08011910 08011a99 00000000 08002d8d     .............-..
 8011930:	08011920 08011a95 00000000 08002d41      ...........A-..
 8011940:	08011930 08011a8f 00000000 08002ef5     0...............
 8011950:	08011940 08011a80 00000000 08002ec5     @...............
 8011960:	08011950 08011a6d 00000000 08002d09     P...m........-..
 8011970:	08011960 08011a58 00000000 08002ea1     `...X...........
 8011980:	08011970 08011a47 00000000 08002ca1     p...G........,..
 8011990:	08011980 08011a3a 00000000 08002c45     ....:.......E,..
 80119a0:	08011990 08011a2c 00000000 08002dfd     ....,........-..
 80119b0:	080119a0 08011a1f 00000000 08002bf1     .............+..
 80119c0:	080119b0 08011a12 00000000 08002b71     ............q+..
 80119d0:	080119c0 08011a02 00000000 08002b39     ............9+..
 80119e0:	080119d0 080119f0 00000000 08002b01     .............+..

080119f0 <__compound_literal.15>:
 80119f0:	65726210 6f706b61 2d746e69 61656c63     .breakpoint-clea
 8011a00:	620e0072                                         r.

08011a02 <__compound_literal.14>:
 8011a02:	6572620e 6f706b61 2d746e69 00746573     .breakpoint-set.

08011a12 <__compound_literal.13>:
 8011a12:	616c660b 772d6873 65746972 6c660b00              .flash-write.

08011a1f <__compound_literal.12>:
 8011a1f:	616c660b 652d6873 65736172 61740c00              .flash-erase.

08011a2c <__compound_literal.11>:
 8011a2c:	7261740c 2d746567 65736572 740b0074              .target-reset.

08011a3a <__compound_literal.10>:
 8011a3a:	7261740b 2d746567 706d7564 743f0f00              .target-dump.

08011a47 <__compound_literal.9>:
 8011a47:	61743f0f 74656772 6d656d2d 70616d2d     .?target-mem-map
	...

08011a58 <__compound_literal.8>:
 8011a58:	72617413 2d746567 75716572 2d747365     .target-request-
 8011a68:	746c6168 743f1100                                halt.

08011a6d <__compound_literal.7>:
 8011a6d:	61743f11 74656772 6e75722d 6174732d     .?target-run-sta
 8011a7d:	0d006574                                         te.

08011a80 <__compound_literal.6>:
 8011a80:	7261740d 2d746567 75736572 0400656d              .target-resume.

08011a8f <__compound_literal.5>:
 8011a8f:	65747304 74020070                                .step.

08011a95 <__compound_literal.4>:
 8011a95:	00407402                                .t@.

08011a99 <__compound_literal.3>:
 8011a99:	65723f05 0a007367                                .?regs.

08011aa0 <__compound_literal.2>:
 8011aa0:	6264670a 7474612d 00686361              .gdb-attach.

08011aac <__compound_literal.1>:
 8011aac:	64777309 63732d70 00006e61                       .swdp-scan.

08011ab7 <__compound_literal.0>:
 8011ab7:	00000000 31304500 65726200 6f706b61     .....E01.breakpo
 8011ac7:	2d746e69 6f727265 62000a72 6b616572     int-error..break
 8011ad7:	6e696f70 6b6f2d74 6174000a 74656772     point-ok..target
 8011ae7:	746f6e20 6e6f6320 7463656e 000a6465      not connected..
 8011af7:	73616c66 72772068 65747469 7573206e     flash written su
 8011b07:	73656363 6c756673 6500796c 726f7272     ccessfully.error
 8011b17:	69727720 676e6974 616c6620 66006873      writing flash.f
 8011b27:	6873616c 61726520 20646573 63637573     lash erased succ
 8011b37:	66737365 796c6c75 72726500 6520726f     essfully.error e
 8011b47:	69736172 6620676e 6873616c 20282e00     rasing flash..( 
 8011b57:	6c696166 74206465 6572206f 6d206461     failed to read m
 8011b67:	726f6d65 74612079 64646120 73736572     emory at address
 8011b77:	62202920 20657361 77732040 68207061      ) base @ swap h
 8011b87:	2e207865 20726320 65736162 62002120     ex . cr base !.b
 8011b97:	20657361 65682040 61740078 74656772     ase @ hex.target
 8011ba7:	736f6c2d 74000a74 65677261 61682d74     -lost..target-ha
 8011bb7:	6465746c 6174000a 74656772 6c61682d     lted..target-hal
 8011bc7:	2d646574 63746177 696f7068 000a746e     ted-watchpoint..
 8011bd7:	67726174 682d7465 65746c61 61662d64     target-halted-fa
 8011be7:	0a746c75 72617400 2d746567 746c6168     ult..target-halt
 8011bf7:	622d6465 6b616572 6e696f70 74000a74     ed-breakpoint..t
 8011c07:	65677261 6f6e2074 6f632074 63656e6e     arget not connec
 8011c17:	00646574 6d635271 4f002c64 0045004b     ted.qRcmd,.OK.E.
 8011c27:	70755371 74726f70 50006465 656b6361     qSupported.Packe
 8011c37:	7a695374 58253d65 6658713b 6d3a7265     tSize=%X;qXfer:m
 8011c47:	726f6d65 616d2d79 65723a70 3b2b6461     emory-map:read+;
 8011c57:	65665871 65663a72 72757461 723a7365     qXfer:features:r
 8011c67:	2b646165 66587100 6d3a7265 726f6d65     ead+.qXfer:memor
 8011c77:	616d2d79 65723a70 3a3a6461 66587100     y-map:read::.qXf
 8011c87:	663a7265 75746165 3a736572 64616572     er:features:read
 8011c97:	7261743a 2e746567 3a6c6d78 52437100     :target.xml:.qCR
 8011ca7:	6c253a43 6c252c78 25430078 2a00786c     C:%lx,%lx.C%lx.*
 8011cb7:	55202a2a 7075736e 74726f70 70206465     ** Unsupported p
 8011cc7:	656b6361 25203a74 45000a73 45004646     acket: %s..EFF.E
 8011cd7:	7265746e 20676e69 20424447 746f7270     ntering GDB prot
 8011ce7:	6c6f636f 69616d20 6f6c206e 6d00706f     ocol main loop.m
 8011cf7:	2c786c25 00786c25 6170206d 74656b63     %lx,%lx.m packet
 8011d07:	6461203a 3d207264 786c2520 656c202c     : addr = %lx, le
 8011d17:	203d206e 0a786c25 6c254d00 6c252c78     n = %lx..M%lx,%l
 8011d27:	6e253a78 70204d00 656b6361 61203a74     x:%n.M packet: a
 8011d37:	20726464 6c25203d 6c202c78 3d206e65     ddr = %lx, len =
 8011d47:	786c2520 3158000a 30570044 25580030      %lx..X1D.W00.X%
 8011d57:	00583230 47524154 4c205445 2e54534f     02X.TARGET LOST.
 8011d67:	30255400 54005832 58323025 63746177     .T%02X.T%02Xwatc
 8011d77:	30253a68 003b5838 202a2a2a 61702046     h:%08X;.*** F pa
 8011d87:	74656b63 65687720 6f6e206e 6e692074     cket when not in
 8011d97:	73797320 6c6c6163 25272021 000a2773      syscall! '%s'..
 8011da7:	786c2558 786c252c 006e253a 61702058     X%lx,%lx:%n.X pa
 8011db7:	74656b63 6461203a 3d207264 786c2520     cket: addr = %lx
 8011dc7:	656c202c 203d206e 0a786c25 74417600     , len = %lx..vAt
 8011dd7:	68636174 3830253b 5400786c 76003530     tach;%08lx.T05.v
 8011de7:	3b6e7552 6c467600 45687361 65736172     Run;.vFlashErase
 8011df7:	3830253a 252c786c 786c3830 616c4600     :%08lx,%08lx.Fla
 8011e07:	45206873 65736172 38302520 2520586c     sh Erase %08lX %
 8011e17:	586c3830 4676000a 6873616c 74697257     08lX..vFlashWrit
 8011e27:	30253a65 3a786c38 46006e25 6873616c     e:%08lx:%n.Flash
 8011e37:	69725720 25206574 586c3830 38302520      Write %08lX %08
 8011e47:	000a586c 616c4676 6f446873 2c00656e     lX..vFlashDone.,
 8011e57:	2c786c25 25006425 78252c78 0063252c     %lx,%d.%x,%x,%c.
 8011e67:	65706f46 30252c6e 252f5838 30252c58     Fopen,%08X/%X,%0
 8011e77:	252c5838 00583830 6f6c6346 252c6573     8X,%08X.Fclose,%
 8011e87:	00583830 61657246 30252c64 252c5838     08X.Fread,%08X,%
 8011e97:	2c583830 58383025 72774600 2c657469     08X,%08X.Fwrite,
 8011ea7:	58383025 3830252c 30252c58 46005838     %08X,%08X,%08X.F
 8011eb7:	6565736c 30252c6b 252c5838 2c583830     lseek,%08X,%08X,
 8011ec7:	58383025 65724600 656d616e 3830252c     %08X.Frename,%08
 8011ed7:	58252f58 3830252c 58252f58 6e754600     X/%X,%08X/%X.Fun
 8011ee7:	6b6e696c 3830252c 58252f58 74734600     link,%08X/%X.Fst
 8011ef7:	252c7461 2f583830 252c5825 00583830     at,%08X/%X,%08X.
 8011f07:	74736646 252c7461 30252c58 46005838     Ffstat,%X,%08X.F
 8011f17:	74746567 6f656d69 79616466 3830252c     gettimeofday,%08
 8011f27:	30252c58 46005838 74617369 252c7974     X,%08X.Fisatty,%
 8011f37:	00583830 73797346 2c6d6574 58383025     08X.Fsystem,%08X
 8011f47:	0058252f                                /%X.

08011f4b <hexdigits>:
 8011f4b:	33323130 37363534 62613938 66656463     0123456789abcdef
	...

08011f5c <ones>:
 8011f5c:	ffffffff ffffffff 00000000              ............

08011f68 <dev_descr>:
 8011f68:	0ba00477 0fff0fff 080121f0 08000815     w........!......
 8011f78:	06410041 0fffffff 08012211 00000000     A.A......"......
 8011f88:	06412041 0fffffff 0801223d 00000000     A A.....="......
 8011f98:	06414041 0fffffff 08012266 00000000     A@A.....f"......
 8011fa8:	06416041 0fffffff 08012290 00000000     A`A......"......
 8011fb8:	06418041 0fffffff 080122ad 00000000     A.A......"......
 8011fc8:	06420041 0fffffff 080122dc 00000000     A.B......"......
 8011fd8:	06428041 0fffffff 08012304 00000000     A.B......#......
 8011fe8:	06411041 ffffffff 0801233a 00000000     A.A.....:#......
 8011ff8:	06413041 ffffffff 0801235a 00000000     A0A.....Z#......
 8012008:	0bb11477 ffffffff 0801237a 00000000     w.......z#......
 8012018:	8940303f ffffffff 08012389 00000000     ?0@......#......
 8012028:	0792603f ffffffff 0801239a 00000000     ?`.......#......
 8012038:	20270013 ffffffff 080123ae 00000000     ..' .....#......
 8012048:	07b7617f ffffffff 080123bf 00000000     .a.......#......
 8012058:	4ba00477 ffffffff 080123d2 00000000     w..K.....#......
	...
 8012070:	080123e5 00000000 65736552 6e697474     .#......Resettin
 8012080:	41542067 69470050 206e6576 7473696c     g TAP.Given list
 8012090:	20666f20 6c205249 74676e65 202c7368      of IR lengths, 
 80120a0:	70696b73 676e6970 6f727020 43006562     skipping probe.C
 80120b0:	676e6168 74732065 20657461 53206f74     hange state to S
 80120c0:	74666968 0052492d 63656863 6166206b     hift-IR.check fa
 80120d0:	64656c69 5249203a 205d305b 31203d21     iled: IR[0] != 1
 80120e0:	61635300 6e696e6e 756f2067 52492074     .Scanning out IR
 80120f0:	746a0073 735f6761 3a6e6163 6e615320     s.jtag_scan: San
 8012100:	20797469 63656863 6166206b 64656c69     ity check failed
 8012110:	5249203a 205d305b 66696873 20646574     : IR[0] shifted 
 8012120:	2074756f 30207361 61746a00 63735f67     out as 0.jtag_sc
 8012130:	203a6e61 6978614d 206d756d 69766564     an: Maximum devi
 8012140:	63206563 746e756f 63786520 65646565     ce count exceede
 8012150:	746a0064 735f6761 3a6e6163 78614d20     d.jtag_scan: Max
 8012160:	6d756d69 20524920 676e656c 65206874     imum IR length e
 8012170:	65656378 00646564 75746552 74206e72     xceeded.Return t
 8012180:	7552206f 65542d6e 492f7473 00656c64     o Run-Test/Idle.
 8012190:	6e616843 73206567 65746174 206f7420     Change state to 
 80121a0:	66696853 52442d74 61746a00 63735f67     Shift-DR.jtag_sc
 80121b0:	203a6e61 696e6153 63207974 6b636568     an: Sanity check
 80121c0:	69616620 3a64656c 50594220 20535341      failed: BYPASS 
 80121d0:	20766564 6e756f63 6f642074 276e7365     dev count doesn'
 80121e0:	616d2074 20686374 73205249 006e6163     t match IR scan.
 80121f0:	204d5241 696d694c 3a646574 49444120     ARM Limited: ADI
 8012200:	4a203576 2d474154 70205044 2e74726f     v5 JTAG-DP port.
 8012210:	20545300 7263694d 656c656f 6f727463     .ST Microelectro
 8012220:	7363696e 5453203a 2c32334d 64654d20     nics: STM32, Med
 8012230:	206d7569 736e6564 2e797469 20545300     ium density..ST 
 8012240:	7263694d 656c656f 6f727463 7363696e     Microelectronics
 8012250:	5453203a 2c32334d 776f4c20 6e656420     : STM32, Low den
 8012260:	79746973 5453002e 63694d20 6c656f72     sity..ST Microel
 8012270:	72746365 63696e6f 53203a73 32334d54     ectronics: STM32
 8012280:	6948202c 64206867 69736e65 002e7974     , High density..
 8012290:	4d205453 6f726369 63656c65 6e6f7274     ST Microelectron
 80122a0:	3a736369 4d545320 2e4c3233 20545300     ics: STM32L..ST 
 80122b0:	7263694d 656c656f 6f727463 7363696e     Microelectronics
 80122c0:	5453203a 2c32334d 6e6f4320 7463656e     : STM32, Connect
 80122d0:	74697669 694c2079 002e656e 4d205453     ivity Line..ST M
 80122e0:	6f726369 63656c65 6e6f7274 3a736369     icroelectronics:
 80122f0:	4d545320 202c3233 756c6156 694c2065      STM32, Value Li
 8012300:	002e656e 4d205453 6f726369 63656c65     ne..ST Microelec
 8012310:	6e6f7274 3a736369 4d545320 202c3233     tronics: STM32, 
 8012320:	756c6156 694c2065 202c656e 68676948     Value Line, High
 8012330:	6e656420 79746973 5453002e 63694d20      density..ST Mic
 8012340:	6c656f72 72746365 63696e6f 53203a73     roelectronics: S
 8012350:	32334d54 78783246 5453002e 63694d20     TM32F2xx..ST Mic
 8012360:	6c656f72 72746365 63696e6f 53203a73     roelectronics: S
 8012370:	32334d54 78783446 504e002e 4c203a58     TM32F4xx..NPX: L
 8012380:	31314350 2e343243 4d544100 203a4c45     PC11C24..ATMEL: 
 8012390:	654d5441 36316167 5441002e 3a4c454d     ATMega16..ATMEL:
 80123a0:	39544120 4d415331 31363239 6e49002e      AT91SAM9261..In
 80123b0:	3a6c6574 30386920 65363833 42002e78     tel: i80386ex..B
 80123c0:	64616f72 3a6d6f63 4d434220 35333832     roadcom: BCM2835
 80123d0:	7242002e 6364616f 203a6d6f 324d4342     ..Broadcom: BCM2
 80123e0:	2e363338 6b6e5500 6e776f6e 23000000              836..Unknown..

080123ee <lmi_flash_write_stub>:
 80123ee:	009c2300 1c1c1909 42930892 4e08d20e     .#.........B...N
 80123fe:	60351905 4d07590e 4d07602e 602e4e07     ..5`.Y.M.`.M.N.`
 801240e:	07f6682e 3301d4fc e7ee3404 46c0be00     .h.....3.4.....F
 801241e:	400fd000 400fd004 400fd008 a4420001     ...@...@...@..B.

0801242e <lmi_driver_str>:
 801242e:	53204954 6c6c6574 73697261 7669542f     TI Stellaris/Tiv
 801243e:	504c0061 78313143 504c0078 78313843     a.LPC11xx.LPC81x
 801244e:	43504c00 00783238 3143504c 00787835     .LPC82x.LPC15xx.
	...

08012460 <reset_val.6534>:
 8012460:	05fa0004                                ....

08012464 <lpc43xx_cmd_list>:
 8012464:	080118ba 0800466d 080118c5 080112e9     ....mF..........
 8012474:	080046c1 08012550 0801255d 080046fd     .F..P%..]%...F..
 8012484:	08012564 00000000 00000000 00000000     d%..............
 8012494:	73617245 4b4f2065 45000a2e 63657078     Erase OK...Expec
 80124a4:	20646574 6b6e6162 67726120 6e656d75     ted bank argumen
 80124b4:	20302074 3120726f 55000a2e 7078656e     t 0 or 1...Unexp
 80124c4:	65746365 61622064 6e206b6e 65626d75     ected bank numbe
 80124d4:	73202c72 6c756f68 65622064 6f203020     r, should be 0 o
 80124e4:	2e312072 6553000a 6f622074 6261746f     r 1...Set bootab
 80124f4:	6620656c 656c6961 000a2e64 20746553     le failed...Set 
 8012504:	746f6f62 656c6261 2e4b4f20 504c000a     bootable OK...LP
 8012514:	78333443 6f432078 78657472 00344d2d     C43xx Cortex-M4.
 8012524:	3443504c 00787833 3443504c 20787833     LPC43xx.LPC43xx 
 8012534:	74726f43 4d2d7865 504c0030 78333443     Cortex-M0.LPC43x
 8012544:	553c2078 6f6e6b6e 003e6e77 65736552     x <Unknown>.Rese
 8012554:	61742074 74656772 626b6d00 00746f6f     t target.mkboot.
 8012564:	656b614d 616c6620 62206873 206b6e61     Make flash bank 
 8012574:	746f6f62 656c6261 324c4b00 4c4b0035     bootable.KL25.KL
 8012584:	4b003732 7832304c 4b003233 7832304c     27.KL02x32.KL02x
 8012594:	4b003631 7832304c 001d0038                       16.KL02x8.

0801259e <morse_letter>:
 801259e:	0008001d 000c0157 000e05d7 000a0057     ....W.......W...
 80125ae:	00040001 000c0175 000c0177 000a0055     ....u...w...U...
 80125be:	00060005 00101ddd 000c01d7 000c015d     ............]...
 80125ce:	000a0077 00080017 000e0777 000e05dd     w.......w.......
 80125de:	00101d77 000a005d 00080015 00060007     w...]...........
 80125ee:	000a0075 000c01d5 000c01dd 000e0757     u...........W...
 80125fe:	00101dd7 000e0577 fdc00000                       ....w.....

08012608 <nrf51_read_cmd_list>:
 8012608:	0800fdc0 08004c79 08012770 0801278f     ....yL..p'...'..
 8012618:	08004d95 08012794 080127b8 08004d75     .M...'...'..uM..
 8012628:	080127bd 080127d9 08004d45 080127e2     .'...'..EM...'..
 8012638:	080127f8 08004cfd 08012803 00000000     .'...L...(......
	...

08012650 <nrf51_flash_write_stub>:
 8012650:	49094808 3228467a 2b004b08 6814d009     .H.IzF(2.K.+...h
 8012660:	6804600c 42342601 3b04d0fb 32043104     .`.h.&4B...;.1.2
 8012670:	be00e7f3 4001e400 00000000 0000000c     .......@........
 8012680:	aaaaaaaa bbbbbbbb cccccccc              ............

0801268c <nrf51_cmd_list>:
 801268c:	080118ba 08004f39 080118c5 08012817     ....9O.......(..
 801269c:	08004cb1 0801281c 00000000 00000000     .L...(..........
 80126ac:	00000000 64616552 6d6f6320 646e616d     ....Read command
 80126bc:	000a3a73 6c627550 796c6369 73694c20     s:..Publicly Lis
 80126cc:	20646574 72646441 3a737365 25783020     ted Address: 0x%
 80126dc:	25583430 0a583830 6e615200 6c6d6f64     04X%08X..Randoml
 80126ec:	73412079 6e676973 41206465 65726464     y Assigned Addre
 80126fc:	203a7373 30257830 30255834 000a5838     ss: 0x%04X%08X..
 801270c:	69766544 49206563 30203a44 38302578     Device ID: 0x%08
 801271c:	38302558 46000a58 776d7269 20657261     X%08X..Firmware 
 801272c:	203a4449 30257830 000a5834 64726148     ID: 0x%04X..Hard
 801273c:	65726177 3a444920 25783020 0a583430     ware ID: 0x%04X.
 801274c:	61726500 2e2e6573 6f4e000a 63696472     .erase....Nordic
 801275c:	46526e20 4e003135 6964726f 526e2063      nRF51.Nordic nR
 801276c:	00323546 70736944 2079616c 706c6568     F52.Display help
 801277c:	726f6620 61657220 6f632064 6e616d6d      for read comman
 801278c:	68007364 00646977 64616552 72616820     ds.hwid.Read har
 801279c:	72617764 64692065 69746e65 61636966     dware identifica
 80127ac:	6e6f6974 6d756e20 00726562 64697766     tion number.fwid
 80127bc:	61655200 72702064 6f6c2d65 64656461     .Read pre-loaded
 80127cc:	72696620 7261776d 44492065 76656400      firmware ID.dev
 80127dc:	69656369 65520064 75206461 7571696e     iceid.Read uniqu
 80127ec:	65642065 65636976 00444920 69766564     e device ID.devi
 80127fc:	64616563 52007264 20646165 69766564     ceaddr.Read devi
 801280c:	61206563 65726464 72007373 00646165     ce address.read.
 801281c:	64616552 76656420 20656369 61726170     Read device para
 801282c:	6574656d 00007372                       meters..

08012834 <vx_sw_driving_data>:
 8012834:	48000018 00000020 00200000 48000018     ...H ..... ....H
 8012844:	00000040 00400000 48000010 00200000     @.....@....H.. .
 8012854:	00000020 6e6b6e75 006e776f               ...unknown.

08012860 <__func__.6378>:
 8012860:	336d6173 6c665f78 5f687361 00646d63     sam3x_flash_cmd.

08012870 <sam3x_cmd_list>:
 8012870:	0801292a 08005b9d 08012934 08012944     *)...[..4)..D)..
 8012880:	08005bd1 0801294e 00000000 00000000     .[..N)..........
 8012890:	00000000 203a7325 65736162 30203d20     ....%s: base = 0
 80128a0:	38302578 6320786c 3d20646d 25783020     x%08lx cmd = 0x%
 80128b0:	2c583230 67726120 30203d20 36302578     02X, arg = 0x%06
 80128c0:	41000a58 6c656d74 4d415320 41005833     X..Atmel SAM3X.A
 80128d0:	6c656d74 4d415320 47005533 4d564e50     tmel SAM3U.GPNVM
 80128e0:	7830203a 58383025 7375000a 3a656761     : 0x%08X..usage:
 80128f0:	6e6f6d20 726f7469 6e706720 735f6d76      monitor gpnvm_s
 8012900:	3c207465 3e746962 61763c20 000a3e6c     et <bit> <val>..
 8012910:	656d7441 4153206c 2f4e334d 74410053     Atmel SAM3N/S.At
 8012920:	206c656d 344d4153 70670053 5f6d766e     mel SAM4S.gpnvm_
 8012930:	00746567 20746547 4e565047 6176204d     get.Get GPVNM va
 8012940:	0065756c 766e7067 65735f6d 65530074     lue.gpnvm_set.Se
 8012950:	50472074 204d4e56 00746962              t GPVNM bit.

0801295c <__ram_size>:
 801295c:	0000c000 00000400 00000800 00001800     ................
 801296c:	00006000 00001000 00014000 00028000     .`.......@......
 801297c:	00002000 00004000 00008000 00010000     . ...@..........
 801298c:	00020000 00040000 00018000 00080000     ................

0801299c <__nvp_size>:
 801299c:	00000000 00002000 00004000 00008000     ..... ...@......
 80129ac:	00000000 00010000 00000000 00020000     ................
 80129bc:	00000000 00040000 00080000 00000000     ................
 80129cc:	00100000 00000000 00200000 00000000     .......... .....
 80129dc:	4d41530a 203a4c34 346d6173 6c665f6c     .SAM4L: sam4l_fl
 80129ec:	5f687361 6d6d6f63 3a646e61 52534620     ash_command: FSR
 80129fc:	7830203a 78383025 6170202c 3d206567     : 0x%08x, page =
 8012a0c:	2c642520 6d6f6320 646e616d 25203d20      %d, command = %
 8012a1c:	0a000a64 344d4153 73203a4c 6c346d61     d...SAM4L: sam4l
 8012a2c:	616c665f 635f6873 616d6d6f 203a646e     _flash_command: 
 8012a3c:	20746f4e 64616572 53202179 75746174     Not ready! Statu
 8012a4c:	203d2073 30257830 000a7838 4d41530a     s = 0x%08x...SAM
 8012a5c:	203a4c34 346d6173 6c665f6c 5f687361     4L: sam4l_flash_
 8012a6c:	6d6d6f63 3a646e61 74725720 20676e69     command: Wrting 
 8012a7c:	6d6d6f63 20646e61 64726f77 25783020     command word 0x%
 8012a8c:	0a783830 4d415300 203a4c34 73616c66     08x..SAM4L: flas
 8012a9c:	72652068 20657361 72646461 20737365     h erase address 
 8012aac:	30257830 66207838 2520726f 79622064     0x%08x for %d by
 8012abc:	0a736574 41530a00 3a4c344d 6d617320     tes...SAM4L: sam
 8012acc:	665f6c34 6873616c 6972775f 625f6574     4l_flash_write_b
 8012adc:	203a6675 72646461 30203d20 38302578     uf: addr = 0x%08
 8012aec:	202c786c 206e656c 000a6425 344d4153     lx, len %d..SAM4
 8012afc:	45203a4c 6e657478 20646564 65736552     L: Extended Rese
 8012b0c:	530a0074 4c344d41 4d53203a 535f5041     t..SAM4L: SMAP_S
 8012b1c:	61682052 78302073 6c383025 0a000a78     R has 0x%08lx...
 8012b2c:	344d4153 52203a4c 74657365 69616620     SAM4L: Reset fai
 8012b3c:	2e64656c 414d5320 52535f50 73616820     led. SMAP_SR has
 8012b4c:	25783020 786c3830 530a000a 4c344d41      0x%08lx...SAM4L
 8012b5c:	7250203a 2065626f 636e7566 6e6f6974     : Probe function
 8012b6c:	6c616320 0064656c 656d7441 4153206c      called.Atmel SA
 8012b7c:	004c344d 4d41530a 203a4c34 204d4152     M4L..SAM4L: RAM 
 8012b8c:	7830203d 28207825 294b6425 4c46202c     = 0x%x (%dK), FL
 8012b9c:	20485341 7830203d 28207825 294b6425     ASH = 0x%x (%dK)
 8012bac:	530a000a 4c344d41 4153203a 204c344d     ...SAM4L: SAM4L 
 8012bbc:	656c6553 64657463 4153002e 3a4c344d     Selected..SAM4L:
 8012bcc:	72617420 5f746567 63656863 72655f6b      target_check_er
 8012bdc:	20726f72 75746572 64656e72 75727420     ror returned tru
 8012bec:	00000065                                e...

08012bf0 <samd_cmd_list>:
 8012bf0:	080118ba 0800639d 080118c5 08012dc3     .....c.......-..
 8012c00:	08006151 08012d9b 08012dc1 08006141     Qa...-...-..Aa..
 8012c10:	08012dce 08012ddc 0800636d 08012de5     .-...-..mc...-..
 8012c20:	080118df 08006321 08012e00 08012e15     ....!c..........
 8012c30:	08006271 08012e1b 08012e39 08006231     qb......9...1b..
 8012c40:	08012e4a 00000000 00000000 00000000     J...............
 8012c50:	20746553 20656874 75636573 79746972     Set the security
 8012c60:	74696220 6f592021 69772075 6e206c6c      bit! You will n
 8012c70:	20646565 69206f74 65757373 6f6d2720     eed to issue 'mo
 8012c80:	6f74696e 72652072 5f657361 7373616d     nitor erase_mass
 8012c90:	6f742027 656c6320 74207261 2e736968     ' to clear this.
 8012ca0:	424d000a 20545349 20746f6e 206e7572     ..MBIST not run 
 8012cb0:	20657564 70206f74 65746f72 6f697463     due to protectio
 8012cc0:	7265206e 2e726f72 424d000a 20545349     n error...MBIST 
 8012cd0:	6c696146 30204020 38302578 4d000a78     Fail @ 0x%08x..M
 8012ce0:	54534942 73615020 21646573 6553000a     BIST Passed!..Se
 8012cf0:	6c616972 6d754e20 3a726562 00783020     rial Number: 0x.
 8012d00:	78383025 65735500 6f522072 30203a77     %08x.User Row: 0
 8012d10:	38302578 38302578 45000a78 65736172     x%08x%08x..Erase
 8012d20:	69616620 2064656c 20657564 61206f74      failed due to a
 8012d30:	6f727020 74636574 206e6f69 6f727265      protection erro
 8012d40:	000a2e72 73617245 61662065 64656c69     r...Erase failed
 8012d50:	41000a2e 6c656d74 4d415320 25642544     ...Atmel SAMD%d%
 8012d60:	41642563 28207325 20766572 20296325     c%dA%s (rev %c) 
 8012d70:	4f525028 29313d54 6d744100 53206c65     (PROT=1).Atmel S
 8012d80:	25444d41 25632564 73254164 65722820     AMD%d%c%dA%s (re
 8012d90:	63252076 41530029 4c00444d 736b636f     v %c).SAMD.Locks
 8012da0:	616c6620 61206873 6e696167 73207473      flash against s
 8012db0:	69727570 2073756f 6d6d6f63 73646e61     purious commands
 8012dc0:	6c6e7500 5f6b636f 73616c66 6e550068     .unlock_flash.Un
 8012dd0:	6b636f6c 6c662073 00687361 72657375     locks flash.user
 8012de0:	776f725f 69725000 2073746e 72657375     _row.Prints user
 8012df0:	776f7220 6f726620 6c66206d 00687361      row from flash.
 8012e00:	6e697250 73207374 61697265 756e206c     Prints serial nu
 8012e10:	7265626d 69626d00 52007473 20736e75     mber.mbist.Runs 
 8012e20:	20656874 6c697562 6e692d74 6d656d20     the built-in mem
 8012e30:	2079726f 74736574 74657300 6365735f     ory test.set_sec
 8012e40:	74697275 69625f79 65530074 74207374     urity_bit.Sets t
 8012e50:	53206568 72756365 20797469 00746942     he Security Bit.

08012e60 <stm32f1_flash_write_stub>:
 8012e60:	4c092300 d2094293 4d082601 5acd602e     .#.L.B...&.M.`.Z
 8012e70:	682552c5 d4fc07ed e7f23302 68222314     .R%h.....3...#"h
 8012e80:	d000421a be00be01 4002200c 40022010     .B....... .@. .@

08012e90 <stm32f1_cmd_list>:
 8012e90:	080118ba 08006851 080118c5 08012fe1     ....Qh......./..
 8012ea0:	08006929 08012fe8 00000000 00000000     )i.../..........
 8012eb0:	00000000 73617265 65440065 65636976     ....erase.Device
 8012ec0:	20736920 64616552 6f725020 74636574      is Read Protect
 8012ed0:	000a6465 20657355 6e6f6d22 726f7469     ed..Use "monitor
 8012ee0:	74706f20 206e6f69 73617265 74202265      option erase" t
 8012ef0:	6e75206f 746f7270 2c746365 61726520     o unprotect, era
 8012f00:	676e6973 76656420 0a656369 61737500     sing device..usa
 8012f10:	203a6567 696e6f6d 20726f74 6974706f     ge: monitor opti
 8012f20:	65206e6f 65736172 7375000a 3a656761     on erase..usage:
 8012f30:	6e6f6d20 726f7469 74706f20 206e6f69      monitor option 
 8012f40:	6464613c 3c203e72 756c6176 000a3e65     <addr> <value>..
 8012f50:	30257830 203a5838 30257830 000a5834     0x%08X: 0x%04X..
 8012f60:	334d5453 20314632 6964656d 64206d75     STM32F1 medium d
 8012f70:	69736e65 53007974 32334d54 2f444c20     ensity.STM32 LD/
 8012f80:	5300444d 32334d54 68203146 20686769     MD.STM32F1 high 
 8012f90:	736e6564 00797469 334d5453 44482032     density.STM32 HD
 8012fa0:	004c432f 334d5453 00334632 334d5453     /CL.STM32F3.STM3
 8012fb0:	33304632 4d545300 30463233 54530034     2F03.STM32F04.ST
 8012fc0:	4632334d 53003530 32334d54 00373046     M32F05.STM32F07.
 8012fd0:	334d5453 39304632 4d545300 30463233     STM32F09.STM32F0
 8012fe0:	74706f00 006e6f69 696e614d 616c7570     .option.Manipula
 8012ff0:	6f206574 6f697470 7962206e 00736574     te option bytes.

08013000 <stm32f4_flash_write_stub>:
 8013000:	4c0a2300 d20b4293 4d0a4e09 58cd602e     .#.L.B...N.M.`.X
 8013010:	f3bf50c5 68258f4f d4fc03ed e7f03304     .P..O.%h.....3..
 8013020:	682223f2 d000421a be00be01 40023c0c     .#"h.B.......<.@
 8013030:	00000201 40023c10                       .....<.@

08013038 <stm32f2_driver_str>:
 8013038:	334d5453 78324632 54530078                       STM32F2xx.

08013042 <stm32f4_driver_str>:
 8013042:	334d5453 78344632 18ba0078                       STM32F4xx.

0801304c <stm32f4_cmd_list>:
 801304c:	080118ba 08006e89 080118c5 08012fe1     .....n......./..
 801305c:	08006d19 08012fe8 00000000 00000000     .m.../..........
 801306c:	00000000                                ....

08013070 <stm32f7_driver_str>:
 8013070:	334d5453 78374632 00000078 74697277     STM32F7xx...writ
 8013080:	73750065 3a656761 6e6f6d20 726f7469     e.usage: monitor
 8013090:	74706f20 206e6f69 74697277 763c2065      option write <v
 80130a0:	65756c61 45000a3e 69736172 6620676e     alue>..Erasing f
 80130b0:	6873616c 202e2e2e 73696854 79616d20     lash... This may
 80130c0:	6b617420 20612065 20776566 6f636573      take a few seco
 80130d0:	2e73646e 08002020 7c006325 005c2d2f     nds.  ..%c.|/-\.
 80130e0:	334d5453 00324632 334d5453 00344632     STM32F2.STM32F4.
 80130f0:	334d5453 00374632                       STM32F7.

080130f8 <stm32lx_cmd_list>:
 80130f8:	08012fe1 08007501 08012fe8 0801350d     ./...u.../...5..
 8013108:	080078a9 08013514 00000000 00000000     .x...5..........
 8013118:	00000000 00525245 62616e75 7420656c     ....ERR.unable t
 8013128:	6e75206f 6b636f6c 4d564e20 74706f20     o unlock NVM opt
 8013138:	206e6f69 65747962 6f000a73 6c5f6c62     ion bytes..obl_l
 8013148:	636e7561 61720068 61720077 30252077     aunch.raw.raw %0
 8013158:	3c207838 3025202d 000a7838 6974706f     8x <- %08x..opti
 8013168:	77206e6f 65746972 69616620 0a64656c     on write failed.
 8013178:	69727700 25206574 20783830 25202d3c     .write %08x <- %
 8013188:	0a783830 6f687300 78300077 78383025     08x..show.0x%08x
 8013198:	7830203a 78343025 25783020 20783430     : 0x%04x 0x%04x 
 80131a8:	000a7325 5254504f 7830203a 78383025     %s..OPTR: 0x%08x
 80131b8:	4452202c 20545250 202c6425 4d525053     , RDPRT %d, SPRM
 80131c8:	64252044 4f42202c 64252052 4457202c     D %d, BOR %d, WD
 80131d8:	57535f47 2c642520 53526e20 54535f54     G_SW %d, nRST_ST
 80131e8:	64252050 526e202c 535f5453 20594254     P %d, nRST_STBY 
 80131f8:	202c6425 4246426e 64252032 504f000a     %d, nBFB2 %d..OP
 8013208:	203a5254 30257830 202c7838 52504452     TR: 0x%08x, RDPR
 8013218:	2520544f 57202c64 4f4d5250 64252044     OT %d, WPRMOD %d
 8013228:	4457202c 57535f47 2c642520 4f4f4220     , WDG_SW %d, BOO
 8013238:	25203154 75000a64 65676173 6f6d203a     T1 %d..usage: mo
 8013248:	6f74696e 706f2072 6e6f6974 52415b20     nitor option [AR
 8013258:	0a5d5347 73202000 20776f68 20202020     GS]..  show     
 8013268:	20202020 20202020 20202020 202d2020                   - 
 8013278:	776f6853 74706f20 736e6f69 206e6920     Show options in 
 8013288:	204d564e 20646e61 6c207361 6564616f     NVM and as loade
 8013298:	20000a64 6c626f20 75616c5f 2068636e     d..  obl_launch 
 80132a8:	20202020 20202020 20202020 6552202d                 - Re
 80132b8:	64616f6c 74706f20 736e6f69 6f726620     load options fro
 80132c8:	564e206d 20000a4d 69727720 3c206574     m NVM..  write <
 80132d8:	72646461 763c203e 65756c61 203e3631     addr> <value16> 
 80132e8:	6553202d 706f2074 6e6f6974 6c616820     - Set option hal
 80132f8:	6f772d66 203b6472 706d6f63 656d656c     f-word; compleme
 8013308:	6320746e 75706d6f 0a646574 72202000     nt computed..  r
 8013318:	3c207761 72646461 763c203e 65756c61     aw <addr> <value
 8013328:	203e3233 202d2020 20746553 6974706f     32>   - Set opti
 8013338:	77206e6f 0a64726f 65685400 6c617620     on word..The val
 8013348:	6f206575 613c2066 3e726464 73756d20     ue of <addr> mus
 8013358:	65622074 726f7720 6c612064 656e6769     t be word aligne
 8013368:	6e612064 72662064 30206d6f 38302578     d and from 0x%08
 8013378:	6f742078 78302b20 000a7825 62616e75     x to +0x%x..unab
 8013388:	7420656c 6e75206f 6b636f6c 50454520     le to unlock EEP
 8013398:	0a4d4f52 74796200 72770065 20657469     ROM..byte.write 
 80133a8:	65747962 25783020 20783830 30202d3c     byte 0x%08x <- 0
 80133b8:	38302578 65000a78 6f727065 7277206d     x%08x..eeprom wr
 80133c8:	20657469 6c696166 000a6465 666c6168     ite failed..half
 80133d8:	64726f77 69727700 68206574 77666c61     word.write halfw
 80133e8:	2064726f 30257830 3c207838 7830202d     ord 0x%08x <- 0x
 80133f8:	78343025 7277000a 20657469 64726f77     %04x..write word
 8013408:	25783020 20783830 30202d3c 38302578      0x%08x <- 0x%08
 8013418:	75000a78 65676173 6f6d203a 6f74696e     x..usage: monito
 8013428:	65652072 6d6f7270 52415b20 0a5d5347     r eeprom [ARGS].
 8013438:	62202000 20657479 20202020 6464613c     .  byte     <add
 8013448:	3c203e72 756c6176 203e3865 57202d20     r> <value8>  - W
 8013458:	65746972 62206120 0a657479 68202000     rite a byte..  h
 8013468:	77666c61 2064726f 6464613c 3c203e72     alfword <addr> <
 8013478:	756c6176 3e363165 57202d20 65746972     value16> - Write
 8013488:	68206120 2d666c61 64726f77 2020000a      a half-word..  
 8013498:	64726f77 20202020 64613c20 203e7264     word     <addr> 
 80134a8:	6c61763c 32336575 202d203e 74697257     <value32> - Writ
 80134b8:	20612065 64726f77 6854000a 61762065     e a word..The va
 80134c8:	2065756c 3c20666f 72646461 756d203e     lue of <addr> mu
 80134d8:	69207473 6874206e 6e692065 76726574     st in the interv
 80134e8:	5b206c61 30257830 202c7838 78257830     al [0x%08x, 0x%x
 80134f8:	53000a29 32334d54 0078314c 334d5453     )..STM32L1x.STM3
 8013508:	78304c32 70656500 006d6f72 696e614d     2L0x.eeprom.Mani
 8013518:	616c7570 45206574 4f525045 564e284d     pulate EEPROM(NV
 8013528:	6164204d 20296174 6f6d656d 00007972     M data) memory..

08013538 <stm32l4_flash_write_stub>:
 8013538:	43141c04 07642300 be01d011 4c11e00f     ...C.#d........L
 8013548:	03ed6825 6826d4fb 422e4d0f 6825d115     %h....&h.M.B..%h
 8013558:	d51207ed 68252601 43353308 4c0b6025     .....&%h.35C%`.L
 8013568:	d20c4293 60254d0a 50c458cc 686518cc     .B...M%`.X.P..eh
 8013578:	606518c4 8f4ff3bf be01e7e1 2300e7ea     ..e`..O........#
 8013588:	be006023 40022010 0000c3fa 40022014     #`... .@..... .@
 8013598:	03000001                                ....

0801359c <stm32l4_driver_str>:
 801359c:	334d5453 78344c32 00000078              STM32L4xx...

080135a8 <stm32l4_cmd_list>:
 80135a8:	080118ba 08007d43 080118c5 0801360c     ....C}.......6..
 80135b8:	08007d39 08013618 08013638 08007d2d     9}...6..86..-}..
 80135c8:	08013644 08012fe1 08007bad 08012fe8     D6.../...{.../..
	...
 80135e4:	30257830 203a5838 30257830 000a7838     0x%08X: 0x%08x..
 80135f4:	30257830 203a5838 30257830 000a5838     0x%08X: 0x%08X..
 8013604:	334d5453 00344c32 73617265 61625f65     STM32L4.erase_ba
 8013614:	00316b6e 73617245 6e652065 65726974     nk1.Erase entire
 8013624:	6e616220 6620316b 6873616c 6d656d20      bank1 flash mem
 8013634:	0079726f 73617265 61625f65 00326b6e     ory.erase_bank2.
 8013644:	73617245 6e652065 65726974 6e616220     Erase entire ban
 8013654:	6620326b 6873616c 6d656d20 0079726f     k2 flash memory.
 8013664:	6d656d3c 2d79726f 3e70616d 656d3c00     <memory-map>.<me
 8013674:	79726f6d 70797420 72223d65 20226d61     mory type="ram" 
 8013684:	72617473 30223d74 38302578 2022786c     start="0x%08lx" 
 8013694:	676e656c 223d6874 6c257830 3e2f2278     length="0x%lx"/>
 80136a4:	656d3c00 79726f6d 70797420 66223d65     .<memory type="f
 80136b4:	6873616c 74732022 3d747261 25783022     lash" start="0x%
 80136c4:	786c3830 656c2022 6874676e 7830223d     08lx" length="0x
 80136d4:	22786c25 703c003e 65706f72 20797472     %lx">.<property 
 80136e4:	656d616e 6c62223d 736b636f 22657a69     name="blocksize"
 80136f4:	2578303e 2f3c786c 706f7270 79747265     >0x%lx</property
 8013704:	6d2f3c3e 726f6d65 3c003e79 6d656d2f     ></memory>.</mem
 8013714:	2d79726f 3e70616d 20732500 63657073     ory-map>.%s spec
 8013724:	63696669 6d6f6320 646e616d 000a3a73     ific commands:..

08013734 <xt_runtime_does>:
 8013734:	00000000 080149da 00000000 08008745     .....I......E...

08013744 <__func__.5635>:
 8013744:	68737570 00000000                       push....

0801374c <xt_runtime_branch_on_false>:
 801374c:	00000000 08014957 00000000 08008f1d     ....WI..........

0801375c <xt_runtime_branch>:
 801375c:	00000000 08014978 00000000 08008765     ....xI......e...

0801376c <__func__.5613>:
 801376c:	00706f70                                pop.

08013770 <xt_runtime_literal>:
 8013770:	00000000 08014990 00000000 08008b35     .....I......5...

08013780 <__func__.5654>:
 8013780:	00706f74                                top.

08013784 <__func__.5622>:
 8013784:	64706f70 73757000                                popd.

08013789 <__func__.5643>:
 8013789:	68737570 6f640064                                pushd.

0801378f <__func__.6710>:
 801378f:	6e5f6f64 65626d75 69735f72 30006e67              do_number_sign.

0801379e <digs.6706>:
 801379e:	33323130 37363534 42413938 46454443     0123456789ABCDEF
 80137ae:	4a494847 4e4d4c4b 5251504f 56555453     GHIJKLMNOPQRSTUV
 80137be:	5a595857                                WXYZ

080137c2 <__func__.5659>:
 80137c2:	64706f74 5f6f6400                                topd.

080137c7 <__func__.6722>:
 80137c7:	745f6f64 006b6369                       do_tick.

080137cf <__func__.5617>:
 80137cf:	706f7073 75707300                                spop.

080137d4 <__func__.5639>:
 80137d4:	73757073 6f640068                                spush.

080137da <__func__.6738>:
 80137da:	735f6f64 5f726174 73616c73 6f640068              do_star_slash.

080137e8 <__func__.6746>:
 80137e8:	735f6f64 5f726174 73616c73 6f6d5f68     do_star_slash_mo
 80137f8:	70720064                                         d.

080137fa <__func__.5631>:
 80137fa:	706f7072 75646400                                rpop.

080137ff <__func__.5672>:
 80137ff:	70756464 746f7200                                ddup.

08013804 <__func__.5696>:
 8013804:	00746f72                                rot.

08013808 <__func__.6779>:
 8013808:	735f6f64 6873616c 5f6f6400                       do_slash.

08013811 <__func__.6784>:
 8013811:	735f6f64 6873616c 646f6d5f 6f777400              do_slash_mod.

0801381e <__func__.5692>:
 801381e:	5f6f7774 7265766f 75707200                       two_over.

08013827 <__func__.5650>:
 8013827:	73757072 6f640068                                rpush.

0801382d <__func__.6832>:
 801382d:	735f6f64 63696d65 6e6f6c6f 5f6f6400              do_semicolon.

0801383a <__func__.6954>:
 801383a:	635f6f64 74616572 6f640065                       do_create.

08013844 <__func__.6828>:
 8013844:	635f6f64 6e6f6c6f 61777300                       do_colon.

0801384d <__func__.5668>:
 801384d:	70617773 6f707300                                swap.

08013852 <__func__.5627>:
 8013852:	706f7073 6f640064                                spopd.

08013858 <__func__.7012>:
 8013858:	665f6f64 735f6d5f 6873616c 646f6d5f     do_f_m_slash_mod
	...

08013869 <__func__.7022>:
 8013869:	695f6f64 5f6f6400                                do_i.

0801386e <__func__.7035>:
 801386e:	6a5f6f64 6f777400                                do_j.

08013873 <__func__.5684>:
 8013873:	5f6f7774 65665f72 00686374              two_r_fetch.

0801387f <__func__.7076>:
 801387f:	6d5f6f64 6f00646f                                do_mod.

08013886 <__func__.5688>:
 8013886:	7265766f 6f747200                                over.

0801388b <__func__.5663>:
 801388b:	706f7472 5f6f6400                                rtop.

08013890 <__func__.7145>:
 8013890:	735f6f64 735f6d5f 6873616c 6d65725f     do_s_m_slash_rem
	...

080138a1 <__func__.5705>:
 80138a1:	6b636970 6f777400                                pick.

080138a6 <__func__.5676>:
 80138a6:	5f6f7774 725f6f74 6f777400                       two_to_r.

080138af <__func__.5680>:
 80138af:	5f6f7774 72665f72 64006d6f                       two_r_from.

080138ba <__func__.7266>:
 80138ba:	635f6f64 6e6f6c6f 5f6f6e5f 656d616e     do_colon_no_name
	...

080138cb <__func__.6695>:
 80138cb:	7478656e 6d79735f 00000000                       next_sym.

080138d4 <xt_runtime_loop>:
 80138d4:	00000000 080149c4 00000000 0800a0b1     .....I..........

080138e4 <__func__.7097>:
 80138e4:	705f6f64 7074736f 00656e6f              do_postpone.

080138f0 <xt_runtime_plus_loop>:
 80138f0:	00000000 080149a9 00000000 0800989d     .....I..........

08013900 <__func__.7399>:
 8013900:	745f6f64 7572006f                                do_to.

08013906 <__func__.6643>:
 8013906:	746e7572 5f656d69 6f6c6f63 6f64006e              runtime_colon.

08013914 <__func__.7389>:
 8013914:	735f6f64 6361625f 616c736b 715f6873     do_s_backslash_q
 8013924:	65746f75 00000000                       uote....

0801392c <dictionary>:
 801392c:	00000000 08014956 00000000 00000000     ....VI..........
 801393c:	0801392c 08014953 00000000 080093b9     ,9..SI..........
 801394c:	0801393c 08014950 00000000 080096cb     <9..PI..........
 801395c:	0801394c 0801494c 00000000 080093c3     L9..LI..........
 801396c:	0801395c 08014948 00000000 08009761     \9..HI......a...
 801397c:	0801396c 08014945 00000000 08009831     l9..EI......1...
 801398c:	0801397c 08014942 00000001 0800913d     |9..BI......=...
 801399c:	0801398c 0801493f 00000000 080093e5     .9..?I..........
 80139ac:	0801399c 0801493b 00000000 08009a1f     .9..;I..........
 80139bc:	080139ac 08014934 00000000 08009a61     .9..4I......a...
 80139cc:	080139bc 08014931 00000000 080093f3     .9..1I..........
 80139dc:	080139cc 0801492d 00000000 08009401     .9..-I..........
 80139ec:	080139dc 08014926 00000001 0800a531     .9..&I......1...
 80139fc:	080139ec 08014923 00000000 08008d01     .9..#I..........
 8013a0c:	080139fc 08014920 00000000 0800940f     .9.. I..........
 8013a1c:	08013a0c 0801491d 00000000 08009b99     .:...I..........
 8013a2c:	08013a1c 08014919 00000001 0800a4c1     .:...I..........
 8013a3c:	08013a2c 08014916 00000000 08009c5f     ,:...I......_...
 8013a4c:	08013a3c 08014910 00000000 08009c85     <:...I..........
 8013a5c:	08013a4c 0801490c 00000000 08009939     L:...I......9...
 8013a6c:	08013a5c 08014908 00000000 08008d21     \:...I......!...
 8013a7c:	08013a6c 08014904 00000000 08008d33     l:...I......3...
 8013a8c:	08013a7c 08014900 00000000 08008d41     |:...I......A...
 8013a9c:	08013a8c 080148fc 00000000 08008d4f     .:...H......O...
 8013aac:	08013a9c 080148f8 00000000 08008d65     .:...H......e...
 8013abc:	08013aac 080148f4 00000000 080099b9     .:...H..........
 8013acc:	08013abc 080148f0 00000000 08008d73     .:...H......s...
 8013adc:	08013acc 080148e9 00000000 0800944d     .:...H......M...
 8013aec:	08013adc 080148e3 00000000 080097d1     .:...H..........
 8013afc:	08013aec 080148dc 00000000 08009cbd     .:...H..........
 8013b0c:	08013afc 080148d5 00000000 08009585     .:...H..........
 8013b1c:	08013b0c 080148d2 00000000 08009ea9     .;...H..........
 8013b2c:	08013b1c 080148cf 00000001 08009d49     .;...H......I...
 8013b3c:	08013b2c 080148cc 00000000 08009455     ,;...H......U...
 8013b4c:	08013b3c 080148c8 00000000 08008791     <;...H..........
 8013b5c:	08013b4c 080148c5 00000000 0800946b     L;...H......k...
 8013b6c:	08013b5c 080148c2 00000000 0800947f     \;...H..........
 8013b7c:	08013b6c 080148bb 00000000 08008d89     l;...H..........
 8013b8c:	08013b7c 080148b6 00000000 08008aa1     |;...H..........
 8013b9c:	08013b8c 080148ad 00000000 080095a9     .;...H..........
 8013bac:	08013b9c 080148a9 00000000 08009d3d     .;...H......=...
 8013bbc:	08013bac 080148a3 00000000 0800936d     .;...H......m...
 8013bcc:	08013bbc 080148a0 00000000 08008d97     .;...H..........
 8013bdc:	08013bcc 08014899 00000000 080088ad     .;...H..........
 8013bec:	08013bdc 08014891 00000001 0800a4d5     .;...H..........
 8013bfc:	08013bec 0801488c 00000000 080099c7     .;...H..........
 8013c0c:	08013bfc 08014885 00000000 0800879d     .;...H..........
 8013c1c:	08013c0c 0801487c 00000000 08008da5     .<..|H..........
 8013c2c:	08013c1c 08014875 00000000 08008db7     .<..uH..........
 8013c3c:	08013c2c 08014870 00000000 08009495     ,<..pH..........
 8013c4c:	08013c3c 0801486a 00000000 08008ab1     <<..jH..........
 8013c5c:	08013c4c 08014863 00000001 08008ac1     L<..cH..........
 8013c6c:	08013c5c 0801485f 00000000 08008ad1     \<.._H..........
 8013c7c:	08013c6c 0801485b 00000000 080094a3     l<..[H..........
 8013c8c:	08013c7c 08014857 00000000 08008dcd     |<..WH..........
 8013c9c:	08013c8c 08014853 00000000 08008de5     .<..SH..........
 8013cac:	08013c9c 0801484c 00000000 08008df3     .<..LH..........
 8013cbc:	08013cac 08014845 00000000 08008e01     .<..EH..........
 8013ccc:	08013cbc 0801483f 00000000 08009185     .<..?H..........
 8013cdc:	08013ccc 08014838 00000000 08008e0f     .<..8H..........
 8013cec:	08013cdc 08014831 00000000 08008e1d     .<..1H..........
 8013cfc:	08013cec 08014827 00000000 08009dfd     .<..'H..........
 8013d0c:	08013cfc 08014820 00000000 08008e29     .<.. H......)...
 8013d1c:	08013d0c 0801481c 00000000 08008e53     .=...H......S...
 8013d2c:	08013d1c 08014814 00000000 08009d85     .=...H..........
 8013d3c:	08013d2c 0801480b 00000000 080087b1     ,=...H..........
 8013d4c:	08013d3c 08014804 00000000 080099d9     <=...H..........
 8013d5c:	08013d4c 08014800 00000001 0800a3fd     L=...H..........
 8013d6c:	08013d5c 080147f9 00000001 080087bd     \=...G..........
 8013d7c:	08013d6c 080147f3 00000000 08008e3f     l=...G......?...
 8013d8c:	08013d7c 080147ee 00000000 08009b49     |=...G......I...
 8013d9c:	08013d8c 080147e8 00000001 08009f29     .=...G......)...
 8013dac:	08013d9c 080147e2 00000000 08008e47     .=...G......G...
 8013dbc:	08013dac 080147d8 00000000 0800a85d     .=...G......]...
 8013dcc:	08013dbc 080147cf 00000000 08008e6d     .=...G......m...
 8013ddc:	08013dcc 080147c9 00000001 080087d9     .=...G..........
 8013dec:	08013ddc 080147c3 00000000 08008e8d     .=...G..........
 8013dfc:	08013dec 080147bd 00000000 08008ea9     .=...G..........
 8013e0c:	08013dfc 080147b5 00000000 08009f89     .=...G..........
 8013e1c:	08013e0c 080147af 00000000 08008b01     .>...G..........
 8013e2c:	08013e1c 080147a9 00000000 08008f05     .>...G..........
 8013e3c:	08013e2c 080147a6 00000000 08009ff1     ,>...G..........
 8013e4c:	08013e3c 080147a2 00000001 08008b11     <>...G..........
 8013e5c:	08013e4c 08014797 00000000 080087ed     L>...G..........
 8013e6c:	08013e5c 0801478f 00000000 08008f41     \>...G......A...
 8013e7c:	08013e6c 0801478c 00000000 0800a025     l>...G......%...
 8013e8c:	08013e7c 08014785 00000001 0800a56d     |>...G......m...
 8013e9c:	08013e8c 0801477c 00000001 08008f4f     .>..|G......O...
 8013eac:	08013e9c 08014776 00000001 0800a415     .>..vG..........
 8013ebc:	08013eac 0801476e 00000000 080094ad     .>..nG..........
 8013ecc:	08013ebc 0801476a 00000000 0800969d     .>..jG..........
 8013edc:	08013ecc 08014765 00000000 080099e9     .>..eG..........
 8013eec:	08013edc 08014760 00000000 080099fd     .>..`G..........
 8013efc:	08013eec 0801475b 00000000 0800a0db     .>..[G..........
 8013f0c:	08013efc 08014755 00000000 08008f71     .>..UG......q...
 8013f1c:	08013f0c 0801474d 00000000 08009a11     .?..MG..........
 8013f2c:	08013f1c 08014749 00000000 080094bb     .?..IG..........
 8013f3c:	08013f2c 08014743 00000000 0800a105     ,?..CG..........
 8013f4c:	08013f3c 08014739 00000001 0800a45d     <?..9G......]...
 8013f5c:	08013f4c 08014733 00000000 0800ac81     L?..3G..........
 8013f6c:	08013f5c 0801472f 00000000 08009af1     \?../G..........
 8013f7c:	08013f6c 0801472b 00000000 0800a145     l?..+G......E...
 8013f8c:	08013f7c 08014722 00000001 08008801     |?.."G..........
 8013f9c:	08013f8c 0801471a 00000001 08008fbd     .?...G..........
 8013fac:	08013f9c 08014715 00000000 08009bdd     .?...G..........
 8013fbc:	08013fac 0801470d 00000000 080094c9     .?...G..........
 8013fcc:	08013fbc 08014709 00000001 0800a4ad     .?...G..........
 8013fdc:	08013fcc 08014704 00000000 08009947     .?...G......G...
 8013fec:	08013fdc 080146fe 00000000 08009955     .?...F......U...
 8013ffc:	08013fec 080146f6 00000000 0800a179     .?...F......y...
 801400c:	08013ffc 080146ee 00000000 08008b4d     .?...F......M...
 801401c:	0801400c 080146e7 00000000 08008e61     .@...F......a...
 801402c:	0801401c 080146df 00000000 08008f8f     .@...F..........
 801403c:	0801402c 080146d8 00000000 08008b65     ,@...F......e...
 801404c:	0801403c 080146d2 00000000 08009f39     <@...F......9...
 801405c:	0801404c 080146cc 00000001 08008fa5     L@...F..........
 801406c:	0801405c 080146c6 00000000 08008fe9     \@...F..........
 801407c:	0801406c 080146c2 00000000 08009771     l@...F......q...
 801408c:	0801407c 080146be 00000000 080094d7     |@...F..........
 801409c:	0801408c 080146b9 00000000 080096b5     .@...F..........
 80140ac:	0801409c 080146b1 00000000 080094e7     .@...F..........
 80140bc:	080140ac 080146a9 00000001 0800a519     .@...F..........
 80140cc:	080140bc 080146a2 00000001 0800900d     .@...F..........
 80140dc:	080140cc 08014698 00000000 08009e29     .@...F......)...
 80140ec:	080140dc 08014691 00000001 0800a589     .@...F..........
 80140fc:	080140ec 0801468b 00000000 080091ab     .@...F..........
 801410c:	080140fc 08014686 00000000 08009519     .@...F..........
 801411c:	0801410c 08014683 00000001 08008819     .A...F..........
 801412c:	0801411c 0801467e 00000001 0800985d     .A..~F......]...
 801413c:	0801412c 08014676 00000001 0800924d     ,A..vF......M...
 801414c:	0801413c 08014673 00000001 08008825     <A..sF......%...
 801415c:	0801414c 0801466f 00000001 080097dd     LA..oF..........
 801416c:	0801415c 0801466b 00000000 08009be5     \A..kF..........
 801417c:	0801416c 08014666 00000000 08009035     lA..fF......5...
 801418c:	0801417c 08014662 00000000 08009975     |A..bF......u...
 801419c:	0801418c 0801465d 00000000 0800a249     .A..]F......I...
 80141ac:	0801419c 08014658 00000000 0800a2a1     .A..XF..........
 80141bc:	080141ac 08014653 00000000 0800a0d3     .A..SF..........
 80141cc:	080141bc 0801464a 00000001 0800a2f9     .A..JF..........
 80141dc:	080141cc 08014646 00000000 08009527     .A..FF......'...
 80141ec:	080141dc 08014641 00000001 0800a5b1     .A..AF..........
 80141fc:	080141ec 0801463a 00000001 08009047     .A..:F......G...
 801420c:	080141fc 08014631 00000000 08009e3d     .A..1F......=...
 801421c:	0801420c 0801462d 00000000 0800926f     .B..-F......o...
 801422c:	0801421c 08014627 00000001 08008b75     .B..'F......u...
 801423c:	0801422c 0801461d 00000000 08008d19     ,B...F..........
 801424c:	0801423c 08014614 00000001 0800a611     <B...F..........
 801425c:	0801424c 0801460d 00000001 08009c31     LB...F......1...
 801426c:	0801425c 08014606 00000000 08009071     \B...F......q...
 801427c:	0801426c 080145ff 00000000 08008b7f     lB...E..........
 801428c:	0801427c 080145fa 00000000 08008835     |B...E......5...
 801429c:	0801428c 080145f2 00000000 08009e49     .B...E......I...
 80142ac:	0801429c 080145ed 00000000 08009f41     .B...E......A...
 80142bc:	080142ac 080145e9 00000001 0800a631     .B...E......1...
 80142cc:	080142bc 080145e4 00000000 08008b89     .B...E..........
 80142dc:	080142cc 080145dd 00000000 08009087     .B...E..........
 80142ec:	080142dc 080145d1 00000000 08009131     .B...E......1...
 80142fc:	080142ec 080145cb 00000000 0800a241     .B...E......A...
 801430c:	080142fc 080145c3 00000000 08008b99     .B...E..........
 801431c:	0801430c 080145b4 00000000 080092b9     .C...E..........
 801432c:	0801431c 080145ae 00000000 0800a239     .C...E......9...
 801433c:	0801432c 080145a9 00000001 0800a8dd     ,C...E..........
 801434c:	0801433c 0801459d 00000000 08008c15     <C...E..........
 801435c:	0801434c 08014592 00000000 08008c39     LC...E......9...
 801436c:	0801435c 0801458e 00000001 0800a659     \C...E......Y...
 801437c:	0801436c 08014588 00000000 08008c49     lC...E......I...
 801438c:	0801437c 08014582 00000000 08009c4f     |C...E......O...
 801439c:	0801438c 0801457d 00000000 08009795     .C..}E..........
 80143ac:	0801439c 08014579 00000000 0800953b     .C..yE......;...
 80143bc:	080143ac 08014571 00000000 0800941d     .C..qE..........
 80143cc:	080143bc 0801456a 00000000 08009e7d     .C..jE......}...
 80143dc:	080143cc 08014562 00000000 080092e9     .C..bE..........
 80143ec:	080143dc 0801455f 00000001 080088d9     .C.._E..........
 80143fc:	080143ec 08014558 00000001 08008c69     .C..XE......i...
 801440c:	080143fc 08014551 00000000 08008841     .C..QE......A...
 801441c:	0801440c 0801454c 00000000 080088c9     .D..LE..........
 801442c:	0801441c 08014544 00000000 08008c8d     .D..DE..........
 801443c:	0801442c 0801453c 00000000 08008c9d     ,D..<E..........
 801444c:	0801443c 08014532 00000000 0800a9dd     <D..2E..........
 801445c:	0801444c 0801452e 00000000 0800ab45     LD...E......E...
 801446c:	0801445c 08014527 00000000 0800932d     \D..'E......-...
 801447c:	0801446c 08014524 00000000 08009bcd     lD..$E..........
 801448c:	0801447c 0801451e 00000000 0800ab89     |D...E..........
 801449c:	0801448c 08014515 00000000 08008cad     .D...E..........
 80144ac:	0801449c 08014508 00000000 08008cbd     .D...E..........
 80144bc:	080144ac 08014500 00000000 08008843     .D...E......C...
 80144cc:	080144bc 080144f6 00000000 08008855     .D...D......U...
 80144dc:	080144cc 080144ec 00000000 08008869     .D...D......i...

080144ec <__compound_literal.193>:
 80144ec:	2d667308 65736572 75080074                       .sf-reset.

080144f6 <__compound_literal.192>:
 80144f6:	736e7508 6764756d 73060065                       .unsmudge.

08014500 <__compound_literal.191>:
 8014500:	756d7306 00656764                       .smudge.

08014508 <__compound_literal.190>:
 8014508:	6c6f630b 642d6e6f 67756265 72630700              .colon-debug.

08014515 <__compound_literal.189>:
 8014515:	2d726307 6f686365 75640400                       .cr-echo.

0801451e <__compound_literal.188>:
 801451e:	6d756404 3f010070                                .dump.

08014524 <__compound_literal.187>:
 8014524:	05003f01                                         .?.

08014527 <__compound_literal.186>:
 8014527:	616e3e05 0200656d                                .>name.

0801452e <__compound_literal.185>:
 801452e:	00732e02                                ..s.

08014532 <__compound_literal.184>:
 8014532:	636e6908 6564756c 6a060064                       .included.

0801453c <__compound_literal.183>:
 801453c:	706d6a06 00766e65                       .jmpenv.

08014544 <__compound_literal.182>:
 8014544:	74616c06 00747365                       .latest.

0801454c <__compound_literal.181>:
 801454c:	65796203 72620500                                .bye.

08014551 <__compound_literal.180>:
 8014551:	65726205 05006b61                                .break.

08014558 <__compound_literal.179>:
 8014558:	65686105 01006461                                .ahead.

0801455f <__compound_literal.178>:
 801455f:	06005c01                                         .\.

08014562 <__compound_literal.177>:
 8014562:	74697706 006e6968                       .within.

0801456a <__compound_literal.176>:
 801456a:	6c617605 06006575                                .value.

08014571 <__compound_literal.175>:
 8014571:	756e7506 00646573                       .unused.

08014579 <__compound_literal.174>:
 8014579:	003e7502                                .u>.

0801457d <__compound_literal.173>:
 801457d:	722e7503 75740400                                .u.r.

08014582 <__compound_literal.172>:
 8014582:	63757404 7404006b                                .tuck.

08014588 <__compound_literal.171>:
 8014588:	75727404 74020065                                .true.

0801458e <__compound_literal.170>:
 801458e:	006f7402                                .to.

08014592 <__compound_literal.169>:
 8014592:	756f7309 2d656372 0a006469                       .source-id.

0801459d <__compound_literal.168>:
 801459d:	7661730a 6e692d65 00747570              .save-input.

080145a9 <__compound_literal.167>:
 80145a9:	225c7303 6f720400                                .s\".

080145ae <__compound_literal.166>:
 80145ae:	6c6f7204 720d006c                                .roll.

080145b4 <__compound_literal.165>:
 80145b4:	7365720d 65726f74 706e692d 06007475              .restore-input.

080145c3 <__compound_literal.164>:
 80145c3:	66657206 006c6c69                       .refill.

080145cb <__compound_literal.163>:
 80145cb:	63697004 700a006b                                .pick.

080145d1 <__compound_literal.162>:
 80145d1:	7261700a 6e2d6573 00656d61              .parse-name.

080145dd <__compound_literal.161>:
 80145dd:	72617005 03006573                                .parse.

080145e4 <__compound_literal.160>:
 80145e4:	64617003 666f0200                                .pad.

080145e9 <__compound_literal.159>:
 80145e9:	00666f02                                .of.

080145ed <__compound_literal.158>:
 80145ed:	70696e03 616d0600                                .nip.

080145f2 <__compound_literal.157>:
 80145f2:	72616d06 0072656b                       .marker.

080145fa <__compound_literal.156>:
 80145fa:	78656803 61660500                                .hex.

080145ff <__compound_literal.155>:
 80145ff:	6c616605 05006573                                .false.

08014606 <__compound_literal.154>:
 8014606:	61726505 05006573                                .erase.

0801460d <__compound_literal.153>:
 801460d:	646e6505 0700666f                                .endof.

08014614 <__compound_literal.152>:
 8014614:	646e6507 65736163 6f630800                       .endcase.

0801461d <__compound_literal.151>:
 801461d:	6d6f6308 656c6970 6304002c                       .compile,.

08014627 <__compound_literal.150>:
 8014627:	73616304 63020065                                .case.

0801462d <__compound_literal.149>:
 801462d:	00226302                                .c".

08014631 <__compound_literal.148>:
 8014631:	66756207 3a726566 67610500                       .buffer:.

0801463a <__compound_literal.147>:
 801463a:	61676105 03006e69                                .again.

08014641 <__compound_literal.146>:
 8014641:	6f643f03 3e3c0200                                .?do.

08014646 <__compound_literal.145>:
 8014646:	003e3c02                                .<>.

0801464a <__compound_literal.144>:
 801464a:	6f6e3a07 656d616e 72320300                       .:noname.

08014653 <__compound_literal.143>:
 8014653:	40723203 72320300                                .2r@.

08014658 <__compound_literal.142>:
 8014658:	3e723203 3e320300                                .2r>.

0801465d <__compound_literal.141>:
 801465d:	723e3203 3e300200                                .2>r.

08014662 <__compound_literal.140>:
 8014662:	003e3002                                .0>.

08014666 <__compound_literal.139>:
 8014666:	3e3c3003 722e0200                                .0<>.

0801466b <__compound_literal.138>:
 801466b:	00722e02                                ..r.

0801466f <__compound_literal.137>:
 801466f:	00282e02                                ..(.

08014673 <__compound_literal.136>:
 8014673:	06005d01                                         .].

08014676 <__compound_literal.135>:
 8014676:	68635b06 005d7261                       .[char].

0801467e <__compound_literal.134>:
 801467e:	5d275b03 005b0100                                .['].

08014683 <__compound_literal.133>:
 8014683:	03005b01                                         .[.

08014686 <__compound_literal.132>:
 8014686:	726f7803 6f770400                                .xor.

0801468b <__compound_literal.131>:
 801468b:	726f7704 77050064                                .word.

08014691 <__compound_literal.130>:
 8014691:	69687705 0800656c                                .while.

08014698 <__compound_literal.129>:
 8014698:	72617608 6c626169 75050065                       .variable.

080146a2 <__compound_literal.128>:
 80146a2:	746e7505 06006c69                                .until.

080146a9 <__compound_literal.127>:
 80146a9:	6c6e7506 00706f6f                       .unloop.

080146b1 <__compound_literal.126>:
 80146b1:	2f6d7506 00646f6d                       .um/mod.

080146b9 <__compound_literal.125>:
 80146b9:	2a6d7503 3c750200                                .um*.

080146be <__compound_literal.124>:
 80146be:	003c7502                                .u<.

080146c2 <__compound_literal.123>:
 80146c2:	002e7502                                .u..

080146c6 <__compound_literal.122>:
 80146c6:	70797404 74040065                                .type.

080146cc <__compound_literal.121>:
 80146cc:	65687404 7304006e                                .then.

080146d2 <__compound_literal.120>:
 80146d2:	61777304 73050070                                .swap.

080146d8 <__compound_literal.119>:
 80146d8:	61747305 06006574                                .state.

080146df <__compound_literal.118>:
 80146df:	61707306 00736563                       .spaces.

080146e7 <__compound_literal.117>:
 80146e7:	61707305 06006563                                .space.

080146ee <__compound_literal.116>:
 80146ee:	756f7306 00656372                       .source.

080146f6 <__compound_literal.115>:
 80146f6:	2f6d7306 006d6572                       .sm/rem.

080146fe <__compound_literal.114>:
 80146fe:	67697304 7303006e                                .sign.

08014704 <__compound_literal.113>:
 8014704:	643e7303 22730200                                .s>d.

08014709 <__compound_literal.112>:
 8014709:	00227302                                .s".

0801470d <__compound_literal.111>:
 801470d:	68737206 00746669                       .rshift.

08014715 <__compound_literal.110>:
 8014715:	746f7203 65720600                                .rot.

0801471a <__compound_literal.109>:
 801471a:	70657206 00746165                       .repeat.

08014722 <__compound_literal.108>:
 8014722:	63657207 65737275 40720200                       .recurse.

0801472b <__compound_literal.107>:
 801472b:	00407202                                .r@.

0801472f <__compound_literal.106>:
 801472f:	003e7202                                .r>.

08014733 <__compound_literal.105>:
 8014733:	69757104 70080074                                .quit.

08014739 <__compound_literal.104>:
 8014739:	736f7008 6e6f7074 6f040065                       .postpone.

08014743 <__compound_literal.103>:
 8014743:	65766f04 6f020072                                .over.

08014749 <__compound_literal.102>:
 8014749:	00726f02                                .or.

0801474d <__compound_literal.101>:
 801474d:	67656e06 00657461                       .negate.

08014755 <__compound_literal.100>:
 8014755:	766f6d04 6d030065                                .move.

0801475b <__compound_literal.99>:
 801475b:	646f6d03 696d0300                                .mod.

08014760 <__compound_literal.98>:
 8014760:	6e696d03 616d0300                                .min.

08014765 <__compound_literal.97>:
 8014765:	78616d03 2a6d0200                                .max.

0801476a <__compound_literal.96>:
 801476a:	002a6d02                                .m*.

0801476e <__compound_literal.95>:
 801476e:	68736c06 00746669                       .lshift.

08014776 <__compound_literal.94>:
 8014776:	6f6f6c04 6c070070                                .loop.

0801477c <__compound_literal.93>:
 801477c:	74696c07 6c617265 656c0500                       .literal.

08014785 <__compound_literal.92>:
 8014785:	61656c05 01006576                                .leave.

0801478c <__compound_literal.91>:
 801478c:	06006a01                                         .j.

0801478f <__compound_literal.90>:
 801478f:	766e6906 00747265                       .invert.

08014797 <__compound_literal.89>:
 8014797:	6d6d6909 61696465 02006574                       .immediate.

080147a2 <__compound_literal.88>:
 80147a2:	00666902                                .if.

080147a6 <__compound_literal.87>:
 80147a6:	04006901                                         .i.

080147a9 <__compound_literal.86>:
 80147a9:	6c6f6804 68040064                                .hold.

080147af <__compound_literal.85>:
 80147af:	72656804 66060065                                .here.

080147b5 <__compound_literal.84>:
 80147b5:	2f6d6606 00646f6d                       .fm/mod.

080147bd <__compound_literal.83>:
 80147bd:	6e696604 66040064                                .find.

080147c3 <__compound_literal.82>:
 80147c3:	6c696604 6504006c                                .fill.

080147c9 <__compound_literal.81>:
 80147c9:	69786504 65070074                                .exit.

080147cf <__compound_literal.80>:
 80147cf:	65786507 65747563 76650800                       .execute.

080147d8 <__compound_literal.79>:
 80147d8:	61766508 7461756c 65040065                       .evaluate.

080147e2 <__compound_literal.78>:
 80147e2:	696d6504 65040074                                .emit.

080147e8 <__compound_literal.77>:
 80147e8:	736c6504 64030065                                .else.

080147ee <__compound_literal.76>:
 80147ee:	70756403 72640400                                .dup.

080147f3 <__compound_literal.75>:
 80147f3:	6f726404 64050070                                .drop.

080147f9 <__compound_literal.74>:
 80147f9:	656f6405 02003e73                                .does>.

08014800 <__compound_literal.73>:
 8014800:	006f6402                                .do.

08014804 <__compound_literal.72>:
 8014804:	70656405 07006874                                .depth.

0801480b <__compound_literal.71>:
 801480b:	63656407 6c616d69 72630600                       .decimal.

08014814 <__compound_literal.70>:
 8014814:	65726306 00657461                       .create.

0801481c <__compound_literal.69>:
 801481c:	00726302                                .cr.

08014820 <__compound_literal.68>:
 8014820:	756f6305 0800746e                                .count.

08014827 <__compound_literal.67>:
 8014827:	6e6f6308 6e617473 63050074                       .constant.

08014831 <__compound_literal.66>:
 8014831:	61686305 05007372                                .chars.

08014838 <__compound_literal.65>:
 8014838:	61686305 04002b72                                .char+.

0801483f <__compound_literal.64>:
 801483f:	61686304 63050072                                .char.

08014845 <__compound_literal.63>:
 8014845:	6c656305 0500736c                                .cells.

0801484c <__compound_literal.62>:
 801484c:	6c656305 02002b6c                                .cell+.

08014853 <__compound_literal.61>:
 8014853:	00406302                                .c@.

08014857 <__compound_literal.60>:
 8014857:	002c6302                                .c,.

0801485b <__compound_literal.59>:
 801485b:	00216302                                .c!.

0801485f <__compound_literal.58>:
 801485f:	006c6202                                .bl.

08014863 <__compound_literal.57>:
 8014863:	67656205 04006e69                                .begin.

0801486a <__compound_literal.56>:
 801486a:	73616204 61030065                                .base.

08014870 <__compound_literal.55>:
 8014870:	646e6103 6c610500                                .and.

08014875 <__compound_literal.54>:
 8014875:	6c6c6105 0700746f                                .allot.

0801487c <__compound_literal.53>:
 801487c:	696c6107 64656e67 6c610500                       .aligned.

08014885 <__compound_literal.52>:
 8014885:	696c6105 03006e67                                .align.

0801488c <__compound_literal.51>:
 801488c:	73626103 62610600                                .abs.

08014891 <__compound_literal.50>:
 8014891:	6f626106 00227472                       .abort".

08014899 <__compound_literal.49>:
 8014899:	6f626105 01007472                                .abort.

080148a0 <__compound_literal.48>:
 80148a0:	04004001                                         .@.

080148a3 <__compound_literal.47>:
 80148a3:	75643f04 3e020070                                .?dup.

080148a9 <__compound_literal.46>:
 80148a9:	00723e02                                .>r.

080148ad <__compound_literal.45>:
 80148ad:	756e3e07 7265626d 693e0300                       .>number.

080148b6 <__compound_literal.44>:
 80148b6:	6e693e03 623e0500                                .>in.

080148bb <__compound_literal.43>:
 80148bb:	6f623e05 01007964                                .>body.

080148c2 <__compound_literal.42>:
 80148c2:	01003e01                                         .>.

080148c5 <__compound_literal.41>:
 80148c5:	02003d01                                         .=.

080148c8 <__compound_literal.40>:
 80148c8:	00233c02                                .<#.

080148cc <__compound_literal.39>:
 80148cc:	01003c01                                         .<.

080148cf <__compound_literal.38>:
 80148cf:	01003b01                                         .;.

080148d2 <__compound_literal.37>:
 80148d2:	05003a01                                         .:.

080148d5 <__compound_literal.36>:
 80148d5:	77733205 05007061                                .2swap.

080148dc <__compound_literal.35>:
 80148dc:	766f3205 04007265                                .2over.

080148e3 <__compound_literal.34>:
 80148e3:	75643204 32050070                                .2dup.

080148e9 <__compound_literal.33>:
 80148e9:	72643205 0200706f                                .2drop.

080148f0 <__compound_literal.32>:
 80148f0:	00403202                                .2@.

080148f4 <__compound_literal.31>:
 80148f4:	002f3202                                .2/.

080148f8 <__compound_literal.30>:
 80148f8:	002a3202                                .2*.

080148fc <__compound_literal.29>:
 80148fc:	00213202                                .2!.

08014900 <__compound_literal.28>:
 8014900:	002d3102                                .1-.

08014904 <__compound_literal.27>:
 8014904:	002b3102                                .1+.

08014908 <__compound_literal.26>:
 8014908:	003d3002                                .0=.

0801490c <__compound_literal.25>:
 801490c:	003c3002                                .0<.

08014910 <__compound_literal.24>:
 8014910:	6f6d2f04 2f010064                                ./mod.

08014916 <__compound_literal.23>:
 8014916:	02002f01                                         ./.

08014919 <__compound_literal.22>:
 8014919:	00222e02                                ..".

0801491d <__compound_literal.21>:
 801491d:	01002e01                                         ...

08014920 <__compound_literal.20>:
 8014920:	01002d01                                         .-.

08014923 <__compound_literal.19>:
 8014923:	05002c01                                         .,.

08014926 <__compound_literal.18>:
 8014926:	6f6c2b05 0200706f                                .+loop.

0801492d <__compound_literal.17>:
 801492d:	00212b02                                .+!.

08014931 <__compound_literal.16>:
 8014931:	05002b01                                         .+.

08014934 <__compound_literal.15>:
 8014934:	6d2f2a05 0200646f                                .*/mod.

0801493b <__compound_literal.14>:
 801493b:	002f2a02                                .*/.

0801493f <__compound_literal.13>:
 801493f:	01002a01                                         .*.

08014942 <__compound_literal.12>:
 8014942:	01002801                                         .(.

08014945 <__compound_literal.11>:
 8014945:	02002701                                         .'.

08014948 <__compound_literal.10>:
 8014948:	00732302                                .#s.

0801494c <__compound_literal.9>:
 801494c:	003e2302                                .#>.

08014950 <__compound_literal.8>:
 8014950:	01002301                                         .#.

08014953 <__compound_literal.7>:
 8014953:	00002101                                         .!.

08014956 <__compound_literal.6>:
	...

08014957 <__compound_literal.5>:
 8014957:	3c3c3c1f 6e757220 656d6974 6172622d     .<<< runtime-bra
 8014967:	2d68636e 662d6e6f 65736c61 3e3e3e20     nch-on-false >>>
	...

08014978 <__compound_literal.4>:
 8014978:	3c3c3c16 6e757220 656d6974 6172622d     .<<< runtime-bra
 8014988:	2068636e 003e3e3e                       nch >>>.

08014990 <__compound_literal.3>:
 8014990:	3c3c3c17 6e757220 656d6974 74696c2d     .<<< runtime-lit
 80149a0:	6c617265 3e3e3e20 3c3c1900                       eral >>>.

080149a9 <__compound_literal.2>:
 80149a9:	3c3c3c19 6e757220 656d6974 756c702d     .<<< runtime-plu
 80149b9:	6f6c2d73 3e20706f 14003e3e                       s-loop >>>.

080149c4 <__compound_literal.1>:
 80149c4:	3c3c3c14 6e757220 656d6974 6f6f6c2d     .<<< runtime-loo
 80149d4:	3e3e2070 3c14003e                                p >>>.

080149da <__compound_literal.0>:
 80149da:	3c3c3c14 6e757220 656d6974 656f642d     .<<< runtime-doe
 80149ea:	3e3e2073 6164003e 73206174 6b636174     s >>>.data stack
 80149fa:	65766f20 6f6c6672 61640077 73206174      overflow.data s
 8014a0a:	6b636174 646e7520 6c667265 6400776f     tack underflow.d
 8014a1a:	20617461 63617473 6d65206b 00797470     ata stack empty.
 8014a2a:	20646162 656d756e 20636972 65736162     bad numeric base
 8014a3a:	76696400 20656469 7a207962 006f7265     .divide by zero.
 8014a4a:	75746572 73206e72 6b636174 646e7520     return stack und
 8014a5a:	6c667265 6300776f 6f6e6e61 78652074     erflow.cannot ex
 8014a6a:	74756365 6f722065 6e692074 74616420     ecute rot in dat
 8014a7a:	74732061 006b6361 75746572 73206e72     a stack.return s
 8014a8a:	6b636174 65766f20 6f6c6672 61620077     tack overflow.ba
 8014a9a:	74732064 00657461 75666572 676e6973     d state.refusing
 8014aaa:	206f7420 20657375 657a2061 6c2d6f72      to use a zero-l
 8014aba:	74676e65 74732068 676e6972 20736120     ength string as 
 8014aca:	616e2061 6200656d 73206461 6b636174     a name.bad stack
 8014ada:	6e616300 20746f6e 63657865 20657475     .cannot execute 
 8014aea:	7265766f 206e6920 61746164 61747320     over in data sta
 8014afa:	72006b63 72757465 7473206e 206b6361     ck.return stack 
 8014b0a:	74706d65 61620079 74732064 206b6361     empty.bad stack 
 8014b1a:	20726f66 6b636970 72726500 7020726f     for pick.error p
 8014b2a:	69737261 6520676e 70616373 73206465     arsing escaped s
 8014b3a:	6e697274 3a000a67 6e616320 20746f6e     tring..: cannot 
 8014b4a:	706d6f63 20656c69 64726f77 6f77202c     compile word, wo
 8014b5a:	6e206472 6620746f 646e756f 3e32000a     rd not found..2>
 8014b6a:	72320072 6432003e 00706f72 6f77203a     r.2r>.2drop.: wo
 8014b7a:	6e206472 6620746f 646e756f 6d6f6300     rd not found.com
 8014b8a:	656c6970 6f63002c 00746e75 65707974     pile,.count.type
 8014b9a:	746f7200 00726300 726f6261 3e3c0074     .rot.cr.abort.<>
 8014baa:	65766f00 003d0072 203a2928 72617473     .over.=.(): star
 8014bba:	676e6974 65786520 69747563 6f206e6f     ting execution o
 8014bca:	6f632066 206e6f6c 64726f77 2800203a     f colon word: .(
 8014bda:	6e203a29 76697461 20796c65 63657865     ): natively exec
 8014bea:	6e697475 6f772067 203a6472 3c3c3c00     uting word: .<<<
 8014bfa:	746e6920 616e7265 3e3e206c 6f77003e      internal >>>.wo
 8014c0a:	27206472 6e202700 6620746f 646e756f     rd '.' not found
 8014c1a:	6177000a 6e696e72 75203a67 6f6e6b6e     ..warning: unkno
 8014c2a:	692f6e77 6c61766e 65206469 70616373     wn/invalid escap
 8014c3a:	65732065 6e657571 69206563 7365206e     e sequence in es
 8014c4a:	65706163 74732064 676e6972 71657220     caped string req
 8014c5a:	74736575 202c6465 6f6e6769 676e6972     uested, ignoring
 8014c6a:	7365000a 65706163 74732064 676e6972     ..escaped string
 8014c7a:	6f6f7420 72616c20 000a6567 6c636e69      too large..incl
 8014c8a:	6f697375 656c206e 206c6576 206f6f74     usion level too 
 8014c9a:	70656564 6261202c 6974726f 000a676e     deep, aborting..
 8014caa:	6c756f63 6f6e2064 706f2074 69206e65     could not open i
 8014cba:	756c636e 20646564 656c6966 7865000a     ncluded file..ex
 8014cca:	74706563 206e6f69 656b6174 63000a6e     ception taken..c
 8014cda:	69736f6c 6f20676e 6620656e 0a656c69     losing one file.
 8014cea:	00093a00 00202e2e 726f6673 733a6874     .:.... .sforth:s
 8014cfa:	3a003a70 3a707372 00203e00 726f6261     p:.:rsp:.> .abor
 8014d0a:	676e6974 69757120 69203a74 7475706e     ting quit: input
 8014d1a:	68786520 74737561 000a6465 006c0000               exhausted....

08014d28 <custom_dict>:
 8014d28:	2000006c 08014de2 00000000 0800af59     l.. .M......Y...
 8014d38:	08014d28 08014dd9 00000000 0800aeb9     (M...M..........
 8014d48:	08014d38 08014dd2 00000000 0800af43     8M...M......C...
 8014d58:	08014d48 08014dcb 00000000 0800aed9     HM...M..........
 8014d68:	08014d58 08014dc3 00000000 0800adf1     XM...M..........
 8014d78:	08014d68 08014dba 00000000 0800ae6d     hM...M......m...
 8014d88:	08014d78 08014db2 00000000 0800ae0f     xM...M..........
 8014d98:	08014d88 08014da8 00000001 0800aef7     .M...M..........

08014da8 <__compound_literal.8>:
 8014da8:	696c7308 61726574 7306006c                       .sliteral.

08014db2 <__compound_literal.7>:
 8014db2:	61657306 00686372                       .search.

08014dba <__compound_literal.6>:
 8014dba:	6d6f6307 65726170 6d630600                       .compare.

08014dc3 <__compound_literal.5>:
 8014dc3:	6f6d6306 003e6576                       .cmove>.

08014dcb <__compound_literal.4>:
 8014dcb:	6f6d6305 05006576                                .cmove.

08014dd2 <__compound_literal.3>:
 8014dd2:	616c6205 07006b6e                                .blank.

08014dd9 <__compound_literal.2>:
 8014dd9:	74732f07 676e6972 742d0900                       ./string.

08014de2 <__compound_literal.1>:
 8014de2:	72742d09 696c6961 0000676e                       .-trailing.

08014ded <__compound_literal.0>:
 8014ded:	64000000                                         ...

08014df0 <__func__.5546>:
 8014df0:	625f6f64 6b636172 655f7465 0065736c     do_bracket_else.

08014e00 <custom_dict>:
 8014e00:	2000007c 08014e76 00000000 0800afbf     |.. vN..........
 8014e10:	08014e00 08014e70 00000000 0800b0ad     .N..pN..........
 8014e20:	08014e10 08014e68 00000000 0800af95     .N..hN..........
 8014e30:	08014e20 08014e5d 00000000 0800af97      N..]N..........
 8014e40:	08014e30 08014e50 00000000 0800afb3     0N..PN..........

08014e50 <__compound_literal.5>:
 8014e50:	6e755b0b 69666564 5d64656e 645b0900              .[undefined].

08014e5d <__compound_literal.4>:
 8014e5d:	65645b09 656e6966 06005d64                       .[defined].

08014e68 <__compound_literal.3>:
 8014e68:	68745b06 005d6e65                       .[then].

08014e70 <__compound_literal.2>:
 8014e70:	66695b04 5b06005d                                .[if].

08014e76 <__compound_literal.1>:
 8014e76:	6c655b06 005d6573                       .[else].

08014e7e <__compound_literal.0>:
 8014e7e:	29280000 6e69203a 20747570 61687865     ..(): input exha
 8014e8e:	65747375 61203b64 74726f62 0a676e69     usted; aborting.
 8014e9e:	66695b00 655b005d 5d65736c 68745b00     .[if].[else].[th
 8014eae:	005d6e65 008c0000                                en]...

08014eb4 <custom_dict>:
 8014eb4:	2000008c 08014efe 00000001 0800b0f9     ... .N..........
 8014ec4:	08014eb4 08014ef5 00000000 0800b0e9     .N...N..........
 8014ed4:	08014ec4 08014ee4 00000000 0800b0d5     .N...N..........

08014ee4 <__compound_literal.3>:
 8014ee4:	7065720f 7469736f 2d6e6f69 656c6966     .reposition-file
	...

08014ef5 <__compound_literal.2>:
 8014ef5:	636e6907 6564756c 22730200                       .include.

08014efe <__compound_literal.1>:
 8014efe:	00227302                                .s".

08014f02 <__compound_literal.0>:
	...

08014f04 <custom_dict>:
 8014f04:	2000009c 08014f29 00000000 0800b185     ... )O..........
 8014f14:	08014f04 08014f24 00000000 0800b161     .O..$O......a...

08014f24 <__compound_literal.2>:
 8014f24:	64636703 71730700                                .gcd.

08014f29 <__compound_literal.1>:
 8014f29:	75717307 64657261 12000000                       .squared.

08014f32 <__compound_literal.0>:
	...

08014f34 <dev>:
 8014f34:	02000112 400102ef 60181d50 02010100     .......@P..`....
 8014f44:	02090103                                         ..

08014f46 <config>:
 8014f46:	00000209 80000105 014f5432 00000008              ........2TO...

08014f54 <ifaces>:
 8014f54:	00000000 00000001 0801503c 08015059     ........<P..YP..
 8014f64:	00000000 00000001 00000000 08015044     ............DP..
 8014f74:	00000000 00000001 08014fca 08014fe7     .........O...O..
 8014f84:	00000000 00000001 00000000 08014fd2     .............O..
 8014f94:	00000000 00000001 08014fa4 08014fac     .........O...O..

08014fa4 <dfu_assoc>:
 8014fa4:	01040b08 060101fe                       ........

08014fac <dfu_iface>:
 8014fac:	00040409 0101fe00 00000006 014fc100     ..............O.
 8014fbc:	00000908 09210900                                .....

08014fc1 <dfu_function>:
 8014fc1:	ff092109 1a040000 020b0801                       .!.......

08014fca <uart_assoc>:
 8014fca:	02020b08 00010202                       ........

08014fd2 <uart_data_iface>:
 8014fd2:	00030409 00000a02 01500f00 00000008     ..........P.....
 8014fe2:	00000000 02040900                                .....

08014fe7 <uart_comm_iface>:
 8014fe7:	00020409 01020201 01502d05 014ffc08     .........-P...O.
 8014ff7:	00001308 00240500                                .....

08014ffc <uart_cdcacm_functional_descriptors>:
 8014ffc:	10002405 01240501 24040300 24050202     .$....$....$...$
 801500c:	07030206                                         ...

0801500f <uart_data_endp>:
 801500f:	02030507 00010040 00000000 07000000     ....@...........
 801501f:	40028305 00000100 00000000 05070000              ...@..........

0801502d <uart_comm_endp>:
 801502d:	03840507 00ff0010 00000000 08000000              ...............

0801503c <gdb_assoc>:
 801503c:	02000b08 00010202                       ........

08015044 <gdb_data_iface>:
 8015044:	00010409 00000a02 01508100 00000008     ..........P.....
 8015054:	00000000 00040900                                .....

08015059 <gdb_comm_iface>:
 8015059:	00000409 01020201 01509f04 01506e08     ..........P..nP.
 8015069:	00001308 00240500                                .....

0801506e <gdb_cdcacm_functional_descriptors>:
 801506e:	10002405 01240501 24040100 24050202     .$....$....$...$
 801507e:	07010006                                         ...

08015081 <gdb_data_endp>:
 8015081:	02010507 00010040 00000000 07000000     ....@...........
 8015091:	40028105 00000100 00000000 05070000              ...@..........

0801509f <gdb_comm_endp>:
 801509f:	03820507 00ff0010 00000000 00000000     ................
 80150af:	616c4200 53206b63 72656870 65542065     .Black Sphere Te
 80150bf:	6f6e6863 69676f6c 42007365 6b63616c     chnologies.Black
 80150cf:	67614d20 50206369 65626f72 78762820      Magic Probe (vx
 80150df:	28202c29 6d726946 65726177 2e317620     ), (Firmware v1.
 80150ef:	63722d36 31332d30 63672d38 39306266     6-rc0-318-gcfb09
 80150ff:	642d3231 79747269 6c420029 206b6361     12-dirty).Black 
 801510f:	6967614d 44472063 65532042 72657672     Magic GDB Server
 801511f:	616c4200 4d206b63 63696761 52415520     .Black Magic UAR
 801512f:	6f502054 42007472 6b63616c 67614d20     T Port.Black Mag
 801513f:	46206369 776d7269 20657261 72677055     ic Firmware Upgr
 801514f:	20656461 4c545328 294b4e49 00bc5d00              ade (STLINK).

0801515c <CSWTCH.24>:
 801515c:	0800bc5d 00000000 00000000 00000000     ]...............
 801516c:	00000000 0800bccf 0800bd81 00000000     ................
 801517c:	0800bbe5 0800bb2f                       ..../...

08015184 <CSWTCH.26>:
 8015184:	0800bc75 00000000 00000000 00000000     u...............
	...
 80151ac:	0800bc09 0800bd03                       ........

080151b4 <st_usbfs_v2_usb_driver>:
 80151b4:	0800c1a9 0800c365 0800c3b9 0800c4d5     ....e...........
 80151c4:	0800c519 0800c5f9 0800c5bd 0800c64d     ............M...
 80151d4:	0800c6bd 0800c765 00000000 00000000     ....e...........
 80151e4:	00000000 04000200 06000000              ............

080151f0 <_global_impure_ptr>:
 80151f0:	200000d0                                ... 

080151f4 <_ctype_>:
 80151f4:	20202000 20202020 28282020 20282828     .         ((((( 
 8015204:	20202020 20202020 20202020 20202020                     
 8015214:	10108820 10101010 10101010 10101010      ...............
 8015224:	04040410 04040404 10040404 10101010     ................
 8015234:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8015244:	01010101 01010101 01010101 10101010     ................
 8015254:	42421010 42424242 02020202 02020202     ..BBBBBB........
 8015264:	02020202 02020202 02020202 10101010     ................
 8015274:	00000020 00000000 00000000 00000000      ...............
	...

080152f8 <__sf_fake_stdin>:
	...

08015318 <__sf_fake_stdout>:
	...

08015338 <__sf_fake_stderr>:
	...
 8015358:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 8015368:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 8015378:	31300046 35343332 39383736 64636261     F.0123456789abcd
 8015388:	00006665 080153aa 08011d52 080153ad     ef...S..R....S..
 8015398:	61462d41 3938662d 33323130 37363534     A-Fa-f8901234567
 80153a8:	2d2b005d 00587800                       ].+-.xX.
